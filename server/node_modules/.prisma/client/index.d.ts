
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Booking
 * 
 */
export type Booking = $Result.DefaultSelection<Prisma.$BookingPayload>
/**
 * Model PendingBooking
 * 
 */
export type PendingBooking = $Result.DefaultSelection<Prisma.$PendingBookingPayload>
/**
 * Model Instalment
 * 
 */
export type Instalment = $Result.DefaultSelection<Prisma.$InstalmentPayload>
/**
 * Model PendingInstalment
 * 
 */
export type PendingInstalment = $Result.DefaultSelection<Prisma.$PendingInstalmentPayload>
/**
 * Model InstalmentPayment
 * 
 */
export type InstalmentPayment = $Result.DefaultSelection<Prisma.$InstalmentPaymentPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model CostItem
 * 
 */
export type CostItem = $Result.DefaultSelection<Prisma.$CostItemPayload>
/**
 * Model PendingCostItem
 * 
 */
export type PendingCostItem = $Result.DefaultSelection<Prisma.$PendingCostItemPayload>
/**
 * Model Passenger
 * 
 */
export type Passenger = $Result.DefaultSelection<Prisma.$PassengerPayload>
/**
 * Model PendingPassenger
 * 
 */
export type PendingPassenger = $Result.DefaultSelection<Prisma.$PendingPassengerPayload>
/**
 * Model CostItemSupplier
 * 
 */
export type CostItemSupplier = $Result.DefaultSelection<Prisma.$CostItemSupplierPayload>
/**
 * Model SupplierPaymentSettlement
 * 
 */
export type SupplierPaymentSettlement = $Result.DefaultSelection<Prisma.$SupplierPaymentSettlementPayload>
/**
 * Model Cancellation
 * 
 */
export type Cancellation = $Result.DefaultSelection<Prisma.$CancellationPayload>
/**
 * Model SupplierCreditNote
 * 
 */
export type SupplierCreditNote = $Result.DefaultSelection<Prisma.$SupplierCreditNotePayload>
/**
 * Model CreditNoteUsage
 * 
 */
export type CreditNoteUsage = $Result.DefaultSelection<Prisma.$CreditNoteUsagePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const InstalmentStatus: {
  PENDING: 'PENDING',
  PAID: 'PAID',
  OVERDUE: 'OVERDUE'
};

export type InstalmentStatus = (typeof InstalmentStatus)[keyof typeof InstalmentStatus]


export const Teams: {
  PH: 'PH',
  TOURS: 'TOURS'
};

export type Teams = (typeof Teams)[keyof typeof Teams]


export const Suppliers: {
  BTRES: 'BTRES',
  LYCA: 'LYCA',
  CEBU: 'CEBU',
  BTRES_LYCA: 'BTRES_LYCA',
  BA: 'BA',
  TRAINLINE: 'TRAINLINE',
  EASYJET: 'EASYJET',
  FLYDUBAI: 'FLYDUBAI'
};

export type Suppliers = (typeof Suppliers)[keyof typeof Suppliers]


export const Role: {
  ADMIN: 'ADMIN',
  MANAGER: 'MANAGER',
  AGENT: 'AGENT'
};

export type Role = (typeof Role)[keyof typeof Role]


export const BookingType: {
  FRESH: 'FRESH',
  DATE_CHANGE: 'DATE_CHANGE',
  CANCELLATION: 'CANCELLATION'
};

export type BookingType = (typeof BookingType)[keyof typeof BookingType]


export const PaxType: {
  FRESH: 'FRESH',
  REFERRAL: 'REFERRAL',
  REPEAT: 'REPEAT'
};

export type PaxType = (typeof PaxType)[keyof typeof PaxType]


export const PaymentMethod: {
  FULL: 'FULL',
  INTERNAL: 'INTERNAL',
  REFUND: 'REFUND',
  HUMM: 'HUMM',
  FULL_HUMM: 'FULL_HUMM',
  INTERNAL_HUMM: 'INTERNAL_HUMM'
};

export type PaymentMethod = (typeof PaymentMethod)[keyof typeof PaymentMethod]


export const BookingStatus: {
  PENDING: 'PENDING',
  CONFIRMED: 'CONFIRMED',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type BookingStatus = (typeof BookingStatus)[keyof typeof BookingStatus]


export const PendingStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED'
};

export type PendingStatus = (typeof PendingStatus)[keyof typeof PendingStatus]


export const Title: {
  MR: 'MR',
  MRS: 'MRS',
  MS: 'MS',
  MASTER: 'MASTER'
};

export type Title = (typeof Title)[keyof typeof Title]


export const Gender: {
  MALE: 'MALE',
  FEMALE: 'FEMALE',
  OTHER: 'OTHER'
};

export type Gender = (typeof Gender)[keyof typeof Gender]


export const PassengerCategory: {
  ADULT: 'ADULT',
  CHILD: 'CHILD',
  INFANT: 'INFANT'
};

export type PassengerCategory = (typeof PassengerCategory)[keyof typeof PassengerCategory]


export const CreditNoteStatus: {
  AVAILABLE: 'AVAILABLE',
  PARTIALLY_USED: 'PARTIALLY_USED',
  USED: 'USED'
};

export type CreditNoteStatus = (typeof CreditNoteStatus)[keyof typeof CreditNoteStatus]

}

export type InstalmentStatus = $Enums.InstalmentStatus

export const InstalmentStatus: typeof $Enums.InstalmentStatus

export type Teams = $Enums.Teams

export const Teams: typeof $Enums.Teams

export type Suppliers = $Enums.Suppliers

export const Suppliers: typeof $Enums.Suppliers

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type BookingType = $Enums.BookingType

export const BookingType: typeof $Enums.BookingType

export type PaxType = $Enums.PaxType

export const PaxType: typeof $Enums.PaxType

export type PaymentMethod = $Enums.PaymentMethod

export const PaymentMethod: typeof $Enums.PaymentMethod

export type BookingStatus = $Enums.BookingStatus

export const BookingStatus: typeof $Enums.BookingStatus

export type PendingStatus = $Enums.PendingStatus

export const PendingStatus: typeof $Enums.PendingStatus

export type Title = $Enums.Title

export const Title: typeof $Enums.Title

export type Gender = $Enums.Gender

export const Gender: typeof $Enums.Gender

export type PassengerCategory = $Enums.PassengerCategory

export const PassengerCategory: typeof $Enums.PassengerCategory

export type CreditNoteStatus = $Enums.CreditNoteStatus

export const CreditNoteStatus: typeof $Enums.CreditNoteStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Bookings
 * const bookings = await prisma.booking.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Bookings
   * const bookings = await prisma.booking.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.booking`: Exposes CRUD operations for the **Booking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bookings
    * const bookings = await prisma.booking.findMany()
    * ```
    */
  get booking(): Prisma.BookingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pendingBooking`: Exposes CRUD operations for the **PendingBooking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PendingBookings
    * const pendingBookings = await prisma.pendingBooking.findMany()
    * ```
    */
  get pendingBooking(): Prisma.PendingBookingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.instalment`: Exposes CRUD operations for the **Instalment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Instalments
    * const instalments = await prisma.instalment.findMany()
    * ```
    */
  get instalment(): Prisma.InstalmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pendingInstalment`: Exposes CRUD operations for the **PendingInstalment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PendingInstalments
    * const pendingInstalments = await prisma.pendingInstalment.findMany()
    * ```
    */
  get pendingInstalment(): Prisma.PendingInstalmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.instalmentPayment`: Exposes CRUD operations for the **InstalmentPayment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InstalmentPayments
    * const instalmentPayments = await prisma.instalmentPayment.findMany()
    * ```
    */
  get instalmentPayment(): Prisma.InstalmentPaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.costItem`: Exposes CRUD operations for the **CostItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CostItems
    * const costItems = await prisma.costItem.findMany()
    * ```
    */
  get costItem(): Prisma.CostItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pendingCostItem`: Exposes CRUD operations for the **PendingCostItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PendingCostItems
    * const pendingCostItems = await prisma.pendingCostItem.findMany()
    * ```
    */
  get pendingCostItem(): Prisma.PendingCostItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.passenger`: Exposes CRUD operations for the **Passenger** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Passengers
    * const passengers = await prisma.passenger.findMany()
    * ```
    */
  get passenger(): Prisma.PassengerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pendingPassenger`: Exposes CRUD operations for the **PendingPassenger** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PendingPassengers
    * const pendingPassengers = await prisma.pendingPassenger.findMany()
    * ```
    */
  get pendingPassenger(): Prisma.PendingPassengerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.costItemSupplier`: Exposes CRUD operations for the **CostItemSupplier** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CostItemSuppliers
    * const costItemSuppliers = await prisma.costItemSupplier.findMany()
    * ```
    */
  get costItemSupplier(): Prisma.CostItemSupplierDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.supplierPaymentSettlement`: Exposes CRUD operations for the **SupplierPaymentSettlement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SupplierPaymentSettlements
    * const supplierPaymentSettlements = await prisma.supplierPaymentSettlement.findMany()
    * ```
    */
  get supplierPaymentSettlement(): Prisma.SupplierPaymentSettlementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cancellation`: Exposes CRUD operations for the **Cancellation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cancellations
    * const cancellations = await prisma.cancellation.findMany()
    * ```
    */
  get cancellation(): Prisma.CancellationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.supplierCreditNote`: Exposes CRUD operations for the **SupplierCreditNote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SupplierCreditNotes
    * const supplierCreditNotes = await prisma.supplierCreditNote.findMany()
    * ```
    */
  get supplierCreditNote(): Prisma.SupplierCreditNoteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.creditNoteUsage`: Exposes CRUD operations for the **CreditNoteUsage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CreditNoteUsages
    * const creditNoteUsages = await prisma.creditNoteUsage.findMany()
    * ```
    */
  get creditNoteUsage(): Prisma.CreditNoteUsageDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.11.0
   * Query Engine version: 9c30299f5a0ea26a96790e13f796dc6094db3173
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Booking: 'Booking',
    PendingBooking: 'PendingBooking',
    Instalment: 'Instalment',
    PendingInstalment: 'PendingInstalment',
    InstalmentPayment: 'InstalmentPayment',
    User: 'User',
    CostItem: 'CostItem',
    PendingCostItem: 'PendingCostItem',
    Passenger: 'Passenger',
    PendingPassenger: 'PendingPassenger',
    CostItemSupplier: 'CostItemSupplier',
    SupplierPaymentSettlement: 'SupplierPaymentSettlement',
    Cancellation: 'Cancellation',
    SupplierCreditNote: 'SupplierCreditNote',
    CreditNoteUsage: 'CreditNoteUsage'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "booking" | "pendingBooking" | "instalment" | "pendingInstalment" | "instalmentPayment" | "user" | "costItem" | "pendingCostItem" | "passenger" | "pendingPassenger" | "costItemSupplier" | "supplierPaymentSettlement" | "cancellation" | "supplierCreditNote" | "creditNoteUsage"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Booking: {
        payload: Prisma.$BookingPayload<ExtArgs>
        fields: Prisma.BookingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          findFirst: {
            args: Prisma.BookingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          findMany: {
            args: Prisma.BookingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          create: {
            args: Prisma.BookingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          createMany: {
            args: Prisma.BookingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BookingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          delete: {
            args: Prisma.BookingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          update: {
            args: Prisma.BookingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          deleteMany: {
            args: Prisma.BookingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BookingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          upsert: {
            args: Prisma.BookingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          aggregate: {
            args: Prisma.BookingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBooking>
          }
          groupBy: {
            args: Prisma.BookingGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookingGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookingCountArgs<ExtArgs>
            result: $Utils.Optional<BookingCountAggregateOutputType> | number
          }
        }
      }
      PendingBooking: {
        payload: Prisma.$PendingBookingPayload<ExtArgs>
        fields: Prisma.PendingBookingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PendingBookingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingBookingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PendingBookingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingBookingPayload>
          }
          findFirst: {
            args: Prisma.PendingBookingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingBookingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PendingBookingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingBookingPayload>
          }
          findMany: {
            args: Prisma.PendingBookingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingBookingPayload>[]
          }
          create: {
            args: Prisma.PendingBookingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingBookingPayload>
          }
          createMany: {
            args: Prisma.PendingBookingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PendingBookingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingBookingPayload>[]
          }
          delete: {
            args: Prisma.PendingBookingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingBookingPayload>
          }
          update: {
            args: Prisma.PendingBookingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingBookingPayload>
          }
          deleteMany: {
            args: Prisma.PendingBookingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PendingBookingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PendingBookingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingBookingPayload>[]
          }
          upsert: {
            args: Prisma.PendingBookingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingBookingPayload>
          }
          aggregate: {
            args: Prisma.PendingBookingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePendingBooking>
          }
          groupBy: {
            args: Prisma.PendingBookingGroupByArgs<ExtArgs>
            result: $Utils.Optional<PendingBookingGroupByOutputType>[]
          }
          count: {
            args: Prisma.PendingBookingCountArgs<ExtArgs>
            result: $Utils.Optional<PendingBookingCountAggregateOutputType> | number
          }
        }
      }
      Instalment: {
        payload: Prisma.$InstalmentPayload<ExtArgs>
        fields: Prisma.InstalmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InstalmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstalmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InstalmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstalmentPayload>
          }
          findFirst: {
            args: Prisma.InstalmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstalmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InstalmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstalmentPayload>
          }
          findMany: {
            args: Prisma.InstalmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstalmentPayload>[]
          }
          create: {
            args: Prisma.InstalmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstalmentPayload>
          }
          createMany: {
            args: Prisma.InstalmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InstalmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstalmentPayload>[]
          }
          delete: {
            args: Prisma.InstalmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstalmentPayload>
          }
          update: {
            args: Prisma.InstalmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstalmentPayload>
          }
          deleteMany: {
            args: Prisma.InstalmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InstalmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InstalmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstalmentPayload>[]
          }
          upsert: {
            args: Prisma.InstalmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstalmentPayload>
          }
          aggregate: {
            args: Prisma.InstalmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInstalment>
          }
          groupBy: {
            args: Prisma.InstalmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<InstalmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.InstalmentCountArgs<ExtArgs>
            result: $Utils.Optional<InstalmentCountAggregateOutputType> | number
          }
        }
      }
      PendingInstalment: {
        payload: Prisma.$PendingInstalmentPayload<ExtArgs>
        fields: Prisma.PendingInstalmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PendingInstalmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingInstalmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PendingInstalmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingInstalmentPayload>
          }
          findFirst: {
            args: Prisma.PendingInstalmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingInstalmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PendingInstalmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingInstalmentPayload>
          }
          findMany: {
            args: Prisma.PendingInstalmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingInstalmentPayload>[]
          }
          create: {
            args: Prisma.PendingInstalmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingInstalmentPayload>
          }
          createMany: {
            args: Prisma.PendingInstalmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PendingInstalmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingInstalmentPayload>[]
          }
          delete: {
            args: Prisma.PendingInstalmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingInstalmentPayload>
          }
          update: {
            args: Prisma.PendingInstalmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingInstalmentPayload>
          }
          deleteMany: {
            args: Prisma.PendingInstalmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PendingInstalmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PendingInstalmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingInstalmentPayload>[]
          }
          upsert: {
            args: Prisma.PendingInstalmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingInstalmentPayload>
          }
          aggregate: {
            args: Prisma.PendingInstalmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePendingInstalment>
          }
          groupBy: {
            args: Prisma.PendingInstalmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PendingInstalmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PendingInstalmentCountArgs<ExtArgs>
            result: $Utils.Optional<PendingInstalmentCountAggregateOutputType> | number
          }
        }
      }
      InstalmentPayment: {
        payload: Prisma.$InstalmentPaymentPayload<ExtArgs>
        fields: Prisma.InstalmentPaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InstalmentPaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstalmentPaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InstalmentPaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstalmentPaymentPayload>
          }
          findFirst: {
            args: Prisma.InstalmentPaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstalmentPaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InstalmentPaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstalmentPaymentPayload>
          }
          findMany: {
            args: Prisma.InstalmentPaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstalmentPaymentPayload>[]
          }
          create: {
            args: Prisma.InstalmentPaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstalmentPaymentPayload>
          }
          createMany: {
            args: Prisma.InstalmentPaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InstalmentPaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstalmentPaymentPayload>[]
          }
          delete: {
            args: Prisma.InstalmentPaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstalmentPaymentPayload>
          }
          update: {
            args: Prisma.InstalmentPaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstalmentPaymentPayload>
          }
          deleteMany: {
            args: Prisma.InstalmentPaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InstalmentPaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InstalmentPaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstalmentPaymentPayload>[]
          }
          upsert: {
            args: Prisma.InstalmentPaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstalmentPaymentPayload>
          }
          aggregate: {
            args: Prisma.InstalmentPaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInstalmentPayment>
          }
          groupBy: {
            args: Prisma.InstalmentPaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<InstalmentPaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.InstalmentPaymentCountArgs<ExtArgs>
            result: $Utils.Optional<InstalmentPaymentCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      CostItem: {
        payload: Prisma.$CostItemPayload<ExtArgs>
        fields: Prisma.CostItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CostItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CostItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostItemPayload>
          }
          findFirst: {
            args: Prisma.CostItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CostItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostItemPayload>
          }
          findMany: {
            args: Prisma.CostItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostItemPayload>[]
          }
          create: {
            args: Prisma.CostItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostItemPayload>
          }
          createMany: {
            args: Prisma.CostItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CostItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostItemPayload>[]
          }
          delete: {
            args: Prisma.CostItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostItemPayload>
          }
          update: {
            args: Prisma.CostItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostItemPayload>
          }
          deleteMany: {
            args: Prisma.CostItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CostItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CostItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostItemPayload>[]
          }
          upsert: {
            args: Prisma.CostItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostItemPayload>
          }
          aggregate: {
            args: Prisma.CostItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCostItem>
          }
          groupBy: {
            args: Prisma.CostItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<CostItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.CostItemCountArgs<ExtArgs>
            result: $Utils.Optional<CostItemCountAggregateOutputType> | number
          }
        }
      }
      PendingCostItem: {
        payload: Prisma.$PendingCostItemPayload<ExtArgs>
        fields: Prisma.PendingCostItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PendingCostItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingCostItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PendingCostItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingCostItemPayload>
          }
          findFirst: {
            args: Prisma.PendingCostItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingCostItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PendingCostItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingCostItemPayload>
          }
          findMany: {
            args: Prisma.PendingCostItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingCostItemPayload>[]
          }
          create: {
            args: Prisma.PendingCostItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingCostItemPayload>
          }
          createMany: {
            args: Prisma.PendingCostItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PendingCostItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingCostItemPayload>[]
          }
          delete: {
            args: Prisma.PendingCostItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingCostItemPayload>
          }
          update: {
            args: Prisma.PendingCostItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingCostItemPayload>
          }
          deleteMany: {
            args: Prisma.PendingCostItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PendingCostItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PendingCostItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingCostItemPayload>[]
          }
          upsert: {
            args: Prisma.PendingCostItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingCostItemPayload>
          }
          aggregate: {
            args: Prisma.PendingCostItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePendingCostItem>
          }
          groupBy: {
            args: Prisma.PendingCostItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<PendingCostItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.PendingCostItemCountArgs<ExtArgs>
            result: $Utils.Optional<PendingCostItemCountAggregateOutputType> | number
          }
        }
      }
      Passenger: {
        payload: Prisma.$PassengerPayload<ExtArgs>
        fields: Prisma.PassengerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PassengerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PassengerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PassengerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PassengerPayload>
          }
          findFirst: {
            args: Prisma.PassengerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PassengerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PassengerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PassengerPayload>
          }
          findMany: {
            args: Prisma.PassengerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PassengerPayload>[]
          }
          create: {
            args: Prisma.PassengerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PassengerPayload>
          }
          createMany: {
            args: Prisma.PassengerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PassengerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PassengerPayload>[]
          }
          delete: {
            args: Prisma.PassengerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PassengerPayload>
          }
          update: {
            args: Prisma.PassengerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PassengerPayload>
          }
          deleteMany: {
            args: Prisma.PassengerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PassengerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PassengerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PassengerPayload>[]
          }
          upsert: {
            args: Prisma.PassengerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PassengerPayload>
          }
          aggregate: {
            args: Prisma.PassengerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePassenger>
          }
          groupBy: {
            args: Prisma.PassengerGroupByArgs<ExtArgs>
            result: $Utils.Optional<PassengerGroupByOutputType>[]
          }
          count: {
            args: Prisma.PassengerCountArgs<ExtArgs>
            result: $Utils.Optional<PassengerCountAggregateOutputType> | number
          }
        }
      }
      PendingPassenger: {
        payload: Prisma.$PendingPassengerPayload<ExtArgs>
        fields: Prisma.PendingPassengerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PendingPassengerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingPassengerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PendingPassengerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingPassengerPayload>
          }
          findFirst: {
            args: Prisma.PendingPassengerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingPassengerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PendingPassengerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingPassengerPayload>
          }
          findMany: {
            args: Prisma.PendingPassengerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingPassengerPayload>[]
          }
          create: {
            args: Prisma.PendingPassengerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingPassengerPayload>
          }
          createMany: {
            args: Prisma.PendingPassengerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PendingPassengerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingPassengerPayload>[]
          }
          delete: {
            args: Prisma.PendingPassengerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingPassengerPayload>
          }
          update: {
            args: Prisma.PendingPassengerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingPassengerPayload>
          }
          deleteMany: {
            args: Prisma.PendingPassengerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PendingPassengerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PendingPassengerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingPassengerPayload>[]
          }
          upsert: {
            args: Prisma.PendingPassengerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingPassengerPayload>
          }
          aggregate: {
            args: Prisma.PendingPassengerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePendingPassenger>
          }
          groupBy: {
            args: Prisma.PendingPassengerGroupByArgs<ExtArgs>
            result: $Utils.Optional<PendingPassengerGroupByOutputType>[]
          }
          count: {
            args: Prisma.PendingPassengerCountArgs<ExtArgs>
            result: $Utils.Optional<PendingPassengerCountAggregateOutputType> | number
          }
        }
      }
      CostItemSupplier: {
        payload: Prisma.$CostItemSupplierPayload<ExtArgs>
        fields: Prisma.CostItemSupplierFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CostItemSupplierFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostItemSupplierPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CostItemSupplierFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostItemSupplierPayload>
          }
          findFirst: {
            args: Prisma.CostItemSupplierFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostItemSupplierPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CostItemSupplierFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostItemSupplierPayload>
          }
          findMany: {
            args: Prisma.CostItemSupplierFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostItemSupplierPayload>[]
          }
          create: {
            args: Prisma.CostItemSupplierCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostItemSupplierPayload>
          }
          createMany: {
            args: Prisma.CostItemSupplierCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CostItemSupplierCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostItemSupplierPayload>[]
          }
          delete: {
            args: Prisma.CostItemSupplierDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostItemSupplierPayload>
          }
          update: {
            args: Prisma.CostItemSupplierUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostItemSupplierPayload>
          }
          deleteMany: {
            args: Prisma.CostItemSupplierDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CostItemSupplierUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CostItemSupplierUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostItemSupplierPayload>[]
          }
          upsert: {
            args: Prisma.CostItemSupplierUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostItemSupplierPayload>
          }
          aggregate: {
            args: Prisma.CostItemSupplierAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCostItemSupplier>
          }
          groupBy: {
            args: Prisma.CostItemSupplierGroupByArgs<ExtArgs>
            result: $Utils.Optional<CostItemSupplierGroupByOutputType>[]
          }
          count: {
            args: Prisma.CostItemSupplierCountArgs<ExtArgs>
            result: $Utils.Optional<CostItemSupplierCountAggregateOutputType> | number
          }
        }
      }
      SupplierPaymentSettlement: {
        payload: Prisma.$SupplierPaymentSettlementPayload<ExtArgs>
        fields: Prisma.SupplierPaymentSettlementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SupplierPaymentSettlementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPaymentSettlementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SupplierPaymentSettlementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPaymentSettlementPayload>
          }
          findFirst: {
            args: Prisma.SupplierPaymentSettlementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPaymentSettlementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SupplierPaymentSettlementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPaymentSettlementPayload>
          }
          findMany: {
            args: Prisma.SupplierPaymentSettlementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPaymentSettlementPayload>[]
          }
          create: {
            args: Prisma.SupplierPaymentSettlementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPaymentSettlementPayload>
          }
          createMany: {
            args: Prisma.SupplierPaymentSettlementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SupplierPaymentSettlementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPaymentSettlementPayload>[]
          }
          delete: {
            args: Prisma.SupplierPaymentSettlementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPaymentSettlementPayload>
          }
          update: {
            args: Prisma.SupplierPaymentSettlementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPaymentSettlementPayload>
          }
          deleteMany: {
            args: Prisma.SupplierPaymentSettlementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SupplierPaymentSettlementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SupplierPaymentSettlementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPaymentSettlementPayload>[]
          }
          upsert: {
            args: Prisma.SupplierPaymentSettlementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPaymentSettlementPayload>
          }
          aggregate: {
            args: Prisma.SupplierPaymentSettlementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSupplierPaymentSettlement>
          }
          groupBy: {
            args: Prisma.SupplierPaymentSettlementGroupByArgs<ExtArgs>
            result: $Utils.Optional<SupplierPaymentSettlementGroupByOutputType>[]
          }
          count: {
            args: Prisma.SupplierPaymentSettlementCountArgs<ExtArgs>
            result: $Utils.Optional<SupplierPaymentSettlementCountAggregateOutputType> | number
          }
        }
      }
      Cancellation: {
        payload: Prisma.$CancellationPayload<ExtArgs>
        fields: Prisma.CancellationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CancellationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CancellationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CancellationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CancellationPayload>
          }
          findFirst: {
            args: Prisma.CancellationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CancellationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CancellationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CancellationPayload>
          }
          findMany: {
            args: Prisma.CancellationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CancellationPayload>[]
          }
          create: {
            args: Prisma.CancellationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CancellationPayload>
          }
          createMany: {
            args: Prisma.CancellationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CancellationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CancellationPayload>[]
          }
          delete: {
            args: Prisma.CancellationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CancellationPayload>
          }
          update: {
            args: Prisma.CancellationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CancellationPayload>
          }
          deleteMany: {
            args: Prisma.CancellationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CancellationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CancellationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CancellationPayload>[]
          }
          upsert: {
            args: Prisma.CancellationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CancellationPayload>
          }
          aggregate: {
            args: Prisma.CancellationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCancellation>
          }
          groupBy: {
            args: Prisma.CancellationGroupByArgs<ExtArgs>
            result: $Utils.Optional<CancellationGroupByOutputType>[]
          }
          count: {
            args: Prisma.CancellationCountArgs<ExtArgs>
            result: $Utils.Optional<CancellationCountAggregateOutputType> | number
          }
        }
      }
      SupplierCreditNote: {
        payload: Prisma.$SupplierCreditNotePayload<ExtArgs>
        fields: Prisma.SupplierCreditNoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SupplierCreditNoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierCreditNotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SupplierCreditNoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierCreditNotePayload>
          }
          findFirst: {
            args: Prisma.SupplierCreditNoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierCreditNotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SupplierCreditNoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierCreditNotePayload>
          }
          findMany: {
            args: Prisma.SupplierCreditNoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierCreditNotePayload>[]
          }
          create: {
            args: Prisma.SupplierCreditNoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierCreditNotePayload>
          }
          createMany: {
            args: Prisma.SupplierCreditNoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SupplierCreditNoteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierCreditNotePayload>[]
          }
          delete: {
            args: Prisma.SupplierCreditNoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierCreditNotePayload>
          }
          update: {
            args: Prisma.SupplierCreditNoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierCreditNotePayload>
          }
          deleteMany: {
            args: Prisma.SupplierCreditNoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SupplierCreditNoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SupplierCreditNoteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierCreditNotePayload>[]
          }
          upsert: {
            args: Prisma.SupplierCreditNoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierCreditNotePayload>
          }
          aggregate: {
            args: Prisma.SupplierCreditNoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSupplierCreditNote>
          }
          groupBy: {
            args: Prisma.SupplierCreditNoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<SupplierCreditNoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.SupplierCreditNoteCountArgs<ExtArgs>
            result: $Utils.Optional<SupplierCreditNoteCountAggregateOutputType> | number
          }
        }
      }
      CreditNoteUsage: {
        payload: Prisma.$CreditNoteUsagePayload<ExtArgs>
        fields: Prisma.CreditNoteUsageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CreditNoteUsageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditNoteUsagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CreditNoteUsageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditNoteUsagePayload>
          }
          findFirst: {
            args: Prisma.CreditNoteUsageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditNoteUsagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CreditNoteUsageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditNoteUsagePayload>
          }
          findMany: {
            args: Prisma.CreditNoteUsageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditNoteUsagePayload>[]
          }
          create: {
            args: Prisma.CreditNoteUsageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditNoteUsagePayload>
          }
          createMany: {
            args: Prisma.CreditNoteUsageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CreditNoteUsageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditNoteUsagePayload>[]
          }
          delete: {
            args: Prisma.CreditNoteUsageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditNoteUsagePayload>
          }
          update: {
            args: Prisma.CreditNoteUsageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditNoteUsagePayload>
          }
          deleteMany: {
            args: Prisma.CreditNoteUsageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CreditNoteUsageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CreditNoteUsageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditNoteUsagePayload>[]
          }
          upsert: {
            args: Prisma.CreditNoteUsageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditNoteUsagePayload>
          }
          aggregate: {
            args: Prisma.CreditNoteUsageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCreditNoteUsage>
          }
          groupBy: {
            args: Prisma.CreditNoteUsageGroupByArgs<ExtArgs>
            result: $Utils.Optional<CreditNoteUsageGroupByOutputType>[]
          }
          count: {
            args: Prisma.CreditNoteUsageCountArgs<ExtArgs>
            result: $Utils.Optional<CreditNoteUsageCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    booking?: BookingOmit
    pendingBooking?: PendingBookingOmit
    instalment?: InstalmentOmit
    pendingInstalment?: PendingInstalmentOmit
    instalmentPayment?: InstalmentPaymentOmit
    user?: UserOmit
    costItem?: CostItemOmit
    pendingCostItem?: PendingCostItemOmit
    passenger?: PassengerOmit
    pendingPassenger?: PendingPassengerOmit
    costItemSupplier?: CostItemSupplierOmit
    supplierPaymentSettlement?: SupplierPaymentSettlementOmit
    cancellation?: CancellationOmit
    supplierCreditNote?: SupplierCreditNoteOmit
    creditNoteUsage?: CreditNoteUsageOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type BookingCountOutputType
   */

  export type BookingCountOutputType = {
    costItems: number
    instalments: number
    passengers: number
  }

  export type BookingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    costItems?: boolean | BookingCountOutputTypeCountCostItemsArgs
    instalments?: boolean | BookingCountOutputTypeCountInstalmentsArgs
    passengers?: boolean | BookingCountOutputTypeCountPassengersArgs
  }

  // Custom InputTypes
  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingCountOutputType
     */
    select?: BookingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeCountCostItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CostItemWhereInput
  }

  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeCountInstalmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstalmentWhereInput
  }

  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeCountPassengersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PassengerWhereInput
  }


  /**
   * Count Type PendingBookingCountOutputType
   */

  export type PendingBookingCountOutputType = {
    costItems: number
    instalments: number
    passengers: number
  }

  export type PendingBookingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    costItems?: boolean | PendingBookingCountOutputTypeCountCostItemsArgs
    instalments?: boolean | PendingBookingCountOutputTypeCountInstalmentsArgs
    passengers?: boolean | PendingBookingCountOutputTypeCountPassengersArgs
  }

  // Custom InputTypes
  /**
   * PendingBookingCountOutputType without action
   */
  export type PendingBookingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingBookingCountOutputType
     */
    select?: PendingBookingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PendingBookingCountOutputType without action
   */
  export type PendingBookingCountOutputTypeCountCostItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PendingCostItemWhereInput
  }

  /**
   * PendingBookingCountOutputType without action
   */
  export type PendingBookingCountOutputTypeCountInstalmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PendingInstalmentWhereInput
  }

  /**
   * PendingBookingCountOutputType without action
   */
  export type PendingBookingCountOutputTypeCountPassengersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PendingPassengerWhereInput
  }


  /**
   * Count Type InstalmentCountOutputType
   */

  export type InstalmentCountOutputType = {
    payments: number
  }

  export type InstalmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | InstalmentCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * InstalmentCountOutputType without action
   */
  export type InstalmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstalmentCountOutputType
     */
    select?: InstalmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InstalmentCountOutputType without action
   */
  export type InstalmentCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstalmentPaymentWhereInput
  }


  /**
   * Count Type CostItemCountOutputType
   */

  export type CostItemCountOutputType = {
    suppliers: number
  }

  export type CostItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    suppliers?: boolean | CostItemCountOutputTypeCountSuppliersArgs
  }

  // Custom InputTypes
  /**
   * CostItemCountOutputType without action
   */
  export type CostItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostItemCountOutputType
     */
    select?: CostItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CostItemCountOutputType without action
   */
  export type CostItemCountOutputTypeCountSuppliersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CostItemSupplierWhereInput
  }


  /**
   * Count Type PendingCostItemCountOutputType
   */

  export type PendingCostItemCountOutputType = {
    suppliers: number
  }

  export type PendingCostItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    suppliers?: boolean | PendingCostItemCountOutputTypeCountSuppliersArgs
  }

  // Custom InputTypes
  /**
   * PendingCostItemCountOutputType without action
   */
  export type PendingCostItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingCostItemCountOutputType
     */
    select?: PendingCostItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PendingCostItemCountOutputType without action
   */
  export type PendingCostItemCountOutputTypeCountSuppliersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CostItemSupplierWhereInput
  }


  /**
   * Count Type CostItemSupplierCountOutputType
   */

  export type CostItemSupplierCountOutputType = {
    settlements: number
    paidByCreditNoteUsage: number
  }

  export type CostItemSupplierCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    settlements?: boolean | CostItemSupplierCountOutputTypeCountSettlementsArgs
    paidByCreditNoteUsage?: boolean | CostItemSupplierCountOutputTypeCountPaidByCreditNoteUsageArgs
  }

  // Custom InputTypes
  /**
   * CostItemSupplierCountOutputType without action
   */
  export type CostItemSupplierCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostItemSupplierCountOutputType
     */
    select?: CostItemSupplierCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CostItemSupplierCountOutputType without action
   */
  export type CostItemSupplierCountOutputTypeCountSettlementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplierPaymentSettlementWhereInput
  }

  /**
   * CostItemSupplierCountOutputType without action
   */
  export type CostItemSupplierCountOutputTypeCountPaidByCreditNoteUsageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreditNoteUsageWhereInput
  }


  /**
   * Count Type SupplierCreditNoteCountOutputType
   */

  export type SupplierCreditNoteCountOutputType = {
    usageHistory: number
  }

  export type SupplierCreditNoteCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usageHistory?: boolean | SupplierCreditNoteCountOutputTypeCountUsageHistoryArgs
  }

  // Custom InputTypes
  /**
   * SupplierCreditNoteCountOutputType without action
   */
  export type SupplierCreditNoteCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierCreditNoteCountOutputType
     */
    select?: SupplierCreditNoteCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SupplierCreditNoteCountOutputType without action
   */
  export type SupplierCreditNoteCountOutputTypeCountUsageHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreditNoteUsageWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Booking
   */

  export type AggregateBooking = {
    _count: BookingCountAggregateOutputType | null
    _avg: BookingAvgAggregateOutputType | null
    _sum: BookingSumAggregateOutputType | null
    _min: BookingMinAggregateOutputType | null
    _max: BookingMaxAggregateOutputType | null
  }

  export type BookingAvgAggregateOutputType = {
    id: number | null
    folderNo: number | null
    revenue: number | null
    prodCost: number | null
    transFee: number | null
    surcharge: number | null
    received: number | null
    balance: number | null
    profit: number | null
    numPax: number | null
    initialDeposit: number | null
  }

  export type BookingSumAggregateOutputType = {
    id: number | null
    folderNo: number | null
    revenue: number | null
    prodCost: number | null
    transFee: number | null
    surcharge: number | null
    received: number | null
    balance: number | null
    profit: number | null
    numPax: number | null
    initialDeposit: number | null
  }

  export type BookingMinAggregateOutputType = {
    id: number | null
    folderNo: number | null
    refNo: string | null
    paxName: string | null
    agentName: string | null
    teamName: $Enums.Teams | null
    pnr: string | null
    airline: string | null
    fromTo: string | null
    bookingType: $Enums.BookingType | null
    bookingStatus: $Enums.BookingStatus | null
    pcDate: Date | null
    issuedDate: Date | null
    paymentMethod: $Enums.PaymentMethod | null
    lastPaymentDate: Date | null
    travelDate: Date | null
    revenue: number | null
    prodCost: number | null
    transFee: number | null
    surcharge: number | null
    received: number | null
    transactionMethod: string | null
    receivedDate: Date | null
    balance: number | null
    profit: number | null
    invoiced: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    numPax: number | null
    initialDeposit: number | null
  }

  export type BookingMaxAggregateOutputType = {
    id: number | null
    folderNo: number | null
    refNo: string | null
    paxName: string | null
    agentName: string | null
    teamName: $Enums.Teams | null
    pnr: string | null
    airline: string | null
    fromTo: string | null
    bookingType: $Enums.BookingType | null
    bookingStatus: $Enums.BookingStatus | null
    pcDate: Date | null
    issuedDate: Date | null
    paymentMethod: $Enums.PaymentMethod | null
    lastPaymentDate: Date | null
    travelDate: Date | null
    revenue: number | null
    prodCost: number | null
    transFee: number | null
    surcharge: number | null
    received: number | null
    transactionMethod: string | null
    receivedDate: Date | null
    balance: number | null
    profit: number | null
    invoiced: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    numPax: number | null
    initialDeposit: number | null
  }

  export type BookingCountAggregateOutputType = {
    id: number
    folderNo: number
    refNo: number
    paxName: number
    agentName: number
    teamName: number
    pnr: number
    airline: number
    fromTo: number
    bookingType: number
    bookingStatus: number
    pcDate: number
    issuedDate: number
    paymentMethod: number
    lastPaymentDate: number
    travelDate: number
    revenue: number
    prodCost: number
    transFee: number
    surcharge: number
    received: number
    transactionMethod: number
    receivedDate: number
    balance: number
    profit: number
    invoiced: number
    description: number
    createdAt: number
    updatedAt: number
    numPax: number
    initialDeposit: number
    _all: number
  }


  export type BookingAvgAggregateInputType = {
    id?: true
    folderNo?: true
    revenue?: true
    prodCost?: true
    transFee?: true
    surcharge?: true
    received?: true
    balance?: true
    profit?: true
    numPax?: true
    initialDeposit?: true
  }

  export type BookingSumAggregateInputType = {
    id?: true
    folderNo?: true
    revenue?: true
    prodCost?: true
    transFee?: true
    surcharge?: true
    received?: true
    balance?: true
    profit?: true
    numPax?: true
    initialDeposit?: true
  }

  export type BookingMinAggregateInputType = {
    id?: true
    folderNo?: true
    refNo?: true
    paxName?: true
    agentName?: true
    teamName?: true
    pnr?: true
    airline?: true
    fromTo?: true
    bookingType?: true
    bookingStatus?: true
    pcDate?: true
    issuedDate?: true
    paymentMethod?: true
    lastPaymentDate?: true
    travelDate?: true
    revenue?: true
    prodCost?: true
    transFee?: true
    surcharge?: true
    received?: true
    transactionMethod?: true
    receivedDate?: true
    balance?: true
    profit?: true
    invoiced?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    numPax?: true
    initialDeposit?: true
  }

  export type BookingMaxAggregateInputType = {
    id?: true
    folderNo?: true
    refNo?: true
    paxName?: true
    agentName?: true
    teamName?: true
    pnr?: true
    airline?: true
    fromTo?: true
    bookingType?: true
    bookingStatus?: true
    pcDate?: true
    issuedDate?: true
    paymentMethod?: true
    lastPaymentDate?: true
    travelDate?: true
    revenue?: true
    prodCost?: true
    transFee?: true
    surcharge?: true
    received?: true
    transactionMethod?: true
    receivedDate?: true
    balance?: true
    profit?: true
    invoiced?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    numPax?: true
    initialDeposit?: true
  }

  export type BookingCountAggregateInputType = {
    id?: true
    folderNo?: true
    refNo?: true
    paxName?: true
    agentName?: true
    teamName?: true
    pnr?: true
    airline?: true
    fromTo?: true
    bookingType?: true
    bookingStatus?: true
    pcDate?: true
    issuedDate?: true
    paymentMethod?: true
    lastPaymentDate?: true
    travelDate?: true
    revenue?: true
    prodCost?: true
    transFee?: true
    surcharge?: true
    received?: true
    transactionMethod?: true
    receivedDate?: true
    balance?: true
    profit?: true
    invoiced?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    numPax?: true
    initialDeposit?: true
    _all?: true
  }

  export type BookingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Booking to aggregate.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bookings
    **/
    _count?: true | BookingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BookingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BookingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookingMaxAggregateInputType
  }

  export type GetBookingAggregateType<T extends BookingAggregateArgs> = {
        [P in keyof T & keyof AggregateBooking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBooking[P]>
      : GetScalarType<T[P], AggregateBooking[P]>
  }




  export type BookingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithAggregationInput | BookingOrderByWithAggregationInput[]
    by: BookingScalarFieldEnum[] | BookingScalarFieldEnum
    having?: BookingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookingCountAggregateInputType | true
    _avg?: BookingAvgAggregateInputType
    _sum?: BookingSumAggregateInputType
    _min?: BookingMinAggregateInputType
    _max?: BookingMaxAggregateInputType
  }

  export type BookingGroupByOutputType = {
    id: number
    folderNo: number
    refNo: string
    paxName: string
    agentName: string
    teamName: $Enums.Teams | null
    pnr: string
    airline: string
    fromTo: string
    bookingType: $Enums.BookingType
    bookingStatus: $Enums.BookingStatus | null
    pcDate: Date
    issuedDate: Date | null
    paymentMethod: $Enums.PaymentMethod
    lastPaymentDate: Date | null
    travelDate: Date | null
    revenue: number | null
    prodCost: number | null
    transFee: number | null
    surcharge: number | null
    received: number | null
    transactionMethod: string | null
    receivedDate: Date | null
    balance: number | null
    profit: number | null
    invoiced: string | null
    description: string | null
    createdAt: Date
    updatedAt: Date
    numPax: number
    initialDeposit: number | null
    _count: BookingCountAggregateOutputType | null
    _avg: BookingAvgAggregateOutputType | null
    _sum: BookingSumAggregateOutputType | null
    _min: BookingMinAggregateOutputType | null
    _max: BookingMaxAggregateOutputType | null
  }

  type GetBookingGroupByPayload<T extends BookingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookingGroupByOutputType[P]>
            : GetScalarType<T[P], BookingGroupByOutputType[P]>
        }
      >
    >


  export type BookingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    folderNo?: boolean
    refNo?: boolean
    paxName?: boolean
    agentName?: boolean
    teamName?: boolean
    pnr?: boolean
    airline?: boolean
    fromTo?: boolean
    bookingType?: boolean
    bookingStatus?: boolean
    pcDate?: boolean
    issuedDate?: boolean
    paymentMethod?: boolean
    lastPaymentDate?: boolean
    travelDate?: boolean
    revenue?: boolean
    prodCost?: boolean
    transFee?: boolean
    surcharge?: boolean
    received?: boolean
    transactionMethod?: boolean
    receivedDate?: boolean
    balance?: boolean
    profit?: boolean
    invoiced?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    numPax?: boolean
    initialDeposit?: boolean
    costItems?: boolean | Booking$costItemsArgs<ExtArgs>
    instalments?: boolean | Booking$instalmentsArgs<ExtArgs>
    passengers?: boolean | Booking$passengersArgs<ExtArgs>
    cancellation?: boolean | Booking$cancellationArgs<ExtArgs>
    _count?: boolean | BookingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>

  export type BookingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    folderNo?: boolean
    refNo?: boolean
    paxName?: boolean
    agentName?: boolean
    teamName?: boolean
    pnr?: boolean
    airline?: boolean
    fromTo?: boolean
    bookingType?: boolean
    bookingStatus?: boolean
    pcDate?: boolean
    issuedDate?: boolean
    paymentMethod?: boolean
    lastPaymentDate?: boolean
    travelDate?: boolean
    revenue?: boolean
    prodCost?: boolean
    transFee?: boolean
    surcharge?: boolean
    received?: boolean
    transactionMethod?: boolean
    receivedDate?: boolean
    balance?: boolean
    profit?: boolean
    invoiced?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    numPax?: boolean
    initialDeposit?: boolean
  }, ExtArgs["result"]["booking"]>

  export type BookingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    folderNo?: boolean
    refNo?: boolean
    paxName?: boolean
    agentName?: boolean
    teamName?: boolean
    pnr?: boolean
    airline?: boolean
    fromTo?: boolean
    bookingType?: boolean
    bookingStatus?: boolean
    pcDate?: boolean
    issuedDate?: boolean
    paymentMethod?: boolean
    lastPaymentDate?: boolean
    travelDate?: boolean
    revenue?: boolean
    prodCost?: boolean
    transFee?: boolean
    surcharge?: boolean
    received?: boolean
    transactionMethod?: boolean
    receivedDate?: boolean
    balance?: boolean
    profit?: boolean
    invoiced?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    numPax?: boolean
    initialDeposit?: boolean
  }, ExtArgs["result"]["booking"]>

  export type BookingSelectScalar = {
    id?: boolean
    folderNo?: boolean
    refNo?: boolean
    paxName?: boolean
    agentName?: boolean
    teamName?: boolean
    pnr?: boolean
    airline?: boolean
    fromTo?: boolean
    bookingType?: boolean
    bookingStatus?: boolean
    pcDate?: boolean
    issuedDate?: boolean
    paymentMethod?: boolean
    lastPaymentDate?: boolean
    travelDate?: boolean
    revenue?: boolean
    prodCost?: boolean
    transFee?: boolean
    surcharge?: boolean
    received?: boolean
    transactionMethod?: boolean
    receivedDate?: boolean
    balance?: boolean
    profit?: boolean
    invoiced?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    numPax?: boolean
    initialDeposit?: boolean
  }

  export type BookingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "folderNo" | "refNo" | "paxName" | "agentName" | "teamName" | "pnr" | "airline" | "fromTo" | "bookingType" | "bookingStatus" | "pcDate" | "issuedDate" | "paymentMethod" | "lastPaymentDate" | "travelDate" | "revenue" | "prodCost" | "transFee" | "surcharge" | "received" | "transactionMethod" | "receivedDate" | "balance" | "profit" | "invoiced" | "description" | "createdAt" | "updatedAt" | "numPax" | "initialDeposit", ExtArgs["result"]["booking"]>
  export type BookingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    costItems?: boolean | Booking$costItemsArgs<ExtArgs>
    instalments?: boolean | Booking$instalmentsArgs<ExtArgs>
    passengers?: boolean | Booking$passengersArgs<ExtArgs>
    cancellation?: boolean | Booking$cancellationArgs<ExtArgs>
    _count?: boolean | BookingCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BookingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type BookingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BookingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Booking"
    objects: {
      costItems: Prisma.$CostItemPayload<ExtArgs>[]
      instalments: Prisma.$InstalmentPayload<ExtArgs>[]
      passengers: Prisma.$PassengerPayload<ExtArgs>[]
      cancellation: Prisma.$CancellationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      folderNo: number
      refNo: string
      paxName: string
      agentName: string
      teamName: $Enums.Teams | null
      pnr: string
      airline: string
      fromTo: string
      bookingType: $Enums.BookingType
      bookingStatus: $Enums.BookingStatus | null
      pcDate: Date
      issuedDate: Date | null
      paymentMethod: $Enums.PaymentMethod
      lastPaymentDate: Date | null
      travelDate: Date | null
      revenue: number | null
      prodCost: number | null
      transFee: number | null
      surcharge: number | null
      received: number | null
      transactionMethod: string | null
      receivedDate: Date | null
      balance: number | null
      profit: number | null
      invoiced: string | null
      description: string | null
      createdAt: Date
      updatedAt: Date
      numPax: number
      initialDeposit: number | null
    }, ExtArgs["result"]["booking"]>
    composites: {}
  }

  type BookingGetPayload<S extends boolean | null | undefined | BookingDefaultArgs> = $Result.GetResult<Prisma.$BookingPayload, S>

  type BookingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BookingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BookingCountAggregateInputType | true
    }

  export interface BookingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Booking'], meta: { name: 'Booking' } }
    /**
     * Find zero or one Booking that matches the filter.
     * @param {BookingFindUniqueArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookingFindUniqueArgs>(args: SelectSubset<T, BookingFindUniqueArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Booking that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BookingFindUniqueOrThrowArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookingFindUniqueOrThrowArgs>(args: SelectSubset<T, BookingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Booking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindFirstArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookingFindFirstArgs>(args?: SelectSubset<T, BookingFindFirstArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Booking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindFirstOrThrowArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookingFindFirstOrThrowArgs>(args?: SelectSubset<T, BookingFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Bookings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bookings
     * const bookings = await prisma.booking.findMany()
     * 
     * // Get first 10 Bookings
     * const bookings = await prisma.booking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookingWithIdOnly = await prisma.booking.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BookingFindManyArgs>(args?: SelectSubset<T, BookingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Booking.
     * @param {BookingCreateArgs} args - Arguments to create a Booking.
     * @example
     * // Create one Booking
     * const Booking = await prisma.booking.create({
     *   data: {
     *     // ... data to create a Booking
     *   }
     * })
     * 
     */
    create<T extends BookingCreateArgs>(args: SelectSubset<T, BookingCreateArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Bookings.
     * @param {BookingCreateManyArgs} args - Arguments to create many Bookings.
     * @example
     * // Create many Bookings
     * const booking = await prisma.booking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookingCreateManyArgs>(args?: SelectSubset<T, BookingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bookings and returns the data saved in the database.
     * @param {BookingCreateManyAndReturnArgs} args - Arguments to create many Bookings.
     * @example
     * // Create many Bookings
     * const booking = await prisma.booking.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bookings and only return the `id`
     * const bookingWithIdOnly = await prisma.booking.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BookingCreateManyAndReturnArgs>(args?: SelectSubset<T, BookingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Booking.
     * @param {BookingDeleteArgs} args - Arguments to delete one Booking.
     * @example
     * // Delete one Booking
     * const Booking = await prisma.booking.delete({
     *   where: {
     *     // ... filter to delete one Booking
     *   }
     * })
     * 
     */
    delete<T extends BookingDeleteArgs>(args: SelectSubset<T, BookingDeleteArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Booking.
     * @param {BookingUpdateArgs} args - Arguments to update one Booking.
     * @example
     * // Update one Booking
     * const booking = await prisma.booking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookingUpdateArgs>(args: SelectSubset<T, BookingUpdateArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Bookings.
     * @param {BookingDeleteManyArgs} args - Arguments to filter Bookings to delete.
     * @example
     * // Delete a few Bookings
     * const { count } = await prisma.booking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookingDeleteManyArgs>(args?: SelectSubset<T, BookingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bookings
     * const booking = await prisma.booking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookingUpdateManyArgs>(args: SelectSubset<T, BookingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bookings and returns the data updated in the database.
     * @param {BookingUpdateManyAndReturnArgs} args - Arguments to update many Bookings.
     * @example
     * // Update many Bookings
     * const booking = await prisma.booking.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Bookings and only return the `id`
     * const bookingWithIdOnly = await prisma.booking.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BookingUpdateManyAndReturnArgs>(args: SelectSubset<T, BookingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Booking.
     * @param {BookingUpsertArgs} args - Arguments to update or create a Booking.
     * @example
     * // Update or create a Booking
     * const booking = await prisma.booking.upsert({
     *   create: {
     *     // ... data to create a Booking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Booking we want to update
     *   }
     * })
     */
    upsert<T extends BookingUpsertArgs>(args: SelectSubset<T, BookingUpsertArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingCountArgs} args - Arguments to filter Bookings to count.
     * @example
     * // Count the number of Bookings
     * const count = await prisma.booking.count({
     *   where: {
     *     // ... the filter for the Bookings we want to count
     *   }
     * })
    **/
    count<T extends BookingCountArgs>(
      args?: Subset<T, BookingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Booking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookingAggregateArgs>(args: Subset<T, BookingAggregateArgs>): Prisma.PrismaPromise<GetBookingAggregateType<T>>

    /**
     * Group by Booking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookingGroupByArgs['orderBy'] }
        : { orderBy?: BookingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Booking model
   */
  readonly fields: BookingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Booking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    costItems<T extends Booking$costItemsArgs<ExtArgs> = {}>(args?: Subset<T, Booking$costItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CostItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    instalments<T extends Booking$instalmentsArgs<ExtArgs> = {}>(args?: Subset<T, Booking$instalmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstalmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    passengers<T extends Booking$passengersArgs<ExtArgs> = {}>(args?: Subset<T, Booking$passengersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PassengerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cancellation<T extends Booking$cancellationArgs<ExtArgs> = {}>(args?: Subset<T, Booking$cancellationArgs<ExtArgs>>): Prisma__CancellationClient<$Result.GetResult<Prisma.$CancellationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Booking model
   */
  interface BookingFieldRefs {
    readonly id: FieldRef<"Booking", 'Int'>
    readonly folderNo: FieldRef<"Booking", 'Int'>
    readonly refNo: FieldRef<"Booking", 'String'>
    readonly paxName: FieldRef<"Booking", 'String'>
    readonly agentName: FieldRef<"Booking", 'String'>
    readonly teamName: FieldRef<"Booking", 'Teams'>
    readonly pnr: FieldRef<"Booking", 'String'>
    readonly airline: FieldRef<"Booking", 'String'>
    readonly fromTo: FieldRef<"Booking", 'String'>
    readonly bookingType: FieldRef<"Booking", 'BookingType'>
    readonly bookingStatus: FieldRef<"Booking", 'BookingStatus'>
    readonly pcDate: FieldRef<"Booking", 'DateTime'>
    readonly issuedDate: FieldRef<"Booking", 'DateTime'>
    readonly paymentMethod: FieldRef<"Booking", 'PaymentMethod'>
    readonly lastPaymentDate: FieldRef<"Booking", 'DateTime'>
    readonly travelDate: FieldRef<"Booking", 'DateTime'>
    readonly revenue: FieldRef<"Booking", 'Float'>
    readonly prodCost: FieldRef<"Booking", 'Float'>
    readonly transFee: FieldRef<"Booking", 'Float'>
    readonly surcharge: FieldRef<"Booking", 'Float'>
    readonly received: FieldRef<"Booking", 'Float'>
    readonly transactionMethod: FieldRef<"Booking", 'String'>
    readonly receivedDate: FieldRef<"Booking", 'DateTime'>
    readonly balance: FieldRef<"Booking", 'Float'>
    readonly profit: FieldRef<"Booking", 'Float'>
    readonly invoiced: FieldRef<"Booking", 'String'>
    readonly description: FieldRef<"Booking", 'String'>
    readonly createdAt: FieldRef<"Booking", 'DateTime'>
    readonly updatedAt: FieldRef<"Booking", 'DateTime'>
    readonly numPax: FieldRef<"Booking", 'Int'>
    readonly initialDeposit: FieldRef<"Booking", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * Booking findUnique
   */
  export type BookingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking findUniqueOrThrow
   */
  export type BookingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking findFirst
   */
  export type BookingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookings.
     */
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking findFirstOrThrow
   */
  export type BookingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookings.
     */
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking findMany
   */
  export type BookingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Bookings to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking create
   */
  export type BookingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The data needed to create a Booking.
     */
    data: XOR<BookingCreateInput, BookingUncheckedCreateInput>
  }

  /**
   * Booking createMany
   */
  export type BookingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bookings.
     */
    data: BookingCreateManyInput | BookingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Booking createManyAndReturn
   */
  export type BookingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * The data used to create many Bookings.
     */
    data: BookingCreateManyInput | BookingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Booking update
   */
  export type BookingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The data needed to update a Booking.
     */
    data: XOR<BookingUpdateInput, BookingUncheckedUpdateInput>
    /**
     * Choose, which Booking to update.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking updateMany
   */
  export type BookingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bookings.
     */
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyInput>
    /**
     * Filter which Bookings to update
     */
    where?: BookingWhereInput
    /**
     * Limit how many Bookings to update.
     */
    limit?: number
  }

  /**
   * Booking updateManyAndReturn
   */
  export type BookingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * The data used to update Bookings.
     */
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyInput>
    /**
     * Filter which Bookings to update
     */
    where?: BookingWhereInput
    /**
     * Limit how many Bookings to update.
     */
    limit?: number
  }

  /**
   * Booking upsert
   */
  export type BookingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The filter to search for the Booking to update in case it exists.
     */
    where: BookingWhereUniqueInput
    /**
     * In case the Booking found by the `where` argument doesn't exist, create a new Booking with this data.
     */
    create: XOR<BookingCreateInput, BookingUncheckedCreateInput>
    /**
     * In case the Booking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookingUpdateInput, BookingUncheckedUpdateInput>
  }

  /**
   * Booking delete
   */
  export type BookingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter which Booking to delete.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking deleteMany
   */
  export type BookingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bookings to delete
     */
    where?: BookingWhereInput
    /**
     * Limit how many Bookings to delete.
     */
    limit?: number
  }

  /**
   * Booking.costItems
   */
  export type Booking$costItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostItem
     */
    select?: CostItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostItem
     */
    omit?: CostItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostItemInclude<ExtArgs> | null
    where?: CostItemWhereInput
    orderBy?: CostItemOrderByWithRelationInput | CostItemOrderByWithRelationInput[]
    cursor?: CostItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CostItemScalarFieldEnum | CostItemScalarFieldEnum[]
  }

  /**
   * Booking.instalments
   */
  export type Booking$instalmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instalment
     */
    select?: InstalmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instalment
     */
    omit?: InstalmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstalmentInclude<ExtArgs> | null
    where?: InstalmentWhereInput
    orderBy?: InstalmentOrderByWithRelationInput | InstalmentOrderByWithRelationInput[]
    cursor?: InstalmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InstalmentScalarFieldEnum | InstalmentScalarFieldEnum[]
  }

  /**
   * Booking.passengers
   */
  export type Booking$passengersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passenger
     */
    select?: PassengerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Passenger
     */
    omit?: PassengerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PassengerInclude<ExtArgs> | null
    where?: PassengerWhereInput
    orderBy?: PassengerOrderByWithRelationInput | PassengerOrderByWithRelationInput[]
    cursor?: PassengerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PassengerScalarFieldEnum | PassengerScalarFieldEnum[]
  }

  /**
   * Booking.cancellation
   */
  export type Booking$cancellationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cancellation
     */
    select?: CancellationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cancellation
     */
    omit?: CancellationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CancellationInclude<ExtArgs> | null
    where?: CancellationWhereInput
  }

  /**
   * Booking without action
   */
  export type BookingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
  }


  /**
   * Model PendingBooking
   */

  export type AggregatePendingBooking = {
    _count: PendingBookingCountAggregateOutputType | null
    _avg: PendingBookingAvgAggregateOutputType | null
    _sum: PendingBookingSumAggregateOutputType | null
    _min: PendingBookingMinAggregateOutputType | null
    _max: PendingBookingMaxAggregateOutputType | null
  }

  export type PendingBookingAvgAggregateOutputType = {
    id: number | null
    revenue: number | null
    prodCost: number | null
    transFee: number | null
    surcharge: number | null
    received: number | null
    balance: number | null
    profit: number | null
    numPax: number | null
  }

  export type PendingBookingSumAggregateOutputType = {
    id: number | null
    revenue: number | null
    prodCost: number | null
    transFee: number | null
    surcharge: number | null
    received: number | null
    balance: number | null
    profit: number | null
    numPax: number | null
  }

  export type PendingBookingMinAggregateOutputType = {
    id: number | null
    refNo: string | null
    paxName: string | null
    agentName: string | null
    teamName: $Enums.Teams | null
    pnr: string | null
    airline: string | null
    fromTo: string | null
    bookingType: $Enums.BookingType | null
    bookingStatus: $Enums.BookingStatus | null
    pcDate: Date | null
    issuedDate: Date | null
    paymentMethod: $Enums.PaymentMethod | null
    lastPaymentDate: Date | null
    travelDate: Date | null
    revenue: number | null
    prodCost: number | null
    transFee: number | null
    surcharge: number | null
    received: number | null
    transactionMethod: string | null
    receivedDate: Date | null
    balance: number | null
    profit: number | null
    invoiced: string | null
    description: string | null
    status: $Enums.PendingStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    numPax: number | null
  }

  export type PendingBookingMaxAggregateOutputType = {
    id: number | null
    refNo: string | null
    paxName: string | null
    agentName: string | null
    teamName: $Enums.Teams | null
    pnr: string | null
    airline: string | null
    fromTo: string | null
    bookingType: $Enums.BookingType | null
    bookingStatus: $Enums.BookingStatus | null
    pcDate: Date | null
    issuedDate: Date | null
    paymentMethod: $Enums.PaymentMethod | null
    lastPaymentDate: Date | null
    travelDate: Date | null
    revenue: number | null
    prodCost: number | null
    transFee: number | null
    surcharge: number | null
    received: number | null
    transactionMethod: string | null
    receivedDate: Date | null
    balance: number | null
    profit: number | null
    invoiced: string | null
    description: string | null
    status: $Enums.PendingStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    numPax: number | null
  }

  export type PendingBookingCountAggregateOutputType = {
    id: number
    refNo: number
    paxName: number
    agentName: number
    teamName: number
    pnr: number
    airline: number
    fromTo: number
    bookingType: number
    bookingStatus: number
    pcDate: number
    issuedDate: number
    paymentMethod: number
    lastPaymentDate: number
    travelDate: number
    revenue: number
    prodCost: number
    transFee: number
    surcharge: number
    received: number
    transactionMethod: number
    receivedDate: number
    balance: number
    profit: number
    invoiced: number
    description: number
    status: number
    createdAt: number
    updatedAt: number
    numPax: number
    _all: number
  }


  export type PendingBookingAvgAggregateInputType = {
    id?: true
    revenue?: true
    prodCost?: true
    transFee?: true
    surcharge?: true
    received?: true
    balance?: true
    profit?: true
    numPax?: true
  }

  export type PendingBookingSumAggregateInputType = {
    id?: true
    revenue?: true
    prodCost?: true
    transFee?: true
    surcharge?: true
    received?: true
    balance?: true
    profit?: true
    numPax?: true
  }

  export type PendingBookingMinAggregateInputType = {
    id?: true
    refNo?: true
    paxName?: true
    agentName?: true
    teamName?: true
    pnr?: true
    airline?: true
    fromTo?: true
    bookingType?: true
    bookingStatus?: true
    pcDate?: true
    issuedDate?: true
    paymentMethod?: true
    lastPaymentDate?: true
    travelDate?: true
    revenue?: true
    prodCost?: true
    transFee?: true
    surcharge?: true
    received?: true
    transactionMethod?: true
    receivedDate?: true
    balance?: true
    profit?: true
    invoiced?: true
    description?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    numPax?: true
  }

  export type PendingBookingMaxAggregateInputType = {
    id?: true
    refNo?: true
    paxName?: true
    agentName?: true
    teamName?: true
    pnr?: true
    airline?: true
    fromTo?: true
    bookingType?: true
    bookingStatus?: true
    pcDate?: true
    issuedDate?: true
    paymentMethod?: true
    lastPaymentDate?: true
    travelDate?: true
    revenue?: true
    prodCost?: true
    transFee?: true
    surcharge?: true
    received?: true
    transactionMethod?: true
    receivedDate?: true
    balance?: true
    profit?: true
    invoiced?: true
    description?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    numPax?: true
  }

  export type PendingBookingCountAggregateInputType = {
    id?: true
    refNo?: true
    paxName?: true
    agentName?: true
    teamName?: true
    pnr?: true
    airline?: true
    fromTo?: true
    bookingType?: true
    bookingStatus?: true
    pcDate?: true
    issuedDate?: true
    paymentMethod?: true
    lastPaymentDate?: true
    travelDate?: true
    revenue?: true
    prodCost?: true
    transFee?: true
    surcharge?: true
    received?: true
    transactionMethod?: true
    receivedDate?: true
    balance?: true
    profit?: true
    invoiced?: true
    description?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    numPax?: true
    _all?: true
  }

  export type PendingBookingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PendingBooking to aggregate.
     */
    where?: PendingBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PendingBookings to fetch.
     */
    orderBy?: PendingBookingOrderByWithRelationInput | PendingBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PendingBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PendingBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PendingBookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PendingBookings
    **/
    _count?: true | PendingBookingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PendingBookingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PendingBookingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PendingBookingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PendingBookingMaxAggregateInputType
  }

  export type GetPendingBookingAggregateType<T extends PendingBookingAggregateArgs> = {
        [P in keyof T & keyof AggregatePendingBooking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePendingBooking[P]>
      : GetScalarType<T[P], AggregatePendingBooking[P]>
  }




  export type PendingBookingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PendingBookingWhereInput
    orderBy?: PendingBookingOrderByWithAggregationInput | PendingBookingOrderByWithAggregationInput[]
    by: PendingBookingScalarFieldEnum[] | PendingBookingScalarFieldEnum
    having?: PendingBookingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PendingBookingCountAggregateInputType | true
    _avg?: PendingBookingAvgAggregateInputType
    _sum?: PendingBookingSumAggregateInputType
    _min?: PendingBookingMinAggregateInputType
    _max?: PendingBookingMaxAggregateInputType
  }

  export type PendingBookingGroupByOutputType = {
    id: number
    refNo: string
    paxName: string
    agentName: string
    teamName: $Enums.Teams | null
    pnr: string
    airline: string
    fromTo: string
    bookingType: $Enums.BookingType
    bookingStatus: $Enums.BookingStatus | null
    pcDate: Date
    issuedDate: Date | null
    paymentMethod: $Enums.PaymentMethod
    lastPaymentDate: Date | null
    travelDate: Date | null
    revenue: number | null
    prodCost: number | null
    transFee: number | null
    surcharge: number | null
    received: number | null
    transactionMethod: string | null
    receivedDate: Date | null
    balance: number | null
    profit: number | null
    invoiced: string | null
    description: string | null
    status: $Enums.PendingStatus
    createdAt: Date
    updatedAt: Date
    numPax: number
    _count: PendingBookingCountAggregateOutputType | null
    _avg: PendingBookingAvgAggregateOutputType | null
    _sum: PendingBookingSumAggregateOutputType | null
    _min: PendingBookingMinAggregateOutputType | null
    _max: PendingBookingMaxAggregateOutputType | null
  }

  type GetPendingBookingGroupByPayload<T extends PendingBookingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PendingBookingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PendingBookingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PendingBookingGroupByOutputType[P]>
            : GetScalarType<T[P], PendingBookingGroupByOutputType[P]>
        }
      >
    >


  export type PendingBookingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    refNo?: boolean
    paxName?: boolean
    agentName?: boolean
    teamName?: boolean
    pnr?: boolean
    airline?: boolean
    fromTo?: boolean
    bookingType?: boolean
    bookingStatus?: boolean
    pcDate?: boolean
    issuedDate?: boolean
    paymentMethod?: boolean
    lastPaymentDate?: boolean
    travelDate?: boolean
    revenue?: boolean
    prodCost?: boolean
    transFee?: boolean
    surcharge?: boolean
    received?: boolean
    transactionMethod?: boolean
    receivedDate?: boolean
    balance?: boolean
    profit?: boolean
    invoiced?: boolean
    description?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    numPax?: boolean
    costItems?: boolean | PendingBooking$costItemsArgs<ExtArgs>
    instalments?: boolean | PendingBooking$instalmentsArgs<ExtArgs>
    passengers?: boolean | PendingBooking$passengersArgs<ExtArgs>
    _count?: boolean | PendingBookingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pendingBooking"]>

  export type PendingBookingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    refNo?: boolean
    paxName?: boolean
    agentName?: boolean
    teamName?: boolean
    pnr?: boolean
    airline?: boolean
    fromTo?: boolean
    bookingType?: boolean
    bookingStatus?: boolean
    pcDate?: boolean
    issuedDate?: boolean
    paymentMethod?: boolean
    lastPaymentDate?: boolean
    travelDate?: boolean
    revenue?: boolean
    prodCost?: boolean
    transFee?: boolean
    surcharge?: boolean
    received?: boolean
    transactionMethod?: boolean
    receivedDate?: boolean
    balance?: boolean
    profit?: boolean
    invoiced?: boolean
    description?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    numPax?: boolean
  }, ExtArgs["result"]["pendingBooking"]>

  export type PendingBookingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    refNo?: boolean
    paxName?: boolean
    agentName?: boolean
    teamName?: boolean
    pnr?: boolean
    airline?: boolean
    fromTo?: boolean
    bookingType?: boolean
    bookingStatus?: boolean
    pcDate?: boolean
    issuedDate?: boolean
    paymentMethod?: boolean
    lastPaymentDate?: boolean
    travelDate?: boolean
    revenue?: boolean
    prodCost?: boolean
    transFee?: boolean
    surcharge?: boolean
    received?: boolean
    transactionMethod?: boolean
    receivedDate?: boolean
    balance?: boolean
    profit?: boolean
    invoiced?: boolean
    description?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    numPax?: boolean
  }, ExtArgs["result"]["pendingBooking"]>

  export type PendingBookingSelectScalar = {
    id?: boolean
    refNo?: boolean
    paxName?: boolean
    agentName?: boolean
    teamName?: boolean
    pnr?: boolean
    airline?: boolean
    fromTo?: boolean
    bookingType?: boolean
    bookingStatus?: boolean
    pcDate?: boolean
    issuedDate?: boolean
    paymentMethod?: boolean
    lastPaymentDate?: boolean
    travelDate?: boolean
    revenue?: boolean
    prodCost?: boolean
    transFee?: boolean
    surcharge?: boolean
    received?: boolean
    transactionMethod?: boolean
    receivedDate?: boolean
    balance?: boolean
    profit?: boolean
    invoiced?: boolean
    description?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    numPax?: boolean
  }

  export type PendingBookingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "refNo" | "paxName" | "agentName" | "teamName" | "pnr" | "airline" | "fromTo" | "bookingType" | "bookingStatus" | "pcDate" | "issuedDate" | "paymentMethod" | "lastPaymentDate" | "travelDate" | "revenue" | "prodCost" | "transFee" | "surcharge" | "received" | "transactionMethod" | "receivedDate" | "balance" | "profit" | "invoiced" | "description" | "status" | "createdAt" | "updatedAt" | "numPax", ExtArgs["result"]["pendingBooking"]>
  export type PendingBookingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    costItems?: boolean | PendingBooking$costItemsArgs<ExtArgs>
    instalments?: boolean | PendingBooking$instalmentsArgs<ExtArgs>
    passengers?: boolean | PendingBooking$passengersArgs<ExtArgs>
    _count?: boolean | PendingBookingCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PendingBookingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PendingBookingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PendingBookingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PendingBooking"
    objects: {
      costItems: Prisma.$PendingCostItemPayload<ExtArgs>[]
      instalments: Prisma.$PendingInstalmentPayload<ExtArgs>[]
      passengers: Prisma.$PendingPassengerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      refNo: string
      paxName: string
      agentName: string
      teamName: $Enums.Teams | null
      pnr: string
      airline: string
      fromTo: string
      bookingType: $Enums.BookingType
      bookingStatus: $Enums.BookingStatus | null
      pcDate: Date
      issuedDate: Date | null
      paymentMethod: $Enums.PaymentMethod
      lastPaymentDate: Date | null
      travelDate: Date | null
      revenue: number | null
      prodCost: number | null
      transFee: number | null
      surcharge: number | null
      received: number | null
      transactionMethod: string | null
      receivedDate: Date | null
      balance: number | null
      profit: number | null
      invoiced: string | null
      description: string | null
      status: $Enums.PendingStatus
      createdAt: Date
      updatedAt: Date
      numPax: number
    }, ExtArgs["result"]["pendingBooking"]>
    composites: {}
  }

  type PendingBookingGetPayload<S extends boolean | null | undefined | PendingBookingDefaultArgs> = $Result.GetResult<Prisma.$PendingBookingPayload, S>

  type PendingBookingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PendingBookingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PendingBookingCountAggregateInputType | true
    }

  export interface PendingBookingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PendingBooking'], meta: { name: 'PendingBooking' } }
    /**
     * Find zero or one PendingBooking that matches the filter.
     * @param {PendingBookingFindUniqueArgs} args - Arguments to find a PendingBooking
     * @example
     * // Get one PendingBooking
     * const pendingBooking = await prisma.pendingBooking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PendingBookingFindUniqueArgs>(args: SelectSubset<T, PendingBookingFindUniqueArgs<ExtArgs>>): Prisma__PendingBookingClient<$Result.GetResult<Prisma.$PendingBookingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PendingBooking that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PendingBookingFindUniqueOrThrowArgs} args - Arguments to find a PendingBooking
     * @example
     * // Get one PendingBooking
     * const pendingBooking = await prisma.pendingBooking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PendingBookingFindUniqueOrThrowArgs>(args: SelectSubset<T, PendingBookingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PendingBookingClient<$Result.GetResult<Prisma.$PendingBookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PendingBooking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingBookingFindFirstArgs} args - Arguments to find a PendingBooking
     * @example
     * // Get one PendingBooking
     * const pendingBooking = await prisma.pendingBooking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PendingBookingFindFirstArgs>(args?: SelectSubset<T, PendingBookingFindFirstArgs<ExtArgs>>): Prisma__PendingBookingClient<$Result.GetResult<Prisma.$PendingBookingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PendingBooking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingBookingFindFirstOrThrowArgs} args - Arguments to find a PendingBooking
     * @example
     * // Get one PendingBooking
     * const pendingBooking = await prisma.pendingBooking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PendingBookingFindFirstOrThrowArgs>(args?: SelectSubset<T, PendingBookingFindFirstOrThrowArgs<ExtArgs>>): Prisma__PendingBookingClient<$Result.GetResult<Prisma.$PendingBookingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PendingBookings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingBookingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PendingBookings
     * const pendingBookings = await prisma.pendingBooking.findMany()
     * 
     * // Get first 10 PendingBookings
     * const pendingBookings = await prisma.pendingBooking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pendingBookingWithIdOnly = await prisma.pendingBooking.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PendingBookingFindManyArgs>(args?: SelectSubset<T, PendingBookingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PendingBookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PendingBooking.
     * @param {PendingBookingCreateArgs} args - Arguments to create a PendingBooking.
     * @example
     * // Create one PendingBooking
     * const PendingBooking = await prisma.pendingBooking.create({
     *   data: {
     *     // ... data to create a PendingBooking
     *   }
     * })
     * 
     */
    create<T extends PendingBookingCreateArgs>(args: SelectSubset<T, PendingBookingCreateArgs<ExtArgs>>): Prisma__PendingBookingClient<$Result.GetResult<Prisma.$PendingBookingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PendingBookings.
     * @param {PendingBookingCreateManyArgs} args - Arguments to create many PendingBookings.
     * @example
     * // Create many PendingBookings
     * const pendingBooking = await prisma.pendingBooking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PendingBookingCreateManyArgs>(args?: SelectSubset<T, PendingBookingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PendingBookings and returns the data saved in the database.
     * @param {PendingBookingCreateManyAndReturnArgs} args - Arguments to create many PendingBookings.
     * @example
     * // Create many PendingBookings
     * const pendingBooking = await prisma.pendingBooking.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PendingBookings and only return the `id`
     * const pendingBookingWithIdOnly = await prisma.pendingBooking.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PendingBookingCreateManyAndReturnArgs>(args?: SelectSubset<T, PendingBookingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PendingBookingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PendingBooking.
     * @param {PendingBookingDeleteArgs} args - Arguments to delete one PendingBooking.
     * @example
     * // Delete one PendingBooking
     * const PendingBooking = await prisma.pendingBooking.delete({
     *   where: {
     *     // ... filter to delete one PendingBooking
     *   }
     * })
     * 
     */
    delete<T extends PendingBookingDeleteArgs>(args: SelectSubset<T, PendingBookingDeleteArgs<ExtArgs>>): Prisma__PendingBookingClient<$Result.GetResult<Prisma.$PendingBookingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PendingBooking.
     * @param {PendingBookingUpdateArgs} args - Arguments to update one PendingBooking.
     * @example
     * // Update one PendingBooking
     * const pendingBooking = await prisma.pendingBooking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PendingBookingUpdateArgs>(args: SelectSubset<T, PendingBookingUpdateArgs<ExtArgs>>): Prisma__PendingBookingClient<$Result.GetResult<Prisma.$PendingBookingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PendingBookings.
     * @param {PendingBookingDeleteManyArgs} args - Arguments to filter PendingBookings to delete.
     * @example
     * // Delete a few PendingBookings
     * const { count } = await prisma.pendingBooking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PendingBookingDeleteManyArgs>(args?: SelectSubset<T, PendingBookingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PendingBookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingBookingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PendingBookings
     * const pendingBooking = await prisma.pendingBooking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PendingBookingUpdateManyArgs>(args: SelectSubset<T, PendingBookingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PendingBookings and returns the data updated in the database.
     * @param {PendingBookingUpdateManyAndReturnArgs} args - Arguments to update many PendingBookings.
     * @example
     * // Update many PendingBookings
     * const pendingBooking = await prisma.pendingBooking.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PendingBookings and only return the `id`
     * const pendingBookingWithIdOnly = await prisma.pendingBooking.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PendingBookingUpdateManyAndReturnArgs>(args: SelectSubset<T, PendingBookingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PendingBookingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PendingBooking.
     * @param {PendingBookingUpsertArgs} args - Arguments to update or create a PendingBooking.
     * @example
     * // Update or create a PendingBooking
     * const pendingBooking = await prisma.pendingBooking.upsert({
     *   create: {
     *     // ... data to create a PendingBooking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PendingBooking we want to update
     *   }
     * })
     */
    upsert<T extends PendingBookingUpsertArgs>(args: SelectSubset<T, PendingBookingUpsertArgs<ExtArgs>>): Prisma__PendingBookingClient<$Result.GetResult<Prisma.$PendingBookingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PendingBookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingBookingCountArgs} args - Arguments to filter PendingBookings to count.
     * @example
     * // Count the number of PendingBookings
     * const count = await prisma.pendingBooking.count({
     *   where: {
     *     // ... the filter for the PendingBookings we want to count
     *   }
     * })
    **/
    count<T extends PendingBookingCountArgs>(
      args?: Subset<T, PendingBookingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PendingBookingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PendingBooking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingBookingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PendingBookingAggregateArgs>(args: Subset<T, PendingBookingAggregateArgs>): Prisma.PrismaPromise<GetPendingBookingAggregateType<T>>

    /**
     * Group by PendingBooking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingBookingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PendingBookingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PendingBookingGroupByArgs['orderBy'] }
        : { orderBy?: PendingBookingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PendingBookingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPendingBookingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PendingBooking model
   */
  readonly fields: PendingBookingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PendingBooking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PendingBookingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    costItems<T extends PendingBooking$costItemsArgs<ExtArgs> = {}>(args?: Subset<T, PendingBooking$costItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PendingCostItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    instalments<T extends PendingBooking$instalmentsArgs<ExtArgs> = {}>(args?: Subset<T, PendingBooking$instalmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PendingInstalmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    passengers<T extends PendingBooking$passengersArgs<ExtArgs> = {}>(args?: Subset<T, PendingBooking$passengersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PendingPassengerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PendingBooking model
   */
  interface PendingBookingFieldRefs {
    readonly id: FieldRef<"PendingBooking", 'Int'>
    readonly refNo: FieldRef<"PendingBooking", 'String'>
    readonly paxName: FieldRef<"PendingBooking", 'String'>
    readonly agentName: FieldRef<"PendingBooking", 'String'>
    readonly teamName: FieldRef<"PendingBooking", 'Teams'>
    readonly pnr: FieldRef<"PendingBooking", 'String'>
    readonly airline: FieldRef<"PendingBooking", 'String'>
    readonly fromTo: FieldRef<"PendingBooking", 'String'>
    readonly bookingType: FieldRef<"PendingBooking", 'BookingType'>
    readonly bookingStatus: FieldRef<"PendingBooking", 'BookingStatus'>
    readonly pcDate: FieldRef<"PendingBooking", 'DateTime'>
    readonly issuedDate: FieldRef<"PendingBooking", 'DateTime'>
    readonly paymentMethod: FieldRef<"PendingBooking", 'PaymentMethod'>
    readonly lastPaymentDate: FieldRef<"PendingBooking", 'DateTime'>
    readonly travelDate: FieldRef<"PendingBooking", 'DateTime'>
    readonly revenue: FieldRef<"PendingBooking", 'Float'>
    readonly prodCost: FieldRef<"PendingBooking", 'Float'>
    readonly transFee: FieldRef<"PendingBooking", 'Float'>
    readonly surcharge: FieldRef<"PendingBooking", 'Float'>
    readonly received: FieldRef<"PendingBooking", 'Float'>
    readonly transactionMethod: FieldRef<"PendingBooking", 'String'>
    readonly receivedDate: FieldRef<"PendingBooking", 'DateTime'>
    readonly balance: FieldRef<"PendingBooking", 'Float'>
    readonly profit: FieldRef<"PendingBooking", 'Float'>
    readonly invoiced: FieldRef<"PendingBooking", 'String'>
    readonly description: FieldRef<"PendingBooking", 'String'>
    readonly status: FieldRef<"PendingBooking", 'PendingStatus'>
    readonly createdAt: FieldRef<"PendingBooking", 'DateTime'>
    readonly updatedAt: FieldRef<"PendingBooking", 'DateTime'>
    readonly numPax: FieldRef<"PendingBooking", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PendingBooking findUnique
   */
  export type PendingBookingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingBooking
     */
    select?: PendingBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingBooking
     */
    omit?: PendingBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingBookingInclude<ExtArgs> | null
    /**
     * Filter, which PendingBooking to fetch.
     */
    where: PendingBookingWhereUniqueInput
  }

  /**
   * PendingBooking findUniqueOrThrow
   */
  export type PendingBookingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingBooking
     */
    select?: PendingBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingBooking
     */
    omit?: PendingBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingBookingInclude<ExtArgs> | null
    /**
     * Filter, which PendingBooking to fetch.
     */
    where: PendingBookingWhereUniqueInput
  }

  /**
   * PendingBooking findFirst
   */
  export type PendingBookingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingBooking
     */
    select?: PendingBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingBooking
     */
    omit?: PendingBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingBookingInclude<ExtArgs> | null
    /**
     * Filter, which PendingBooking to fetch.
     */
    where?: PendingBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PendingBookings to fetch.
     */
    orderBy?: PendingBookingOrderByWithRelationInput | PendingBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PendingBookings.
     */
    cursor?: PendingBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PendingBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PendingBookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PendingBookings.
     */
    distinct?: PendingBookingScalarFieldEnum | PendingBookingScalarFieldEnum[]
  }

  /**
   * PendingBooking findFirstOrThrow
   */
  export type PendingBookingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingBooking
     */
    select?: PendingBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingBooking
     */
    omit?: PendingBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingBookingInclude<ExtArgs> | null
    /**
     * Filter, which PendingBooking to fetch.
     */
    where?: PendingBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PendingBookings to fetch.
     */
    orderBy?: PendingBookingOrderByWithRelationInput | PendingBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PendingBookings.
     */
    cursor?: PendingBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PendingBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PendingBookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PendingBookings.
     */
    distinct?: PendingBookingScalarFieldEnum | PendingBookingScalarFieldEnum[]
  }

  /**
   * PendingBooking findMany
   */
  export type PendingBookingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingBooking
     */
    select?: PendingBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingBooking
     */
    omit?: PendingBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingBookingInclude<ExtArgs> | null
    /**
     * Filter, which PendingBookings to fetch.
     */
    where?: PendingBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PendingBookings to fetch.
     */
    orderBy?: PendingBookingOrderByWithRelationInput | PendingBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PendingBookings.
     */
    cursor?: PendingBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PendingBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PendingBookings.
     */
    skip?: number
    distinct?: PendingBookingScalarFieldEnum | PendingBookingScalarFieldEnum[]
  }

  /**
   * PendingBooking create
   */
  export type PendingBookingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingBooking
     */
    select?: PendingBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingBooking
     */
    omit?: PendingBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingBookingInclude<ExtArgs> | null
    /**
     * The data needed to create a PendingBooking.
     */
    data: XOR<PendingBookingCreateInput, PendingBookingUncheckedCreateInput>
  }

  /**
   * PendingBooking createMany
   */
  export type PendingBookingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PendingBookings.
     */
    data: PendingBookingCreateManyInput | PendingBookingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PendingBooking createManyAndReturn
   */
  export type PendingBookingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingBooking
     */
    select?: PendingBookingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PendingBooking
     */
    omit?: PendingBookingOmit<ExtArgs> | null
    /**
     * The data used to create many PendingBookings.
     */
    data: PendingBookingCreateManyInput | PendingBookingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PendingBooking update
   */
  export type PendingBookingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingBooking
     */
    select?: PendingBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingBooking
     */
    omit?: PendingBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingBookingInclude<ExtArgs> | null
    /**
     * The data needed to update a PendingBooking.
     */
    data: XOR<PendingBookingUpdateInput, PendingBookingUncheckedUpdateInput>
    /**
     * Choose, which PendingBooking to update.
     */
    where: PendingBookingWhereUniqueInput
  }

  /**
   * PendingBooking updateMany
   */
  export type PendingBookingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PendingBookings.
     */
    data: XOR<PendingBookingUpdateManyMutationInput, PendingBookingUncheckedUpdateManyInput>
    /**
     * Filter which PendingBookings to update
     */
    where?: PendingBookingWhereInput
    /**
     * Limit how many PendingBookings to update.
     */
    limit?: number
  }

  /**
   * PendingBooking updateManyAndReturn
   */
  export type PendingBookingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingBooking
     */
    select?: PendingBookingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PendingBooking
     */
    omit?: PendingBookingOmit<ExtArgs> | null
    /**
     * The data used to update PendingBookings.
     */
    data: XOR<PendingBookingUpdateManyMutationInput, PendingBookingUncheckedUpdateManyInput>
    /**
     * Filter which PendingBookings to update
     */
    where?: PendingBookingWhereInput
    /**
     * Limit how many PendingBookings to update.
     */
    limit?: number
  }

  /**
   * PendingBooking upsert
   */
  export type PendingBookingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingBooking
     */
    select?: PendingBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingBooking
     */
    omit?: PendingBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingBookingInclude<ExtArgs> | null
    /**
     * The filter to search for the PendingBooking to update in case it exists.
     */
    where: PendingBookingWhereUniqueInput
    /**
     * In case the PendingBooking found by the `where` argument doesn't exist, create a new PendingBooking with this data.
     */
    create: XOR<PendingBookingCreateInput, PendingBookingUncheckedCreateInput>
    /**
     * In case the PendingBooking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PendingBookingUpdateInput, PendingBookingUncheckedUpdateInput>
  }

  /**
   * PendingBooking delete
   */
  export type PendingBookingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingBooking
     */
    select?: PendingBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingBooking
     */
    omit?: PendingBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingBookingInclude<ExtArgs> | null
    /**
     * Filter which PendingBooking to delete.
     */
    where: PendingBookingWhereUniqueInput
  }

  /**
   * PendingBooking deleteMany
   */
  export type PendingBookingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PendingBookings to delete
     */
    where?: PendingBookingWhereInput
    /**
     * Limit how many PendingBookings to delete.
     */
    limit?: number
  }

  /**
   * PendingBooking.costItems
   */
  export type PendingBooking$costItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingCostItem
     */
    select?: PendingCostItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingCostItem
     */
    omit?: PendingCostItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingCostItemInclude<ExtArgs> | null
    where?: PendingCostItemWhereInput
    orderBy?: PendingCostItemOrderByWithRelationInput | PendingCostItemOrderByWithRelationInput[]
    cursor?: PendingCostItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PendingCostItemScalarFieldEnum | PendingCostItemScalarFieldEnum[]
  }

  /**
   * PendingBooking.instalments
   */
  export type PendingBooking$instalmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingInstalment
     */
    select?: PendingInstalmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingInstalment
     */
    omit?: PendingInstalmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingInstalmentInclude<ExtArgs> | null
    where?: PendingInstalmentWhereInput
    orderBy?: PendingInstalmentOrderByWithRelationInput | PendingInstalmentOrderByWithRelationInput[]
    cursor?: PendingInstalmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PendingInstalmentScalarFieldEnum | PendingInstalmentScalarFieldEnum[]
  }

  /**
   * PendingBooking.passengers
   */
  export type PendingBooking$passengersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingPassenger
     */
    select?: PendingPassengerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingPassenger
     */
    omit?: PendingPassengerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingPassengerInclude<ExtArgs> | null
    where?: PendingPassengerWhereInput
    orderBy?: PendingPassengerOrderByWithRelationInput | PendingPassengerOrderByWithRelationInput[]
    cursor?: PendingPassengerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PendingPassengerScalarFieldEnum | PendingPassengerScalarFieldEnum[]
  }

  /**
   * PendingBooking without action
   */
  export type PendingBookingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingBooking
     */
    select?: PendingBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingBooking
     */
    omit?: PendingBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingBookingInclude<ExtArgs> | null
  }


  /**
   * Model Instalment
   */

  export type AggregateInstalment = {
    _count: InstalmentCountAggregateOutputType | null
    _avg: InstalmentAvgAggregateOutputType | null
    _sum: InstalmentSumAggregateOutputType | null
    _min: InstalmentMinAggregateOutputType | null
    _max: InstalmentMaxAggregateOutputType | null
  }

  export type InstalmentAvgAggregateOutputType = {
    id: number | null
    bookingId: number | null
    amount: number | null
  }

  export type InstalmentSumAggregateOutputType = {
    id: number | null
    bookingId: number | null
    amount: number | null
  }

  export type InstalmentMinAggregateOutputType = {
    id: number | null
    bookingId: number | null
    dueDate: Date | null
    amount: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InstalmentMaxAggregateOutputType = {
    id: number | null
    bookingId: number | null
    dueDate: Date | null
    amount: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InstalmentCountAggregateOutputType = {
    id: number
    bookingId: number
    dueDate: number
    amount: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InstalmentAvgAggregateInputType = {
    id?: true
    bookingId?: true
    amount?: true
  }

  export type InstalmentSumAggregateInputType = {
    id?: true
    bookingId?: true
    amount?: true
  }

  export type InstalmentMinAggregateInputType = {
    id?: true
    bookingId?: true
    dueDate?: true
    amount?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InstalmentMaxAggregateInputType = {
    id?: true
    bookingId?: true
    dueDate?: true
    amount?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InstalmentCountAggregateInputType = {
    id?: true
    bookingId?: true
    dueDate?: true
    amount?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InstalmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Instalment to aggregate.
     */
    where?: InstalmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Instalments to fetch.
     */
    orderBy?: InstalmentOrderByWithRelationInput | InstalmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InstalmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Instalments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Instalments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Instalments
    **/
    _count?: true | InstalmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InstalmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InstalmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InstalmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InstalmentMaxAggregateInputType
  }

  export type GetInstalmentAggregateType<T extends InstalmentAggregateArgs> = {
        [P in keyof T & keyof AggregateInstalment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInstalment[P]>
      : GetScalarType<T[P], AggregateInstalment[P]>
  }




  export type InstalmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstalmentWhereInput
    orderBy?: InstalmentOrderByWithAggregationInput | InstalmentOrderByWithAggregationInput[]
    by: InstalmentScalarFieldEnum[] | InstalmentScalarFieldEnum
    having?: InstalmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InstalmentCountAggregateInputType | true
    _avg?: InstalmentAvgAggregateInputType
    _sum?: InstalmentSumAggregateInputType
    _min?: InstalmentMinAggregateInputType
    _max?: InstalmentMaxAggregateInputType
  }

  export type InstalmentGroupByOutputType = {
    id: number
    bookingId: number
    dueDate: Date
    amount: number
    status: string
    createdAt: Date
    updatedAt: Date
    _count: InstalmentCountAggregateOutputType | null
    _avg: InstalmentAvgAggregateOutputType | null
    _sum: InstalmentSumAggregateOutputType | null
    _min: InstalmentMinAggregateOutputType | null
    _max: InstalmentMaxAggregateOutputType | null
  }

  type GetInstalmentGroupByPayload<T extends InstalmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InstalmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InstalmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InstalmentGroupByOutputType[P]>
            : GetScalarType<T[P], InstalmentGroupByOutputType[P]>
        }
      >
    >


  export type InstalmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    dueDate?: boolean
    amount?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    payments?: boolean | Instalment$paymentsArgs<ExtArgs>
    _count?: boolean | InstalmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["instalment"]>

  export type InstalmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    dueDate?: boolean
    amount?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["instalment"]>

  export type InstalmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    dueDate?: boolean
    amount?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["instalment"]>

  export type InstalmentSelectScalar = {
    id?: boolean
    bookingId?: boolean
    dueDate?: boolean
    amount?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InstalmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bookingId" | "dueDate" | "amount" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["instalment"]>
  export type InstalmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    payments?: boolean | Instalment$paymentsArgs<ExtArgs>
    _count?: boolean | InstalmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InstalmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }
  export type InstalmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }

  export type $InstalmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Instalment"
    objects: {
      booking: Prisma.$BookingPayload<ExtArgs>
      payments: Prisma.$InstalmentPaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      bookingId: number
      dueDate: Date
      amount: number
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["instalment"]>
    composites: {}
  }

  type InstalmentGetPayload<S extends boolean | null | undefined | InstalmentDefaultArgs> = $Result.GetResult<Prisma.$InstalmentPayload, S>

  type InstalmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InstalmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InstalmentCountAggregateInputType | true
    }

  export interface InstalmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Instalment'], meta: { name: 'Instalment' } }
    /**
     * Find zero or one Instalment that matches the filter.
     * @param {InstalmentFindUniqueArgs} args - Arguments to find a Instalment
     * @example
     * // Get one Instalment
     * const instalment = await prisma.instalment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InstalmentFindUniqueArgs>(args: SelectSubset<T, InstalmentFindUniqueArgs<ExtArgs>>): Prisma__InstalmentClient<$Result.GetResult<Prisma.$InstalmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Instalment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InstalmentFindUniqueOrThrowArgs} args - Arguments to find a Instalment
     * @example
     * // Get one Instalment
     * const instalment = await prisma.instalment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InstalmentFindUniqueOrThrowArgs>(args: SelectSubset<T, InstalmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InstalmentClient<$Result.GetResult<Prisma.$InstalmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Instalment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstalmentFindFirstArgs} args - Arguments to find a Instalment
     * @example
     * // Get one Instalment
     * const instalment = await prisma.instalment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InstalmentFindFirstArgs>(args?: SelectSubset<T, InstalmentFindFirstArgs<ExtArgs>>): Prisma__InstalmentClient<$Result.GetResult<Prisma.$InstalmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Instalment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstalmentFindFirstOrThrowArgs} args - Arguments to find a Instalment
     * @example
     * // Get one Instalment
     * const instalment = await prisma.instalment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InstalmentFindFirstOrThrowArgs>(args?: SelectSubset<T, InstalmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__InstalmentClient<$Result.GetResult<Prisma.$InstalmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Instalments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstalmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Instalments
     * const instalments = await prisma.instalment.findMany()
     * 
     * // Get first 10 Instalments
     * const instalments = await prisma.instalment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const instalmentWithIdOnly = await prisma.instalment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InstalmentFindManyArgs>(args?: SelectSubset<T, InstalmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstalmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Instalment.
     * @param {InstalmentCreateArgs} args - Arguments to create a Instalment.
     * @example
     * // Create one Instalment
     * const Instalment = await prisma.instalment.create({
     *   data: {
     *     // ... data to create a Instalment
     *   }
     * })
     * 
     */
    create<T extends InstalmentCreateArgs>(args: SelectSubset<T, InstalmentCreateArgs<ExtArgs>>): Prisma__InstalmentClient<$Result.GetResult<Prisma.$InstalmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Instalments.
     * @param {InstalmentCreateManyArgs} args - Arguments to create many Instalments.
     * @example
     * // Create many Instalments
     * const instalment = await prisma.instalment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InstalmentCreateManyArgs>(args?: SelectSubset<T, InstalmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Instalments and returns the data saved in the database.
     * @param {InstalmentCreateManyAndReturnArgs} args - Arguments to create many Instalments.
     * @example
     * // Create many Instalments
     * const instalment = await prisma.instalment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Instalments and only return the `id`
     * const instalmentWithIdOnly = await prisma.instalment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InstalmentCreateManyAndReturnArgs>(args?: SelectSubset<T, InstalmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstalmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Instalment.
     * @param {InstalmentDeleteArgs} args - Arguments to delete one Instalment.
     * @example
     * // Delete one Instalment
     * const Instalment = await prisma.instalment.delete({
     *   where: {
     *     // ... filter to delete one Instalment
     *   }
     * })
     * 
     */
    delete<T extends InstalmentDeleteArgs>(args: SelectSubset<T, InstalmentDeleteArgs<ExtArgs>>): Prisma__InstalmentClient<$Result.GetResult<Prisma.$InstalmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Instalment.
     * @param {InstalmentUpdateArgs} args - Arguments to update one Instalment.
     * @example
     * // Update one Instalment
     * const instalment = await prisma.instalment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InstalmentUpdateArgs>(args: SelectSubset<T, InstalmentUpdateArgs<ExtArgs>>): Prisma__InstalmentClient<$Result.GetResult<Prisma.$InstalmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Instalments.
     * @param {InstalmentDeleteManyArgs} args - Arguments to filter Instalments to delete.
     * @example
     * // Delete a few Instalments
     * const { count } = await prisma.instalment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InstalmentDeleteManyArgs>(args?: SelectSubset<T, InstalmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Instalments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstalmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Instalments
     * const instalment = await prisma.instalment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InstalmentUpdateManyArgs>(args: SelectSubset<T, InstalmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Instalments and returns the data updated in the database.
     * @param {InstalmentUpdateManyAndReturnArgs} args - Arguments to update many Instalments.
     * @example
     * // Update many Instalments
     * const instalment = await prisma.instalment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Instalments and only return the `id`
     * const instalmentWithIdOnly = await prisma.instalment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InstalmentUpdateManyAndReturnArgs>(args: SelectSubset<T, InstalmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstalmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Instalment.
     * @param {InstalmentUpsertArgs} args - Arguments to update or create a Instalment.
     * @example
     * // Update or create a Instalment
     * const instalment = await prisma.instalment.upsert({
     *   create: {
     *     // ... data to create a Instalment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Instalment we want to update
     *   }
     * })
     */
    upsert<T extends InstalmentUpsertArgs>(args: SelectSubset<T, InstalmentUpsertArgs<ExtArgs>>): Prisma__InstalmentClient<$Result.GetResult<Prisma.$InstalmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Instalments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstalmentCountArgs} args - Arguments to filter Instalments to count.
     * @example
     * // Count the number of Instalments
     * const count = await prisma.instalment.count({
     *   where: {
     *     // ... the filter for the Instalments we want to count
     *   }
     * })
    **/
    count<T extends InstalmentCountArgs>(
      args?: Subset<T, InstalmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InstalmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Instalment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstalmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InstalmentAggregateArgs>(args: Subset<T, InstalmentAggregateArgs>): Prisma.PrismaPromise<GetInstalmentAggregateType<T>>

    /**
     * Group by Instalment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstalmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InstalmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InstalmentGroupByArgs['orderBy'] }
        : { orderBy?: InstalmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InstalmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInstalmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Instalment model
   */
  readonly fields: InstalmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Instalment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InstalmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    booking<T extends BookingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BookingDefaultArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    payments<T extends Instalment$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Instalment$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstalmentPaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Instalment model
   */
  interface InstalmentFieldRefs {
    readonly id: FieldRef<"Instalment", 'Int'>
    readonly bookingId: FieldRef<"Instalment", 'Int'>
    readonly dueDate: FieldRef<"Instalment", 'DateTime'>
    readonly amount: FieldRef<"Instalment", 'Float'>
    readonly status: FieldRef<"Instalment", 'String'>
    readonly createdAt: FieldRef<"Instalment", 'DateTime'>
    readonly updatedAt: FieldRef<"Instalment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Instalment findUnique
   */
  export type InstalmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instalment
     */
    select?: InstalmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instalment
     */
    omit?: InstalmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstalmentInclude<ExtArgs> | null
    /**
     * Filter, which Instalment to fetch.
     */
    where: InstalmentWhereUniqueInput
  }

  /**
   * Instalment findUniqueOrThrow
   */
  export type InstalmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instalment
     */
    select?: InstalmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instalment
     */
    omit?: InstalmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstalmentInclude<ExtArgs> | null
    /**
     * Filter, which Instalment to fetch.
     */
    where: InstalmentWhereUniqueInput
  }

  /**
   * Instalment findFirst
   */
  export type InstalmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instalment
     */
    select?: InstalmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instalment
     */
    omit?: InstalmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstalmentInclude<ExtArgs> | null
    /**
     * Filter, which Instalment to fetch.
     */
    where?: InstalmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Instalments to fetch.
     */
    orderBy?: InstalmentOrderByWithRelationInput | InstalmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Instalments.
     */
    cursor?: InstalmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Instalments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Instalments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Instalments.
     */
    distinct?: InstalmentScalarFieldEnum | InstalmentScalarFieldEnum[]
  }

  /**
   * Instalment findFirstOrThrow
   */
  export type InstalmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instalment
     */
    select?: InstalmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instalment
     */
    omit?: InstalmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstalmentInclude<ExtArgs> | null
    /**
     * Filter, which Instalment to fetch.
     */
    where?: InstalmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Instalments to fetch.
     */
    orderBy?: InstalmentOrderByWithRelationInput | InstalmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Instalments.
     */
    cursor?: InstalmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Instalments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Instalments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Instalments.
     */
    distinct?: InstalmentScalarFieldEnum | InstalmentScalarFieldEnum[]
  }

  /**
   * Instalment findMany
   */
  export type InstalmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instalment
     */
    select?: InstalmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instalment
     */
    omit?: InstalmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstalmentInclude<ExtArgs> | null
    /**
     * Filter, which Instalments to fetch.
     */
    where?: InstalmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Instalments to fetch.
     */
    orderBy?: InstalmentOrderByWithRelationInput | InstalmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Instalments.
     */
    cursor?: InstalmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Instalments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Instalments.
     */
    skip?: number
    distinct?: InstalmentScalarFieldEnum | InstalmentScalarFieldEnum[]
  }

  /**
   * Instalment create
   */
  export type InstalmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instalment
     */
    select?: InstalmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instalment
     */
    omit?: InstalmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstalmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Instalment.
     */
    data: XOR<InstalmentCreateInput, InstalmentUncheckedCreateInput>
  }

  /**
   * Instalment createMany
   */
  export type InstalmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Instalments.
     */
    data: InstalmentCreateManyInput | InstalmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Instalment createManyAndReturn
   */
  export type InstalmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instalment
     */
    select?: InstalmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Instalment
     */
    omit?: InstalmentOmit<ExtArgs> | null
    /**
     * The data used to create many Instalments.
     */
    data: InstalmentCreateManyInput | InstalmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstalmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Instalment update
   */
  export type InstalmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instalment
     */
    select?: InstalmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instalment
     */
    omit?: InstalmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstalmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Instalment.
     */
    data: XOR<InstalmentUpdateInput, InstalmentUncheckedUpdateInput>
    /**
     * Choose, which Instalment to update.
     */
    where: InstalmentWhereUniqueInput
  }

  /**
   * Instalment updateMany
   */
  export type InstalmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Instalments.
     */
    data: XOR<InstalmentUpdateManyMutationInput, InstalmentUncheckedUpdateManyInput>
    /**
     * Filter which Instalments to update
     */
    where?: InstalmentWhereInput
    /**
     * Limit how many Instalments to update.
     */
    limit?: number
  }

  /**
   * Instalment updateManyAndReturn
   */
  export type InstalmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instalment
     */
    select?: InstalmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Instalment
     */
    omit?: InstalmentOmit<ExtArgs> | null
    /**
     * The data used to update Instalments.
     */
    data: XOR<InstalmentUpdateManyMutationInput, InstalmentUncheckedUpdateManyInput>
    /**
     * Filter which Instalments to update
     */
    where?: InstalmentWhereInput
    /**
     * Limit how many Instalments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstalmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Instalment upsert
   */
  export type InstalmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instalment
     */
    select?: InstalmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instalment
     */
    omit?: InstalmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstalmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Instalment to update in case it exists.
     */
    where: InstalmentWhereUniqueInput
    /**
     * In case the Instalment found by the `where` argument doesn't exist, create a new Instalment with this data.
     */
    create: XOR<InstalmentCreateInput, InstalmentUncheckedCreateInput>
    /**
     * In case the Instalment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InstalmentUpdateInput, InstalmentUncheckedUpdateInput>
  }

  /**
   * Instalment delete
   */
  export type InstalmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instalment
     */
    select?: InstalmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instalment
     */
    omit?: InstalmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstalmentInclude<ExtArgs> | null
    /**
     * Filter which Instalment to delete.
     */
    where: InstalmentWhereUniqueInput
  }

  /**
   * Instalment deleteMany
   */
  export type InstalmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Instalments to delete
     */
    where?: InstalmentWhereInput
    /**
     * Limit how many Instalments to delete.
     */
    limit?: number
  }

  /**
   * Instalment.payments
   */
  export type Instalment$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstalmentPayment
     */
    select?: InstalmentPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstalmentPayment
     */
    omit?: InstalmentPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstalmentPaymentInclude<ExtArgs> | null
    where?: InstalmentPaymentWhereInput
    orderBy?: InstalmentPaymentOrderByWithRelationInput | InstalmentPaymentOrderByWithRelationInput[]
    cursor?: InstalmentPaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InstalmentPaymentScalarFieldEnum | InstalmentPaymentScalarFieldEnum[]
  }

  /**
   * Instalment without action
   */
  export type InstalmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instalment
     */
    select?: InstalmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instalment
     */
    omit?: InstalmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstalmentInclude<ExtArgs> | null
  }


  /**
   * Model PendingInstalment
   */

  export type AggregatePendingInstalment = {
    _count: PendingInstalmentCountAggregateOutputType | null
    _avg: PendingInstalmentAvgAggregateOutputType | null
    _sum: PendingInstalmentSumAggregateOutputType | null
    _min: PendingInstalmentMinAggregateOutputType | null
    _max: PendingInstalmentMaxAggregateOutputType | null
  }

  export type PendingInstalmentAvgAggregateOutputType = {
    id: number | null
    pendingBookingId: number | null
    amount: number | null
  }

  export type PendingInstalmentSumAggregateOutputType = {
    id: number | null
    pendingBookingId: number | null
    amount: number | null
  }

  export type PendingInstalmentMinAggregateOutputType = {
    id: number | null
    pendingBookingId: number | null
    dueDate: Date | null
    amount: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PendingInstalmentMaxAggregateOutputType = {
    id: number | null
    pendingBookingId: number | null
    dueDate: Date | null
    amount: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PendingInstalmentCountAggregateOutputType = {
    id: number
    pendingBookingId: number
    dueDate: number
    amount: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PendingInstalmentAvgAggregateInputType = {
    id?: true
    pendingBookingId?: true
    amount?: true
  }

  export type PendingInstalmentSumAggregateInputType = {
    id?: true
    pendingBookingId?: true
    amount?: true
  }

  export type PendingInstalmentMinAggregateInputType = {
    id?: true
    pendingBookingId?: true
    dueDate?: true
    amount?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PendingInstalmentMaxAggregateInputType = {
    id?: true
    pendingBookingId?: true
    dueDate?: true
    amount?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PendingInstalmentCountAggregateInputType = {
    id?: true
    pendingBookingId?: true
    dueDate?: true
    amount?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PendingInstalmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PendingInstalment to aggregate.
     */
    where?: PendingInstalmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PendingInstalments to fetch.
     */
    orderBy?: PendingInstalmentOrderByWithRelationInput | PendingInstalmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PendingInstalmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PendingInstalments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PendingInstalments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PendingInstalments
    **/
    _count?: true | PendingInstalmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PendingInstalmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PendingInstalmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PendingInstalmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PendingInstalmentMaxAggregateInputType
  }

  export type GetPendingInstalmentAggregateType<T extends PendingInstalmentAggregateArgs> = {
        [P in keyof T & keyof AggregatePendingInstalment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePendingInstalment[P]>
      : GetScalarType<T[P], AggregatePendingInstalment[P]>
  }




  export type PendingInstalmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PendingInstalmentWhereInput
    orderBy?: PendingInstalmentOrderByWithAggregationInput | PendingInstalmentOrderByWithAggregationInput[]
    by: PendingInstalmentScalarFieldEnum[] | PendingInstalmentScalarFieldEnum
    having?: PendingInstalmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PendingInstalmentCountAggregateInputType | true
    _avg?: PendingInstalmentAvgAggregateInputType
    _sum?: PendingInstalmentSumAggregateInputType
    _min?: PendingInstalmentMinAggregateInputType
    _max?: PendingInstalmentMaxAggregateInputType
  }

  export type PendingInstalmentGroupByOutputType = {
    id: number
    pendingBookingId: number
    dueDate: Date
    amount: number
    status: string
    createdAt: Date
    updatedAt: Date
    _count: PendingInstalmentCountAggregateOutputType | null
    _avg: PendingInstalmentAvgAggregateOutputType | null
    _sum: PendingInstalmentSumAggregateOutputType | null
    _min: PendingInstalmentMinAggregateOutputType | null
    _max: PendingInstalmentMaxAggregateOutputType | null
  }

  type GetPendingInstalmentGroupByPayload<T extends PendingInstalmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PendingInstalmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PendingInstalmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PendingInstalmentGroupByOutputType[P]>
            : GetScalarType<T[P], PendingInstalmentGroupByOutputType[P]>
        }
      >
    >


  export type PendingInstalmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pendingBookingId?: boolean
    dueDate?: boolean
    amount?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pendingBooking?: boolean | PendingBookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pendingInstalment"]>

  export type PendingInstalmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pendingBookingId?: boolean
    dueDate?: boolean
    amount?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pendingBooking?: boolean | PendingBookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pendingInstalment"]>

  export type PendingInstalmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pendingBookingId?: boolean
    dueDate?: boolean
    amount?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pendingBooking?: boolean | PendingBookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pendingInstalment"]>

  export type PendingInstalmentSelectScalar = {
    id?: boolean
    pendingBookingId?: boolean
    dueDate?: boolean
    amount?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PendingInstalmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "pendingBookingId" | "dueDate" | "amount" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["pendingInstalment"]>
  export type PendingInstalmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pendingBooking?: boolean | PendingBookingDefaultArgs<ExtArgs>
  }
  export type PendingInstalmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pendingBooking?: boolean | PendingBookingDefaultArgs<ExtArgs>
  }
  export type PendingInstalmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pendingBooking?: boolean | PendingBookingDefaultArgs<ExtArgs>
  }

  export type $PendingInstalmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PendingInstalment"
    objects: {
      pendingBooking: Prisma.$PendingBookingPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      pendingBookingId: number
      dueDate: Date
      amount: number
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["pendingInstalment"]>
    composites: {}
  }

  type PendingInstalmentGetPayload<S extends boolean | null | undefined | PendingInstalmentDefaultArgs> = $Result.GetResult<Prisma.$PendingInstalmentPayload, S>

  type PendingInstalmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PendingInstalmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PendingInstalmentCountAggregateInputType | true
    }

  export interface PendingInstalmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PendingInstalment'], meta: { name: 'PendingInstalment' } }
    /**
     * Find zero or one PendingInstalment that matches the filter.
     * @param {PendingInstalmentFindUniqueArgs} args - Arguments to find a PendingInstalment
     * @example
     * // Get one PendingInstalment
     * const pendingInstalment = await prisma.pendingInstalment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PendingInstalmentFindUniqueArgs>(args: SelectSubset<T, PendingInstalmentFindUniqueArgs<ExtArgs>>): Prisma__PendingInstalmentClient<$Result.GetResult<Prisma.$PendingInstalmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PendingInstalment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PendingInstalmentFindUniqueOrThrowArgs} args - Arguments to find a PendingInstalment
     * @example
     * // Get one PendingInstalment
     * const pendingInstalment = await prisma.pendingInstalment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PendingInstalmentFindUniqueOrThrowArgs>(args: SelectSubset<T, PendingInstalmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PendingInstalmentClient<$Result.GetResult<Prisma.$PendingInstalmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PendingInstalment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingInstalmentFindFirstArgs} args - Arguments to find a PendingInstalment
     * @example
     * // Get one PendingInstalment
     * const pendingInstalment = await prisma.pendingInstalment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PendingInstalmentFindFirstArgs>(args?: SelectSubset<T, PendingInstalmentFindFirstArgs<ExtArgs>>): Prisma__PendingInstalmentClient<$Result.GetResult<Prisma.$PendingInstalmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PendingInstalment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingInstalmentFindFirstOrThrowArgs} args - Arguments to find a PendingInstalment
     * @example
     * // Get one PendingInstalment
     * const pendingInstalment = await prisma.pendingInstalment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PendingInstalmentFindFirstOrThrowArgs>(args?: SelectSubset<T, PendingInstalmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PendingInstalmentClient<$Result.GetResult<Prisma.$PendingInstalmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PendingInstalments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingInstalmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PendingInstalments
     * const pendingInstalments = await prisma.pendingInstalment.findMany()
     * 
     * // Get first 10 PendingInstalments
     * const pendingInstalments = await prisma.pendingInstalment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pendingInstalmentWithIdOnly = await prisma.pendingInstalment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PendingInstalmentFindManyArgs>(args?: SelectSubset<T, PendingInstalmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PendingInstalmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PendingInstalment.
     * @param {PendingInstalmentCreateArgs} args - Arguments to create a PendingInstalment.
     * @example
     * // Create one PendingInstalment
     * const PendingInstalment = await prisma.pendingInstalment.create({
     *   data: {
     *     // ... data to create a PendingInstalment
     *   }
     * })
     * 
     */
    create<T extends PendingInstalmentCreateArgs>(args: SelectSubset<T, PendingInstalmentCreateArgs<ExtArgs>>): Prisma__PendingInstalmentClient<$Result.GetResult<Prisma.$PendingInstalmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PendingInstalments.
     * @param {PendingInstalmentCreateManyArgs} args - Arguments to create many PendingInstalments.
     * @example
     * // Create many PendingInstalments
     * const pendingInstalment = await prisma.pendingInstalment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PendingInstalmentCreateManyArgs>(args?: SelectSubset<T, PendingInstalmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PendingInstalments and returns the data saved in the database.
     * @param {PendingInstalmentCreateManyAndReturnArgs} args - Arguments to create many PendingInstalments.
     * @example
     * // Create many PendingInstalments
     * const pendingInstalment = await prisma.pendingInstalment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PendingInstalments and only return the `id`
     * const pendingInstalmentWithIdOnly = await prisma.pendingInstalment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PendingInstalmentCreateManyAndReturnArgs>(args?: SelectSubset<T, PendingInstalmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PendingInstalmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PendingInstalment.
     * @param {PendingInstalmentDeleteArgs} args - Arguments to delete one PendingInstalment.
     * @example
     * // Delete one PendingInstalment
     * const PendingInstalment = await prisma.pendingInstalment.delete({
     *   where: {
     *     // ... filter to delete one PendingInstalment
     *   }
     * })
     * 
     */
    delete<T extends PendingInstalmentDeleteArgs>(args: SelectSubset<T, PendingInstalmentDeleteArgs<ExtArgs>>): Prisma__PendingInstalmentClient<$Result.GetResult<Prisma.$PendingInstalmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PendingInstalment.
     * @param {PendingInstalmentUpdateArgs} args - Arguments to update one PendingInstalment.
     * @example
     * // Update one PendingInstalment
     * const pendingInstalment = await prisma.pendingInstalment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PendingInstalmentUpdateArgs>(args: SelectSubset<T, PendingInstalmentUpdateArgs<ExtArgs>>): Prisma__PendingInstalmentClient<$Result.GetResult<Prisma.$PendingInstalmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PendingInstalments.
     * @param {PendingInstalmentDeleteManyArgs} args - Arguments to filter PendingInstalments to delete.
     * @example
     * // Delete a few PendingInstalments
     * const { count } = await prisma.pendingInstalment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PendingInstalmentDeleteManyArgs>(args?: SelectSubset<T, PendingInstalmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PendingInstalments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingInstalmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PendingInstalments
     * const pendingInstalment = await prisma.pendingInstalment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PendingInstalmentUpdateManyArgs>(args: SelectSubset<T, PendingInstalmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PendingInstalments and returns the data updated in the database.
     * @param {PendingInstalmentUpdateManyAndReturnArgs} args - Arguments to update many PendingInstalments.
     * @example
     * // Update many PendingInstalments
     * const pendingInstalment = await prisma.pendingInstalment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PendingInstalments and only return the `id`
     * const pendingInstalmentWithIdOnly = await prisma.pendingInstalment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PendingInstalmentUpdateManyAndReturnArgs>(args: SelectSubset<T, PendingInstalmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PendingInstalmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PendingInstalment.
     * @param {PendingInstalmentUpsertArgs} args - Arguments to update or create a PendingInstalment.
     * @example
     * // Update or create a PendingInstalment
     * const pendingInstalment = await prisma.pendingInstalment.upsert({
     *   create: {
     *     // ... data to create a PendingInstalment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PendingInstalment we want to update
     *   }
     * })
     */
    upsert<T extends PendingInstalmentUpsertArgs>(args: SelectSubset<T, PendingInstalmentUpsertArgs<ExtArgs>>): Prisma__PendingInstalmentClient<$Result.GetResult<Prisma.$PendingInstalmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PendingInstalments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingInstalmentCountArgs} args - Arguments to filter PendingInstalments to count.
     * @example
     * // Count the number of PendingInstalments
     * const count = await prisma.pendingInstalment.count({
     *   where: {
     *     // ... the filter for the PendingInstalments we want to count
     *   }
     * })
    **/
    count<T extends PendingInstalmentCountArgs>(
      args?: Subset<T, PendingInstalmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PendingInstalmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PendingInstalment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingInstalmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PendingInstalmentAggregateArgs>(args: Subset<T, PendingInstalmentAggregateArgs>): Prisma.PrismaPromise<GetPendingInstalmentAggregateType<T>>

    /**
     * Group by PendingInstalment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingInstalmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PendingInstalmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PendingInstalmentGroupByArgs['orderBy'] }
        : { orderBy?: PendingInstalmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PendingInstalmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPendingInstalmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PendingInstalment model
   */
  readonly fields: PendingInstalmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PendingInstalment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PendingInstalmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pendingBooking<T extends PendingBookingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PendingBookingDefaultArgs<ExtArgs>>): Prisma__PendingBookingClient<$Result.GetResult<Prisma.$PendingBookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PendingInstalment model
   */
  interface PendingInstalmentFieldRefs {
    readonly id: FieldRef<"PendingInstalment", 'Int'>
    readonly pendingBookingId: FieldRef<"PendingInstalment", 'Int'>
    readonly dueDate: FieldRef<"PendingInstalment", 'DateTime'>
    readonly amount: FieldRef<"PendingInstalment", 'Float'>
    readonly status: FieldRef<"PendingInstalment", 'String'>
    readonly createdAt: FieldRef<"PendingInstalment", 'DateTime'>
    readonly updatedAt: FieldRef<"PendingInstalment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PendingInstalment findUnique
   */
  export type PendingInstalmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingInstalment
     */
    select?: PendingInstalmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingInstalment
     */
    omit?: PendingInstalmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingInstalmentInclude<ExtArgs> | null
    /**
     * Filter, which PendingInstalment to fetch.
     */
    where: PendingInstalmentWhereUniqueInput
  }

  /**
   * PendingInstalment findUniqueOrThrow
   */
  export type PendingInstalmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingInstalment
     */
    select?: PendingInstalmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingInstalment
     */
    omit?: PendingInstalmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingInstalmentInclude<ExtArgs> | null
    /**
     * Filter, which PendingInstalment to fetch.
     */
    where: PendingInstalmentWhereUniqueInput
  }

  /**
   * PendingInstalment findFirst
   */
  export type PendingInstalmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingInstalment
     */
    select?: PendingInstalmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingInstalment
     */
    omit?: PendingInstalmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingInstalmentInclude<ExtArgs> | null
    /**
     * Filter, which PendingInstalment to fetch.
     */
    where?: PendingInstalmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PendingInstalments to fetch.
     */
    orderBy?: PendingInstalmentOrderByWithRelationInput | PendingInstalmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PendingInstalments.
     */
    cursor?: PendingInstalmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PendingInstalments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PendingInstalments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PendingInstalments.
     */
    distinct?: PendingInstalmentScalarFieldEnum | PendingInstalmentScalarFieldEnum[]
  }

  /**
   * PendingInstalment findFirstOrThrow
   */
  export type PendingInstalmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingInstalment
     */
    select?: PendingInstalmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingInstalment
     */
    omit?: PendingInstalmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingInstalmentInclude<ExtArgs> | null
    /**
     * Filter, which PendingInstalment to fetch.
     */
    where?: PendingInstalmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PendingInstalments to fetch.
     */
    orderBy?: PendingInstalmentOrderByWithRelationInput | PendingInstalmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PendingInstalments.
     */
    cursor?: PendingInstalmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PendingInstalments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PendingInstalments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PendingInstalments.
     */
    distinct?: PendingInstalmentScalarFieldEnum | PendingInstalmentScalarFieldEnum[]
  }

  /**
   * PendingInstalment findMany
   */
  export type PendingInstalmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingInstalment
     */
    select?: PendingInstalmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingInstalment
     */
    omit?: PendingInstalmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingInstalmentInclude<ExtArgs> | null
    /**
     * Filter, which PendingInstalments to fetch.
     */
    where?: PendingInstalmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PendingInstalments to fetch.
     */
    orderBy?: PendingInstalmentOrderByWithRelationInput | PendingInstalmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PendingInstalments.
     */
    cursor?: PendingInstalmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PendingInstalments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PendingInstalments.
     */
    skip?: number
    distinct?: PendingInstalmentScalarFieldEnum | PendingInstalmentScalarFieldEnum[]
  }

  /**
   * PendingInstalment create
   */
  export type PendingInstalmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingInstalment
     */
    select?: PendingInstalmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingInstalment
     */
    omit?: PendingInstalmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingInstalmentInclude<ExtArgs> | null
    /**
     * The data needed to create a PendingInstalment.
     */
    data: XOR<PendingInstalmentCreateInput, PendingInstalmentUncheckedCreateInput>
  }

  /**
   * PendingInstalment createMany
   */
  export type PendingInstalmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PendingInstalments.
     */
    data: PendingInstalmentCreateManyInput | PendingInstalmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PendingInstalment createManyAndReturn
   */
  export type PendingInstalmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingInstalment
     */
    select?: PendingInstalmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PendingInstalment
     */
    omit?: PendingInstalmentOmit<ExtArgs> | null
    /**
     * The data used to create many PendingInstalments.
     */
    data: PendingInstalmentCreateManyInput | PendingInstalmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingInstalmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PendingInstalment update
   */
  export type PendingInstalmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingInstalment
     */
    select?: PendingInstalmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingInstalment
     */
    omit?: PendingInstalmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingInstalmentInclude<ExtArgs> | null
    /**
     * The data needed to update a PendingInstalment.
     */
    data: XOR<PendingInstalmentUpdateInput, PendingInstalmentUncheckedUpdateInput>
    /**
     * Choose, which PendingInstalment to update.
     */
    where: PendingInstalmentWhereUniqueInput
  }

  /**
   * PendingInstalment updateMany
   */
  export type PendingInstalmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PendingInstalments.
     */
    data: XOR<PendingInstalmentUpdateManyMutationInput, PendingInstalmentUncheckedUpdateManyInput>
    /**
     * Filter which PendingInstalments to update
     */
    where?: PendingInstalmentWhereInput
    /**
     * Limit how many PendingInstalments to update.
     */
    limit?: number
  }

  /**
   * PendingInstalment updateManyAndReturn
   */
  export type PendingInstalmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingInstalment
     */
    select?: PendingInstalmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PendingInstalment
     */
    omit?: PendingInstalmentOmit<ExtArgs> | null
    /**
     * The data used to update PendingInstalments.
     */
    data: XOR<PendingInstalmentUpdateManyMutationInput, PendingInstalmentUncheckedUpdateManyInput>
    /**
     * Filter which PendingInstalments to update
     */
    where?: PendingInstalmentWhereInput
    /**
     * Limit how many PendingInstalments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingInstalmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PendingInstalment upsert
   */
  export type PendingInstalmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingInstalment
     */
    select?: PendingInstalmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingInstalment
     */
    omit?: PendingInstalmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingInstalmentInclude<ExtArgs> | null
    /**
     * The filter to search for the PendingInstalment to update in case it exists.
     */
    where: PendingInstalmentWhereUniqueInput
    /**
     * In case the PendingInstalment found by the `where` argument doesn't exist, create a new PendingInstalment with this data.
     */
    create: XOR<PendingInstalmentCreateInput, PendingInstalmentUncheckedCreateInput>
    /**
     * In case the PendingInstalment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PendingInstalmentUpdateInput, PendingInstalmentUncheckedUpdateInput>
  }

  /**
   * PendingInstalment delete
   */
  export type PendingInstalmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingInstalment
     */
    select?: PendingInstalmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingInstalment
     */
    omit?: PendingInstalmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingInstalmentInclude<ExtArgs> | null
    /**
     * Filter which PendingInstalment to delete.
     */
    where: PendingInstalmentWhereUniqueInput
  }

  /**
   * PendingInstalment deleteMany
   */
  export type PendingInstalmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PendingInstalments to delete
     */
    where?: PendingInstalmentWhereInput
    /**
     * Limit how many PendingInstalments to delete.
     */
    limit?: number
  }

  /**
   * PendingInstalment without action
   */
  export type PendingInstalmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingInstalment
     */
    select?: PendingInstalmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingInstalment
     */
    omit?: PendingInstalmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingInstalmentInclude<ExtArgs> | null
  }


  /**
   * Model InstalmentPayment
   */

  export type AggregateInstalmentPayment = {
    _count: InstalmentPaymentCountAggregateOutputType | null
    _avg: InstalmentPaymentAvgAggregateOutputType | null
    _sum: InstalmentPaymentSumAggregateOutputType | null
    _min: InstalmentPaymentMinAggregateOutputType | null
    _max: InstalmentPaymentMaxAggregateOutputType | null
  }

  export type InstalmentPaymentAvgAggregateOutputType = {
    id: number | null
    instalmentId: number | null
    amount: number | null
  }

  export type InstalmentPaymentSumAggregateOutputType = {
    id: number | null
    instalmentId: number | null
    amount: number | null
  }

  export type InstalmentPaymentMinAggregateOutputType = {
    id: number | null
    instalmentId: number | null
    amount: number | null
    transactionMethod: string | null
    paymentDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InstalmentPaymentMaxAggregateOutputType = {
    id: number | null
    instalmentId: number | null
    amount: number | null
    transactionMethod: string | null
    paymentDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InstalmentPaymentCountAggregateOutputType = {
    id: number
    instalmentId: number
    amount: number
    transactionMethod: number
    paymentDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InstalmentPaymentAvgAggregateInputType = {
    id?: true
    instalmentId?: true
    amount?: true
  }

  export type InstalmentPaymentSumAggregateInputType = {
    id?: true
    instalmentId?: true
    amount?: true
  }

  export type InstalmentPaymentMinAggregateInputType = {
    id?: true
    instalmentId?: true
    amount?: true
    transactionMethod?: true
    paymentDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InstalmentPaymentMaxAggregateInputType = {
    id?: true
    instalmentId?: true
    amount?: true
    transactionMethod?: true
    paymentDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InstalmentPaymentCountAggregateInputType = {
    id?: true
    instalmentId?: true
    amount?: true
    transactionMethod?: true
    paymentDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InstalmentPaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InstalmentPayment to aggregate.
     */
    where?: InstalmentPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstalmentPayments to fetch.
     */
    orderBy?: InstalmentPaymentOrderByWithRelationInput | InstalmentPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InstalmentPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstalmentPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstalmentPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InstalmentPayments
    **/
    _count?: true | InstalmentPaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InstalmentPaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InstalmentPaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InstalmentPaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InstalmentPaymentMaxAggregateInputType
  }

  export type GetInstalmentPaymentAggregateType<T extends InstalmentPaymentAggregateArgs> = {
        [P in keyof T & keyof AggregateInstalmentPayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInstalmentPayment[P]>
      : GetScalarType<T[P], AggregateInstalmentPayment[P]>
  }




  export type InstalmentPaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstalmentPaymentWhereInput
    orderBy?: InstalmentPaymentOrderByWithAggregationInput | InstalmentPaymentOrderByWithAggregationInput[]
    by: InstalmentPaymentScalarFieldEnum[] | InstalmentPaymentScalarFieldEnum
    having?: InstalmentPaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InstalmentPaymentCountAggregateInputType | true
    _avg?: InstalmentPaymentAvgAggregateInputType
    _sum?: InstalmentPaymentSumAggregateInputType
    _min?: InstalmentPaymentMinAggregateInputType
    _max?: InstalmentPaymentMaxAggregateInputType
  }

  export type InstalmentPaymentGroupByOutputType = {
    id: number
    instalmentId: number
    amount: number
    transactionMethod: string
    paymentDate: Date
    createdAt: Date
    updatedAt: Date
    _count: InstalmentPaymentCountAggregateOutputType | null
    _avg: InstalmentPaymentAvgAggregateOutputType | null
    _sum: InstalmentPaymentSumAggregateOutputType | null
    _min: InstalmentPaymentMinAggregateOutputType | null
    _max: InstalmentPaymentMaxAggregateOutputType | null
  }

  type GetInstalmentPaymentGroupByPayload<T extends InstalmentPaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InstalmentPaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InstalmentPaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InstalmentPaymentGroupByOutputType[P]>
            : GetScalarType<T[P], InstalmentPaymentGroupByOutputType[P]>
        }
      >
    >


  export type InstalmentPaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    instalmentId?: boolean
    amount?: boolean
    transactionMethod?: boolean
    paymentDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    instalment?: boolean | InstalmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["instalmentPayment"]>

  export type InstalmentPaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    instalmentId?: boolean
    amount?: boolean
    transactionMethod?: boolean
    paymentDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    instalment?: boolean | InstalmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["instalmentPayment"]>

  export type InstalmentPaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    instalmentId?: boolean
    amount?: boolean
    transactionMethod?: boolean
    paymentDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    instalment?: boolean | InstalmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["instalmentPayment"]>

  export type InstalmentPaymentSelectScalar = {
    id?: boolean
    instalmentId?: boolean
    amount?: boolean
    transactionMethod?: boolean
    paymentDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InstalmentPaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "instalmentId" | "amount" | "transactionMethod" | "paymentDate" | "createdAt" | "updatedAt", ExtArgs["result"]["instalmentPayment"]>
  export type InstalmentPaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    instalment?: boolean | InstalmentDefaultArgs<ExtArgs>
  }
  export type InstalmentPaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    instalment?: boolean | InstalmentDefaultArgs<ExtArgs>
  }
  export type InstalmentPaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    instalment?: boolean | InstalmentDefaultArgs<ExtArgs>
  }

  export type $InstalmentPaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InstalmentPayment"
    objects: {
      instalment: Prisma.$InstalmentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      instalmentId: number
      amount: number
      transactionMethod: string
      paymentDate: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["instalmentPayment"]>
    composites: {}
  }

  type InstalmentPaymentGetPayload<S extends boolean | null | undefined | InstalmentPaymentDefaultArgs> = $Result.GetResult<Prisma.$InstalmentPaymentPayload, S>

  type InstalmentPaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InstalmentPaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InstalmentPaymentCountAggregateInputType | true
    }

  export interface InstalmentPaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InstalmentPayment'], meta: { name: 'InstalmentPayment' } }
    /**
     * Find zero or one InstalmentPayment that matches the filter.
     * @param {InstalmentPaymentFindUniqueArgs} args - Arguments to find a InstalmentPayment
     * @example
     * // Get one InstalmentPayment
     * const instalmentPayment = await prisma.instalmentPayment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InstalmentPaymentFindUniqueArgs>(args: SelectSubset<T, InstalmentPaymentFindUniqueArgs<ExtArgs>>): Prisma__InstalmentPaymentClient<$Result.GetResult<Prisma.$InstalmentPaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InstalmentPayment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InstalmentPaymentFindUniqueOrThrowArgs} args - Arguments to find a InstalmentPayment
     * @example
     * // Get one InstalmentPayment
     * const instalmentPayment = await prisma.instalmentPayment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InstalmentPaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, InstalmentPaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InstalmentPaymentClient<$Result.GetResult<Prisma.$InstalmentPaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InstalmentPayment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstalmentPaymentFindFirstArgs} args - Arguments to find a InstalmentPayment
     * @example
     * // Get one InstalmentPayment
     * const instalmentPayment = await prisma.instalmentPayment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InstalmentPaymentFindFirstArgs>(args?: SelectSubset<T, InstalmentPaymentFindFirstArgs<ExtArgs>>): Prisma__InstalmentPaymentClient<$Result.GetResult<Prisma.$InstalmentPaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InstalmentPayment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstalmentPaymentFindFirstOrThrowArgs} args - Arguments to find a InstalmentPayment
     * @example
     * // Get one InstalmentPayment
     * const instalmentPayment = await prisma.instalmentPayment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InstalmentPaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, InstalmentPaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__InstalmentPaymentClient<$Result.GetResult<Prisma.$InstalmentPaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InstalmentPayments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstalmentPaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InstalmentPayments
     * const instalmentPayments = await prisma.instalmentPayment.findMany()
     * 
     * // Get first 10 InstalmentPayments
     * const instalmentPayments = await prisma.instalmentPayment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const instalmentPaymentWithIdOnly = await prisma.instalmentPayment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InstalmentPaymentFindManyArgs>(args?: SelectSubset<T, InstalmentPaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstalmentPaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InstalmentPayment.
     * @param {InstalmentPaymentCreateArgs} args - Arguments to create a InstalmentPayment.
     * @example
     * // Create one InstalmentPayment
     * const InstalmentPayment = await prisma.instalmentPayment.create({
     *   data: {
     *     // ... data to create a InstalmentPayment
     *   }
     * })
     * 
     */
    create<T extends InstalmentPaymentCreateArgs>(args: SelectSubset<T, InstalmentPaymentCreateArgs<ExtArgs>>): Prisma__InstalmentPaymentClient<$Result.GetResult<Prisma.$InstalmentPaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InstalmentPayments.
     * @param {InstalmentPaymentCreateManyArgs} args - Arguments to create many InstalmentPayments.
     * @example
     * // Create many InstalmentPayments
     * const instalmentPayment = await prisma.instalmentPayment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InstalmentPaymentCreateManyArgs>(args?: SelectSubset<T, InstalmentPaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InstalmentPayments and returns the data saved in the database.
     * @param {InstalmentPaymentCreateManyAndReturnArgs} args - Arguments to create many InstalmentPayments.
     * @example
     * // Create many InstalmentPayments
     * const instalmentPayment = await prisma.instalmentPayment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InstalmentPayments and only return the `id`
     * const instalmentPaymentWithIdOnly = await prisma.instalmentPayment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InstalmentPaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, InstalmentPaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstalmentPaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InstalmentPayment.
     * @param {InstalmentPaymentDeleteArgs} args - Arguments to delete one InstalmentPayment.
     * @example
     * // Delete one InstalmentPayment
     * const InstalmentPayment = await prisma.instalmentPayment.delete({
     *   where: {
     *     // ... filter to delete one InstalmentPayment
     *   }
     * })
     * 
     */
    delete<T extends InstalmentPaymentDeleteArgs>(args: SelectSubset<T, InstalmentPaymentDeleteArgs<ExtArgs>>): Prisma__InstalmentPaymentClient<$Result.GetResult<Prisma.$InstalmentPaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InstalmentPayment.
     * @param {InstalmentPaymentUpdateArgs} args - Arguments to update one InstalmentPayment.
     * @example
     * // Update one InstalmentPayment
     * const instalmentPayment = await prisma.instalmentPayment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InstalmentPaymentUpdateArgs>(args: SelectSubset<T, InstalmentPaymentUpdateArgs<ExtArgs>>): Prisma__InstalmentPaymentClient<$Result.GetResult<Prisma.$InstalmentPaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InstalmentPayments.
     * @param {InstalmentPaymentDeleteManyArgs} args - Arguments to filter InstalmentPayments to delete.
     * @example
     * // Delete a few InstalmentPayments
     * const { count } = await prisma.instalmentPayment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InstalmentPaymentDeleteManyArgs>(args?: SelectSubset<T, InstalmentPaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InstalmentPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstalmentPaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InstalmentPayments
     * const instalmentPayment = await prisma.instalmentPayment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InstalmentPaymentUpdateManyArgs>(args: SelectSubset<T, InstalmentPaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InstalmentPayments and returns the data updated in the database.
     * @param {InstalmentPaymentUpdateManyAndReturnArgs} args - Arguments to update many InstalmentPayments.
     * @example
     * // Update many InstalmentPayments
     * const instalmentPayment = await prisma.instalmentPayment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InstalmentPayments and only return the `id`
     * const instalmentPaymentWithIdOnly = await prisma.instalmentPayment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InstalmentPaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, InstalmentPaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstalmentPaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InstalmentPayment.
     * @param {InstalmentPaymentUpsertArgs} args - Arguments to update or create a InstalmentPayment.
     * @example
     * // Update or create a InstalmentPayment
     * const instalmentPayment = await prisma.instalmentPayment.upsert({
     *   create: {
     *     // ... data to create a InstalmentPayment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InstalmentPayment we want to update
     *   }
     * })
     */
    upsert<T extends InstalmentPaymentUpsertArgs>(args: SelectSubset<T, InstalmentPaymentUpsertArgs<ExtArgs>>): Prisma__InstalmentPaymentClient<$Result.GetResult<Prisma.$InstalmentPaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InstalmentPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstalmentPaymentCountArgs} args - Arguments to filter InstalmentPayments to count.
     * @example
     * // Count the number of InstalmentPayments
     * const count = await prisma.instalmentPayment.count({
     *   where: {
     *     // ... the filter for the InstalmentPayments we want to count
     *   }
     * })
    **/
    count<T extends InstalmentPaymentCountArgs>(
      args?: Subset<T, InstalmentPaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InstalmentPaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InstalmentPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstalmentPaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InstalmentPaymentAggregateArgs>(args: Subset<T, InstalmentPaymentAggregateArgs>): Prisma.PrismaPromise<GetInstalmentPaymentAggregateType<T>>

    /**
     * Group by InstalmentPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstalmentPaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InstalmentPaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InstalmentPaymentGroupByArgs['orderBy'] }
        : { orderBy?: InstalmentPaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InstalmentPaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInstalmentPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InstalmentPayment model
   */
  readonly fields: InstalmentPaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InstalmentPayment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InstalmentPaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    instalment<T extends InstalmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstalmentDefaultArgs<ExtArgs>>): Prisma__InstalmentClient<$Result.GetResult<Prisma.$InstalmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InstalmentPayment model
   */
  interface InstalmentPaymentFieldRefs {
    readonly id: FieldRef<"InstalmentPayment", 'Int'>
    readonly instalmentId: FieldRef<"InstalmentPayment", 'Int'>
    readonly amount: FieldRef<"InstalmentPayment", 'Float'>
    readonly transactionMethod: FieldRef<"InstalmentPayment", 'String'>
    readonly paymentDate: FieldRef<"InstalmentPayment", 'DateTime'>
    readonly createdAt: FieldRef<"InstalmentPayment", 'DateTime'>
    readonly updatedAt: FieldRef<"InstalmentPayment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InstalmentPayment findUnique
   */
  export type InstalmentPaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstalmentPayment
     */
    select?: InstalmentPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstalmentPayment
     */
    omit?: InstalmentPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstalmentPaymentInclude<ExtArgs> | null
    /**
     * Filter, which InstalmentPayment to fetch.
     */
    where: InstalmentPaymentWhereUniqueInput
  }

  /**
   * InstalmentPayment findUniqueOrThrow
   */
  export type InstalmentPaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstalmentPayment
     */
    select?: InstalmentPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstalmentPayment
     */
    omit?: InstalmentPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstalmentPaymentInclude<ExtArgs> | null
    /**
     * Filter, which InstalmentPayment to fetch.
     */
    where: InstalmentPaymentWhereUniqueInput
  }

  /**
   * InstalmentPayment findFirst
   */
  export type InstalmentPaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstalmentPayment
     */
    select?: InstalmentPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstalmentPayment
     */
    omit?: InstalmentPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstalmentPaymentInclude<ExtArgs> | null
    /**
     * Filter, which InstalmentPayment to fetch.
     */
    where?: InstalmentPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstalmentPayments to fetch.
     */
    orderBy?: InstalmentPaymentOrderByWithRelationInput | InstalmentPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InstalmentPayments.
     */
    cursor?: InstalmentPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstalmentPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstalmentPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InstalmentPayments.
     */
    distinct?: InstalmentPaymentScalarFieldEnum | InstalmentPaymentScalarFieldEnum[]
  }

  /**
   * InstalmentPayment findFirstOrThrow
   */
  export type InstalmentPaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstalmentPayment
     */
    select?: InstalmentPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstalmentPayment
     */
    omit?: InstalmentPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstalmentPaymentInclude<ExtArgs> | null
    /**
     * Filter, which InstalmentPayment to fetch.
     */
    where?: InstalmentPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstalmentPayments to fetch.
     */
    orderBy?: InstalmentPaymentOrderByWithRelationInput | InstalmentPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InstalmentPayments.
     */
    cursor?: InstalmentPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstalmentPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstalmentPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InstalmentPayments.
     */
    distinct?: InstalmentPaymentScalarFieldEnum | InstalmentPaymentScalarFieldEnum[]
  }

  /**
   * InstalmentPayment findMany
   */
  export type InstalmentPaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstalmentPayment
     */
    select?: InstalmentPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstalmentPayment
     */
    omit?: InstalmentPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstalmentPaymentInclude<ExtArgs> | null
    /**
     * Filter, which InstalmentPayments to fetch.
     */
    where?: InstalmentPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstalmentPayments to fetch.
     */
    orderBy?: InstalmentPaymentOrderByWithRelationInput | InstalmentPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InstalmentPayments.
     */
    cursor?: InstalmentPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstalmentPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstalmentPayments.
     */
    skip?: number
    distinct?: InstalmentPaymentScalarFieldEnum | InstalmentPaymentScalarFieldEnum[]
  }

  /**
   * InstalmentPayment create
   */
  export type InstalmentPaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstalmentPayment
     */
    select?: InstalmentPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstalmentPayment
     */
    omit?: InstalmentPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstalmentPaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a InstalmentPayment.
     */
    data: XOR<InstalmentPaymentCreateInput, InstalmentPaymentUncheckedCreateInput>
  }

  /**
   * InstalmentPayment createMany
   */
  export type InstalmentPaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InstalmentPayments.
     */
    data: InstalmentPaymentCreateManyInput | InstalmentPaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InstalmentPayment createManyAndReturn
   */
  export type InstalmentPaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstalmentPayment
     */
    select?: InstalmentPaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InstalmentPayment
     */
    omit?: InstalmentPaymentOmit<ExtArgs> | null
    /**
     * The data used to create many InstalmentPayments.
     */
    data: InstalmentPaymentCreateManyInput | InstalmentPaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstalmentPaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InstalmentPayment update
   */
  export type InstalmentPaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstalmentPayment
     */
    select?: InstalmentPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstalmentPayment
     */
    omit?: InstalmentPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstalmentPaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a InstalmentPayment.
     */
    data: XOR<InstalmentPaymentUpdateInput, InstalmentPaymentUncheckedUpdateInput>
    /**
     * Choose, which InstalmentPayment to update.
     */
    where: InstalmentPaymentWhereUniqueInput
  }

  /**
   * InstalmentPayment updateMany
   */
  export type InstalmentPaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InstalmentPayments.
     */
    data: XOR<InstalmentPaymentUpdateManyMutationInput, InstalmentPaymentUncheckedUpdateManyInput>
    /**
     * Filter which InstalmentPayments to update
     */
    where?: InstalmentPaymentWhereInput
    /**
     * Limit how many InstalmentPayments to update.
     */
    limit?: number
  }

  /**
   * InstalmentPayment updateManyAndReturn
   */
  export type InstalmentPaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstalmentPayment
     */
    select?: InstalmentPaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InstalmentPayment
     */
    omit?: InstalmentPaymentOmit<ExtArgs> | null
    /**
     * The data used to update InstalmentPayments.
     */
    data: XOR<InstalmentPaymentUpdateManyMutationInput, InstalmentPaymentUncheckedUpdateManyInput>
    /**
     * Filter which InstalmentPayments to update
     */
    where?: InstalmentPaymentWhereInput
    /**
     * Limit how many InstalmentPayments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstalmentPaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InstalmentPayment upsert
   */
  export type InstalmentPaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstalmentPayment
     */
    select?: InstalmentPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstalmentPayment
     */
    omit?: InstalmentPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstalmentPaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the InstalmentPayment to update in case it exists.
     */
    where: InstalmentPaymentWhereUniqueInput
    /**
     * In case the InstalmentPayment found by the `where` argument doesn't exist, create a new InstalmentPayment with this data.
     */
    create: XOR<InstalmentPaymentCreateInput, InstalmentPaymentUncheckedCreateInput>
    /**
     * In case the InstalmentPayment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InstalmentPaymentUpdateInput, InstalmentPaymentUncheckedUpdateInput>
  }

  /**
   * InstalmentPayment delete
   */
  export type InstalmentPaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstalmentPayment
     */
    select?: InstalmentPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstalmentPayment
     */
    omit?: InstalmentPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstalmentPaymentInclude<ExtArgs> | null
    /**
     * Filter which InstalmentPayment to delete.
     */
    where: InstalmentPaymentWhereUniqueInput
  }

  /**
   * InstalmentPayment deleteMany
   */
  export type InstalmentPaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InstalmentPayments to delete
     */
    where?: InstalmentPaymentWhereInput
    /**
     * Limit how many InstalmentPayments to delete.
     */
    limit?: number
  }

  /**
   * InstalmentPayment without action
   */
  export type InstalmentPaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstalmentPayment
     */
    select?: InstalmentPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstalmentPayment
     */
    omit?: InstalmentPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstalmentPaymentInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    email: string | null
    title: string | null
    firstName: string | null
    lastName: string | null
    contactNo: string | null
    role: $Enums.Role | null
    createdAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    email: string | null
    title: string | null
    firstName: string | null
    lastName: string | null
    contactNo: string | null
    role: $Enums.Role | null
    createdAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    title: number
    firstName: number
    lastName: number
    contactNo: number
    role: number
    createdAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    title?: true
    firstName?: true
    lastName?: true
    contactNo?: true
    role?: true
    createdAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    title?: true
    firstName?: true
    lastName?: true
    contactNo?: true
    role?: true
    createdAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    title?: true
    firstName?: true
    lastName?: true
    contactNo?: true
    role?: true
    createdAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    email: string | null
    title: string | null
    firstName: string
    lastName: string
    contactNo: string | null
    role: $Enums.Role
    createdAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    title?: boolean
    firstName?: boolean
    lastName?: boolean
    contactNo?: boolean
    role?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    title?: boolean
    firstName?: boolean
    lastName?: boolean
    contactNo?: boolean
    role?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    title?: boolean
    firstName?: boolean
    lastName?: boolean
    contactNo?: boolean
    role?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    title?: boolean
    firstName?: boolean
    lastName?: boolean
    contactNo?: boolean
    role?: boolean
    createdAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "title" | "firstName" | "lastName" | "contactNo" | "role" | "createdAt", ExtArgs["result"]["user"]>

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string | null
      title: string | null
      firstName: string
      lastName: string
      contactNo: string | null
      role: $Enums.Role
      createdAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly email: FieldRef<"User", 'String'>
    readonly title: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly contactNo: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
  }


  /**
   * Model CostItem
   */

  export type AggregateCostItem = {
    _count: CostItemCountAggregateOutputType | null
    _avg: CostItemAvgAggregateOutputType | null
    _sum: CostItemSumAggregateOutputType | null
    _min: CostItemMinAggregateOutputType | null
    _max: CostItemMaxAggregateOutputType | null
  }

  export type CostItemAvgAggregateOutputType = {
    id: number | null
    bookingId: number | null
    amount: number | null
  }

  export type CostItemSumAggregateOutputType = {
    id: number | null
    bookingId: number | null
    amount: number | null
  }

  export type CostItemMinAggregateOutputType = {
    id: number | null
    bookingId: number | null
    category: string | null
    amount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CostItemMaxAggregateOutputType = {
    id: number | null
    bookingId: number | null
    category: string | null
    amount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CostItemCountAggregateOutputType = {
    id: number
    bookingId: number
    category: number
    amount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CostItemAvgAggregateInputType = {
    id?: true
    bookingId?: true
    amount?: true
  }

  export type CostItemSumAggregateInputType = {
    id?: true
    bookingId?: true
    amount?: true
  }

  export type CostItemMinAggregateInputType = {
    id?: true
    bookingId?: true
    category?: true
    amount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CostItemMaxAggregateInputType = {
    id?: true
    bookingId?: true
    category?: true
    amount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CostItemCountAggregateInputType = {
    id?: true
    bookingId?: true
    category?: true
    amount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CostItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CostItem to aggregate.
     */
    where?: CostItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CostItems to fetch.
     */
    orderBy?: CostItemOrderByWithRelationInput | CostItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CostItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CostItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CostItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CostItems
    **/
    _count?: true | CostItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CostItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CostItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CostItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CostItemMaxAggregateInputType
  }

  export type GetCostItemAggregateType<T extends CostItemAggregateArgs> = {
        [P in keyof T & keyof AggregateCostItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCostItem[P]>
      : GetScalarType<T[P], AggregateCostItem[P]>
  }




  export type CostItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CostItemWhereInput
    orderBy?: CostItemOrderByWithAggregationInput | CostItemOrderByWithAggregationInput[]
    by: CostItemScalarFieldEnum[] | CostItemScalarFieldEnum
    having?: CostItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CostItemCountAggregateInputType | true
    _avg?: CostItemAvgAggregateInputType
    _sum?: CostItemSumAggregateInputType
    _min?: CostItemMinAggregateInputType
    _max?: CostItemMaxAggregateInputType
  }

  export type CostItemGroupByOutputType = {
    id: number
    bookingId: number
    category: string
    amount: number
    createdAt: Date
    updatedAt: Date
    _count: CostItemCountAggregateOutputType | null
    _avg: CostItemAvgAggregateOutputType | null
    _sum: CostItemSumAggregateOutputType | null
    _min: CostItemMinAggregateOutputType | null
    _max: CostItemMaxAggregateOutputType | null
  }

  type GetCostItemGroupByPayload<T extends CostItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CostItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CostItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CostItemGroupByOutputType[P]>
            : GetScalarType<T[P], CostItemGroupByOutputType[P]>
        }
      >
    >


  export type CostItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    category?: boolean
    amount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    suppliers?: boolean | CostItem$suppliersArgs<ExtArgs>
    _count?: boolean | CostItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["costItem"]>

  export type CostItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    category?: boolean
    amount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["costItem"]>

  export type CostItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    category?: boolean
    amount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["costItem"]>

  export type CostItemSelectScalar = {
    id?: boolean
    bookingId?: boolean
    category?: boolean
    amount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CostItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bookingId" | "category" | "amount" | "createdAt" | "updatedAt", ExtArgs["result"]["costItem"]>
  export type CostItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    suppliers?: boolean | CostItem$suppliersArgs<ExtArgs>
    _count?: boolean | CostItemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CostItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }
  export type CostItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }

  export type $CostItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CostItem"
    objects: {
      booking: Prisma.$BookingPayload<ExtArgs>
      suppliers: Prisma.$CostItemSupplierPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      bookingId: number
      category: string
      amount: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["costItem"]>
    composites: {}
  }

  type CostItemGetPayload<S extends boolean | null | undefined | CostItemDefaultArgs> = $Result.GetResult<Prisma.$CostItemPayload, S>

  type CostItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CostItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CostItemCountAggregateInputType | true
    }

  export interface CostItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CostItem'], meta: { name: 'CostItem' } }
    /**
     * Find zero or one CostItem that matches the filter.
     * @param {CostItemFindUniqueArgs} args - Arguments to find a CostItem
     * @example
     * // Get one CostItem
     * const costItem = await prisma.costItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CostItemFindUniqueArgs>(args: SelectSubset<T, CostItemFindUniqueArgs<ExtArgs>>): Prisma__CostItemClient<$Result.GetResult<Prisma.$CostItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CostItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CostItemFindUniqueOrThrowArgs} args - Arguments to find a CostItem
     * @example
     * // Get one CostItem
     * const costItem = await prisma.costItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CostItemFindUniqueOrThrowArgs>(args: SelectSubset<T, CostItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CostItemClient<$Result.GetResult<Prisma.$CostItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CostItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostItemFindFirstArgs} args - Arguments to find a CostItem
     * @example
     * // Get one CostItem
     * const costItem = await prisma.costItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CostItemFindFirstArgs>(args?: SelectSubset<T, CostItemFindFirstArgs<ExtArgs>>): Prisma__CostItemClient<$Result.GetResult<Prisma.$CostItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CostItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostItemFindFirstOrThrowArgs} args - Arguments to find a CostItem
     * @example
     * // Get one CostItem
     * const costItem = await prisma.costItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CostItemFindFirstOrThrowArgs>(args?: SelectSubset<T, CostItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__CostItemClient<$Result.GetResult<Prisma.$CostItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CostItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CostItems
     * const costItems = await prisma.costItem.findMany()
     * 
     * // Get first 10 CostItems
     * const costItems = await prisma.costItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const costItemWithIdOnly = await prisma.costItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CostItemFindManyArgs>(args?: SelectSubset<T, CostItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CostItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CostItem.
     * @param {CostItemCreateArgs} args - Arguments to create a CostItem.
     * @example
     * // Create one CostItem
     * const CostItem = await prisma.costItem.create({
     *   data: {
     *     // ... data to create a CostItem
     *   }
     * })
     * 
     */
    create<T extends CostItemCreateArgs>(args: SelectSubset<T, CostItemCreateArgs<ExtArgs>>): Prisma__CostItemClient<$Result.GetResult<Prisma.$CostItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CostItems.
     * @param {CostItemCreateManyArgs} args - Arguments to create many CostItems.
     * @example
     * // Create many CostItems
     * const costItem = await prisma.costItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CostItemCreateManyArgs>(args?: SelectSubset<T, CostItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CostItems and returns the data saved in the database.
     * @param {CostItemCreateManyAndReturnArgs} args - Arguments to create many CostItems.
     * @example
     * // Create many CostItems
     * const costItem = await prisma.costItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CostItems and only return the `id`
     * const costItemWithIdOnly = await prisma.costItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CostItemCreateManyAndReturnArgs>(args?: SelectSubset<T, CostItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CostItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CostItem.
     * @param {CostItemDeleteArgs} args - Arguments to delete one CostItem.
     * @example
     * // Delete one CostItem
     * const CostItem = await prisma.costItem.delete({
     *   where: {
     *     // ... filter to delete one CostItem
     *   }
     * })
     * 
     */
    delete<T extends CostItemDeleteArgs>(args: SelectSubset<T, CostItemDeleteArgs<ExtArgs>>): Prisma__CostItemClient<$Result.GetResult<Prisma.$CostItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CostItem.
     * @param {CostItemUpdateArgs} args - Arguments to update one CostItem.
     * @example
     * // Update one CostItem
     * const costItem = await prisma.costItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CostItemUpdateArgs>(args: SelectSubset<T, CostItemUpdateArgs<ExtArgs>>): Prisma__CostItemClient<$Result.GetResult<Prisma.$CostItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CostItems.
     * @param {CostItemDeleteManyArgs} args - Arguments to filter CostItems to delete.
     * @example
     * // Delete a few CostItems
     * const { count } = await prisma.costItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CostItemDeleteManyArgs>(args?: SelectSubset<T, CostItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CostItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CostItems
     * const costItem = await prisma.costItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CostItemUpdateManyArgs>(args: SelectSubset<T, CostItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CostItems and returns the data updated in the database.
     * @param {CostItemUpdateManyAndReturnArgs} args - Arguments to update many CostItems.
     * @example
     * // Update many CostItems
     * const costItem = await prisma.costItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CostItems and only return the `id`
     * const costItemWithIdOnly = await prisma.costItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CostItemUpdateManyAndReturnArgs>(args: SelectSubset<T, CostItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CostItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CostItem.
     * @param {CostItemUpsertArgs} args - Arguments to update or create a CostItem.
     * @example
     * // Update or create a CostItem
     * const costItem = await prisma.costItem.upsert({
     *   create: {
     *     // ... data to create a CostItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CostItem we want to update
     *   }
     * })
     */
    upsert<T extends CostItemUpsertArgs>(args: SelectSubset<T, CostItemUpsertArgs<ExtArgs>>): Prisma__CostItemClient<$Result.GetResult<Prisma.$CostItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CostItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostItemCountArgs} args - Arguments to filter CostItems to count.
     * @example
     * // Count the number of CostItems
     * const count = await prisma.costItem.count({
     *   where: {
     *     // ... the filter for the CostItems we want to count
     *   }
     * })
    **/
    count<T extends CostItemCountArgs>(
      args?: Subset<T, CostItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CostItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CostItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CostItemAggregateArgs>(args: Subset<T, CostItemAggregateArgs>): Prisma.PrismaPromise<GetCostItemAggregateType<T>>

    /**
     * Group by CostItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CostItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CostItemGroupByArgs['orderBy'] }
        : { orderBy?: CostItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CostItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCostItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CostItem model
   */
  readonly fields: CostItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CostItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CostItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    booking<T extends BookingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BookingDefaultArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    suppliers<T extends CostItem$suppliersArgs<ExtArgs> = {}>(args?: Subset<T, CostItem$suppliersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CostItemSupplierPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CostItem model
   */
  interface CostItemFieldRefs {
    readonly id: FieldRef<"CostItem", 'Int'>
    readonly bookingId: FieldRef<"CostItem", 'Int'>
    readonly category: FieldRef<"CostItem", 'String'>
    readonly amount: FieldRef<"CostItem", 'Float'>
    readonly createdAt: FieldRef<"CostItem", 'DateTime'>
    readonly updatedAt: FieldRef<"CostItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CostItem findUnique
   */
  export type CostItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostItem
     */
    select?: CostItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostItem
     */
    omit?: CostItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostItemInclude<ExtArgs> | null
    /**
     * Filter, which CostItem to fetch.
     */
    where: CostItemWhereUniqueInput
  }

  /**
   * CostItem findUniqueOrThrow
   */
  export type CostItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostItem
     */
    select?: CostItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostItem
     */
    omit?: CostItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostItemInclude<ExtArgs> | null
    /**
     * Filter, which CostItem to fetch.
     */
    where: CostItemWhereUniqueInput
  }

  /**
   * CostItem findFirst
   */
  export type CostItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostItem
     */
    select?: CostItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostItem
     */
    omit?: CostItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostItemInclude<ExtArgs> | null
    /**
     * Filter, which CostItem to fetch.
     */
    where?: CostItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CostItems to fetch.
     */
    orderBy?: CostItemOrderByWithRelationInput | CostItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CostItems.
     */
    cursor?: CostItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CostItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CostItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CostItems.
     */
    distinct?: CostItemScalarFieldEnum | CostItemScalarFieldEnum[]
  }

  /**
   * CostItem findFirstOrThrow
   */
  export type CostItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostItem
     */
    select?: CostItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostItem
     */
    omit?: CostItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostItemInclude<ExtArgs> | null
    /**
     * Filter, which CostItem to fetch.
     */
    where?: CostItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CostItems to fetch.
     */
    orderBy?: CostItemOrderByWithRelationInput | CostItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CostItems.
     */
    cursor?: CostItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CostItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CostItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CostItems.
     */
    distinct?: CostItemScalarFieldEnum | CostItemScalarFieldEnum[]
  }

  /**
   * CostItem findMany
   */
  export type CostItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostItem
     */
    select?: CostItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostItem
     */
    omit?: CostItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostItemInclude<ExtArgs> | null
    /**
     * Filter, which CostItems to fetch.
     */
    where?: CostItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CostItems to fetch.
     */
    orderBy?: CostItemOrderByWithRelationInput | CostItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CostItems.
     */
    cursor?: CostItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CostItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CostItems.
     */
    skip?: number
    distinct?: CostItemScalarFieldEnum | CostItemScalarFieldEnum[]
  }

  /**
   * CostItem create
   */
  export type CostItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostItem
     */
    select?: CostItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostItem
     */
    omit?: CostItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostItemInclude<ExtArgs> | null
    /**
     * The data needed to create a CostItem.
     */
    data: XOR<CostItemCreateInput, CostItemUncheckedCreateInput>
  }

  /**
   * CostItem createMany
   */
  export type CostItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CostItems.
     */
    data: CostItemCreateManyInput | CostItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CostItem createManyAndReturn
   */
  export type CostItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostItem
     */
    select?: CostItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CostItem
     */
    omit?: CostItemOmit<ExtArgs> | null
    /**
     * The data used to create many CostItems.
     */
    data: CostItemCreateManyInput | CostItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CostItem update
   */
  export type CostItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostItem
     */
    select?: CostItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostItem
     */
    omit?: CostItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostItemInclude<ExtArgs> | null
    /**
     * The data needed to update a CostItem.
     */
    data: XOR<CostItemUpdateInput, CostItemUncheckedUpdateInput>
    /**
     * Choose, which CostItem to update.
     */
    where: CostItemWhereUniqueInput
  }

  /**
   * CostItem updateMany
   */
  export type CostItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CostItems.
     */
    data: XOR<CostItemUpdateManyMutationInput, CostItemUncheckedUpdateManyInput>
    /**
     * Filter which CostItems to update
     */
    where?: CostItemWhereInput
    /**
     * Limit how many CostItems to update.
     */
    limit?: number
  }

  /**
   * CostItem updateManyAndReturn
   */
  export type CostItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostItem
     */
    select?: CostItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CostItem
     */
    omit?: CostItemOmit<ExtArgs> | null
    /**
     * The data used to update CostItems.
     */
    data: XOR<CostItemUpdateManyMutationInput, CostItemUncheckedUpdateManyInput>
    /**
     * Filter which CostItems to update
     */
    where?: CostItemWhereInput
    /**
     * Limit how many CostItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CostItem upsert
   */
  export type CostItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostItem
     */
    select?: CostItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostItem
     */
    omit?: CostItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostItemInclude<ExtArgs> | null
    /**
     * The filter to search for the CostItem to update in case it exists.
     */
    where: CostItemWhereUniqueInput
    /**
     * In case the CostItem found by the `where` argument doesn't exist, create a new CostItem with this data.
     */
    create: XOR<CostItemCreateInput, CostItemUncheckedCreateInput>
    /**
     * In case the CostItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CostItemUpdateInput, CostItemUncheckedUpdateInput>
  }

  /**
   * CostItem delete
   */
  export type CostItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostItem
     */
    select?: CostItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostItem
     */
    omit?: CostItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostItemInclude<ExtArgs> | null
    /**
     * Filter which CostItem to delete.
     */
    where: CostItemWhereUniqueInput
  }

  /**
   * CostItem deleteMany
   */
  export type CostItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CostItems to delete
     */
    where?: CostItemWhereInput
    /**
     * Limit how many CostItems to delete.
     */
    limit?: number
  }

  /**
   * CostItem.suppliers
   */
  export type CostItem$suppliersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostItemSupplier
     */
    select?: CostItemSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostItemSupplier
     */
    omit?: CostItemSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostItemSupplierInclude<ExtArgs> | null
    where?: CostItemSupplierWhereInput
    orderBy?: CostItemSupplierOrderByWithRelationInput | CostItemSupplierOrderByWithRelationInput[]
    cursor?: CostItemSupplierWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CostItemSupplierScalarFieldEnum | CostItemSupplierScalarFieldEnum[]
  }

  /**
   * CostItem without action
   */
  export type CostItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostItem
     */
    select?: CostItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostItem
     */
    omit?: CostItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostItemInclude<ExtArgs> | null
  }


  /**
   * Model PendingCostItem
   */

  export type AggregatePendingCostItem = {
    _count: PendingCostItemCountAggregateOutputType | null
    _avg: PendingCostItemAvgAggregateOutputType | null
    _sum: PendingCostItemSumAggregateOutputType | null
    _min: PendingCostItemMinAggregateOutputType | null
    _max: PendingCostItemMaxAggregateOutputType | null
  }

  export type PendingCostItemAvgAggregateOutputType = {
    id: number | null
    pendingBookingId: number | null
    amount: number | null
  }

  export type PendingCostItemSumAggregateOutputType = {
    id: number | null
    pendingBookingId: number | null
    amount: number | null
  }

  export type PendingCostItemMinAggregateOutputType = {
    id: number | null
    pendingBookingId: number | null
    category: string | null
    amount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PendingCostItemMaxAggregateOutputType = {
    id: number | null
    pendingBookingId: number | null
    category: string | null
    amount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PendingCostItemCountAggregateOutputType = {
    id: number
    pendingBookingId: number
    category: number
    amount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PendingCostItemAvgAggregateInputType = {
    id?: true
    pendingBookingId?: true
    amount?: true
  }

  export type PendingCostItemSumAggregateInputType = {
    id?: true
    pendingBookingId?: true
    amount?: true
  }

  export type PendingCostItemMinAggregateInputType = {
    id?: true
    pendingBookingId?: true
    category?: true
    amount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PendingCostItemMaxAggregateInputType = {
    id?: true
    pendingBookingId?: true
    category?: true
    amount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PendingCostItemCountAggregateInputType = {
    id?: true
    pendingBookingId?: true
    category?: true
    amount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PendingCostItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PendingCostItem to aggregate.
     */
    where?: PendingCostItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PendingCostItems to fetch.
     */
    orderBy?: PendingCostItemOrderByWithRelationInput | PendingCostItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PendingCostItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PendingCostItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PendingCostItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PendingCostItems
    **/
    _count?: true | PendingCostItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PendingCostItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PendingCostItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PendingCostItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PendingCostItemMaxAggregateInputType
  }

  export type GetPendingCostItemAggregateType<T extends PendingCostItemAggregateArgs> = {
        [P in keyof T & keyof AggregatePendingCostItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePendingCostItem[P]>
      : GetScalarType<T[P], AggregatePendingCostItem[P]>
  }




  export type PendingCostItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PendingCostItemWhereInput
    orderBy?: PendingCostItemOrderByWithAggregationInput | PendingCostItemOrderByWithAggregationInput[]
    by: PendingCostItemScalarFieldEnum[] | PendingCostItemScalarFieldEnum
    having?: PendingCostItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PendingCostItemCountAggregateInputType | true
    _avg?: PendingCostItemAvgAggregateInputType
    _sum?: PendingCostItemSumAggregateInputType
    _min?: PendingCostItemMinAggregateInputType
    _max?: PendingCostItemMaxAggregateInputType
  }

  export type PendingCostItemGroupByOutputType = {
    id: number
    pendingBookingId: number
    category: string
    amount: number
    createdAt: Date
    updatedAt: Date
    _count: PendingCostItemCountAggregateOutputType | null
    _avg: PendingCostItemAvgAggregateOutputType | null
    _sum: PendingCostItemSumAggregateOutputType | null
    _min: PendingCostItemMinAggregateOutputType | null
    _max: PendingCostItemMaxAggregateOutputType | null
  }

  type GetPendingCostItemGroupByPayload<T extends PendingCostItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PendingCostItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PendingCostItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PendingCostItemGroupByOutputType[P]>
            : GetScalarType<T[P], PendingCostItemGroupByOutputType[P]>
        }
      >
    >


  export type PendingCostItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pendingBookingId?: boolean
    category?: boolean
    amount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pendingBooking?: boolean | PendingBookingDefaultArgs<ExtArgs>
    suppliers?: boolean | PendingCostItem$suppliersArgs<ExtArgs>
    _count?: boolean | PendingCostItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pendingCostItem"]>

  export type PendingCostItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pendingBookingId?: boolean
    category?: boolean
    amount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pendingBooking?: boolean | PendingBookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pendingCostItem"]>

  export type PendingCostItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pendingBookingId?: boolean
    category?: boolean
    amount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pendingBooking?: boolean | PendingBookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pendingCostItem"]>

  export type PendingCostItemSelectScalar = {
    id?: boolean
    pendingBookingId?: boolean
    category?: boolean
    amount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PendingCostItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "pendingBookingId" | "category" | "amount" | "createdAt" | "updatedAt", ExtArgs["result"]["pendingCostItem"]>
  export type PendingCostItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pendingBooking?: boolean | PendingBookingDefaultArgs<ExtArgs>
    suppliers?: boolean | PendingCostItem$suppliersArgs<ExtArgs>
    _count?: boolean | PendingCostItemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PendingCostItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pendingBooking?: boolean | PendingBookingDefaultArgs<ExtArgs>
  }
  export type PendingCostItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pendingBooking?: boolean | PendingBookingDefaultArgs<ExtArgs>
  }

  export type $PendingCostItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PendingCostItem"
    objects: {
      pendingBooking: Prisma.$PendingBookingPayload<ExtArgs>
      suppliers: Prisma.$CostItemSupplierPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      pendingBookingId: number
      category: string
      amount: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["pendingCostItem"]>
    composites: {}
  }

  type PendingCostItemGetPayload<S extends boolean | null | undefined | PendingCostItemDefaultArgs> = $Result.GetResult<Prisma.$PendingCostItemPayload, S>

  type PendingCostItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PendingCostItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PendingCostItemCountAggregateInputType | true
    }

  export interface PendingCostItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PendingCostItem'], meta: { name: 'PendingCostItem' } }
    /**
     * Find zero or one PendingCostItem that matches the filter.
     * @param {PendingCostItemFindUniqueArgs} args - Arguments to find a PendingCostItem
     * @example
     * // Get one PendingCostItem
     * const pendingCostItem = await prisma.pendingCostItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PendingCostItemFindUniqueArgs>(args: SelectSubset<T, PendingCostItemFindUniqueArgs<ExtArgs>>): Prisma__PendingCostItemClient<$Result.GetResult<Prisma.$PendingCostItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PendingCostItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PendingCostItemFindUniqueOrThrowArgs} args - Arguments to find a PendingCostItem
     * @example
     * // Get one PendingCostItem
     * const pendingCostItem = await prisma.pendingCostItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PendingCostItemFindUniqueOrThrowArgs>(args: SelectSubset<T, PendingCostItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PendingCostItemClient<$Result.GetResult<Prisma.$PendingCostItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PendingCostItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingCostItemFindFirstArgs} args - Arguments to find a PendingCostItem
     * @example
     * // Get one PendingCostItem
     * const pendingCostItem = await prisma.pendingCostItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PendingCostItemFindFirstArgs>(args?: SelectSubset<T, PendingCostItemFindFirstArgs<ExtArgs>>): Prisma__PendingCostItemClient<$Result.GetResult<Prisma.$PendingCostItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PendingCostItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingCostItemFindFirstOrThrowArgs} args - Arguments to find a PendingCostItem
     * @example
     * // Get one PendingCostItem
     * const pendingCostItem = await prisma.pendingCostItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PendingCostItemFindFirstOrThrowArgs>(args?: SelectSubset<T, PendingCostItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__PendingCostItemClient<$Result.GetResult<Prisma.$PendingCostItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PendingCostItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingCostItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PendingCostItems
     * const pendingCostItems = await prisma.pendingCostItem.findMany()
     * 
     * // Get first 10 PendingCostItems
     * const pendingCostItems = await prisma.pendingCostItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pendingCostItemWithIdOnly = await prisma.pendingCostItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PendingCostItemFindManyArgs>(args?: SelectSubset<T, PendingCostItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PendingCostItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PendingCostItem.
     * @param {PendingCostItemCreateArgs} args - Arguments to create a PendingCostItem.
     * @example
     * // Create one PendingCostItem
     * const PendingCostItem = await prisma.pendingCostItem.create({
     *   data: {
     *     // ... data to create a PendingCostItem
     *   }
     * })
     * 
     */
    create<T extends PendingCostItemCreateArgs>(args: SelectSubset<T, PendingCostItemCreateArgs<ExtArgs>>): Prisma__PendingCostItemClient<$Result.GetResult<Prisma.$PendingCostItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PendingCostItems.
     * @param {PendingCostItemCreateManyArgs} args - Arguments to create many PendingCostItems.
     * @example
     * // Create many PendingCostItems
     * const pendingCostItem = await prisma.pendingCostItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PendingCostItemCreateManyArgs>(args?: SelectSubset<T, PendingCostItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PendingCostItems and returns the data saved in the database.
     * @param {PendingCostItemCreateManyAndReturnArgs} args - Arguments to create many PendingCostItems.
     * @example
     * // Create many PendingCostItems
     * const pendingCostItem = await prisma.pendingCostItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PendingCostItems and only return the `id`
     * const pendingCostItemWithIdOnly = await prisma.pendingCostItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PendingCostItemCreateManyAndReturnArgs>(args?: SelectSubset<T, PendingCostItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PendingCostItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PendingCostItem.
     * @param {PendingCostItemDeleteArgs} args - Arguments to delete one PendingCostItem.
     * @example
     * // Delete one PendingCostItem
     * const PendingCostItem = await prisma.pendingCostItem.delete({
     *   where: {
     *     // ... filter to delete one PendingCostItem
     *   }
     * })
     * 
     */
    delete<T extends PendingCostItemDeleteArgs>(args: SelectSubset<T, PendingCostItemDeleteArgs<ExtArgs>>): Prisma__PendingCostItemClient<$Result.GetResult<Prisma.$PendingCostItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PendingCostItem.
     * @param {PendingCostItemUpdateArgs} args - Arguments to update one PendingCostItem.
     * @example
     * // Update one PendingCostItem
     * const pendingCostItem = await prisma.pendingCostItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PendingCostItemUpdateArgs>(args: SelectSubset<T, PendingCostItemUpdateArgs<ExtArgs>>): Prisma__PendingCostItemClient<$Result.GetResult<Prisma.$PendingCostItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PendingCostItems.
     * @param {PendingCostItemDeleteManyArgs} args - Arguments to filter PendingCostItems to delete.
     * @example
     * // Delete a few PendingCostItems
     * const { count } = await prisma.pendingCostItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PendingCostItemDeleteManyArgs>(args?: SelectSubset<T, PendingCostItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PendingCostItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingCostItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PendingCostItems
     * const pendingCostItem = await prisma.pendingCostItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PendingCostItemUpdateManyArgs>(args: SelectSubset<T, PendingCostItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PendingCostItems and returns the data updated in the database.
     * @param {PendingCostItemUpdateManyAndReturnArgs} args - Arguments to update many PendingCostItems.
     * @example
     * // Update many PendingCostItems
     * const pendingCostItem = await prisma.pendingCostItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PendingCostItems and only return the `id`
     * const pendingCostItemWithIdOnly = await prisma.pendingCostItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PendingCostItemUpdateManyAndReturnArgs>(args: SelectSubset<T, PendingCostItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PendingCostItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PendingCostItem.
     * @param {PendingCostItemUpsertArgs} args - Arguments to update or create a PendingCostItem.
     * @example
     * // Update or create a PendingCostItem
     * const pendingCostItem = await prisma.pendingCostItem.upsert({
     *   create: {
     *     // ... data to create a PendingCostItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PendingCostItem we want to update
     *   }
     * })
     */
    upsert<T extends PendingCostItemUpsertArgs>(args: SelectSubset<T, PendingCostItemUpsertArgs<ExtArgs>>): Prisma__PendingCostItemClient<$Result.GetResult<Prisma.$PendingCostItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PendingCostItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingCostItemCountArgs} args - Arguments to filter PendingCostItems to count.
     * @example
     * // Count the number of PendingCostItems
     * const count = await prisma.pendingCostItem.count({
     *   where: {
     *     // ... the filter for the PendingCostItems we want to count
     *   }
     * })
    **/
    count<T extends PendingCostItemCountArgs>(
      args?: Subset<T, PendingCostItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PendingCostItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PendingCostItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingCostItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PendingCostItemAggregateArgs>(args: Subset<T, PendingCostItemAggregateArgs>): Prisma.PrismaPromise<GetPendingCostItemAggregateType<T>>

    /**
     * Group by PendingCostItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingCostItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PendingCostItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PendingCostItemGroupByArgs['orderBy'] }
        : { orderBy?: PendingCostItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PendingCostItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPendingCostItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PendingCostItem model
   */
  readonly fields: PendingCostItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PendingCostItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PendingCostItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pendingBooking<T extends PendingBookingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PendingBookingDefaultArgs<ExtArgs>>): Prisma__PendingBookingClient<$Result.GetResult<Prisma.$PendingBookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    suppliers<T extends PendingCostItem$suppliersArgs<ExtArgs> = {}>(args?: Subset<T, PendingCostItem$suppliersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CostItemSupplierPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PendingCostItem model
   */
  interface PendingCostItemFieldRefs {
    readonly id: FieldRef<"PendingCostItem", 'Int'>
    readonly pendingBookingId: FieldRef<"PendingCostItem", 'Int'>
    readonly category: FieldRef<"PendingCostItem", 'String'>
    readonly amount: FieldRef<"PendingCostItem", 'Float'>
    readonly createdAt: FieldRef<"PendingCostItem", 'DateTime'>
    readonly updatedAt: FieldRef<"PendingCostItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PendingCostItem findUnique
   */
  export type PendingCostItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingCostItem
     */
    select?: PendingCostItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingCostItem
     */
    omit?: PendingCostItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingCostItemInclude<ExtArgs> | null
    /**
     * Filter, which PendingCostItem to fetch.
     */
    where: PendingCostItemWhereUniqueInput
  }

  /**
   * PendingCostItem findUniqueOrThrow
   */
  export type PendingCostItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingCostItem
     */
    select?: PendingCostItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingCostItem
     */
    omit?: PendingCostItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingCostItemInclude<ExtArgs> | null
    /**
     * Filter, which PendingCostItem to fetch.
     */
    where: PendingCostItemWhereUniqueInput
  }

  /**
   * PendingCostItem findFirst
   */
  export type PendingCostItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingCostItem
     */
    select?: PendingCostItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingCostItem
     */
    omit?: PendingCostItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingCostItemInclude<ExtArgs> | null
    /**
     * Filter, which PendingCostItem to fetch.
     */
    where?: PendingCostItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PendingCostItems to fetch.
     */
    orderBy?: PendingCostItemOrderByWithRelationInput | PendingCostItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PendingCostItems.
     */
    cursor?: PendingCostItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PendingCostItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PendingCostItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PendingCostItems.
     */
    distinct?: PendingCostItemScalarFieldEnum | PendingCostItemScalarFieldEnum[]
  }

  /**
   * PendingCostItem findFirstOrThrow
   */
  export type PendingCostItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingCostItem
     */
    select?: PendingCostItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingCostItem
     */
    omit?: PendingCostItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingCostItemInclude<ExtArgs> | null
    /**
     * Filter, which PendingCostItem to fetch.
     */
    where?: PendingCostItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PendingCostItems to fetch.
     */
    orderBy?: PendingCostItemOrderByWithRelationInput | PendingCostItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PendingCostItems.
     */
    cursor?: PendingCostItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PendingCostItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PendingCostItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PendingCostItems.
     */
    distinct?: PendingCostItemScalarFieldEnum | PendingCostItemScalarFieldEnum[]
  }

  /**
   * PendingCostItem findMany
   */
  export type PendingCostItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingCostItem
     */
    select?: PendingCostItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingCostItem
     */
    omit?: PendingCostItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingCostItemInclude<ExtArgs> | null
    /**
     * Filter, which PendingCostItems to fetch.
     */
    where?: PendingCostItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PendingCostItems to fetch.
     */
    orderBy?: PendingCostItemOrderByWithRelationInput | PendingCostItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PendingCostItems.
     */
    cursor?: PendingCostItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PendingCostItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PendingCostItems.
     */
    skip?: number
    distinct?: PendingCostItemScalarFieldEnum | PendingCostItemScalarFieldEnum[]
  }

  /**
   * PendingCostItem create
   */
  export type PendingCostItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingCostItem
     */
    select?: PendingCostItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingCostItem
     */
    omit?: PendingCostItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingCostItemInclude<ExtArgs> | null
    /**
     * The data needed to create a PendingCostItem.
     */
    data: XOR<PendingCostItemCreateInput, PendingCostItemUncheckedCreateInput>
  }

  /**
   * PendingCostItem createMany
   */
  export type PendingCostItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PendingCostItems.
     */
    data: PendingCostItemCreateManyInput | PendingCostItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PendingCostItem createManyAndReturn
   */
  export type PendingCostItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingCostItem
     */
    select?: PendingCostItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PendingCostItem
     */
    omit?: PendingCostItemOmit<ExtArgs> | null
    /**
     * The data used to create many PendingCostItems.
     */
    data: PendingCostItemCreateManyInput | PendingCostItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingCostItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PendingCostItem update
   */
  export type PendingCostItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingCostItem
     */
    select?: PendingCostItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingCostItem
     */
    omit?: PendingCostItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingCostItemInclude<ExtArgs> | null
    /**
     * The data needed to update a PendingCostItem.
     */
    data: XOR<PendingCostItemUpdateInput, PendingCostItemUncheckedUpdateInput>
    /**
     * Choose, which PendingCostItem to update.
     */
    where: PendingCostItemWhereUniqueInput
  }

  /**
   * PendingCostItem updateMany
   */
  export type PendingCostItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PendingCostItems.
     */
    data: XOR<PendingCostItemUpdateManyMutationInput, PendingCostItemUncheckedUpdateManyInput>
    /**
     * Filter which PendingCostItems to update
     */
    where?: PendingCostItemWhereInput
    /**
     * Limit how many PendingCostItems to update.
     */
    limit?: number
  }

  /**
   * PendingCostItem updateManyAndReturn
   */
  export type PendingCostItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingCostItem
     */
    select?: PendingCostItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PendingCostItem
     */
    omit?: PendingCostItemOmit<ExtArgs> | null
    /**
     * The data used to update PendingCostItems.
     */
    data: XOR<PendingCostItemUpdateManyMutationInput, PendingCostItemUncheckedUpdateManyInput>
    /**
     * Filter which PendingCostItems to update
     */
    where?: PendingCostItemWhereInput
    /**
     * Limit how many PendingCostItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingCostItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PendingCostItem upsert
   */
  export type PendingCostItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingCostItem
     */
    select?: PendingCostItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingCostItem
     */
    omit?: PendingCostItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingCostItemInclude<ExtArgs> | null
    /**
     * The filter to search for the PendingCostItem to update in case it exists.
     */
    where: PendingCostItemWhereUniqueInput
    /**
     * In case the PendingCostItem found by the `where` argument doesn't exist, create a new PendingCostItem with this data.
     */
    create: XOR<PendingCostItemCreateInput, PendingCostItemUncheckedCreateInput>
    /**
     * In case the PendingCostItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PendingCostItemUpdateInput, PendingCostItemUncheckedUpdateInput>
  }

  /**
   * PendingCostItem delete
   */
  export type PendingCostItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingCostItem
     */
    select?: PendingCostItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingCostItem
     */
    omit?: PendingCostItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingCostItemInclude<ExtArgs> | null
    /**
     * Filter which PendingCostItem to delete.
     */
    where: PendingCostItemWhereUniqueInput
  }

  /**
   * PendingCostItem deleteMany
   */
  export type PendingCostItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PendingCostItems to delete
     */
    where?: PendingCostItemWhereInput
    /**
     * Limit how many PendingCostItems to delete.
     */
    limit?: number
  }

  /**
   * PendingCostItem.suppliers
   */
  export type PendingCostItem$suppliersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostItemSupplier
     */
    select?: CostItemSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostItemSupplier
     */
    omit?: CostItemSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostItemSupplierInclude<ExtArgs> | null
    where?: CostItemSupplierWhereInput
    orderBy?: CostItemSupplierOrderByWithRelationInput | CostItemSupplierOrderByWithRelationInput[]
    cursor?: CostItemSupplierWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CostItemSupplierScalarFieldEnum | CostItemSupplierScalarFieldEnum[]
  }

  /**
   * PendingCostItem without action
   */
  export type PendingCostItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingCostItem
     */
    select?: PendingCostItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingCostItem
     */
    omit?: PendingCostItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingCostItemInclude<ExtArgs> | null
  }


  /**
   * Model Passenger
   */

  export type AggregatePassenger = {
    _count: PassengerCountAggregateOutputType | null
    _avg: PassengerAvgAggregateOutputType | null
    _sum: PassengerSumAggregateOutputType | null
    _min: PassengerMinAggregateOutputType | null
    _max: PassengerMaxAggregateOutputType | null
  }

  export type PassengerAvgAggregateOutputType = {
    id: number | null
    bookingId: number | null
  }

  export type PassengerSumAggregateOutputType = {
    id: number | null
    bookingId: number | null
  }

  export type PassengerMinAggregateOutputType = {
    id: number | null
    bookingId: number | null
    title: $Enums.Title | null
    firstName: string | null
    middleName: string | null
    lastName: string | null
    gender: $Enums.Gender | null
    email: string | null
    contactNo: string | null
    nationality: string | null
    birthday: Date | null
    category: $Enums.PassengerCategory | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PassengerMaxAggregateOutputType = {
    id: number | null
    bookingId: number | null
    title: $Enums.Title | null
    firstName: string | null
    middleName: string | null
    lastName: string | null
    gender: $Enums.Gender | null
    email: string | null
    contactNo: string | null
    nationality: string | null
    birthday: Date | null
    category: $Enums.PassengerCategory | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PassengerCountAggregateOutputType = {
    id: number
    bookingId: number
    title: number
    firstName: number
    middleName: number
    lastName: number
    gender: number
    email: number
    contactNo: number
    nationality: number
    birthday: number
    category: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PassengerAvgAggregateInputType = {
    id?: true
    bookingId?: true
  }

  export type PassengerSumAggregateInputType = {
    id?: true
    bookingId?: true
  }

  export type PassengerMinAggregateInputType = {
    id?: true
    bookingId?: true
    title?: true
    firstName?: true
    middleName?: true
    lastName?: true
    gender?: true
    email?: true
    contactNo?: true
    nationality?: true
    birthday?: true
    category?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PassengerMaxAggregateInputType = {
    id?: true
    bookingId?: true
    title?: true
    firstName?: true
    middleName?: true
    lastName?: true
    gender?: true
    email?: true
    contactNo?: true
    nationality?: true
    birthday?: true
    category?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PassengerCountAggregateInputType = {
    id?: true
    bookingId?: true
    title?: true
    firstName?: true
    middleName?: true
    lastName?: true
    gender?: true
    email?: true
    contactNo?: true
    nationality?: true
    birthday?: true
    category?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PassengerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Passenger to aggregate.
     */
    where?: PassengerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Passengers to fetch.
     */
    orderBy?: PassengerOrderByWithRelationInput | PassengerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PassengerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Passengers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Passengers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Passengers
    **/
    _count?: true | PassengerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PassengerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PassengerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PassengerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PassengerMaxAggregateInputType
  }

  export type GetPassengerAggregateType<T extends PassengerAggregateArgs> = {
        [P in keyof T & keyof AggregatePassenger]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePassenger[P]>
      : GetScalarType<T[P], AggregatePassenger[P]>
  }




  export type PassengerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PassengerWhereInput
    orderBy?: PassengerOrderByWithAggregationInput | PassengerOrderByWithAggregationInput[]
    by: PassengerScalarFieldEnum[] | PassengerScalarFieldEnum
    having?: PassengerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PassengerCountAggregateInputType | true
    _avg?: PassengerAvgAggregateInputType
    _sum?: PassengerSumAggregateInputType
    _min?: PassengerMinAggregateInputType
    _max?: PassengerMaxAggregateInputType
  }

  export type PassengerGroupByOutputType = {
    id: number
    bookingId: number
    title: $Enums.Title
    firstName: string
    middleName: string | null
    lastName: string
    gender: $Enums.Gender
    email: string | null
    contactNo: string | null
    nationality: string | null
    birthday: Date | null
    category: $Enums.PassengerCategory
    createdAt: Date
    updatedAt: Date
    _count: PassengerCountAggregateOutputType | null
    _avg: PassengerAvgAggregateOutputType | null
    _sum: PassengerSumAggregateOutputType | null
    _min: PassengerMinAggregateOutputType | null
    _max: PassengerMaxAggregateOutputType | null
  }

  type GetPassengerGroupByPayload<T extends PassengerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PassengerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PassengerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PassengerGroupByOutputType[P]>
            : GetScalarType<T[P], PassengerGroupByOutputType[P]>
        }
      >
    >


  export type PassengerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    title?: boolean
    firstName?: boolean
    middleName?: boolean
    lastName?: boolean
    gender?: boolean
    email?: boolean
    contactNo?: boolean
    nationality?: boolean
    birthday?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passenger"]>

  export type PassengerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    title?: boolean
    firstName?: boolean
    middleName?: boolean
    lastName?: boolean
    gender?: boolean
    email?: boolean
    contactNo?: boolean
    nationality?: boolean
    birthday?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passenger"]>

  export type PassengerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    title?: boolean
    firstName?: boolean
    middleName?: boolean
    lastName?: boolean
    gender?: boolean
    email?: boolean
    contactNo?: boolean
    nationality?: boolean
    birthday?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passenger"]>

  export type PassengerSelectScalar = {
    id?: boolean
    bookingId?: boolean
    title?: boolean
    firstName?: boolean
    middleName?: boolean
    lastName?: boolean
    gender?: boolean
    email?: boolean
    contactNo?: boolean
    nationality?: boolean
    birthday?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PassengerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bookingId" | "title" | "firstName" | "middleName" | "lastName" | "gender" | "email" | "contactNo" | "nationality" | "birthday" | "category" | "createdAt" | "updatedAt", ExtArgs["result"]["passenger"]>
  export type PassengerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }
  export type PassengerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }
  export type PassengerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }

  export type $PassengerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Passenger"
    objects: {
      booking: Prisma.$BookingPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      bookingId: number
      title: $Enums.Title
      firstName: string
      middleName: string | null
      lastName: string
      gender: $Enums.Gender
      email: string | null
      contactNo: string | null
      nationality: string | null
      birthday: Date | null
      category: $Enums.PassengerCategory
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["passenger"]>
    composites: {}
  }

  type PassengerGetPayload<S extends boolean | null | undefined | PassengerDefaultArgs> = $Result.GetResult<Prisma.$PassengerPayload, S>

  type PassengerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PassengerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PassengerCountAggregateInputType | true
    }

  export interface PassengerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Passenger'], meta: { name: 'Passenger' } }
    /**
     * Find zero or one Passenger that matches the filter.
     * @param {PassengerFindUniqueArgs} args - Arguments to find a Passenger
     * @example
     * // Get one Passenger
     * const passenger = await prisma.passenger.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PassengerFindUniqueArgs>(args: SelectSubset<T, PassengerFindUniqueArgs<ExtArgs>>): Prisma__PassengerClient<$Result.GetResult<Prisma.$PassengerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Passenger that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PassengerFindUniqueOrThrowArgs} args - Arguments to find a Passenger
     * @example
     * // Get one Passenger
     * const passenger = await prisma.passenger.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PassengerFindUniqueOrThrowArgs>(args: SelectSubset<T, PassengerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PassengerClient<$Result.GetResult<Prisma.$PassengerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Passenger that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PassengerFindFirstArgs} args - Arguments to find a Passenger
     * @example
     * // Get one Passenger
     * const passenger = await prisma.passenger.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PassengerFindFirstArgs>(args?: SelectSubset<T, PassengerFindFirstArgs<ExtArgs>>): Prisma__PassengerClient<$Result.GetResult<Prisma.$PassengerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Passenger that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PassengerFindFirstOrThrowArgs} args - Arguments to find a Passenger
     * @example
     * // Get one Passenger
     * const passenger = await prisma.passenger.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PassengerFindFirstOrThrowArgs>(args?: SelectSubset<T, PassengerFindFirstOrThrowArgs<ExtArgs>>): Prisma__PassengerClient<$Result.GetResult<Prisma.$PassengerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Passengers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PassengerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Passengers
     * const passengers = await prisma.passenger.findMany()
     * 
     * // Get first 10 Passengers
     * const passengers = await prisma.passenger.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const passengerWithIdOnly = await prisma.passenger.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PassengerFindManyArgs>(args?: SelectSubset<T, PassengerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PassengerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Passenger.
     * @param {PassengerCreateArgs} args - Arguments to create a Passenger.
     * @example
     * // Create one Passenger
     * const Passenger = await prisma.passenger.create({
     *   data: {
     *     // ... data to create a Passenger
     *   }
     * })
     * 
     */
    create<T extends PassengerCreateArgs>(args: SelectSubset<T, PassengerCreateArgs<ExtArgs>>): Prisma__PassengerClient<$Result.GetResult<Prisma.$PassengerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Passengers.
     * @param {PassengerCreateManyArgs} args - Arguments to create many Passengers.
     * @example
     * // Create many Passengers
     * const passenger = await prisma.passenger.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PassengerCreateManyArgs>(args?: SelectSubset<T, PassengerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Passengers and returns the data saved in the database.
     * @param {PassengerCreateManyAndReturnArgs} args - Arguments to create many Passengers.
     * @example
     * // Create many Passengers
     * const passenger = await prisma.passenger.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Passengers and only return the `id`
     * const passengerWithIdOnly = await prisma.passenger.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PassengerCreateManyAndReturnArgs>(args?: SelectSubset<T, PassengerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PassengerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Passenger.
     * @param {PassengerDeleteArgs} args - Arguments to delete one Passenger.
     * @example
     * // Delete one Passenger
     * const Passenger = await prisma.passenger.delete({
     *   where: {
     *     // ... filter to delete one Passenger
     *   }
     * })
     * 
     */
    delete<T extends PassengerDeleteArgs>(args: SelectSubset<T, PassengerDeleteArgs<ExtArgs>>): Prisma__PassengerClient<$Result.GetResult<Prisma.$PassengerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Passenger.
     * @param {PassengerUpdateArgs} args - Arguments to update one Passenger.
     * @example
     * // Update one Passenger
     * const passenger = await prisma.passenger.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PassengerUpdateArgs>(args: SelectSubset<T, PassengerUpdateArgs<ExtArgs>>): Prisma__PassengerClient<$Result.GetResult<Prisma.$PassengerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Passengers.
     * @param {PassengerDeleteManyArgs} args - Arguments to filter Passengers to delete.
     * @example
     * // Delete a few Passengers
     * const { count } = await prisma.passenger.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PassengerDeleteManyArgs>(args?: SelectSubset<T, PassengerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Passengers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PassengerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Passengers
     * const passenger = await prisma.passenger.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PassengerUpdateManyArgs>(args: SelectSubset<T, PassengerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Passengers and returns the data updated in the database.
     * @param {PassengerUpdateManyAndReturnArgs} args - Arguments to update many Passengers.
     * @example
     * // Update many Passengers
     * const passenger = await prisma.passenger.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Passengers and only return the `id`
     * const passengerWithIdOnly = await prisma.passenger.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PassengerUpdateManyAndReturnArgs>(args: SelectSubset<T, PassengerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PassengerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Passenger.
     * @param {PassengerUpsertArgs} args - Arguments to update or create a Passenger.
     * @example
     * // Update or create a Passenger
     * const passenger = await prisma.passenger.upsert({
     *   create: {
     *     // ... data to create a Passenger
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Passenger we want to update
     *   }
     * })
     */
    upsert<T extends PassengerUpsertArgs>(args: SelectSubset<T, PassengerUpsertArgs<ExtArgs>>): Prisma__PassengerClient<$Result.GetResult<Prisma.$PassengerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Passengers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PassengerCountArgs} args - Arguments to filter Passengers to count.
     * @example
     * // Count the number of Passengers
     * const count = await prisma.passenger.count({
     *   where: {
     *     // ... the filter for the Passengers we want to count
     *   }
     * })
    **/
    count<T extends PassengerCountArgs>(
      args?: Subset<T, PassengerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PassengerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Passenger.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PassengerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PassengerAggregateArgs>(args: Subset<T, PassengerAggregateArgs>): Prisma.PrismaPromise<GetPassengerAggregateType<T>>

    /**
     * Group by Passenger.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PassengerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PassengerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PassengerGroupByArgs['orderBy'] }
        : { orderBy?: PassengerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PassengerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPassengerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Passenger model
   */
  readonly fields: PassengerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Passenger.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PassengerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    booking<T extends BookingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BookingDefaultArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Passenger model
   */
  interface PassengerFieldRefs {
    readonly id: FieldRef<"Passenger", 'Int'>
    readonly bookingId: FieldRef<"Passenger", 'Int'>
    readonly title: FieldRef<"Passenger", 'Title'>
    readonly firstName: FieldRef<"Passenger", 'String'>
    readonly middleName: FieldRef<"Passenger", 'String'>
    readonly lastName: FieldRef<"Passenger", 'String'>
    readonly gender: FieldRef<"Passenger", 'Gender'>
    readonly email: FieldRef<"Passenger", 'String'>
    readonly contactNo: FieldRef<"Passenger", 'String'>
    readonly nationality: FieldRef<"Passenger", 'String'>
    readonly birthday: FieldRef<"Passenger", 'DateTime'>
    readonly category: FieldRef<"Passenger", 'PassengerCategory'>
    readonly createdAt: FieldRef<"Passenger", 'DateTime'>
    readonly updatedAt: FieldRef<"Passenger", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Passenger findUnique
   */
  export type PassengerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passenger
     */
    select?: PassengerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Passenger
     */
    omit?: PassengerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PassengerInclude<ExtArgs> | null
    /**
     * Filter, which Passenger to fetch.
     */
    where: PassengerWhereUniqueInput
  }

  /**
   * Passenger findUniqueOrThrow
   */
  export type PassengerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passenger
     */
    select?: PassengerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Passenger
     */
    omit?: PassengerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PassengerInclude<ExtArgs> | null
    /**
     * Filter, which Passenger to fetch.
     */
    where: PassengerWhereUniqueInput
  }

  /**
   * Passenger findFirst
   */
  export type PassengerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passenger
     */
    select?: PassengerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Passenger
     */
    omit?: PassengerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PassengerInclude<ExtArgs> | null
    /**
     * Filter, which Passenger to fetch.
     */
    where?: PassengerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Passengers to fetch.
     */
    orderBy?: PassengerOrderByWithRelationInput | PassengerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Passengers.
     */
    cursor?: PassengerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Passengers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Passengers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Passengers.
     */
    distinct?: PassengerScalarFieldEnum | PassengerScalarFieldEnum[]
  }

  /**
   * Passenger findFirstOrThrow
   */
  export type PassengerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passenger
     */
    select?: PassengerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Passenger
     */
    omit?: PassengerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PassengerInclude<ExtArgs> | null
    /**
     * Filter, which Passenger to fetch.
     */
    where?: PassengerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Passengers to fetch.
     */
    orderBy?: PassengerOrderByWithRelationInput | PassengerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Passengers.
     */
    cursor?: PassengerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Passengers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Passengers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Passengers.
     */
    distinct?: PassengerScalarFieldEnum | PassengerScalarFieldEnum[]
  }

  /**
   * Passenger findMany
   */
  export type PassengerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passenger
     */
    select?: PassengerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Passenger
     */
    omit?: PassengerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PassengerInclude<ExtArgs> | null
    /**
     * Filter, which Passengers to fetch.
     */
    where?: PassengerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Passengers to fetch.
     */
    orderBy?: PassengerOrderByWithRelationInput | PassengerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Passengers.
     */
    cursor?: PassengerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Passengers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Passengers.
     */
    skip?: number
    distinct?: PassengerScalarFieldEnum | PassengerScalarFieldEnum[]
  }

  /**
   * Passenger create
   */
  export type PassengerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passenger
     */
    select?: PassengerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Passenger
     */
    omit?: PassengerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PassengerInclude<ExtArgs> | null
    /**
     * The data needed to create a Passenger.
     */
    data: XOR<PassengerCreateInput, PassengerUncheckedCreateInput>
  }

  /**
   * Passenger createMany
   */
  export type PassengerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Passengers.
     */
    data: PassengerCreateManyInput | PassengerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Passenger createManyAndReturn
   */
  export type PassengerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passenger
     */
    select?: PassengerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Passenger
     */
    omit?: PassengerOmit<ExtArgs> | null
    /**
     * The data used to create many Passengers.
     */
    data: PassengerCreateManyInput | PassengerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PassengerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Passenger update
   */
  export type PassengerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passenger
     */
    select?: PassengerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Passenger
     */
    omit?: PassengerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PassengerInclude<ExtArgs> | null
    /**
     * The data needed to update a Passenger.
     */
    data: XOR<PassengerUpdateInput, PassengerUncheckedUpdateInput>
    /**
     * Choose, which Passenger to update.
     */
    where: PassengerWhereUniqueInput
  }

  /**
   * Passenger updateMany
   */
  export type PassengerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Passengers.
     */
    data: XOR<PassengerUpdateManyMutationInput, PassengerUncheckedUpdateManyInput>
    /**
     * Filter which Passengers to update
     */
    where?: PassengerWhereInput
    /**
     * Limit how many Passengers to update.
     */
    limit?: number
  }

  /**
   * Passenger updateManyAndReturn
   */
  export type PassengerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passenger
     */
    select?: PassengerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Passenger
     */
    omit?: PassengerOmit<ExtArgs> | null
    /**
     * The data used to update Passengers.
     */
    data: XOR<PassengerUpdateManyMutationInput, PassengerUncheckedUpdateManyInput>
    /**
     * Filter which Passengers to update
     */
    where?: PassengerWhereInput
    /**
     * Limit how many Passengers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PassengerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Passenger upsert
   */
  export type PassengerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passenger
     */
    select?: PassengerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Passenger
     */
    omit?: PassengerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PassengerInclude<ExtArgs> | null
    /**
     * The filter to search for the Passenger to update in case it exists.
     */
    where: PassengerWhereUniqueInput
    /**
     * In case the Passenger found by the `where` argument doesn't exist, create a new Passenger with this data.
     */
    create: XOR<PassengerCreateInput, PassengerUncheckedCreateInput>
    /**
     * In case the Passenger was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PassengerUpdateInput, PassengerUncheckedUpdateInput>
  }

  /**
   * Passenger delete
   */
  export type PassengerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passenger
     */
    select?: PassengerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Passenger
     */
    omit?: PassengerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PassengerInclude<ExtArgs> | null
    /**
     * Filter which Passenger to delete.
     */
    where: PassengerWhereUniqueInput
  }

  /**
   * Passenger deleteMany
   */
  export type PassengerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Passengers to delete
     */
    where?: PassengerWhereInput
    /**
     * Limit how many Passengers to delete.
     */
    limit?: number
  }

  /**
   * Passenger without action
   */
  export type PassengerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passenger
     */
    select?: PassengerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Passenger
     */
    omit?: PassengerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PassengerInclude<ExtArgs> | null
  }


  /**
   * Model PendingPassenger
   */

  export type AggregatePendingPassenger = {
    _count: PendingPassengerCountAggregateOutputType | null
    _avg: PendingPassengerAvgAggregateOutputType | null
    _sum: PendingPassengerSumAggregateOutputType | null
    _min: PendingPassengerMinAggregateOutputType | null
    _max: PendingPassengerMaxAggregateOutputType | null
  }

  export type PendingPassengerAvgAggregateOutputType = {
    id: number | null
    pendingBookingId: number | null
  }

  export type PendingPassengerSumAggregateOutputType = {
    id: number | null
    pendingBookingId: number | null
  }

  export type PendingPassengerMinAggregateOutputType = {
    id: number | null
    pendingBookingId: number | null
    title: $Enums.Title | null
    firstName: string | null
    middleName: string | null
    lastName: string | null
    gender: $Enums.Gender | null
    email: string | null
    contactNo: string | null
    nationality: string | null
    birthday: Date | null
    category: $Enums.PassengerCategory | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PendingPassengerMaxAggregateOutputType = {
    id: number | null
    pendingBookingId: number | null
    title: $Enums.Title | null
    firstName: string | null
    middleName: string | null
    lastName: string | null
    gender: $Enums.Gender | null
    email: string | null
    contactNo: string | null
    nationality: string | null
    birthday: Date | null
    category: $Enums.PassengerCategory | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PendingPassengerCountAggregateOutputType = {
    id: number
    pendingBookingId: number
    title: number
    firstName: number
    middleName: number
    lastName: number
    gender: number
    email: number
    contactNo: number
    nationality: number
    birthday: number
    category: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PendingPassengerAvgAggregateInputType = {
    id?: true
    pendingBookingId?: true
  }

  export type PendingPassengerSumAggregateInputType = {
    id?: true
    pendingBookingId?: true
  }

  export type PendingPassengerMinAggregateInputType = {
    id?: true
    pendingBookingId?: true
    title?: true
    firstName?: true
    middleName?: true
    lastName?: true
    gender?: true
    email?: true
    contactNo?: true
    nationality?: true
    birthday?: true
    category?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PendingPassengerMaxAggregateInputType = {
    id?: true
    pendingBookingId?: true
    title?: true
    firstName?: true
    middleName?: true
    lastName?: true
    gender?: true
    email?: true
    contactNo?: true
    nationality?: true
    birthday?: true
    category?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PendingPassengerCountAggregateInputType = {
    id?: true
    pendingBookingId?: true
    title?: true
    firstName?: true
    middleName?: true
    lastName?: true
    gender?: true
    email?: true
    contactNo?: true
    nationality?: true
    birthday?: true
    category?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PendingPassengerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PendingPassenger to aggregate.
     */
    where?: PendingPassengerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PendingPassengers to fetch.
     */
    orderBy?: PendingPassengerOrderByWithRelationInput | PendingPassengerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PendingPassengerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PendingPassengers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PendingPassengers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PendingPassengers
    **/
    _count?: true | PendingPassengerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PendingPassengerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PendingPassengerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PendingPassengerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PendingPassengerMaxAggregateInputType
  }

  export type GetPendingPassengerAggregateType<T extends PendingPassengerAggregateArgs> = {
        [P in keyof T & keyof AggregatePendingPassenger]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePendingPassenger[P]>
      : GetScalarType<T[P], AggregatePendingPassenger[P]>
  }




  export type PendingPassengerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PendingPassengerWhereInput
    orderBy?: PendingPassengerOrderByWithAggregationInput | PendingPassengerOrderByWithAggregationInput[]
    by: PendingPassengerScalarFieldEnum[] | PendingPassengerScalarFieldEnum
    having?: PendingPassengerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PendingPassengerCountAggregateInputType | true
    _avg?: PendingPassengerAvgAggregateInputType
    _sum?: PendingPassengerSumAggregateInputType
    _min?: PendingPassengerMinAggregateInputType
    _max?: PendingPassengerMaxAggregateInputType
  }

  export type PendingPassengerGroupByOutputType = {
    id: number
    pendingBookingId: number
    title: $Enums.Title
    firstName: string
    middleName: string | null
    lastName: string
    gender: $Enums.Gender
    email: string | null
    contactNo: string | null
    nationality: string | null
    birthday: Date | null
    category: $Enums.PassengerCategory
    createdAt: Date
    updatedAt: Date
    _count: PendingPassengerCountAggregateOutputType | null
    _avg: PendingPassengerAvgAggregateOutputType | null
    _sum: PendingPassengerSumAggregateOutputType | null
    _min: PendingPassengerMinAggregateOutputType | null
    _max: PendingPassengerMaxAggregateOutputType | null
  }

  type GetPendingPassengerGroupByPayload<T extends PendingPassengerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PendingPassengerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PendingPassengerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PendingPassengerGroupByOutputType[P]>
            : GetScalarType<T[P], PendingPassengerGroupByOutputType[P]>
        }
      >
    >


  export type PendingPassengerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pendingBookingId?: boolean
    title?: boolean
    firstName?: boolean
    middleName?: boolean
    lastName?: boolean
    gender?: boolean
    email?: boolean
    contactNo?: boolean
    nationality?: boolean
    birthday?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pendingBooking?: boolean | PendingBookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pendingPassenger"]>

  export type PendingPassengerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pendingBookingId?: boolean
    title?: boolean
    firstName?: boolean
    middleName?: boolean
    lastName?: boolean
    gender?: boolean
    email?: boolean
    contactNo?: boolean
    nationality?: boolean
    birthday?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pendingBooking?: boolean | PendingBookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pendingPassenger"]>

  export type PendingPassengerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pendingBookingId?: boolean
    title?: boolean
    firstName?: boolean
    middleName?: boolean
    lastName?: boolean
    gender?: boolean
    email?: boolean
    contactNo?: boolean
    nationality?: boolean
    birthday?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pendingBooking?: boolean | PendingBookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pendingPassenger"]>

  export type PendingPassengerSelectScalar = {
    id?: boolean
    pendingBookingId?: boolean
    title?: boolean
    firstName?: boolean
    middleName?: boolean
    lastName?: boolean
    gender?: boolean
    email?: boolean
    contactNo?: boolean
    nationality?: boolean
    birthday?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PendingPassengerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "pendingBookingId" | "title" | "firstName" | "middleName" | "lastName" | "gender" | "email" | "contactNo" | "nationality" | "birthday" | "category" | "createdAt" | "updatedAt", ExtArgs["result"]["pendingPassenger"]>
  export type PendingPassengerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pendingBooking?: boolean | PendingBookingDefaultArgs<ExtArgs>
  }
  export type PendingPassengerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pendingBooking?: boolean | PendingBookingDefaultArgs<ExtArgs>
  }
  export type PendingPassengerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pendingBooking?: boolean | PendingBookingDefaultArgs<ExtArgs>
  }

  export type $PendingPassengerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PendingPassenger"
    objects: {
      pendingBooking: Prisma.$PendingBookingPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      pendingBookingId: number
      title: $Enums.Title
      firstName: string
      middleName: string | null
      lastName: string
      gender: $Enums.Gender
      email: string | null
      contactNo: string | null
      nationality: string | null
      birthday: Date | null
      category: $Enums.PassengerCategory
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["pendingPassenger"]>
    composites: {}
  }

  type PendingPassengerGetPayload<S extends boolean | null | undefined | PendingPassengerDefaultArgs> = $Result.GetResult<Prisma.$PendingPassengerPayload, S>

  type PendingPassengerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PendingPassengerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PendingPassengerCountAggregateInputType | true
    }

  export interface PendingPassengerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PendingPassenger'], meta: { name: 'PendingPassenger' } }
    /**
     * Find zero or one PendingPassenger that matches the filter.
     * @param {PendingPassengerFindUniqueArgs} args - Arguments to find a PendingPassenger
     * @example
     * // Get one PendingPassenger
     * const pendingPassenger = await prisma.pendingPassenger.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PendingPassengerFindUniqueArgs>(args: SelectSubset<T, PendingPassengerFindUniqueArgs<ExtArgs>>): Prisma__PendingPassengerClient<$Result.GetResult<Prisma.$PendingPassengerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PendingPassenger that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PendingPassengerFindUniqueOrThrowArgs} args - Arguments to find a PendingPassenger
     * @example
     * // Get one PendingPassenger
     * const pendingPassenger = await prisma.pendingPassenger.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PendingPassengerFindUniqueOrThrowArgs>(args: SelectSubset<T, PendingPassengerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PendingPassengerClient<$Result.GetResult<Prisma.$PendingPassengerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PendingPassenger that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingPassengerFindFirstArgs} args - Arguments to find a PendingPassenger
     * @example
     * // Get one PendingPassenger
     * const pendingPassenger = await prisma.pendingPassenger.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PendingPassengerFindFirstArgs>(args?: SelectSubset<T, PendingPassengerFindFirstArgs<ExtArgs>>): Prisma__PendingPassengerClient<$Result.GetResult<Prisma.$PendingPassengerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PendingPassenger that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingPassengerFindFirstOrThrowArgs} args - Arguments to find a PendingPassenger
     * @example
     * // Get one PendingPassenger
     * const pendingPassenger = await prisma.pendingPassenger.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PendingPassengerFindFirstOrThrowArgs>(args?: SelectSubset<T, PendingPassengerFindFirstOrThrowArgs<ExtArgs>>): Prisma__PendingPassengerClient<$Result.GetResult<Prisma.$PendingPassengerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PendingPassengers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingPassengerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PendingPassengers
     * const pendingPassengers = await prisma.pendingPassenger.findMany()
     * 
     * // Get first 10 PendingPassengers
     * const pendingPassengers = await prisma.pendingPassenger.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pendingPassengerWithIdOnly = await prisma.pendingPassenger.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PendingPassengerFindManyArgs>(args?: SelectSubset<T, PendingPassengerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PendingPassengerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PendingPassenger.
     * @param {PendingPassengerCreateArgs} args - Arguments to create a PendingPassenger.
     * @example
     * // Create one PendingPassenger
     * const PendingPassenger = await prisma.pendingPassenger.create({
     *   data: {
     *     // ... data to create a PendingPassenger
     *   }
     * })
     * 
     */
    create<T extends PendingPassengerCreateArgs>(args: SelectSubset<T, PendingPassengerCreateArgs<ExtArgs>>): Prisma__PendingPassengerClient<$Result.GetResult<Prisma.$PendingPassengerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PendingPassengers.
     * @param {PendingPassengerCreateManyArgs} args - Arguments to create many PendingPassengers.
     * @example
     * // Create many PendingPassengers
     * const pendingPassenger = await prisma.pendingPassenger.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PendingPassengerCreateManyArgs>(args?: SelectSubset<T, PendingPassengerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PendingPassengers and returns the data saved in the database.
     * @param {PendingPassengerCreateManyAndReturnArgs} args - Arguments to create many PendingPassengers.
     * @example
     * // Create many PendingPassengers
     * const pendingPassenger = await prisma.pendingPassenger.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PendingPassengers and only return the `id`
     * const pendingPassengerWithIdOnly = await prisma.pendingPassenger.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PendingPassengerCreateManyAndReturnArgs>(args?: SelectSubset<T, PendingPassengerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PendingPassengerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PendingPassenger.
     * @param {PendingPassengerDeleteArgs} args - Arguments to delete one PendingPassenger.
     * @example
     * // Delete one PendingPassenger
     * const PendingPassenger = await prisma.pendingPassenger.delete({
     *   where: {
     *     // ... filter to delete one PendingPassenger
     *   }
     * })
     * 
     */
    delete<T extends PendingPassengerDeleteArgs>(args: SelectSubset<T, PendingPassengerDeleteArgs<ExtArgs>>): Prisma__PendingPassengerClient<$Result.GetResult<Prisma.$PendingPassengerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PendingPassenger.
     * @param {PendingPassengerUpdateArgs} args - Arguments to update one PendingPassenger.
     * @example
     * // Update one PendingPassenger
     * const pendingPassenger = await prisma.pendingPassenger.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PendingPassengerUpdateArgs>(args: SelectSubset<T, PendingPassengerUpdateArgs<ExtArgs>>): Prisma__PendingPassengerClient<$Result.GetResult<Prisma.$PendingPassengerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PendingPassengers.
     * @param {PendingPassengerDeleteManyArgs} args - Arguments to filter PendingPassengers to delete.
     * @example
     * // Delete a few PendingPassengers
     * const { count } = await prisma.pendingPassenger.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PendingPassengerDeleteManyArgs>(args?: SelectSubset<T, PendingPassengerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PendingPassengers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingPassengerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PendingPassengers
     * const pendingPassenger = await prisma.pendingPassenger.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PendingPassengerUpdateManyArgs>(args: SelectSubset<T, PendingPassengerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PendingPassengers and returns the data updated in the database.
     * @param {PendingPassengerUpdateManyAndReturnArgs} args - Arguments to update many PendingPassengers.
     * @example
     * // Update many PendingPassengers
     * const pendingPassenger = await prisma.pendingPassenger.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PendingPassengers and only return the `id`
     * const pendingPassengerWithIdOnly = await prisma.pendingPassenger.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PendingPassengerUpdateManyAndReturnArgs>(args: SelectSubset<T, PendingPassengerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PendingPassengerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PendingPassenger.
     * @param {PendingPassengerUpsertArgs} args - Arguments to update or create a PendingPassenger.
     * @example
     * // Update or create a PendingPassenger
     * const pendingPassenger = await prisma.pendingPassenger.upsert({
     *   create: {
     *     // ... data to create a PendingPassenger
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PendingPassenger we want to update
     *   }
     * })
     */
    upsert<T extends PendingPassengerUpsertArgs>(args: SelectSubset<T, PendingPassengerUpsertArgs<ExtArgs>>): Prisma__PendingPassengerClient<$Result.GetResult<Prisma.$PendingPassengerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PendingPassengers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingPassengerCountArgs} args - Arguments to filter PendingPassengers to count.
     * @example
     * // Count the number of PendingPassengers
     * const count = await prisma.pendingPassenger.count({
     *   where: {
     *     // ... the filter for the PendingPassengers we want to count
     *   }
     * })
    **/
    count<T extends PendingPassengerCountArgs>(
      args?: Subset<T, PendingPassengerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PendingPassengerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PendingPassenger.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingPassengerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PendingPassengerAggregateArgs>(args: Subset<T, PendingPassengerAggregateArgs>): Prisma.PrismaPromise<GetPendingPassengerAggregateType<T>>

    /**
     * Group by PendingPassenger.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingPassengerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PendingPassengerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PendingPassengerGroupByArgs['orderBy'] }
        : { orderBy?: PendingPassengerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PendingPassengerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPendingPassengerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PendingPassenger model
   */
  readonly fields: PendingPassengerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PendingPassenger.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PendingPassengerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pendingBooking<T extends PendingBookingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PendingBookingDefaultArgs<ExtArgs>>): Prisma__PendingBookingClient<$Result.GetResult<Prisma.$PendingBookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PendingPassenger model
   */
  interface PendingPassengerFieldRefs {
    readonly id: FieldRef<"PendingPassenger", 'Int'>
    readonly pendingBookingId: FieldRef<"PendingPassenger", 'Int'>
    readonly title: FieldRef<"PendingPassenger", 'Title'>
    readonly firstName: FieldRef<"PendingPassenger", 'String'>
    readonly middleName: FieldRef<"PendingPassenger", 'String'>
    readonly lastName: FieldRef<"PendingPassenger", 'String'>
    readonly gender: FieldRef<"PendingPassenger", 'Gender'>
    readonly email: FieldRef<"PendingPassenger", 'String'>
    readonly contactNo: FieldRef<"PendingPassenger", 'String'>
    readonly nationality: FieldRef<"PendingPassenger", 'String'>
    readonly birthday: FieldRef<"PendingPassenger", 'DateTime'>
    readonly category: FieldRef<"PendingPassenger", 'PassengerCategory'>
    readonly createdAt: FieldRef<"PendingPassenger", 'DateTime'>
    readonly updatedAt: FieldRef<"PendingPassenger", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PendingPassenger findUnique
   */
  export type PendingPassengerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingPassenger
     */
    select?: PendingPassengerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingPassenger
     */
    omit?: PendingPassengerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingPassengerInclude<ExtArgs> | null
    /**
     * Filter, which PendingPassenger to fetch.
     */
    where: PendingPassengerWhereUniqueInput
  }

  /**
   * PendingPassenger findUniqueOrThrow
   */
  export type PendingPassengerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingPassenger
     */
    select?: PendingPassengerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingPassenger
     */
    omit?: PendingPassengerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingPassengerInclude<ExtArgs> | null
    /**
     * Filter, which PendingPassenger to fetch.
     */
    where: PendingPassengerWhereUniqueInput
  }

  /**
   * PendingPassenger findFirst
   */
  export type PendingPassengerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingPassenger
     */
    select?: PendingPassengerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingPassenger
     */
    omit?: PendingPassengerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingPassengerInclude<ExtArgs> | null
    /**
     * Filter, which PendingPassenger to fetch.
     */
    where?: PendingPassengerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PendingPassengers to fetch.
     */
    orderBy?: PendingPassengerOrderByWithRelationInput | PendingPassengerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PendingPassengers.
     */
    cursor?: PendingPassengerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PendingPassengers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PendingPassengers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PendingPassengers.
     */
    distinct?: PendingPassengerScalarFieldEnum | PendingPassengerScalarFieldEnum[]
  }

  /**
   * PendingPassenger findFirstOrThrow
   */
  export type PendingPassengerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingPassenger
     */
    select?: PendingPassengerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingPassenger
     */
    omit?: PendingPassengerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingPassengerInclude<ExtArgs> | null
    /**
     * Filter, which PendingPassenger to fetch.
     */
    where?: PendingPassengerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PendingPassengers to fetch.
     */
    orderBy?: PendingPassengerOrderByWithRelationInput | PendingPassengerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PendingPassengers.
     */
    cursor?: PendingPassengerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PendingPassengers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PendingPassengers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PendingPassengers.
     */
    distinct?: PendingPassengerScalarFieldEnum | PendingPassengerScalarFieldEnum[]
  }

  /**
   * PendingPassenger findMany
   */
  export type PendingPassengerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingPassenger
     */
    select?: PendingPassengerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingPassenger
     */
    omit?: PendingPassengerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingPassengerInclude<ExtArgs> | null
    /**
     * Filter, which PendingPassengers to fetch.
     */
    where?: PendingPassengerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PendingPassengers to fetch.
     */
    orderBy?: PendingPassengerOrderByWithRelationInput | PendingPassengerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PendingPassengers.
     */
    cursor?: PendingPassengerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PendingPassengers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PendingPassengers.
     */
    skip?: number
    distinct?: PendingPassengerScalarFieldEnum | PendingPassengerScalarFieldEnum[]
  }

  /**
   * PendingPassenger create
   */
  export type PendingPassengerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingPassenger
     */
    select?: PendingPassengerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingPassenger
     */
    omit?: PendingPassengerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingPassengerInclude<ExtArgs> | null
    /**
     * The data needed to create a PendingPassenger.
     */
    data: XOR<PendingPassengerCreateInput, PendingPassengerUncheckedCreateInput>
  }

  /**
   * PendingPassenger createMany
   */
  export type PendingPassengerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PendingPassengers.
     */
    data: PendingPassengerCreateManyInput | PendingPassengerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PendingPassenger createManyAndReturn
   */
  export type PendingPassengerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingPassenger
     */
    select?: PendingPassengerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PendingPassenger
     */
    omit?: PendingPassengerOmit<ExtArgs> | null
    /**
     * The data used to create many PendingPassengers.
     */
    data: PendingPassengerCreateManyInput | PendingPassengerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingPassengerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PendingPassenger update
   */
  export type PendingPassengerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingPassenger
     */
    select?: PendingPassengerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingPassenger
     */
    omit?: PendingPassengerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingPassengerInclude<ExtArgs> | null
    /**
     * The data needed to update a PendingPassenger.
     */
    data: XOR<PendingPassengerUpdateInput, PendingPassengerUncheckedUpdateInput>
    /**
     * Choose, which PendingPassenger to update.
     */
    where: PendingPassengerWhereUniqueInput
  }

  /**
   * PendingPassenger updateMany
   */
  export type PendingPassengerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PendingPassengers.
     */
    data: XOR<PendingPassengerUpdateManyMutationInput, PendingPassengerUncheckedUpdateManyInput>
    /**
     * Filter which PendingPassengers to update
     */
    where?: PendingPassengerWhereInput
    /**
     * Limit how many PendingPassengers to update.
     */
    limit?: number
  }

  /**
   * PendingPassenger updateManyAndReturn
   */
  export type PendingPassengerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingPassenger
     */
    select?: PendingPassengerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PendingPassenger
     */
    omit?: PendingPassengerOmit<ExtArgs> | null
    /**
     * The data used to update PendingPassengers.
     */
    data: XOR<PendingPassengerUpdateManyMutationInput, PendingPassengerUncheckedUpdateManyInput>
    /**
     * Filter which PendingPassengers to update
     */
    where?: PendingPassengerWhereInput
    /**
     * Limit how many PendingPassengers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingPassengerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PendingPassenger upsert
   */
  export type PendingPassengerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingPassenger
     */
    select?: PendingPassengerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingPassenger
     */
    omit?: PendingPassengerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingPassengerInclude<ExtArgs> | null
    /**
     * The filter to search for the PendingPassenger to update in case it exists.
     */
    where: PendingPassengerWhereUniqueInput
    /**
     * In case the PendingPassenger found by the `where` argument doesn't exist, create a new PendingPassenger with this data.
     */
    create: XOR<PendingPassengerCreateInput, PendingPassengerUncheckedCreateInput>
    /**
     * In case the PendingPassenger was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PendingPassengerUpdateInput, PendingPassengerUncheckedUpdateInput>
  }

  /**
   * PendingPassenger delete
   */
  export type PendingPassengerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingPassenger
     */
    select?: PendingPassengerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingPassenger
     */
    omit?: PendingPassengerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingPassengerInclude<ExtArgs> | null
    /**
     * Filter which PendingPassenger to delete.
     */
    where: PendingPassengerWhereUniqueInput
  }

  /**
   * PendingPassenger deleteMany
   */
  export type PendingPassengerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PendingPassengers to delete
     */
    where?: PendingPassengerWhereInput
    /**
     * Limit how many PendingPassengers to delete.
     */
    limit?: number
  }

  /**
   * PendingPassenger without action
   */
  export type PendingPassengerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingPassenger
     */
    select?: PendingPassengerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingPassenger
     */
    omit?: PendingPassengerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingPassengerInclude<ExtArgs> | null
  }


  /**
   * Model CostItemSupplier
   */

  export type AggregateCostItemSupplier = {
    _count: CostItemSupplierCountAggregateOutputType | null
    _avg: CostItemSupplierAvgAggregateOutputType | null
    _sum: CostItemSupplierSumAggregateOutputType | null
    _min: CostItemSupplierMinAggregateOutputType | null
    _max: CostItemSupplierMaxAggregateOutputType | null
  }

  export type CostItemSupplierAvgAggregateOutputType = {
    id: number | null
    costItemId: number | null
    pendingCostItemId: number | null
    amount: number | null
    paidAmount: number | null
    pendingAmount: number | null
    firstMethodAmount: number | null
    secondMethodAmount: number | null
  }

  export type CostItemSupplierSumAggregateOutputType = {
    id: number | null
    costItemId: number | null
    pendingCostItemId: number | null
    amount: number | null
    paidAmount: number | null
    pendingAmount: number | null
    firstMethodAmount: number | null
    secondMethodAmount: number | null
  }

  export type CostItemSupplierMinAggregateOutputType = {
    id: number | null
    costItemId: number | null
    pendingCostItemId: number | null
    supplier: $Enums.Suppliers | null
    amount: number | null
    paymentMethod: string | null
    paidAmount: number | null
    pendingAmount: number | null
    transactionMethod: string | null
    firstMethodAmount: number | null
    secondMethodAmount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CostItemSupplierMaxAggregateOutputType = {
    id: number | null
    costItemId: number | null
    pendingCostItemId: number | null
    supplier: $Enums.Suppliers | null
    amount: number | null
    paymentMethod: string | null
    paidAmount: number | null
    pendingAmount: number | null
    transactionMethod: string | null
    firstMethodAmount: number | null
    secondMethodAmount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CostItemSupplierCountAggregateOutputType = {
    id: number
    costItemId: number
    pendingCostItemId: number
    supplier: number
    amount: number
    paymentMethod: number
    paidAmount: number
    pendingAmount: number
    transactionMethod: number
    firstMethodAmount: number
    secondMethodAmount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CostItemSupplierAvgAggregateInputType = {
    id?: true
    costItemId?: true
    pendingCostItemId?: true
    amount?: true
    paidAmount?: true
    pendingAmount?: true
    firstMethodAmount?: true
    secondMethodAmount?: true
  }

  export type CostItemSupplierSumAggregateInputType = {
    id?: true
    costItemId?: true
    pendingCostItemId?: true
    amount?: true
    paidAmount?: true
    pendingAmount?: true
    firstMethodAmount?: true
    secondMethodAmount?: true
  }

  export type CostItemSupplierMinAggregateInputType = {
    id?: true
    costItemId?: true
    pendingCostItemId?: true
    supplier?: true
    amount?: true
    paymentMethod?: true
    paidAmount?: true
    pendingAmount?: true
    transactionMethod?: true
    firstMethodAmount?: true
    secondMethodAmount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CostItemSupplierMaxAggregateInputType = {
    id?: true
    costItemId?: true
    pendingCostItemId?: true
    supplier?: true
    amount?: true
    paymentMethod?: true
    paidAmount?: true
    pendingAmount?: true
    transactionMethod?: true
    firstMethodAmount?: true
    secondMethodAmount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CostItemSupplierCountAggregateInputType = {
    id?: true
    costItemId?: true
    pendingCostItemId?: true
    supplier?: true
    amount?: true
    paymentMethod?: true
    paidAmount?: true
    pendingAmount?: true
    transactionMethod?: true
    firstMethodAmount?: true
    secondMethodAmount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CostItemSupplierAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CostItemSupplier to aggregate.
     */
    where?: CostItemSupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CostItemSuppliers to fetch.
     */
    orderBy?: CostItemSupplierOrderByWithRelationInput | CostItemSupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CostItemSupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CostItemSuppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CostItemSuppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CostItemSuppliers
    **/
    _count?: true | CostItemSupplierCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CostItemSupplierAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CostItemSupplierSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CostItemSupplierMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CostItemSupplierMaxAggregateInputType
  }

  export type GetCostItemSupplierAggregateType<T extends CostItemSupplierAggregateArgs> = {
        [P in keyof T & keyof AggregateCostItemSupplier]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCostItemSupplier[P]>
      : GetScalarType<T[P], AggregateCostItemSupplier[P]>
  }




  export type CostItemSupplierGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CostItemSupplierWhereInput
    orderBy?: CostItemSupplierOrderByWithAggregationInput | CostItemSupplierOrderByWithAggregationInput[]
    by: CostItemSupplierScalarFieldEnum[] | CostItemSupplierScalarFieldEnum
    having?: CostItemSupplierScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CostItemSupplierCountAggregateInputType | true
    _avg?: CostItemSupplierAvgAggregateInputType
    _sum?: CostItemSupplierSumAggregateInputType
    _min?: CostItemSupplierMinAggregateInputType
    _max?: CostItemSupplierMaxAggregateInputType
  }

  export type CostItemSupplierGroupByOutputType = {
    id: number
    costItemId: number | null
    pendingCostItemId: number | null
    supplier: $Enums.Suppliers
    amount: number
    paymentMethod: string
    paidAmount: number
    pendingAmount: number
    transactionMethod: string | null
    firstMethodAmount: number | null
    secondMethodAmount: number | null
    createdAt: Date
    updatedAt: Date
    _count: CostItemSupplierCountAggregateOutputType | null
    _avg: CostItemSupplierAvgAggregateOutputType | null
    _sum: CostItemSupplierSumAggregateOutputType | null
    _min: CostItemSupplierMinAggregateOutputType | null
    _max: CostItemSupplierMaxAggregateOutputType | null
  }

  type GetCostItemSupplierGroupByPayload<T extends CostItemSupplierGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CostItemSupplierGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CostItemSupplierGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CostItemSupplierGroupByOutputType[P]>
            : GetScalarType<T[P], CostItemSupplierGroupByOutputType[P]>
        }
      >
    >


  export type CostItemSupplierSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    costItemId?: boolean
    pendingCostItemId?: boolean
    supplier?: boolean
    amount?: boolean
    paymentMethod?: boolean
    paidAmount?: boolean
    pendingAmount?: boolean
    transactionMethod?: boolean
    firstMethodAmount?: boolean
    secondMethodAmount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    costItem?: boolean | CostItemSupplier$costItemArgs<ExtArgs>
    pendingCostItem?: boolean | CostItemSupplier$pendingCostItemArgs<ExtArgs>
    settlements?: boolean | CostItemSupplier$settlementsArgs<ExtArgs>
    paidByCreditNoteUsage?: boolean | CostItemSupplier$paidByCreditNoteUsageArgs<ExtArgs>
    _count?: boolean | CostItemSupplierCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["costItemSupplier"]>

  export type CostItemSupplierSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    costItemId?: boolean
    pendingCostItemId?: boolean
    supplier?: boolean
    amount?: boolean
    paymentMethod?: boolean
    paidAmount?: boolean
    pendingAmount?: boolean
    transactionMethod?: boolean
    firstMethodAmount?: boolean
    secondMethodAmount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    costItem?: boolean | CostItemSupplier$costItemArgs<ExtArgs>
    pendingCostItem?: boolean | CostItemSupplier$pendingCostItemArgs<ExtArgs>
  }, ExtArgs["result"]["costItemSupplier"]>

  export type CostItemSupplierSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    costItemId?: boolean
    pendingCostItemId?: boolean
    supplier?: boolean
    amount?: boolean
    paymentMethod?: boolean
    paidAmount?: boolean
    pendingAmount?: boolean
    transactionMethod?: boolean
    firstMethodAmount?: boolean
    secondMethodAmount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    costItem?: boolean | CostItemSupplier$costItemArgs<ExtArgs>
    pendingCostItem?: boolean | CostItemSupplier$pendingCostItemArgs<ExtArgs>
  }, ExtArgs["result"]["costItemSupplier"]>

  export type CostItemSupplierSelectScalar = {
    id?: boolean
    costItemId?: boolean
    pendingCostItemId?: boolean
    supplier?: boolean
    amount?: boolean
    paymentMethod?: boolean
    paidAmount?: boolean
    pendingAmount?: boolean
    transactionMethod?: boolean
    firstMethodAmount?: boolean
    secondMethodAmount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CostItemSupplierOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "costItemId" | "pendingCostItemId" | "supplier" | "amount" | "paymentMethod" | "paidAmount" | "pendingAmount" | "transactionMethod" | "firstMethodAmount" | "secondMethodAmount" | "createdAt" | "updatedAt", ExtArgs["result"]["costItemSupplier"]>
  export type CostItemSupplierInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    costItem?: boolean | CostItemSupplier$costItemArgs<ExtArgs>
    pendingCostItem?: boolean | CostItemSupplier$pendingCostItemArgs<ExtArgs>
    settlements?: boolean | CostItemSupplier$settlementsArgs<ExtArgs>
    paidByCreditNoteUsage?: boolean | CostItemSupplier$paidByCreditNoteUsageArgs<ExtArgs>
    _count?: boolean | CostItemSupplierCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CostItemSupplierIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    costItem?: boolean | CostItemSupplier$costItemArgs<ExtArgs>
    pendingCostItem?: boolean | CostItemSupplier$pendingCostItemArgs<ExtArgs>
  }
  export type CostItemSupplierIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    costItem?: boolean | CostItemSupplier$costItemArgs<ExtArgs>
    pendingCostItem?: boolean | CostItemSupplier$pendingCostItemArgs<ExtArgs>
  }

  export type $CostItemSupplierPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CostItemSupplier"
    objects: {
      costItem: Prisma.$CostItemPayload<ExtArgs> | null
      pendingCostItem: Prisma.$PendingCostItemPayload<ExtArgs> | null
      settlements: Prisma.$SupplierPaymentSettlementPayload<ExtArgs>[]
      paidByCreditNoteUsage: Prisma.$CreditNoteUsagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      costItemId: number | null
      pendingCostItemId: number | null
      supplier: $Enums.Suppliers
      amount: number
      paymentMethod: string
      paidAmount: number
      pendingAmount: number
      transactionMethod: string | null
      firstMethodAmount: number | null
      secondMethodAmount: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["costItemSupplier"]>
    composites: {}
  }

  type CostItemSupplierGetPayload<S extends boolean | null | undefined | CostItemSupplierDefaultArgs> = $Result.GetResult<Prisma.$CostItemSupplierPayload, S>

  type CostItemSupplierCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CostItemSupplierFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CostItemSupplierCountAggregateInputType | true
    }

  export interface CostItemSupplierDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CostItemSupplier'], meta: { name: 'CostItemSupplier' } }
    /**
     * Find zero or one CostItemSupplier that matches the filter.
     * @param {CostItemSupplierFindUniqueArgs} args - Arguments to find a CostItemSupplier
     * @example
     * // Get one CostItemSupplier
     * const costItemSupplier = await prisma.costItemSupplier.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CostItemSupplierFindUniqueArgs>(args: SelectSubset<T, CostItemSupplierFindUniqueArgs<ExtArgs>>): Prisma__CostItemSupplierClient<$Result.GetResult<Prisma.$CostItemSupplierPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CostItemSupplier that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CostItemSupplierFindUniqueOrThrowArgs} args - Arguments to find a CostItemSupplier
     * @example
     * // Get one CostItemSupplier
     * const costItemSupplier = await prisma.costItemSupplier.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CostItemSupplierFindUniqueOrThrowArgs>(args: SelectSubset<T, CostItemSupplierFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CostItemSupplierClient<$Result.GetResult<Prisma.$CostItemSupplierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CostItemSupplier that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostItemSupplierFindFirstArgs} args - Arguments to find a CostItemSupplier
     * @example
     * // Get one CostItemSupplier
     * const costItemSupplier = await prisma.costItemSupplier.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CostItemSupplierFindFirstArgs>(args?: SelectSubset<T, CostItemSupplierFindFirstArgs<ExtArgs>>): Prisma__CostItemSupplierClient<$Result.GetResult<Prisma.$CostItemSupplierPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CostItemSupplier that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostItemSupplierFindFirstOrThrowArgs} args - Arguments to find a CostItemSupplier
     * @example
     * // Get one CostItemSupplier
     * const costItemSupplier = await prisma.costItemSupplier.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CostItemSupplierFindFirstOrThrowArgs>(args?: SelectSubset<T, CostItemSupplierFindFirstOrThrowArgs<ExtArgs>>): Prisma__CostItemSupplierClient<$Result.GetResult<Prisma.$CostItemSupplierPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CostItemSuppliers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostItemSupplierFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CostItemSuppliers
     * const costItemSuppliers = await prisma.costItemSupplier.findMany()
     * 
     * // Get first 10 CostItemSuppliers
     * const costItemSuppliers = await prisma.costItemSupplier.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const costItemSupplierWithIdOnly = await prisma.costItemSupplier.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CostItemSupplierFindManyArgs>(args?: SelectSubset<T, CostItemSupplierFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CostItemSupplierPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CostItemSupplier.
     * @param {CostItemSupplierCreateArgs} args - Arguments to create a CostItemSupplier.
     * @example
     * // Create one CostItemSupplier
     * const CostItemSupplier = await prisma.costItemSupplier.create({
     *   data: {
     *     // ... data to create a CostItemSupplier
     *   }
     * })
     * 
     */
    create<T extends CostItemSupplierCreateArgs>(args: SelectSubset<T, CostItemSupplierCreateArgs<ExtArgs>>): Prisma__CostItemSupplierClient<$Result.GetResult<Prisma.$CostItemSupplierPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CostItemSuppliers.
     * @param {CostItemSupplierCreateManyArgs} args - Arguments to create many CostItemSuppliers.
     * @example
     * // Create many CostItemSuppliers
     * const costItemSupplier = await prisma.costItemSupplier.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CostItemSupplierCreateManyArgs>(args?: SelectSubset<T, CostItemSupplierCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CostItemSuppliers and returns the data saved in the database.
     * @param {CostItemSupplierCreateManyAndReturnArgs} args - Arguments to create many CostItemSuppliers.
     * @example
     * // Create many CostItemSuppliers
     * const costItemSupplier = await prisma.costItemSupplier.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CostItemSuppliers and only return the `id`
     * const costItemSupplierWithIdOnly = await prisma.costItemSupplier.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CostItemSupplierCreateManyAndReturnArgs>(args?: SelectSubset<T, CostItemSupplierCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CostItemSupplierPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CostItemSupplier.
     * @param {CostItemSupplierDeleteArgs} args - Arguments to delete one CostItemSupplier.
     * @example
     * // Delete one CostItemSupplier
     * const CostItemSupplier = await prisma.costItemSupplier.delete({
     *   where: {
     *     // ... filter to delete one CostItemSupplier
     *   }
     * })
     * 
     */
    delete<T extends CostItemSupplierDeleteArgs>(args: SelectSubset<T, CostItemSupplierDeleteArgs<ExtArgs>>): Prisma__CostItemSupplierClient<$Result.GetResult<Prisma.$CostItemSupplierPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CostItemSupplier.
     * @param {CostItemSupplierUpdateArgs} args - Arguments to update one CostItemSupplier.
     * @example
     * // Update one CostItemSupplier
     * const costItemSupplier = await prisma.costItemSupplier.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CostItemSupplierUpdateArgs>(args: SelectSubset<T, CostItemSupplierUpdateArgs<ExtArgs>>): Prisma__CostItemSupplierClient<$Result.GetResult<Prisma.$CostItemSupplierPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CostItemSuppliers.
     * @param {CostItemSupplierDeleteManyArgs} args - Arguments to filter CostItemSuppliers to delete.
     * @example
     * // Delete a few CostItemSuppliers
     * const { count } = await prisma.costItemSupplier.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CostItemSupplierDeleteManyArgs>(args?: SelectSubset<T, CostItemSupplierDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CostItemSuppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostItemSupplierUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CostItemSuppliers
     * const costItemSupplier = await prisma.costItemSupplier.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CostItemSupplierUpdateManyArgs>(args: SelectSubset<T, CostItemSupplierUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CostItemSuppliers and returns the data updated in the database.
     * @param {CostItemSupplierUpdateManyAndReturnArgs} args - Arguments to update many CostItemSuppliers.
     * @example
     * // Update many CostItemSuppliers
     * const costItemSupplier = await prisma.costItemSupplier.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CostItemSuppliers and only return the `id`
     * const costItemSupplierWithIdOnly = await prisma.costItemSupplier.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CostItemSupplierUpdateManyAndReturnArgs>(args: SelectSubset<T, CostItemSupplierUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CostItemSupplierPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CostItemSupplier.
     * @param {CostItemSupplierUpsertArgs} args - Arguments to update or create a CostItemSupplier.
     * @example
     * // Update or create a CostItemSupplier
     * const costItemSupplier = await prisma.costItemSupplier.upsert({
     *   create: {
     *     // ... data to create a CostItemSupplier
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CostItemSupplier we want to update
     *   }
     * })
     */
    upsert<T extends CostItemSupplierUpsertArgs>(args: SelectSubset<T, CostItemSupplierUpsertArgs<ExtArgs>>): Prisma__CostItemSupplierClient<$Result.GetResult<Prisma.$CostItemSupplierPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CostItemSuppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostItemSupplierCountArgs} args - Arguments to filter CostItemSuppliers to count.
     * @example
     * // Count the number of CostItemSuppliers
     * const count = await prisma.costItemSupplier.count({
     *   where: {
     *     // ... the filter for the CostItemSuppliers we want to count
     *   }
     * })
    **/
    count<T extends CostItemSupplierCountArgs>(
      args?: Subset<T, CostItemSupplierCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CostItemSupplierCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CostItemSupplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostItemSupplierAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CostItemSupplierAggregateArgs>(args: Subset<T, CostItemSupplierAggregateArgs>): Prisma.PrismaPromise<GetCostItemSupplierAggregateType<T>>

    /**
     * Group by CostItemSupplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostItemSupplierGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CostItemSupplierGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CostItemSupplierGroupByArgs['orderBy'] }
        : { orderBy?: CostItemSupplierGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CostItemSupplierGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCostItemSupplierGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CostItemSupplier model
   */
  readonly fields: CostItemSupplierFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CostItemSupplier.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CostItemSupplierClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    costItem<T extends CostItemSupplier$costItemArgs<ExtArgs> = {}>(args?: Subset<T, CostItemSupplier$costItemArgs<ExtArgs>>): Prisma__CostItemClient<$Result.GetResult<Prisma.$CostItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    pendingCostItem<T extends CostItemSupplier$pendingCostItemArgs<ExtArgs> = {}>(args?: Subset<T, CostItemSupplier$pendingCostItemArgs<ExtArgs>>): Prisma__PendingCostItemClient<$Result.GetResult<Prisma.$PendingCostItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    settlements<T extends CostItemSupplier$settlementsArgs<ExtArgs> = {}>(args?: Subset<T, CostItemSupplier$settlementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPaymentSettlementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    paidByCreditNoteUsage<T extends CostItemSupplier$paidByCreditNoteUsageArgs<ExtArgs> = {}>(args?: Subset<T, CostItemSupplier$paidByCreditNoteUsageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditNoteUsagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CostItemSupplier model
   */
  interface CostItemSupplierFieldRefs {
    readonly id: FieldRef<"CostItemSupplier", 'Int'>
    readonly costItemId: FieldRef<"CostItemSupplier", 'Int'>
    readonly pendingCostItemId: FieldRef<"CostItemSupplier", 'Int'>
    readonly supplier: FieldRef<"CostItemSupplier", 'Suppliers'>
    readonly amount: FieldRef<"CostItemSupplier", 'Float'>
    readonly paymentMethod: FieldRef<"CostItemSupplier", 'String'>
    readonly paidAmount: FieldRef<"CostItemSupplier", 'Float'>
    readonly pendingAmount: FieldRef<"CostItemSupplier", 'Float'>
    readonly transactionMethod: FieldRef<"CostItemSupplier", 'String'>
    readonly firstMethodAmount: FieldRef<"CostItemSupplier", 'Float'>
    readonly secondMethodAmount: FieldRef<"CostItemSupplier", 'Float'>
    readonly createdAt: FieldRef<"CostItemSupplier", 'DateTime'>
    readonly updatedAt: FieldRef<"CostItemSupplier", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CostItemSupplier findUnique
   */
  export type CostItemSupplierFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostItemSupplier
     */
    select?: CostItemSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostItemSupplier
     */
    omit?: CostItemSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostItemSupplierInclude<ExtArgs> | null
    /**
     * Filter, which CostItemSupplier to fetch.
     */
    where: CostItemSupplierWhereUniqueInput
  }

  /**
   * CostItemSupplier findUniqueOrThrow
   */
  export type CostItemSupplierFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostItemSupplier
     */
    select?: CostItemSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostItemSupplier
     */
    omit?: CostItemSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostItemSupplierInclude<ExtArgs> | null
    /**
     * Filter, which CostItemSupplier to fetch.
     */
    where: CostItemSupplierWhereUniqueInput
  }

  /**
   * CostItemSupplier findFirst
   */
  export type CostItemSupplierFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostItemSupplier
     */
    select?: CostItemSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostItemSupplier
     */
    omit?: CostItemSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostItemSupplierInclude<ExtArgs> | null
    /**
     * Filter, which CostItemSupplier to fetch.
     */
    where?: CostItemSupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CostItemSuppliers to fetch.
     */
    orderBy?: CostItemSupplierOrderByWithRelationInput | CostItemSupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CostItemSuppliers.
     */
    cursor?: CostItemSupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CostItemSuppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CostItemSuppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CostItemSuppliers.
     */
    distinct?: CostItemSupplierScalarFieldEnum | CostItemSupplierScalarFieldEnum[]
  }

  /**
   * CostItemSupplier findFirstOrThrow
   */
  export type CostItemSupplierFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostItemSupplier
     */
    select?: CostItemSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostItemSupplier
     */
    omit?: CostItemSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostItemSupplierInclude<ExtArgs> | null
    /**
     * Filter, which CostItemSupplier to fetch.
     */
    where?: CostItemSupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CostItemSuppliers to fetch.
     */
    orderBy?: CostItemSupplierOrderByWithRelationInput | CostItemSupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CostItemSuppliers.
     */
    cursor?: CostItemSupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CostItemSuppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CostItemSuppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CostItemSuppliers.
     */
    distinct?: CostItemSupplierScalarFieldEnum | CostItemSupplierScalarFieldEnum[]
  }

  /**
   * CostItemSupplier findMany
   */
  export type CostItemSupplierFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostItemSupplier
     */
    select?: CostItemSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostItemSupplier
     */
    omit?: CostItemSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostItemSupplierInclude<ExtArgs> | null
    /**
     * Filter, which CostItemSuppliers to fetch.
     */
    where?: CostItemSupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CostItemSuppliers to fetch.
     */
    orderBy?: CostItemSupplierOrderByWithRelationInput | CostItemSupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CostItemSuppliers.
     */
    cursor?: CostItemSupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CostItemSuppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CostItemSuppliers.
     */
    skip?: number
    distinct?: CostItemSupplierScalarFieldEnum | CostItemSupplierScalarFieldEnum[]
  }

  /**
   * CostItemSupplier create
   */
  export type CostItemSupplierCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostItemSupplier
     */
    select?: CostItemSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostItemSupplier
     */
    omit?: CostItemSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostItemSupplierInclude<ExtArgs> | null
    /**
     * The data needed to create a CostItemSupplier.
     */
    data: XOR<CostItemSupplierCreateInput, CostItemSupplierUncheckedCreateInput>
  }

  /**
   * CostItemSupplier createMany
   */
  export type CostItemSupplierCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CostItemSuppliers.
     */
    data: CostItemSupplierCreateManyInput | CostItemSupplierCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CostItemSupplier createManyAndReturn
   */
  export type CostItemSupplierCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostItemSupplier
     */
    select?: CostItemSupplierSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CostItemSupplier
     */
    omit?: CostItemSupplierOmit<ExtArgs> | null
    /**
     * The data used to create many CostItemSuppliers.
     */
    data: CostItemSupplierCreateManyInput | CostItemSupplierCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostItemSupplierIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CostItemSupplier update
   */
  export type CostItemSupplierUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostItemSupplier
     */
    select?: CostItemSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostItemSupplier
     */
    omit?: CostItemSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostItemSupplierInclude<ExtArgs> | null
    /**
     * The data needed to update a CostItemSupplier.
     */
    data: XOR<CostItemSupplierUpdateInput, CostItemSupplierUncheckedUpdateInput>
    /**
     * Choose, which CostItemSupplier to update.
     */
    where: CostItemSupplierWhereUniqueInput
  }

  /**
   * CostItemSupplier updateMany
   */
  export type CostItemSupplierUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CostItemSuppliers.
     */
    data: XOR<CostItemSupplierUpdateManyMutationInput, CostItemSupplierUncheckedUpdateManyInput>
    /**
     * Filter which CostItemSuppliers to update
     */
    where?: CostItemSupplierWhereInput
    /**
     * Limit how many CostItemSuppliers to update.
     */
    limit?: number
  }

  /**
   * CostItemSupplier updateManyAndReturn
   */
  export type CostItemSupplierUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostItemSupplier
     */
    select?: CostItemSupplierSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CostItemSupplier
     */
    omit?: CostItemSupplierOmit<ExtArgs> | null
    /**
     * The data used to update CostItemSuppliers.
     */
    data: XOR<CostItemSupplierUpdateManyMutationInput, CostItemSupplierUncheckedUpdateManyInput>
    /**
     * Filter which CostItemSuppliers to update
     */
    where?: CostItemSupplierWhereInput
    /**
     * Limit how many CostItemSuppliers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostItemSupplierIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CostItemSupplier upsert
   */
  export type CostItemSupplierUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostItemSupplier
     */
    select?: CostItemSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostItemSupplier
     */
    omit?: CostItemSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostItemSupplierInclude<ExtArgs> | null
    /**
     * The filter to search for the CostItemSupplier to update in case it exists.
     */
    where: CostItemSupplierWhereUniqueInput
    /**
     * In case the CostItemSupplier found by the `where` argument doesn't exist, create a new CostItemSupplier with this data.
     */
    create: XOR<CostItemSupplierCreateInput, CostItemSupplierUncheckedCreateInput>
    /**
     * In case the CostItemSupplier was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CostItemSupplierUpdateInput, CostItemSupplierUncheckedUpdateInput>
  }

  /**
   * CostItemSupplier delete
   */
  export type CostItemSupplierDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostItemSupplier
     */
    select?: CostItemSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostItemSupplier
     */
    omit?: CostItemSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostItemSupplierInclude<ExtArgs> | null
    /**
     * Filter which CostItemSupplier to delete.
     */
    where: CostItemSupplierWhereUniqueInput
  }

  /**
   * CostItemSupplier deleteMany
   */
  export type CostItemSupplierDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CostItemSuppliers to delete
     */
    where?: CostItemSupplierWhereInput
    /**
     * Limit how many CostItemSuppliers to delete.
     */
    limit?: number
  }

  /**
   * CostItemSupplier.costItem
   */
  export type CostItemSupplier$costItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostItem
     */
    select?: CostItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostItem
     */
    omit?: CostItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostItemInclude<ExtArgs> | null
    where?: CostItemWhereInput
  }

  /**
   * CostItemSupplier.pendingCostItem
   */
  export type CostItemSupplier$pendingCostItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingCostItem
     */
    select?: PendingCostItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingCostItem
     */
    omit?: PendingCostItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingCostItemInclude<ExtArgs> | null
    where?: PendingCostItemWhereInput
  }

  /**
   * CostItemSupplier.settlements
   */
  export type CostItemSupplier$settlementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierPaymentSettlement
     */
    select?: SupplierPaymentSettlementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierPaymentSettlement
     */
    omit?: SupplierPaymentSettlementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierPaymentSettlementInclude<ExtArgs> | null
    where?: SupplierPaymentSettlementWhereInput
    orderBy?: SupplierPaymentSettlementOrderByWithRelationInput | SupplierPaymentSettlementOrderByWithRelationInput[]
    cursor?: SupplierPaymentSettlementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SupplierPaymentSettlementScalarFieldEnum | SupplierPaymentSettlementScalarFieldEnum[]
  }

  /**
   * CostItemSupplier.paidByCreditNoteUsage
   */
  export type CostItemSupplier$paidByCreditNoteUsageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditNoteUsage
     */
    select?: CreditNoteUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditNoteUsage
     */
    omit?: CreditNoteUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditNoteUsageInclude<ExtArgs> | null
    where?: CreditNoteUsageWhereInput
    orderBy?: CreditNoteUsageOrderByWithRelationInput | CreditNoteUsageOrderByWithRelationInput[]
    cursor?: CreditNoteUsageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CreditNoteUsageScalarFieldEnum | CreditNoteUsageScalarFieldEnum[]
  }

  /**
   * CostItemSupplier without action
   */
  export type CostItemSupplierDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostItemSupplier
     */
    select?: CostItemSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostItemSupplier
     */
    omit?: CostItemSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostItemSupplierInclude<ExtArgs> | null
  }


  /**
   * Model SupplierPaymentSettlement
   */

  export type AggregateSupplierPaymentSettlement = {
    _count: SupplierPaymentSettlementCountAggregateOutputType | null
    _avg: SupplierPaymentSettlementAvgAggregateOutputType | null
    _sum: SupplierPaymentSettlementSumAggregateOutputType | null
    _min: SupplierPaymentSettlementMinAggregateOutputType | null
    _max: SupplierPaymentSettlementMaxAggregateOutputType | null
  }

  export type SupplierPaymentSettlementAvgAggregateOutputType = {
    id: number | null
    costItemSupplierId: number | null
    amount: number | null
  }

  export type SupplierPaymentSettlementSumAggregateOutputType = {
    id: number | null
    costItemSupplierId: number | null
    amount: number | null
  }

  export type SupplierPaymentSettlementMinAggregateOutputType = {
    id: number | null
    costItemSupplierId: number | null
    amount: number | null
    transactionMethod: string | null
    settlementDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SupplierPaymentSettlementMaxAggregateOutputType = {
    id: number | null
    costItemSupplierId: number | null
    amount: number | null
    transactionMethod: string | null
    settlementDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SupplierPaymentSettlementCountAggregateOutputType = {
    id: number
    costItemSupplierId: number
    amount: number
    transactionMethod: number
    settlementDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SupplierPaymentSettlementAvgAggregateInputType = {
    id?: true
    costItemSupplierId?: true
    amount?: true
  }

  export type SupplierPaymentSettlementSumAggregateInputType = {
    id?: true
    costItemSupplierId?: true
    amount?: true
  }

  export type SupplierPaymentSettlementMinAggregateInputType = {
    id?: true
    costItemSupplierId?: true
    amount?: true
    transactionMethod?: true
    settlementDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SupplierPaymentSettlementMaxAggregateInputType = {
    id?: true
    costItemSupplierId?: true
    amount?: true
    transactionMethod?: true
    settlementDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SupplierPaymentSettlementCountAggregateInputType = {
    id?: true
    costItemSupplierId?: true
    amount?: true
    transactionMethod?: true
    settlementDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SupplierPaymentSettlementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SupplierPaymentSettlement to aggregate.
     */
    where?: SupplierPaymentSettlementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupplierPaymentSettlements to fetch.
     */
    orderBy?: SupplierPaymentSettlementOrderByWithRelationInput | SupplierPaymentSettlementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SupplierPaymentSettlementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupplierPaymentSettlements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupplierPaymentSettlements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SupplierPaymentSettlements
    **/
    _count?: true | SupplierPaymentSettlementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SupplierPaymentSettlementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SupplierPaymentSettlementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SupplierPaymentSettlementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SupplierPaymentSettlementMaxAggregateInputType
  }

  export type GetSupplierPaymentSettlementAggregateType<T extends SupplierPaymentSettlementAggregateArgs> = {
        [P in keyof T & keyof AggregateSupplierPaymentSettlement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupplierPaymentSettlement[P]>
      : GetScalarType<T[P], AggregateSupplierPaymentSettlement[P]>
  }




  export type SupplierPaymentSettlementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplierPaymentSettlementWhereInput
    orderBy?: SupplierPaymentSettlementOrderByWithAggregationInput | SupplierPaymentSettlementOrderByWithAggregationInput[]
    by: SupplierPaymentSettlementScalarFieldEnum[] | SupplierPaymentSettlementScalarFieldEnum
    having?: SupplierPaymentSettlementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SupplierPaymentSettlementCountAggregateInputType | true
    _avg?: SupplierPaymentSettlementAvgAggregateInputType
    _sum?: SupplierPaymentSettlementSumAggregateInputType
    _min?: SupplierPaymentSettlementMinAggregateInputType
    _max?: SupplierPaymentSettlementMaxAggregateInputType
  }

  export type SupplierPaymentSettlementGroupByOutputType = {
    id: number
    costItemSupplierId: number
    amount: number
    transactionMethod: string
    settlementDate: Date
    createdAt: Date
    updatedAt: Date
    _count: SupplierPaymentSettlementCountAggregateOutputType | null
    _avg: SupplierPaymentSettlementAvgAggregateOutputType | null
    _sum: SupplierPaymentSettlementSumAggregateOutputType | null
    _min: SupplierPaymentSettlementMinAggregateOutputType | null
    _max: SupplierPaymentSettlementMaxAggregateOutputType | null
  }

  type GetSupplierPaymentSettlementGroupByPayload<T extends SupplierPaymentSettlementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SupplierPaymentSettlementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SupplierPaymentSettlementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SupplierPaymentSettlementGroupByOutputType[P]>
            : GetScalarType<T[P], SupplierPaymentSettlementGroupByOutputType[P]>
        }
      >
    >


  export type SupplierPaymentSettlementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    costItemSupplierId?: boolean
    amount?: boolean
    transactionMethod?: boolean
    settlementDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    costItemSupplier?: boolean | CostItemSupplierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplierPaymentSettlement"]>

  export type SupplierPaymentSettlementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    costItemSupplierId?: boolean
    amount?: boolean
    transactionMethod?: boolean
    settlementDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    costItemSupplier?: boolean | CostItemSupplierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplierPaymentSettlement"]>

  export type SupplierPaymentSettlementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    costItemSupplierId?: boolean
    amount?: boolean
    transactionMethod?: boolean
    settlementDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    costItemSupplier?: boolean | CostItemSupplierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplierPaymentSettlement"]>

  export type SupplierPaymentSettlementSelectScalar = {
    id?: boolean
    costItemSupplierId?: boolean
    amount?: boolean
    transactionMethod?: boolean
    settlementDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SupplierPaymentSettlementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "costItemSupplierId" | "amount" | "transactionMethod" | "settlementDate" | "createdAt" | "updatedAt", ExtArgs["result"]["supplierPaymentSettlement"]>
  export type SupplierPaymentSettlementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    costItemSupplier?: boolean | CostItemSupplierDefaultArgs<ExtArgs>
  }
  export type SupplierPaymentSettlementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    costItemSupplier?: boolean | CostItemSupplierDefaultArgs<ExtArgs>
  }
  export type SupplierPaymentSettlementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    costItemSupplier?: boolean | CostItemSupplierDefaultArgs<ExtArgs>
  }

  export type $SupplierPaymentSettlementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SupplierPaymentSettlement"
    objects: {
      costItemSupplier: Prisma.$CostItemSupplierPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      costItemSupplierId: number
      amount: number
      transactionMethod: string
      settlementDate: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["supplierPaymentSettlement"]>
    composites: {}
  }

  type SupplierPaymentSettlementGetPayload<S extends boolean | null | undefined | SupplierPaymentSettlementDefaultArgs> = $Result.GetResult<Prisma.$SupplierPaymentSettlementPayload, S>

  type SupplierPaymentSettlementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SupplierPaymentSettlementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SupplierPaymentSettlementCountAggregateInputType | true
    }

  export interface SupplierPaymentSettlementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SupplierPaymentSettlement'], meta: { name: 'SupplierPaymentSettlement' } }
    /**
     * Find zero or one SupplierPaymentSettlement that matches the filter.
     * @param {SupplierPaymentSettlementFindUniqueArgs} args - Arguments to find a SupplierPaymentSettlement
     * @example
     * // Get one SupplierPaymentSettlement
     * const supplierPaymentSettlement = await prisma.supplierPaymentSettlement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SupplierPaymentSettlementFindUniqueArgs>(args: SelectSubset<T, SupplierPaymentSettlementFindUniqueArgs<ExtArgs>>): Prisma__SupplierPaymentSettlementClient<$Result.GetResult<Prisma.$SupplierPaymentSettlementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SupplierPaymentSettlement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SupplierPaymentSettlementFindUniqueOrThrowArgs} args - Arguments to find a SupplierPaymentSettlement
     * @example
     * // Get one SupplierPaymentSettlement
     * const supplierPaymentSettlement = await prisma.supplierPaymentSettlement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SupplierPaymentSettlementFindUniqueOrThrowArgs>(args: SelectSubset<T, SupplierPaymentSettlementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SupplierPaymentSettlementClient<$Result.GetResult<Prisma.$SupplierPaymentSettlementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SupplierPaymentSettlement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierPaymentSettlementFindFirstArgs} args - Arguments to find a SupplierPaymentSettlement
     * @example
     * // Get one SupplierPaymentSettlement
     * const supplierPaymentSettlement = await prisma.supplierPaymentSettlement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SupplierPaymentSettlementFindFirstArgs>(args?: SelectSubset<T, SupplierPaymentSettlementFindFirstArgs<ExtArgs>>): Prisma__SupplierPaymentSettlementClient<$Result.GetResult<Prisma.$SupplierPaymentSettlementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SupplierPaymentSettlement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierPaymentSettlementFindFirstOrThrowArgs} args - Arguments to find a SupplierPaymentSettlement
     * @example
     * // Get one SupplierPaymentSettlement
     * const supplierPaymentSettlement = await prisma.supplierPaymentSettlement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SupplierPaymentSettlementFindFirstOrThrowArgs>(args?: SelectSubset<T, SupplierPaymentSettlementFindFirstOrThrowArgs<ExtArgs>>): Prisma__SupplierPaymentSettlementClient<$Result.GetResult<Prisma.$SupplierPaymentSettlementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SupplierPaymentSettlements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierPaymentSettlementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SupplierPaymentSettlements
     * const supplierPaymentSettlements = await prisma.supplierPaymentSettlement.findMany()
     * 
     * // Get first 10 SupplierPaymentSettlements
     * const supplierPaymentSettlements = await prisma.supplierPaymentSettlement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const supplierPaymentSettlementWithIdOnly = await prisma.supplierPaymentSettlement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SupplierPaymentSettlementFindManyArgs>(args?: SelectSubset<T, SupplierPaymentSettlementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPaymentSettlementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SupplierPaymentSettlement.
     * @param {SupplierPaymentSettlementCreateArgs} args - Arguments to create a SupplierPaymentSettlement.
     * @example
     * // Create one SupplierPaymentSettlement
     * const SupplierPaymentSettlement = await prisma.supplierPaymentSettlement.create({
     *   data: {
     *     // ... data to create a SupplierPaymentSettlement
     *   }
     * })
     * 
     */
    create<T extends SupplierPaymentSettlementCreateArgs>(args: SelectSubset<T, SupplierPaymentSettlementCreateArgs<ExtArgs>>): Prisma__SupplierPaymentSettlementClient<$Result.GetResult<Prisma.$SupplierPaymentSettlementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SupplierPaymentSettlements.
     * @param {SupplierPaymentSettlementCreateManyArgs} args - Arguments to create many SupplierPaymentSettlements.
     * @example
     * // Create many SupplierPaymentSettlements
     * const supplierPaymentSettlement = await prisma.supplierPaymentSettlement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SupplierPaymentSettlementCreateManyArgs>(args?: SelectSubset<T, SupplierPaymentSettlementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SupplierPaymentSettlements and returns the data saved in the database.
     * @param {SupplierPaymentSettlementCreateManyAndReturnArgs} args - Arguments to create many SupplierPaymentSettlements.
     * @example
     * // Create many SupplierPaymentSettlements
     * const supplierPaymentSettlement = await prisma.supplierPaymentSettlement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SupplierPaymentSettlements and only return the `id`
     * const supplierPaymentSettlementWithIdOnly = await prisma.supplierPaymentSettlement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SupplierPaymentSettlementCreateManyAndReturnArgs>(args?: SelectSubset<T, SupplierPaymentSettlementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPaymentSettlementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SupplierPaymentSettlement.
     * @param {SupplierPaymentSettlementDeleteArgs} args - Arguments to delete one SupplierPaymentSettlement.
     * @example
     * // Delete one SupplierPaymentSettlement
     * const SupplierPaymentSettlement = await prisma.supplierPaymentSettlement.delete({
     *   where: {
     *     // ... filter to delete one SupplierPaymentSettlement
     *   }
     * })
     * 
     */
    delete<T extends SupplierPaymentSettlementDeleteArgs>(args: SelectSubset<T, SupplierPaymentSettlementDeleteArgs<ExtArgs>>): Prisma__SupplierPaymentSettlementClient<$Result.GetResult<Prisma.$SupplierPaymentSettlementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SupplierPaymentSettlement.
     * @param {SupplierPaymentSettlementUpdateArgs} args - Arguments to update one SupplierPaymentSettlement.
     * @example
     * // Update one SupplierPaymentSettlement
     * const supplierPaymentSettlement = await prisma.supplierPaymentSettlement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SupplierPaymentSettlementUpdateArgs>(args: SelectSubset<T, SupplierPaymentSettlementUpdateArgs<ExtArgs>>): Prisma__SupplierPaymentSettlementClient<$Result.GetResult<Prisma.$SupplierPaymentSettlementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SupplierPaymentSettlements.
     * @param {SupplierPaymentSettlementDeleteManyArgs} args - Arguments to filter SupplierPaymentSettlements to delete.
     * @example
     * // Delete a few SupplierPaymentSettlements
     * const { count } = await prisma.supplierPaymentSettlement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SupplierPaymentSettlementDeleteManyArgs>(args?: SelectSubset<T, SupplierPaymentSettlementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SupplierPaymentSettlements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierPaymentSettlementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SupplierPaymentSettlements
     * const supplierPaymentSettlement = await prisma.supplierPaymentSettlement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SupplierPaymentSettlementUpdateManyArgs>(args: SelectSubset<T, SupplierPaymentSettlementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SupplierPaymentSettlements and returns the data updated in the database.
     * @param {SupplierPaymentSettlementUpdateManyAndReturnArgs} args - Arguments to update many SupplierPaymentSettlements.
     * @example
     * // Update many SupplierPaymentSettlements
     * const supplierPaymentSettlement = await prisma.supplierPaymentSettlement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SupplierPaymentSettlements and only return the `id`
     * const supplierPaymentSettlementWithIdOnly = await prisma.supplierPaymentSettlement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SupplierPaymentSettlementUpdateManyAndReturnArgs>(args: SelectSubset<T, SupplierPaymentSettlementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPaymentSettlementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SupplierPaymentSettlement.
     * @param {SupplierPaymentSettlementUpsertArgs} args - Arguments to update or create a SupplierPaymentSettlement.
     * @example
     * // Update or create a SupplierPaymentSettlement
     * const supplierPaymentSettlement = await prisma.supplierPaymentSettlement.upsert({
     *   create: {
     *     // ... data to create a SupplierPaymentSettlement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SupplierPaymentSettlement we want to update
     *   }
     * })
     */
    upsert<T extends SupplierPaymentSettlementUpsertArgs>(args: SelectSubset<T, SupplierPaymentSettlementUpsertArgs<ExtArgs>>): Prisma__SupplierPaymentSettlementClient<$Result.GetResult<Prisma.$SupplierPaymentSettlementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SupplierPaymentSettlements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierPaymentSettlementCountArgs} args - Arguments to filter SupplierPaymentSettlements to count.
     * @example
     * // Count the number of SupplierPaymentSettlements
     * const count = await prisma.supplierPaymentSettlement.count({
     *   where: {
     *     // ... the filter for the SupplierPaymentSettlements we want to count
     *   }
     * })
    **/
    count<T extends SupplierPaymentSettlementCountArgs>(
      args?: Subset<T, SupplierPaymentSettlementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupplierPaymentSettlementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SupplierPaymentSettlement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierPaymentSettlementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SupplierPaymentSettlementAggregateArgs>(args: Subset<T, SupplierPaymentSettlementAggregateArgs>): Prisma.PrismaPromise<GetSupplierPaymentSettlementAggregateType<T>>

    /**
     * Group by SupplierPaymentSettlement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierPaymentSettlementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SupplierPaymentSettlementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SupplierPaymentSettlementGroupByArgs['orderBy'] }
        : { orderBy?: SupplierPaymentSettlementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SupplierPaymentSettlementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupplierPaymentSettlementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SupplierPaymentSettlement model
   */
  readonly fields: SupplierPaymentSettlementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SupplierPaymentSettlement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SupplierPaymentSettlementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    costItemSupplier<T extends CostItemSupplierDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CostItemSupplierDefaultArgs<ExtArgs>>): Prisma__CostItemSupplierClient<$Result.GetResult<Prisma.$CostItemSupplierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SupplierPaymentSettlement model
   */
  interface SupplierPaymentSettlementFieldRefs {
    readonly id: FieldRef<"SupplierPaymentSettlement", 'Int'>
    readonly costItemSupplierId: FieldRef<"SupplierPaymentSettlement", 'Int'>
    readonly amount: FieldRef<"SupplierPaymentSettlement", 'Float'>
    readonly transactionMethod: FieldRef<"SupplierPaymentSettlement", 'String'>
    readonly settlementDate: FieldRef<"SupplierPaymentSettlement", 'DateTime'>
    readonly createdAt: FieldRef<"SupplierPaymentSettlement", 'DateTime'>
    readonly updatedAt: FieldRef<"SupplierPaymentSettlement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SupplierPaymentSettlement findUnique
   */
  export type SupplierPaymentSettlementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierPaymentSettlement
     */
    select?: SupplierPaymentSettlementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierPaymentSettlement
     */
    omit?: SupplierPaymentSettlementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierPaymentSettlementInclude<ExtArgs> | null
    /**
     * Filter, which SupplierPaymentSettlement to fetch.
     */
    where: SupplierPaymentSettlementWhereUniqueInput
  }

  /**
   * SupplierPaymentSettlement findUniqueOrThrow
   */
  export type SupplierPaymentSettlementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierPaymentSettlement
     */
    select?: SupplierPaymentSettlementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierPaymentSettlement
     */
    omit?: SupplierPaymentSettlementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierPaymentSettlementInclude<ExtArgs> | null
    /**
     * Filter, which SupplierPaymentSettlement to fetch.
     */
    where: SupplierPaymentSettlementWhereUniqueInput
  }

  /**
   * SupplierPaymentSettlement findFirst
   */
  export type SupplierPaymentSettlementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierPaymentSettlement
     */
    select?: SupplierPaymentSettlementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierPaymentSettlement
     */
    omit?: SupplierPaymentSettlementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierPaymentSettlementInclude<ExtArgs> | null
    /**
     * Filter, which SupplierPaymentSettlement to fetch.
     */
    where?: SupplierPaymentSettlementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupplierPaymentSettlements to fetch.
     */
    orderBy?: SupplierPaymentSettlementOrderByWithRelationInput | SupplierPaymentSettlementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SupplierPaymentSettlements.
     */
    cursor?: SupplierPaymentSettlementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupplierPaymentSettlements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupplierPaymentSettlements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SupplierPaymentSettlements.
     */
    distinct?: SupplierPaymentSettlementScalarFieldEnum | SupplierPaymentSettlementScalarFieldEnum[]
  }

  /**
   * SupplierPaymentSettlement findFirstOrThrow
   */
  export type SupplierPaymentSettlementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierPaymentSettlement
     */
    select?: SupplierPaymentSettlementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierPaymentSettlement
     */
    omit?: SupplierPaymentSettlementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierPaymentSettlementInclude<ExtArgs> | null
    /**
     * Filter, which SupplierPaymentSettlement to fetch.
     */
    where?: SupplierPaymentSettlementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupplierPaymentSettlements to fetch.
     */
    orderBy?: SupplierPaymentSettlementOrderByWithRelationInput | SupplierPaymentSettlementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SupplierPaymentSettlements.
     */
    cursor?: SupplierPaymentSettlementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupplierPaymentSettlements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupplierPaymentSettlements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SupplierPaymentSettlements.
     */
    distinct?: SupplierPaymentSettlementScalarFieldEnum | SupplierPaymentSettlementScalarFieldEnum[]
  }

  /**
   * SupplierPaymentSettlement findMany
   */
  export type SupplierPaymentSettlementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierPaymentSettlement
     */
    select?: SupplierPaymentSettlementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierPaymentSettlement
     */
    omit?: SupplierPaymentSettlementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierPaymentSettlementInclude<ExtArgs> | null
    /**
     * Filter, which SupplierPaymentSettlements to fetch.
     */
    where?: SupplierPaymentSettlementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupplierPaymentSettlements to fetch.
     */
    orderBy?: SupplierPaymentSettlementOrderByWithRelationInput | SupplierPaymentSettlementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SupplierPaymentSettlements.
     */
    cursor?: SupplierPaymentSettlementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupplierPaymentSettlements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupplierPaymentSettlements.
     */
    skip?: number
    distinct?: SupplierPaymentSettlementScalarFieldEnum | SupplierPaymentSettlementScalarFieldEnum[]
  }

  /**
   * SupplierPaymentSettlement create
   */
  export type SupplierPaymentSettlementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierPaymentSettlement
     */
    select?: SupplierPaymentSettlementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierPaymentSettlement
     */
    omit?: SupplierPaymentSettlementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierPaymentSettlementInclude<ExtArgs> | null
    /**
     * The data needed to create a SupplierPaymentSettlement.
     */
    data: XOR<SupplierPaymentSettlementCreateInput, SupplierPaymentSettlementUncheckedCreateInput>
  }

  /**
   * SupplierPaymentSettlement createMany
   */
  export type SupplierPaymentSettlementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SupplierPaymentSettlements.
     */
    data: SupplierPaymentSettlementCreateManyInput | SupplierPaymentSettlementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SupplierPaymentSettlement createManyAndReturn
   */
  export type SupplierPaymentSettlementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierPaymentSettlement
     */
    select?: SupplierPaymentSettlementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierPaymentSettlement
     */
    omit?: SupplierPaymentSettlementOmit<ExtArgs> | null
    /**
     * The data used to create many SupplierPaymentSettlements.
     */
    data: SupplierPaymentSettlementCreateManyInput | SupplierPaymentSettlementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierPaymentSettlementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SupplierPaymentSettlement update
   */
  export type SupplierPaymentSettlementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierPaymentSettlement
     */
    select?: SupplierPaymentSettlementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierPaymentSettlement
     */
    omit?: SupplierPaymentSettlementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierPaymentSettlementInclude<ExtArgs> | null
    /**
     * The data needed to update a SupplierPaymentSettlement.
     */
    data: XOR<SupplierPaymentSettlementUpdateInput, SupplierPaymentSettlementUncheckedUpdateInput>
    /**
     * Choose, which SupplierPaymentSettlement to update.
     */
    where: SupplierPaymentSettlementWhereUniqueInput
  }

  /**
   * SupplierPaymentSettlement updateMany
   */
  export type SupplierPaymentSettlementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SupplierPaymentSettlements.
     */
    data: XOR<SupplierPaymentSettlementUpdateManyMutationInput, SupplierPaymentSettlementUncheckedUpdateManyInput>
    /**
     * Filter which SupplierPaymentSettlements to update
     */
    where?: SupplierPaymentSettlementWhereInput
    /**
     * Limit how many SupplierPaymentSettlements to update.
     */
    limit?: number
  }

  /**
   * SupplierPaymentSettlement updateManyAndReturn
   */
  export type SupplierPaymentSettlementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierPaymentSettlement
     */
    select?: SupplierPaymentSettlementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierPaymentSettlement
     */
    omit?: SupplierPaymentSettlementOmit<ExtArgs> | null
    /**
     * The data used to update SupplierPaymentSettlements.
     */
    data: XOR<SupplierPaymentSettlementUpdateManyMutationInput, SupplierPaymentSettlementUncheckedUpdateManyInput>
    /**
     * Filter which SupplierPaymentSettlements to update
     */
    where?: SupplierPaymentSettlementWhereInput
    /**
     * Limit how many SupplierPaymentSettlements to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierPaymentSettlementIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SupplierPaymentSettlement upsert
   */
  export type SupplierPaymentSettlementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierPaymentSettlement
     */
    select?: SupplierPaymentSettlementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierPaymentSettlement
     */
    omit?: SupplierPaymentSettlementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierPaymentSettlementInclude<ExtArgs> | null
    /**
     * The filter to search for the SupplierPaymentSettlement to update in case it exists.
     */
    where: SupplierPaymentSettlementWhereUniqueInput
    /**
     * In case the SupplierPaymentSettlement found by the `where` argument doesn't exist, create a new SupplierPaymentSettlement with this data.
     */
    create: XOR<SupplierPaymentSettlementCreateInput, SupplierPaymentSettlementUncheckedCreateInput>
    /**
     * In case the SupplierPaymentSettlement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SupplierPaymentSettlementUpdateInput, SupplierPaymentSettlementUncheckedUpdateInput>
  }

  /**
   * SupplierPaymentSettlement delete
   */
  export type SupplierPaymentSettlementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierPaymentSettlement
     */
    select?: SupplierPaymentSettlementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierPaymentSettlement
     */
    omit?: SupplierPaymentSettlementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierPaymentSettlementInclude<ExtArgs> | null
    /**
     * Filter which SupplierPaymentSettlement to delete.
     */
    where: SupplierPaymentSettlementWhereUniqueInput
  }

  /**
   * SupplierPaymentSettlement deleteMany
   */
  export type SupplierPaymentSettlementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SupplierPaymentSettlements to delete
     */
    where?: SupplierPaymentSettlementWhereInput
    /**
     * Limit how many SupplierPaymentSettlements to delete.
     */
    limit?: number
  }

  /**
   * SupplierPaymentSettlement without action
   */
  export type SupplierPaymentSettlementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierPaymentSettlement
     */
    select?: SupplierPaymentSettlementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierPaymentSettlement
     */
    omit?: SupplierPaymentSettlementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierPaymentSettlementInclude<ExtArgs> | null
  }


  /**
   * Model Cancellation
   */

  export type AggregateCancellation = {
    _count: CancellationCountAggregateOutputType | null
    _avg: CancellationAvgAggregateOutputType | null
    _sum: CancellationSumAggregateOutputType | null
    _min: CancellationMinAggregateOutputType | null
    _max: CancellationMaxAggregateOutputType | null
  }

  export type CancellationAvgAggregateOutputType = {
    id: number | null
    originalBookingId: number | null
    originalRevenue: number | null
    originalProdCost: number | null
    supplierCancellationFee: number | null
    refundToPassenger: number | null
    creditNoteAmount: number | null
    profitOrLoss: number | null
  }

  export type CancellationSumAggregateOutputType = {
    id: number | null
    originalBookingId: number | null
    originalRevenue: number | null
    originalProdCost: number | null
    supplierCancellationFee: number | null
    refundToPassenger: number | null
    creditNoteAmount: number | null
    profitOrLoss: number | null
  }

  export type CancellationMinAggregateOutputType = {
    id: number | null
    originalBookingId: number | null
    folderNo: string | null
    refundTransactionMethod: string | null
    originalRevenue: number | null
    originalProdCost: number | null
    supplierCancellationFee: number | null
    refundToPassenger: number | null
    creditNoteAmount: number | null
    profitOrLoss: number | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CancellationMaxAggregateOutputType = {
    id: number | null
    originalBookingId: number | null
    folderNo: string | null
    refundTransactionMethod: string | null
    originalRevenue: number | null
    originalProdCost: number | null
    supplierCancellationFee: number | null
    refundToPassenger: number | null
    creditNoteAmount: number | null
    profitOrLoss: number | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CancellationCountAggregateOutputType = {
    id: number
    originalBookingId: number
    folderNo: number
    refundTransactionMethod: number
    originalRevenue: number
    originalProdCost: number
    supplierCancellationFee: number
    refundToPassenger: number
    creditNoteAmount: number
    profitOrLoss: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CancellationAvgAggregateInputType = {
    id?: true
    originalBookingId?: true
    originalRevenue?: true
    originalProdCost?: true
    supplierCancellationFee?: true
    refundToPassenger?: true
    creditNoteAmount?: true
    profitOrLoss?: true
  }

  export type CancellationSumAggregateInputType = {
    id?: true
    originalBookingId?: true
    originalRevenue?: true
    originalProdCost?: true
    supplierCancellationFee?: true
    refundToPassenger?: true
    creditNoteAmount?: true
    profitOrLoss?: true
  }

  export type CancellationMinAggregateInputType = {
    id?: true
    originalBookingId?: true
    folderNo?: true
    refundTransactionMethod?: true
    originalRevenue?: true
    originalProdCost?: true
    supplierCancellationFee?: true
    refundToPassenger?: true
    creditNoteAmount?: true
    profitOrLoss?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CancellationMaxAggregateInputType = {
    id?: true
    originalBookingId?: true
    folderNo?: true
    refundTransactionMethod?: true
    originalRevenue?: true
    originalProdCost?: true
    supplierCancellationFee?: true
    refundToPassenger?: true
    creditNoteAmount?: true
    profitOrLoss?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CancellationCountAggregateInputType = {
    id?: true
    originalBookingId?: true
    folderNo?: true
    refundTransactionMethod?: true
    originalRevenue?: true
    originalProdCost?: true
    supplierCancellationFee?: true
    refundToPassenger?: true
    creditNoteAmount?: true
    profitOrLoss?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CancellationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cancellation to aggregate.
     */
    where?: CancellationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cancellations to fetch.
     */
    orderBy?: CancellationOrderByWithRelationInput | CancellationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CancellationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cancellations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cancellations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Cancellations
    **/
    _count?: true | CancellationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CancellationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CancellationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CancellationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CancellationMaxAggregateInputType
  }

  export type GetCancellationAggregateType<T extends CancellationAggregateArgs> = {
        [P in keyof T & keyof AggregateCancellation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCancellation[P]>
      : GetScalarType<T[P], AggregateCancellation[P]>
  }




  export type CancellationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CancellationWhereInput
    orderBy?: CancellationOrderByWithAggregationInput | CancellationOrderByWithAggregationInput[]
    by: CancellationScalarFieldEnum[] | CancellationScalarFieldEnum
    having?: CancellationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CancellationCountAggregateInputType | true
    _avg?: CancellationAvgAggregateInputType
    _sum?: CancellationSumAggregateInputType
    _min?: CancellationMinAggregateInputType
    _max?: CancellationMaxAggregateInputType
  }

  export type CancellationGroupByOutputType = {
    id: number
    originalBookingId: number
    folderNo: string
    refundTransactionMethod: string
    originalRevenue: number
    originalProdCost: number
    supplierCancellationFee: number
    refundToPassenger: number
    creditNoteAmount: number | null
    profitOrLoss: number
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: CancellationCountAggregateOutputType | null
    _avg: CancellationAvgAggregateOutputType | null
    _sum: CancellationSumAggregateOutputType | null
    _min: CancellationMinAggregateOutputType | null
    _max: CancellationMaxAggregateOutputType | null
  }

  type GetCancellationGroupByPayload<T extends CancellationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CancellationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CancellationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CancellationGroupByOutputType[P]>
            : GetScalarType<T[P], CancellationGroupByOutputType[P]>
        }
      >
    >


  export type CancellationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    originalBookingId?: boolean
    folderNo?: boolean
    refundTransactionMethod?: boolean
    originalRevenue?: boolean
    originalProdCost?: boolean
    supplierCancellationFee?: boolean
    refundToPassenger?: boolean
    creditNoteAmount?: boolean
    profitOrLoss?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    originalBooking?: boolean | BookingDefaultArgs<ExtArgs>
    generatedCreditNote?: boolean | Cancellation$generatedCreditNoteArgs<ExtArgs>
  }, ExtArgs["result"]["cancellation"]>

  export type CancellationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    originalBookingId?: boolean
    folderNo?: boolean
    refundTransactionMethod?: boolean
    originalRevenue?: boolean
    originalProdCost?: boolean
    supplierCancellationFee?: boolean
    refundToPassenger?: boolean
    creditNoteAmount?: boolean
    profitOrLoss?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    originalBooking?: boolean | BookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cancellation"]>

  export type CancellationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    originalBookingId?: boolean
    folderNo?: boolean
    refundTransactionMethod?: boolean
    originalRevenue?: boolean
    originalProdCost?: boolean
    supplierCancellationFee?: boolean
    refundToPassenger?: boolean
    creditNoteAmount?: boolean
    profitOrLoss?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    originalBooking?: boolean | BookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cancellation"]>

  export type CancellationSelectScalar = {
    id?: boolean
    originalBookingId?: boolean
    folderNo?: boolean
    refundTransactionMethod?: boolean
    originalRevenue?: boolean
    originalProdCost?: boolean
    supplierCancellationFee?: boolean
    refundToPassenger?: boolean
    creditNoteAmount?: boolean
    profitOrLoss?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CancellationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "originalBookingId" | "folderNo" | "refundTransactionMethod" | "originalRevenue" | "originalProdCost" | "supplierCancellationFee" | "refundToPassenger" | "creditNoteAmount" | "profitOrLoss" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["cancellation"]>
  export type CancellationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    originalBooking?: boolean | BookingDefaultArgs<ExtArgs>
    generatedCreditNote?: boolean | Cancellation$generatedCreditNoteArgs<ExtArgs>
  }
  export type CancellationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    originalBooking?: boolean | BookingDefaultArgs<ExtArgs>
  }
  export type CancellationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    originalBooking?: boolean | BookingDefaultArgs<ExtArgs>
  }

  export type $CancellationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Cancellation"
    objects: {
      originalBooking: Prisma.$BookingPayload<ExtArgs>
      generatedCreditNote: Prisma.$SupplierCreditNotePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      originalBookingId: number
      folderNo: string
      refundTransactionMethod: string
      originalRevenue: number
      originalProdCost: number
      supplierCancellationFee: number
      refundToPassenger: number
      creditNoteAmount: number | null
      profitOrLoss: number
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cancellation"]>
    composites: {}
  }

  type CancellationGetPayload<S extends boolean | null | undefined | CancellationDefaultArgs> = $Result.GetResult<Prisma.$CancellationPayload, S>

  type CancellationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CancellationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CancellationCountAggregateInputType | true
    }

  export interface CancellationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Cancellation'], meta: { name: 'Cancellation' } }
    /**
     * Find zero or one Cancellation that matches the filter.
     * @param {CancellationFindUniqueArgs} args - Arguments to find a Cancellation
     * @example
     * // Get one Cancellation
     * const cancellation = await prisma.cancellation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CancellationFindUniqueArgs>(args: SelectSubset<T, CancellationFindUniqueArgs<ExtArgs>>): Prisma__CancellationClient<$Result.GetResult<Prisma.$CancellationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Cancellation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CancellationFindUniqueOrThrowArgs} args - Arguments to find a Cancellation
     * @example
     * // Get one Cancellation
     * const cancellation = await prisma.cancellation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CancellationFindUniqueOrThrowArgs>(args: SelectSubset<T, CancellationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CancellationClient<$Result.GetResult<Prisma.$CancellationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cancellation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CancellationFindFirstArgs} args - Arguments to find a Cancellation
     * @example
     * // Get one Cancellation
     * const cancellation = await prisma.cancellation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CancellationFindFirstArgs>(args?: SelectSubset<T, CancellationFindFirstArgs<ExtArgs>>): Prisma__CancellationClient<$Result.GetResult<Prisma.$CancellationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cancellation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CancellationFindFirstOrThrowArgs} args - Arguments to find a Cancellation
     * @example
     * // Get one Cancellation
     * const cancellation = await prisma.cancellation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CancellationFindFirstOrThrowArgs>(args?: SelectSubset<T, CancellationFindFirstOrThrowArgs<ExtArgs>>): Prisma__CancellationClient<$Result.GetResult<Prisma.$CancellationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Cancellations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CancellationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cancellations
     * const cancellations = await prisma.cancellation.findMany()
     * 
     * // Get first 10 Cancellations
     * const cancellations = await prisma.cancellation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cancellationWithIdOnly = await prisma.cancellation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CancellationFindManyArgs>(args?: SelectSubset<T, CancellationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CancellationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Cancellation.
     * @param {CancellationCreateArgs} args - Arguments to create a Cancellation.
     * @example
     * // Create one Cancellation
     * const Cancellation = await prisma.cancellation.create({
     *   data: {
     *     // ... data to create a Cancellation
     *   }
     * })
     * 
     */
    create<T extends CancellationCreateArgs>(args: SelectSubset<T, CancellationCreateArgs<ExtArgs>>): Prisma__CancellationClient<$Result.GetResult<Prisma.$CancellationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Cancellations.
     * @param {CancellationCreateManyArgs} args - Arguments to create many Cancellations.
     * @example
     * // Create many Cancellations
     * const cancellation = await prisma.cancellation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CancellationCreateManyArgs>(args?: SelectSubset<T, CancellationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Cancellations and returns the data saved in the database.
     * @param {CancellationCreateManyAndReturnArgs} args - Arguments to create many Cancellations.
     * @example
     * // Create many Cancellations
     * const cancellation = await prisma.cancellation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Cancellations and only return the `id`
     * const cancellationWithIdOnly = await prisma.cancellation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CancellationCreateManyAndReturnArgs>(args?: SelectSubset<T, CancellationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CancellationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Cancellation.
     * @param {CancellationDeleteArgs} args - Arguments to delete one Cancellation.
     * @example
     * // Delete one Cancellation
     * const Cancellation = await prisma.cancellation.delete({
     *   where: {
     *     // ... filter to delete one Cancellation
     *   }
     * })
     * 
     */
    delete<T extends CancellationDeleteArgs>(args: SelectSubset<T, CancellationDeleteArgs<ExtArgs>>): Prisma__CancellationClient<$Result.GetResult<Prisma.$CancellationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Cancellation.
     * @param {CancellationUpdateArgs} args - Arguments to update one Cancellation.
     * @example
     * // Update one Cancellation
     * const cancellation = await prisma.cancellation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CancellationUpdateArgs>(args: SelectSubset<T, CancellationUpdateArgs<ExtArgs>>): Prisma__CancellationClient<$Result.GetResult<Prisma.$CancellationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Cancellations.
     * @param {CancellationDeleteManyArgs} args - Arguments to filter Cancellations to delete.
     * @example
     * // Delete a few Cancellations
     * const { count } = await prisma.cancellation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CancellationDeleteManyArgs>(args?: SelectSubset<T, CancellationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cancellations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CancellationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cancellations
     * const cancellation = await prisma.cancellation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CancellationUpdateManyArgs>(args: SelectSubset<T, CancellationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cancellations and returns the data updated in the database.
     * @param {CancellationUpdateManyAndReturnArgs} args - Arguments to update many Cancellations.
     * @example
     * // Update many Cancellations
     * const cancellation = await prisma.cancellation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Cancellations and only return the `id`
     * const cancellationWithIdOnly = await prisma.cancellation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CancellationUpdateManyAndReturnArgs>(args: SelectSubset<T, CancellationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CancellationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Cancellation.
     * @param {CancellationUpsertArgs} args - Arguments to update or create a Cancellation.
     * @example
     * // Update or create a Cancellation
     * const cancellation = await prisma.cancellation.upsert({
     *   create: {
     *     // ... data to create a Cancellation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cancellation we want to update
     *   }
     * })
     */
    upsert<T extends CancellationUpsertArgs>(args: SelectSubset<T, CancellationUpsertArgs<ExtArgs>>): Prisma__CancellationClient<$Result.GetResult<Prisma.$CancellationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Cancellations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CancellationCountArgs} args - Arguments to filter Cancellations to count.
     * @example
     * // Count the number of Cancellations
     * const count = await prisma.cancellation.count({
     *   where: {
     *     // ... the filter for the Cancellations we want to count
     *   }
     * })
    **/
    count<T extends CancellationCountArgs>(
      args?: Subset<T, CancellationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CancellationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cancellation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CancellationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CancellationAggregateArgs>(args: Subset<T, CancellationAggregateArgs>): Prisma.PrismaPromise<GetCancellationAggregateType<T>>

    /**
     * Group by Cancellation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CancellationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CancellationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CancellationGroupByArgs['orderBy'] }
        : { orderBy?: CancellationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CancellationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCancellationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Cancellation model
   */
  readonly fields: CancellationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Cancellation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CancellationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    originalBooking<T extends BookingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BookingDefaultArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    generatedCreditNote<T extends Cancellation$generatedCreditNoteArgs<ExtArgs> = {}>(args?: Subset<T, Cancellation$generatedCreditNoteArgs<ExtArgs>>): Prisma__SupplierCreditNoteClient<$Result.GetResult<Prisma.$SupplierCreditNotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Cancellation model
   */
  interface CancellationFieldRefs {
    readonly id: FieldRef<"Cancellation", 'Int'>
    readonly originalBookingId: FieldRef<"Cancellation", 'Int'>
    readonly folderNo: FieldRef<"Cancellation", 'String'>
    readonly refundTransactionMethod: FieldRef<"Cancellation", 'String'>
    readonly originalRevenue: FieldRef<"Cancellation", 'Float'>
    readonly originalProdCost: FieldRef<"Cancellation", 'Float'>
    readonly supplierCancellationFee: FieldRef<"Cancellation", 'Float'>
    readonly refundToPassenger: FieldRef<"Cancellation", 'Float'>
    readonly creditNoteAmount: FieldRef<"Cancellation", 'Float'>
    readonly profitOrLoss: FieldRef<"Cancellation", 'Float'>
    readonly description: FieldRef<"Cancellation", 'String'>
    readonly createdAt: FieldRef<"Cancellation", 'DateTime'>
    readonly updatedAt: FieldRef<"Cancellation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Cancellation findUnique
   */
  export type CancellationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cancellation
     */
    select?: CancellationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cancellation
     */
    omit?: CancellationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CancellationInclude<ExtArgs> | null
    /**
     * Filter, which Cancellation to fetch.
     */
    where: CancellationWhereUniqueInput
  }

  /**
   * Cancellation findUniqueOrThrow
   */
  export type CancellationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cancellation
     */
    select?: CancellationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cancellation
     */
    omit?: CancellationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CancellationInclude<ExtArgs> | null
    /**
     * Filter, which Cancellation to fetch.
     */
    where: CancellationWhereUniqueInput
  }

  /**
   * Cancellation findFirst
   */
  export type CancellationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cancellation
     */
    select?: CancellationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cancellation
     */
    omit?: CancellationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CancellationInclude<ExtArgs> | null
    /**
     * Filter, which Cancellation to fetch.
     */
    where?: CancellationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cancellations to fetch.
     */
    orderBy?: CancellationOrderByWithRelationInput | CancellationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cancellations.
     */
    cursor?: CancellationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cancellations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cancellations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cancellations.
     */
    distinct?: CancellationScalarFieldEnum | CancellationScalarFieldEnum[]
  }

  /**
   * Cancellation findFirstOrThrow
   */
  export type CancellationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cancellation
     */
    select?: CancellationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cancellation
     */
    omit?: CancellationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CancellationInclude<ExtArgs> | null
    /**
     * Filter, which Cancellation to fetch.
     */
    where?: CancellationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cancellations to fetch.
     */
    orderBy?: CancellationOrderByWithRelationInput | CancellationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cancellations.
     */
    cursor?: CancellationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cancellations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cancellations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cancellations.
     */
    distinct?: CancellationScalarFieldEnum | CancellationScalarFieldEnum[]
  }

  /**
   * Cancellation findMany
   */
  export type CancellationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cancellation
     */
    select?: CancellationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cancellation
     */
    omit?: CancellationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CancellationInclude<ExtArgs> | null
    /**
     * Filter, which Cancellations to fetch.
     */
    where?: CancellationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cancellations to fetch.
     */
    orderBy?: CancellationOrderByWithRelationInput | CancellationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Cancellations.
     */
    cursor?: CancellationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cancellations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cancellations.
     */
    skip?: number
    distinct?: CancellationScalarFieldEnum | CancellationScalarFieldEnum[]
  }

  /**
   * Cancellation create
   */
  export type CancellationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cancellation
     */
    select?: CancellationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cancellation
     */
    omit?: CancellationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CancellationInclude<ExtArgs> | null
    /**
     * The data needed to create a Cancellation.
     */
    data: XOR<CancellationCreateInput, CancellationUncheckedCreateInput>
  }

  /**
   * Cancellation createMany
   */
  export type CancellationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Cancellations.
     */
    data: CancellationCreateManyInput | CancellationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Cancellation createManyAndReturn
   */
  export type CancellationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cancellation
     */
    select?: CancellationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Cancellation
     */
    omit?: CancellationOmit<ExtArgs> | null
    /**
     * The data used to create many Cancellations.
     */
    data: CancellationCreateManyInput | CancellationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CancellationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Cancellation update
   */
  export type CancellationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cancellation
     */
    select?: CancellationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cancellation
     */
    omit?: CancellationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CancellationInclude<ExtArgs> | null
    /**
     * The data needed to update a Cancellation.
     */
    data: XOR<CancellationUpdateInput, CancellationUncheckedUpdateInput>
    /**
     * Choose, which Cancellation to update.
     */
    where: CancellationWhereUniqueInput
  }

  /**
   * Cancellation updateMany
   */
  export type CancellationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Cancellations.
     */
    data: XOR<CancellationUpdateManyMutationInput, CancellationUncheckedUpdateManyInput>
    /**
     * Filter which Cancellations to update
     */
    where?: CancellationWhereInput
    /**
     * Limit how many Cancellations to update.
     */
    limit?: number
  }

  /**
   * Cancellation updateManyAndReturn
   */
  export type CancellationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cancellation
     */
    select?: CancellationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Cancellation
     */
    omit?: CancellationOmit<ExtArgs> | null
    /**
     * The data used to update Cancellations.
     */
    data: XOR<CancellationUpdateManyMutationInput, CancellationUncheckedUpdateManyInput>
    /**
     * Filter which Cancellations to update
     */
    where?: CancellationWhereInput
    /**
     * Limit how many Cancellations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CancellationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Cancellation upsert
   */
  export type CancellationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cancellation
     */
    select?: CancellationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cancellation
     */
    omit?: CancellationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CancellationInclude<ExtArgs> | null
    /**
     * The filter to search for the Cancellation to update in case it exists.
     */
    where: CancellationWhereUniqueInput
    /**
     * In case the Cancellation found by the `where` argument doesn't exist, create a new Cancellation with this data.
     */
    create: XOR<CancellationCreateInput, CancellationUncheckedCreateInput>
    /**
     * In case the Cancellation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CancellationUpdateInput, CancellationUncheckedUpdateInput>
  }

  /**
   * Cancellation delete
   */
  export type CancellationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cancellation
     */
    select?: CancellationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cancellation
     */
    omit?: CancellationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CancellationInclude<ExtArgs> | null
    /**
     * Filter which Cancellation to delete.
     */
    where: CancellationWhereUniqueInput
  }

  /**
   * Cancellation deleteMany
   */
  export type CancellationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cancellations to delete
     */
    where?: CancellationWhereInput
    /**
     * Limit how many Cancellations to delete.
     */
    limit?: number
  }

  /**
   * Cancellation.generatedCreditNote
   */
  export type Cancellation$generatedCreditNoteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierCreditNote
     */
    select?: SupplierCreditNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierCreditNote
     */
    omit?: SupplierCreditNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierCreditNoteInclude<ExtArgs> | null
    where?: SupplierCreditNoteWhereInput
  }

  /**
   * Cancellation without action
   */
  export type CancellationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cancellation
     */
    select?: CancellationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cancellation
     */
    omit?: CancellationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CancellationInclude<ExtArgs> | null
  }


  /**
   * Model SupplierCreditNote
   */

  export type AggregateSupplierCreditNote = {
    _count: SupplierCreditNoteCountAggregateOutputType | null
    _avg: SupplierCreditNoteAvgAggregateOutputType | null
    _sum: SupplierCreditNoteSumAggregateOutputType | null
    _min: SupplierCreditNoteMinAggregateOutputType | null
    _max: SupplierCreditNoteMaxAggregateOutputType | null
  }

  export type SupplierCreditNoteAvgAggregateOutputType = {
    id: number | null
    initialAmount: number | null
    remainingAmount: number | null
    generatedFromCancellationId: number | null
  }

  export type SupplierCreditNoteSumAggregateOutputType = {
    id: number | null
    initialAmount: number | null
    remainingAmount: number | null
    generatedFromCancellationId: number | null
  }

  export type SupplierCreditNoteMinAggregateOutputType = {
    id: number | null
    supplier: $Enums.Suppliers | null
    initialAmount: number | null
    remainingAmount: number | null
    status: $Enums.CreditNoteStatus | null
    generatedFromCancellationId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SupplierCreditNoteMaxAggregateOutputType = {
    id: number | null
    supplier: $Enums.Suppliers | null
    initialAmount: number | null
    remainingAmount: number | null
    status: $Enums.CreditNoteStatus | null
    generatedFromCancellationId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SupplierCreditNoteCountAggregateOutputType = {
    id: number
    supplier: number
    initialAmount: number
    remainingAmount: number
    status: number
    generatedFromCancellationId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SupplierCreditNoteAvgAggregateInputType = {
    id?: true
    initialAmount?: true
    remainingAmount?: true
    generatedFromCancellationId?: true
  }

  export type SupplierCreditNoteSumAggregateInputType = {
    id?: true
    initialAmount?: true
    remainingAmount?: true
    generatedFromCancellationId?: true
  }

  export type SupplierCreditNoteMinAggregateInputType = {
    id?: true
    supplier?: true
    initialAmount?: true
    remainingAmount?: true
    status?: true
    generatedFromCancellationId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SupplierCreditNoteMaxAggregateInputType = {
    id?: true
    supplier?: true
    initialAmount?: true
    remainingAmount?: true
    status?: true
    generatedFromCancellationId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SupplierCreditNoteCountAggregateInputType = {
    id?: true
    supplier?: true
    initialAmount?: true
    remainingAmount?: true
    status?: true
    generatedFromCancellationId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SupplierCreditNoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SupplierCreditNote to aggregate.
     */
    where?: SupplierCreditNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupplierCreditNotes to fetch.
     */
    orderBy?: SupplierCreditNoteOrderByWithRelationInput | SupplierCreditNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SupplierCreditNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupplierCreditNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupplierCreditNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SupplierCreditNotes
    **/
    _count?: true | SupplierCreditNoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SupplierCreditNoteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SupplierCreditNoteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SupplierCreditNoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SupplierCreditNoteMaxAggregateInputType
  }

  export type GetSupplierCreditNoteAggregateType<T extends SupplierCreditNoteAggregateArgs> = {
        [P in keyof T & keyof AggregateSupplierCreditNote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupplierCreditNote[P]>
      : GetScalarType<T[P], AggregateSupplierCreditNote[P]>
  }




  export type SupplierCreditNoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplierCreditNoteWhereInput
    orderBy?: SupplierCreditNoteOrderByWithAggregationInput | SupplierCreditNoteOrderByWithAggregationInput[]
    by: SupplierCreditNoteScalarFieldEnum[] | SupplierCreditNoteScalarFieldEnum
    having?: SupplierCreditNoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SupplierCreditNoteCountAggregateInputType | true
    _avg?: SupplierCreditNoteAvgAggregateInputType
    _sum?: SupplierCreditNoteSumAggregateInputType
    _min?: SupplierCreditNoteMinAggregateInputType
    _max?: SupplierCreditNoteMaxAggregateInputType
  }

  export type SupplierCreditNoteGroupByOutputType = {
    id: number
    supplier: $Enums.Suppliers
    initialAmount: number
    remainingAmount: number
    status: $Enums.CreditNoteStatus
    generatedFromCancellationId: number
    createdAt: Date
    updatedAt: Date
    _count: SupplierCreditNoteCountAggregateOutputType | null
    _avg: SupplierCreditNoteAvgAggregateOutputType | null
    _sum: SupplierCreditNoteSumAggregateOutputType | null
    _min: SupplierCreditNoteMinAggregateOutputType | null
    _max: SupplierCreditNoteMaxAggregateOutputType | null
  }

  type GetSupplierCreditNoteGroupByPayload<T extends SupplierCreditNoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SupplierCreditNoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SupplierCreditNoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SupplierCreditNoteGroupByOutputType[P]>
            : GetScalarType<T[P], SupplierCreditNoteGroupByOutputType[P]>
        }
      >
    >


  export type SupplierCreditNoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    supplier?: boolean
    initialAmount?: boolean
    remainingAmount?: boolean
    status?: boolean
    generatedFromCancellationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    generatedFromCancellation?: boolean | CancellationDefaultArgs<ExtArgs>
    usageHistory?: boolean | SupplierCreditNote$usageHistoryArgs<ExtArgs>
    _count?: boolean | SupplierCreditNoteCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplierCreditNote"]>

  export type SupplierCreditNoteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    supplier?: boolean
    initialAmount?: boolean
    remainingAmount?: boolean
    status?: boolean
    generatedFromCancellationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    generatedFromCancellation?: boolean | CancellationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplierCreditNote"]>

  export type SupplierCreditNoteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    supplier?: boolean
    initialAmount?: boolean
    remainingAmount?: boolean
    status?: boolean
    generatedFromCancellationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    generatedFromCancellation?: boolean | CancellationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplierCreditNote"]>

  export type SupplierCreditNoteSelectScalar = {
    id?: boolean
    supplier?: boolean
    initialAmount?: boolean
    remainingAmount?: boolean
    status?: boolean
    generatedFromCancellationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SupplierCreditNoteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "supplier" | "initialAmount" | "remainingAmount" | "status" | "generatedFromCancellationId" | "createdAt" | "updatedAt", ExtArgs["result"]["supplierCreditNote"]>
  export type SupplierCreditNoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    generatedFromCancellation?: boolean | CancellationDefaultArgs<ExtArgs>
    usageHistory?: boolean | SupplierCreditNote$usageHistoryArgs<ExtArgs>
    _count?: boolean | SupplierCreditNoteCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SupplierCreditNoteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    generatedFromCancellation?: boolean | CancellationDefaultArgs<ExtArgs>
  }
  export type SupplierCreditNoteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    generatedFromCancellation?: boolean | CancellationDefaultArgs<ExtArgs>
  }

  export type $SupplierCreditNotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SupplierCreditNote"
    objects: {
      generatedFromCancellation: Prisma.$CancellationPayload<ExtArgs>
      usageHistory: Prisma.$CreditNoteUsagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      supplier: $Enums.Suppliers
      initialAmount: number
      remainingAmount: number
      status: $Enums.CreditNoteStatus
      generatedFromCancellationId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["supplierCreditNote"]>
    composites: {}
  }

  type SupplierCreditNoteGetPayload<S extends boolean | null | undefined | SupplierCreditNoteDefaultArgs> = $Result.GetResult<Prisma.$SupplierCreditNotePayload, S>

  type SupplierCreditNoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SupplierCreditNoteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SupplierCreditNoteCountAggregateInputType | true
    }

  export interface SupplierCreditNoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SupplierCreditNote'], meta: { name: 'SupplierCreditNote' } }
    /**
     * Find zero or one SupplierCreditNote that matches the filter.
     * @param {SupplierCreditNoteFindUniqueArgs} args - Arguments to find a SupplierCreditNote
     * @example
     * // Get one SupplierCreditNote
     * const supplierCreditNote = await prisma.supplierCreditNote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SupplierCreditNoteFindUniqueArgs>(args: SelectSubset<T, SupplierCreditNoteFindUniqueArgs<ExtArgs>>): Prisma__SupplierCreditNoteClient<$Result.GetResult<Prisma.$SupplierCreditNotePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SupplierCreditNote that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SupplierCreditNoteFindUniqueOrThrowArgs} args - Arguments to find a SupplierCreditNote
     * @example
     * // Get one SupplierCreditNote
     * const supplierCreditNote = await prisma.supplierCreditNote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SupplierCreditNoteFindUniqueOrThrowArgs>(args: SelectSubset<T, SupplierCreditNoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SupplierCreditNoteClient<$Result.GetResult<Prisma.$SupplierCreditNotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SupplierCreditNote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierCreditNoteFindFirstArgs} args - Arguments to find a SupplierCreditNote
     * @example
     * // Get one SupplierCreditNote
     * const supplierCreditNote = await prisma.supplierCreditNote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SupplierCreditNoteFindFirstArgs>(args?: SelectSubset<T, SupplierCreditNoteFindFirstArgs<ExtArgs>>): Prisma__SupplierCreditNoteClient<$Result.GetResult<Prisma.$SupplierCreditNotePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SupplierCreditNote that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierCreditNoteFindFirstOrThrowArgs} args - Arguments to find a SupplierCreditNote
     * @example
     * // Get one SupplierCreditNote
     * const supplierCreditNote = await prisma.supplierCreditNote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SupplierCreditNoteFindFirstOrThrowArgs>(args?: SelectSubset<T, SupplierCreditNoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__SupplierCreditNoteClient<$Result.GetResult<Prisma.$SupplierCreditNotePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SupplierCreditNotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierCreditNoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SupplierCreditNotes
     * const supplierCreditNotes = await prisma.supplierCreditNote.findMany()
     * 
     * // Get first 10 SupplierCreditNotes
     * const supplierCreditNotes = await prisma.supplierCreditNote.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const supplierCreditNoteWithIdOnly = await prisma.supplierCreditNote.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SupplierCreditNoteFindManyArgs>(args?: SelectSubset<T, SupplierCreditNoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierCreditNotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SupplierCreditNote.
     * @param {SupplierCreditNoteCreateArgs} args - Arguments to create a SupplierCreditNote.
     * @example
     * // Create one SupplierCreditNote
     * const SupplierCreditNote = await prisma.supplierCreditNote.create({
     *   data: {
     *     // ... data to create a SupplierCreditNote
     *   }
     * })
     * 
     */
    create<T extends SupplierCreditNoteCreateArgs>(args: SelectSubset<T, SupplierCreditNoteCreateArgs<ExtArgs>>): Prisma__SupplierCreditNoteClient<$Result.GetResult<Prisma.$SupplierCreditNotePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SupplierCreditNotes.
     * @param {SupplierCreditNoteCreateManyArgs} args - Arguments to create many SupplierCreditNotes.
     * @example
     * // Create many SupplierCreditNotes
     * const supplierCreditNote = await prisma.supplierCreditNote.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SupplierCreditNoteCreateManyArgs>(args?: SelectSubset<T, SupplierCreditNoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SupplierCreditNotes and returns the data saved in the database.
     * @param {SupplierCreditNoteCreateManyAndReturnArgs} args - Arguments to create many SupplierCreditNotes.
     * @example
     * // Create many SupplierCreditNotes
     * const supplierCreditNote = await prisma.supplierCreditNote.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SupplierCreditNotes and only return the `id`
     * const supplierCreditNoteWithIdOnly = await prisma.supplierCreditNote.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SupplierCreditNoteCreateManyAndReturnArgs>(args?: SelectSubset<T, SupplierCreditNoteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierCreditNotePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SupplierCreditNote.
     * @param {SupplierCreditNoteDeleteArgs} args - Arguments to delete one SupplierCreditNote.
     * @example
     * // Delete one SupplierCreditNote
     * const SupplierCreditNote = await prisma.supplierCreditNote.delete({
     *   where: {
     *     // ... filter to delete one SupplierCreditNote
     *   }
     * })
     * 
     */
    delete<T extends SupplierCreditNoteDeleteArgs>(args: SelectSubset<T, SupplierCreditNoteDeleteArgs<ExtArgs>>): Prisma__SupplierCreditNoteClient<$Result.GetResult<Prisma.$SupplierCreditNotePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SupplierCreditNote.
     * @param {SupplierCreditNoteUpdateArgs} args - Arguments to update one SupplierCreditNote.
     * @example
     * // Update one SupplierCreditNote
     * const supplierCreditNote = await prisma.supplierCreditNote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SupplierCreditNoteUpdateArgs>(args: SelectSubset<T, SupplierCreditNoteUpdateArgs<ExtArgs>>): Prisma__SupplierCreditNoteClient<$Result.GetResult<Prisma.$SupplierCreditNotePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SupplierCreditNotes.
     * @param {SupplierCreditNoteDeleteManyArgs} args - Arguments to filter SupplierCreditNotes to delete.
     * @example
     * // Delete a few SupplierCreditNotes
     * const { count } = await prisma.supplierCreditNote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SupplierCreditNoteDeleteManyArgs>(args?: SelectSubset<T, SupplierCreditNoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SupplierCreditNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierCreditNoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SupplierCreditNotes
     * const supplierCreditNote = await prisma.supplierCreditNote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SupplierCreditNoteUpdateManyArgs>(args: SelectSubset<T, SupplierCreditNoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SupplierCreditNotes and returns the data updated in the database.
     * @param {SupplierCreditNoteUpdateManyAndReturnArgs} args - Arguments to update many SupplierCreditNotes.
     * @example
     * // Update many SupplierCreditNotes
     * const supplierCreditNote = await prisma.supplierCreditNote.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SupplierCreditNotes and only return the `id`
     * const supplierCreditNoteWithIdOnly = await prisma.supplierCreditNote.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SupplierCreditNoteUpdateManyAndReturnArgs>(args: SelectSubset<T, SupplierCreditNoteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierCreditNotePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SupplierCreditNote.
     * @param {SupplierCreditNoteUpsertArgs} args - Arguments to update or create a SupplierCreditNote.
     * @example
     * // Update or create a SupplierCreditNote
     * const supplierCreditNote = await prisma.supplierCreditNote.upsert({
     *   create: {
     *     // ... data to create a SupplierCreditNote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SupplierCreditNote we want to update
     *   }
     * })
     */
    upsert<T extends SupplierCreditNoteUpsertArgs>(args: SelectSubset<T, SupplierCreditNoteUpsertArgs<ExtArgs>>): Prisma__SupplierCreditNoteClient<$Result.GetResult<Prisma.$SupplierCreditNotePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SupplierCreditNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierCreditNoteCountArgs} args - Arguments to filter SupplierCreditNotes to count.
     * @example
     * // Count the number of SupplierCreditNotes
     * const count = await prisma.supplierCreditNote.count({
     *   where: {
     *     // ... the filter for the SupplierCreditNotes we want to count
     *   }
     * })
    **/
    count<T extends SupplierCreditNoteCountArgs>(
      args?: Subset<T, SupplierCreditNoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupplierCreditNoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SupplierCreditNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierCreditNoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SupplierCreditNoteAggregateArgs>(args: Subset<T, SupplierCreditNoteAggregateArgs>): Prisma.PrismaPromise<GetSupplierCreditNoteAggregateType<T>>

    /**
     * Group by SupplierCreditNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierCreditNoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SupplierCreditNoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SupplierCreditNoteGroupByArgs['orderBy'] }
        : { orderBy?: SupplierCreditNoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SupplierCreditNoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupplierCreditNoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SupplierCreditNote model
   */
  readonly fields: SupplierCreditNoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SupplierCreditNote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SupplierCreditNoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    generatedFromCancellation<T extends CancellationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CancellationDefaultArgs<ExtArgs>>): Prisma__CancellationClient<$Result.GetResult<Prisma.$CancellationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    usageHistory<T extends SupplierCreditNote$usageHistoryArgs<ExtArgs> = {}>(args?: Subset<T, SupplierCreditNote$usageHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditNoteUsagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SupplierCreditNote model
   */
  interface SupplierCreditNoteFieldRefs {
    readonly id: FieldRef<"SupplierCreditNote", 'Int'>
    readonly supplier: FieldRef<"SupplierCreditNote", 'Suppliers'>
    readonly initialAmount: FieldRef<"SupplierCreditNote", 'Float'>
    readonly remainingAmount: FieldRef<"SupplierCreditNote", 'Float'>
    readonly status: FieldRef<"SupplierCreditNote", 'CreditNoteStatus'>
    readonly generatedFromCancellationId: FieldRef<"SupplierCreditNote", 'Int'>
    readonly createdAt: FieldRef<"SupplierCreditNote", 'DateTime'>
    readonly updatedAt: FieldRef<"SupplierCreditNote", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SupplierCreditNote findUnique
   */
  export type SupplierCreditNoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierCreditNote
     */
    select?: SupplierCreditNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierCreditNote
     */
    omit?: SupplierCreditNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierCreditNoteInclude<ExtArgs> | null
    /**
     * Filter, which SupplierCreditNote to fetch.
     */
    where: SupplierCreditNoteWhereUniqueInput
  }

  /**
   * SupplierCreditNote findUniqueOrThrow
   */
  export type SupplierCreditNoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierCreditNote
     */
    select?: SupplierCreditNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierCreditNote
     */
    omit?: SupplierCreditNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierCreditNoteInclude<ExtArgs> | null
    /**
     * Filter, which SupplierCreditNote to fetch.
     */
    where: SupplierCreditNoteWhereUniqueInput
  }

  /**
   * SupplierCreditNote findFirst
   */
  export type SupplierCreditNoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierCreditNote
     */
    select?: SupplierCreditNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierCreditNote
     */
    omit?: SupplierCreditNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierCreditNoteInclude<ExtArgs> | null
    /**
     * Filter, which SupplierCreditNote to fetch.
     */
    where?: SupplierCreditNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupplierCreditNotes to fetch.
     */
    orderBy?: SupplierCreditNoteOrderByWithRelationInput | SupplierCreditNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SupplierCreditNotes.
     */
    cursor?: SupplierCreditNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupplierCreditNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupplierCreditNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SupplierCreditNotes.
     */
    distinct?: SupplierCreditNoteScalarFieldEnum | SupplierCreditNoteScalarFieldEnum[]
  }

  /**
   * SupplierCreditNote findFirstOrThrow
   */
  export type SupplierCreditNoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierCreditNote
     */
    select?: SupplierCreditNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierCreditNote
     */
    omit?: SupplierCreditNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierCreditNoteInclude<ExtArgs> | null
    /**
     * Filter, which SupplierCreditNote to fetch.
     */
    where?: SupplierCreditNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupplierCreditNotes to fetch.
     */
    orderBy?: SupplierCreditNoteOrderByWithRelationInput | SupplierCreditNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SupplierCreditNotes.
     */
    cursor?: SupplierCreditNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupplierCreditNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupplierCreditNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SupplierCreditNotes.
     */
    distinct?: SupplierCreditNoteScalarFieldEnum | SupplierCreditNoteScalarFieldEnum[]
  }

  /**
   * SupplierCreditNote findMany
   */
  export type SupplierCreditNoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierCreditNote
     */
    select?: SupplierCreditNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierCreditNote
     */
    omit?: SupplierCreditNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierCreditNoteInclude<ExtArgs> | null
    /**
     * Filter, which SupplierCreditNotes to fetch.
     */
    where?: SupplierCreditNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupplierCreditNotes to fetch.
     */
    orderBy?: SupplierCreditNoteOrderByWithRelationInput | SupplierCreditNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SupplierCreditNotes.
     */
    cursor?: SupplierCreditNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupplierCreditNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupplierCreditNotes.
     */
    skip?: number
    distinct?: SupplierCreditNoteScalarFieldEnum | SupplierCreditNoteScalarFieldEnum[]
  }

  /**
   * SupplierCreditNote create
   */
  export type SupplierCreditNoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierCreditNote
     */
    select?: SupplierCreditNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierCreditNote
     */
    omit?: SupplierCreditNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierCreditNoteInclude<ExtArgs> | null
    /**
     * The data needed to create a SupplierCreditNote.
     */
    data: XOR<SupplierCreditNoteCreateInput, SupplierCreditNoteUncheckedCreateInput>
  }

  /**
   * SupplierCreditNote createMany
   */
  export type SupplierCreditNoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SupplierCreditNotes.
     */
    data: SupplierCreditNoteCreateManyInput | SupplierCreditNoteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SupplierCreditNote createManyAndReturn
   */
  export type SupplierCreditNoteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierCreditNote
     */
    select?: SupplierCreditNoteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierCreditNote
     */
    omit?: SupplierCreditNoteOmit<ExtArgs> | null
    /**
     * The data used to create many SupplierCreditNotes.
     */
    data: SupplierCreditNoteCreateManyInput | SupplierCreditNoteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierCreditNoteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SupplierCreditNote update
   */
  export type SupplierCreditNoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierCreditNote
     */
    select?: SupplierCreditNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierCreditNote
     */
    omit?: SupplierCreditNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierCreditNoteInclude<ExtArgs> | null
    /**
     * The data needed to update a SupplierCreditNote.
     */
    data: XOR<SupplierCreditNoteUpdateInput, SupplierCreditNoteUncheckedUpdateInput>
    /**
     * Choose, which SupplierCreditNote to update.
     */
    where: SupplierCreditNoteWhereUniqueInput
  }

  /**
   * SupplierCreditNote updateMany
   */
  export type SupplierCreditNoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SupplierCreditNotes.
     */
    data: XOR<SupplierCreditNoteUpdateManyMutationInput, SupplierCreditNoteUncheckedUpdateManyInput>
    /**
     * Filter which SupplierCreditNotes to update
     */
    where?: SupplierCreditNoteWhereInput
    /**
     * Limit how many SupplierCreditNotes to update.
     */
    limit?: number
  }

  /**
   * SupplierCreditNote updateManyAndReturn
   */
  export type SupplierCreditNoteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierCreditNote
     */
    select?: SupplierCreditNoteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierCreditNote
     */
    omit?: SupplierCreditNoteOmit<ExtArgs> | null
    /**
     * The data used to update SupplierCreditNotes.
     */
    data: XOR<SupplierCreditNoteUpdateManyMutationInput, SupplierCreditNoteUncheckedUpdateManyInput>
    /**
     * Filter which SupplierCreditNotes to update
     */
    where?: SupplierCreditNoteWhereInput
    /**
     * Limit how many SupplierCreditNotes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierCreditNoteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SupplierCreditNote upsert
   */
  export type SupplierCreditNoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierCreditNote
     */
    select?: SupplierCreditNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierCreditNote
     */
    omit?: SupplierCreditNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierCreditNoteInclude<ExtArgs> | null
    /**
     * The filter to search for the SupplierCreditNote to update in case it exists.
     */
    where: SupplierCreditNoteWhereUniqueInput
    /**
     * In case the SupplierCreditNote found by the `where` argument doesn't exist, create a new SupplierCreditNote with this data.
     */
    create: XOR<SupplierCreditNoteCreateInput, SupplierCreditNoteUncheckedCreateInput>
    /**
     * In case the SupplierCreditNote was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SupplierCreditNoteUpdateInput, SupplierCreditNoteUncheckedUpdateInput>
  }

  /**
   * SupplierCreditNote delete
   */
  export type SupplierCreditNoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierCreditNote
     */
    select?: SupplierCreditNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierCreditNote
     */
    omit?: SupplierCreditNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierCreditNoteInclude<ExtArgs> | null
    /**
     * Filter which SupplierCreditNote to delete.
     */
    where: SupplierCreditNoteWhereUniqueInput
  }

  /**
   * SupplierCreditNote deleteMany
   */
  export type SupplierCreditNoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SupplierCreditNotes to delete
     */
    where?: SupplierCreditNoteWhereInput
    /**
     * Limit how many SupplierCreditNotes to delete.
     */
    limit?: number
  }

  /**
   * SupplierCreditNote.usageHistory
   */
  export type SupplierCreditNote$usageHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditNoteUsage
     */
    select?: CreditNoteUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditNoteUsage
     */
    omit?: CreditNoteUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditNoteUsageInclude<ExtArgs> | null
    where?: CreditNoteUsageWhereInput
    orderBy?: CreditNoteUsageOrderByWithRelationInput | CreditNoteUsageOrderByWithRelationInput[]
    cursor?: CreditNoteUsageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CreditNoteUsageScalarFieldEnum | CreditNoteUsageScalarFieldEnum[]
  }

  /**
   * SupplierCreditNote without action
   */
  export type SupplierCreditNoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierCreditNote
     */
    select?: SupplierCreditNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierCreditNote
     */
    omit?: SupplierCreditNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierCreditNoteInclude<ExtArgs> | null
  }


  /**
   * Model CreditNoteUsage
   */

  export type AggregateCreditNoteUsage = {
    _count: CreditNoteUsageCountAggregateOutputType | null
    _avg: CreditNoteUsageAvgAggregateOutputType | null
    _sum: CreditNoteUsageSumAggregateOutputType | null
    _min: CreditNoteUsageMinAggregateOutputType | null
    _max: CreditNoteUsageMaxAggregateOutputType | null
  }

  export type CreditNoteUsageAvgAggregateOutputType = {
    id: number | null
    amountUsed: number | null
    creditNoteId: number | null
    usedOnCostItemSupplierId: number | null
  }

  export type CreditNoteUsageSumAggregateOutputType = {
    id: number | null
    amountUsed: number | null
    creditNoteId: number | null
    usedOnCostItemSupplierId: number | null
  }

  export type CreditNoteUsageMinAggregateOutputType = {
    id: number | null
    amountUsed: number | null
    usedAt: Date | null
    creditNoteId: number | null
    usedOnCostItemSupplierId: number | null
  }

  export type CreditNoteUsageMaxAggregateOutputType = {
    id: number | null
    amountUsed: number | null
    usedAt: Date | null
    creditNoteId: number | null
    usedOnCostItemSupplierId: number | null
  }

  export type CreditNoteUsageCountAggregateOutputType = {
    id: number
    amountUsed: number
    usedAt: number
    creditNoteId: number
    usedOnCostItemSupplierId: number
    _all: number
  }


  export type CreditNoteUsageAvgAggregateInputType = {
    id?: true
    amountUsed?: true
    creditNoteId?: true
    usedOnCostItemSupplierId?: true
  }

  export type CreditNoteUsageSumAggregateInputType = {
    id?: true
    amountUsed?: true
    creditNoteId?: true
    usedOnCostItemSupplierId?: true
  }

  export type CreditNoteUsageMinAggregateInputType = {
    id?: true
    amountUsed?: true
    usedAt?: true
    creditNoteId?: true
    usedOnCostItemSupplierId?: true
  }

  export type CreditNoteUsageMaxAggregateInputType = {
    id?: true
    amountUsed?: true
    usedAt?: true
    creditNoteId?: true
    usedOnCostItemSupplierId?: true
  }

  export type CreditNoteUsageCountAggregateInputType = {
    id?: true
    amountUsed?: true
    usedAt?: true
    creditNoteId?: true
    usedOnCostItemSupplierId?: true
    _all?: true
  }

  export type CreditNoteUsageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CreditNoteUsage to aggregate.
     */
    where?: CreditNoteUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditNoteUsages to fetch.
     */
    orderBy?: CreditNoteUsageOrderByWithRelationInput | CreditNoteUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CreditNoteUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditNoteUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditNoteUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CreditNoteUsages
    **/
    _count?: true | CreditNoteUsageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CreditNoteUsageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CreditNoteUsageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CreditNoteUsageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CreditNoteUsageMaxAggregateInputType
  }

  export type GetCreditNoteUsageAggregateType<T extends CreditNoteUsageAggregateArgs> = {
        [P in keyof T & keyof AggregateCreditNoteUsage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCreditNoteUsage[P]>
      : GetScalarType<T[P], AggregateCreditNoteUsage[P]>
  }




  export type CreditNoteUsageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreditNoteUsageWhereInput
    orderBy?: CreditNoteUsageOrderByWithAggregationInput | CreditNoteUsageOrderByWithAggregationInput[]
    by: CreditNoteUsageScalarFieldEnum[] | CreditNoteUsageScalarFieldEnum
    having?: CreditNoteUsageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CreditNoteUsageCountAggregateInputType | true
    _avg?: CreditNoteUsageAvgAggregateInputType
    _sum?: CreditNoteUsageSumAggregateInputType
    _min?: CreditNoteUsageMinAggregateInputType
    _max?: CreditNoteUsageMaxAggregateInputType
  }

  export type CreditNoteUsageGroupByOutputType = {
    id: number
    amountUsed: number
    usedAt: Date
    creditNoteId: number
    usedOnCostItemSupplierId: number
    _count: CreditNoteUsageCountAggregateOutputType | null
    _avg: CreditNoteUsageAvgAggregateOutputType | null
    _sum: CreditNoteUsageSumAggregateOutputType | null
    _min: CreditNoteUsageMinAggregateOutputType | null
    _max: CreditNoteUsageMaxAggregateOutputType | null
  }

  type GetCreditNoteUsageGroupByPayload<T extends CreditNoteUsageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CreditNoteUsageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CreditNoteUsageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CreditNoteUsageGroupByOutputType[P]>
            : GetScalarType<T[P], CreditNoteUsageGroupByOutputType[P]>
        }
      >
    >


  export type CreditNoteUsageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amountUsed?: boolean
    usedAt?: boolean
    creditNoteId?: boolean
    usedOnCostItemSupplierId?: boolean
    creditNote?: boolean | SupplierCreditNoteDefaultArgs<ExtArgs>
    usedOnCostItemSupplier?: boolean | CostItemSupplierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creditNoteUsage"]>

  export type CreditNoteUsageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amountUsed?: boolean
    usedAt?: boolean
    creditNoteId?: boolean
    usedOnCostItemSupplierId?: boolean
    creditNote?: boolean | SupplierCreditNoteDefaultArgs<ExtArgs>
    usedOnCostItemSupplier?: boolean | CostItemSupplierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creditNoteUsage"]>

  export type CreditNoteUsageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amountUsed?: boolean
    usedAt?: boolean
    creditNoteId?: boolean
    usedOnCostItemSupplierId?: boolean
    creditNote?: boolean | SupplierCreditNoteDefaultArgs<ExtArgs>
    usedOnCostItemSupplier?: boolean | CostItemSupplierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creditNoteUsage"]>

  export type CreditNoteUsageSelectScalar = {
    id?: boolean
    amountUsed?: boolean
    usedAt?: boolean
    creditNoteId?: boolean
    usedOnCostItemSupplierId?: boolean
  }

  export type CreditNoteUsageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "amountUsed" | "usedAt" | "creditNoteId" | "usedOnCostItemSupplierId", ExtArgs["result"]["creditNoteUsage"]>
  export type CreditNoteUsageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creditNote?: boolean | SupplierCreditNoteDefaultArgs<ExtArgs>
    usedOnCostItemSupplier?: boolean | CostItemSupplierDefaultArgs<ExtArgs>
  }
  export type CreditNoteUsageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creditNote?: boolean | SupplierCreditNoteDefaultArgs<ExtArgs>
    usedOnCostItemSupplier?: boolean | CostItemSupplierDefaultArgs<ExtArgs>
  }
  export type CreditNoteUsageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creditNote?: boolean | SupplierCreditNoteDefaultArgs<ExtArgs>
    usedOnCostItemSupplier?: boolean | CostItemSupplierDefaultArgs<ExtArgs>
  }

  export type $CreditNoteUsagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CreditNoteUsage"
    objects: {
      creditNote: Prisma.$SupplierCreditNotePayload<ExtArgs>
      usedOnCostItemSupplier: Prisma.$CostItemSupplierPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      amountUsed: number
      usedAt: Date
      creditNoteId: number
      usedOnCostItemSupplierId: number
    }, ExtArgs["result"]["creditNoteUsage"]>
    composites: {}
  }

  type CreditNoteUsageGetPayload<S extends boolean | null | undefined | CreditNoteUsageDefaultArgs> = $Result.GetResult<Prisma.$CreditNoteUsagePayload, S>

  type CreditNoteUsageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CreditNoteUsageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CreditNoteUsageCountAggregateInputType | true
    }

  export interface CreditNoteUsageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CreditNoteUsage'], meta: { name: 'CreditNoteUsage' } }
    /**
     * Find zero or one CreditNoteUsage that matches the filter.
     * @param {CreditNoteUsageFindUniqueArgs} args - Arguments to find a CreditNoteUsage
     * @example
     * // Get one CreditNoteUsage
     * const creditNoteUsage = await prisma.creditNoteUsage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CreditNoteUsageFindUniqueArgs>(args: SelectSubset<T, CreditNoteUsageFindUniqueArgs<ExtArgs>>): Prisma__CreditNoteUsageClient<$Result.GetResult<Prisma.$CreditNoteUsagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CreditNoteUsage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CreditNoteUsageFindUniqueOrThrowArgs} args - Arguments to find a CreditNoteUsage
     * @example
     * // Get one CreditNoteUsage
     * const creditNoteUsage = await prisma.creditNoteUsage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CreditNoteUsageFindUniqueOrThrowArgs>(args: SelectSubset<T, CreditNoteUsageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CreditNoteUsageClient<$Result.GetResult<Prisma.$CreditNoteUsagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CreditNoteUsage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditNoteUsageFindFirstArgs} args - Arguments to find a CreditNoteUsage
     * @example
     * // Get one CreditNoteUsage
     * const creditNoteUsage = await prisma.creditNoteUsage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CreditNoteUsageFindFirstArgs>(args?: SelectSubset<T, CreditNoteUsageFindFirstArgs<ExtArgs>>): Prisma__CreditNoteUsageClient<$Result.GetResult<Prisma.$CreditNoteUsagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CreditNoteUsage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditNoteUsageFindFirstOrThrowArgs} args - Arguments to find a CreditNoteUsage
     * @example
     * // Get one CreditNoteUsage
     * const creditNoteUsage = await prisma.creditNoteUsage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CreditNoteUsageFindFirstOrThrowArgs>(args?: SelectSubset<T, CreditNoteUsageFindFirstOrThrowArgs<ExtArgs>>): Prisma__CreditNoteUsageClient<$Result.GetResult<Prisma.$CreditNoteUsagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CreditNoteUsages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditNoteUsageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CreditNoteUsages
     * const creditNoteUsages = await prisma.creditNoteUsage.findMany()
     * 
     * // Get first 10 CreditNoteUsages
     * const creditNoteUsages = await prisma.creditNoteUsage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const creditNoteUsageWithIdOnly = await prisma.creditNoteUsage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CreditNoteUsageFindManyArgs>(args?: SelectSubset<T, CreditNoteUsageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditNoteUsagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CreditNoteUsage.
     * @param {CreditNoteUsageCreateArgs} args - Arguments to create a CreditNoteUsage.
     * @example
     * // Create one CreditNoteUsage
     * const CreditNoteUsage = await prisma.creditNoteUsage.create({
     *   data: {
     *     // ... data to create a CreditNoteUsage
     *   }
     * })
     * 
     */
    create<T extends CreditNoteUsageCreateArgs>(args: SelectSubset<T, CreditNoteUsageCreateArgs<ExtArgs>>): Prisma__CreditNoteUsageClient<$Result.GetResult<Prisma.$CreditNoteUsagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CreditNoteUsages.
     * @param {CreditNoteUsageCreateManyArgs} args - Arguments to create many CreditNoteUsages.
     * @example
     * // Create many CreditNoteUsages
     * const creditNoteUsage = await prisma.creditNoteUsage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CreditNoteUsageCreateManyArgs>(args?: SelectSubset<T, CreditNoteUsageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CreditNoteUsages and returns the data saved in the database.
     * @param {CreditNoteUsageCreateManyAndReturnArgs} args - Arguments to create many CreditNoteUsages.
     * @example
     * // Create many CreditNoteUsages
     * const creditNoteUsage = await prisma.creditNoteUsage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CreditNoteUsages and only return the `id`
     * const creditNoteUsageWithIdOnly = await prisma.creditNoteUsage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CreditNoteUsageCreateManyAndReturnArgs>(args?: SelectSubset<T, CreditNoteUsageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditNoteUsagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CreditNoteUsage.
     * @param {CreditNoteUsageDeleteArgs} args - Arguments to delete one CreditNoteUsage.
     * @example
     * // Delete one CreditNoteUsage
     * const CreditNoteUsage = await prisma.creditNoteUsage.delete({
     *   where: {
     *     // ... filter to delete one CreditNoteUsage
     *   }
     * })
     * 
     */
    delete<T extends CreditNoteUsageDeleteArgs>(args: SelectSubset<T, CreditNoteUsageDeleteArgs<ExtArgs>>): Prisma__CreditNoteUsageClient<$Result.GetResult<Prisma.$CreditNoteUsagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CreditNoteUsage.
     * @param {CreditNoteUsageUpdateArgs} args - Arguments to update one CreditNoteUsage.
     * @example
     * // Update one CreditNoteUsage
     * const creditNoteUsage = await prisma.creditNoteUsage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CreditNoteUsageUpdateArgs>(args: SelectSubset<T, CreditNoteUsageUpdateArgs<ExtArgs>>): Prisma__CreditNoteUsageClient<$Result.GetResult<Prisma.$CreditNoteUsagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CreditNoteUsages.
     * @param {CreditNoteUsageDeleteManyArgs} args - Arguments to filter CreditNoteUsages to delete.
     * @example
     * // Delete a few CreditNoteUsages
     * const { count } = await prisma.creditNoteUsage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CreditNoteUsageDeleteManyArgs>(args?: SelectSubset<T, CreditNoteUsageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CreditNoteUsages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditNoteUsageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CreditNoteUsages
     * const creditNoteUsage = await prisma.creditNoteUsage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CreditNoteUsageUpdateManyArgs>(args: SelectSubset<T, CreditNoteUsageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CreditNoteUsages and returns the data updated in the database.
     * @param {CreditNoteUsageUpdateManyAndReturnArgs} args - Arguments to update many CreditNoteUsages.
     * @example
     * // Update many CreditNoteUsages
     * const creditNoteUsage = await prisma.creditNoteUsage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CreditNoteUsages and only return the `id`
     * const creditNoteUsageWithIdOnly = await prisma.creditNoteUsage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CreditNoteUsageUpdateManyAndReturnArgs>(args: SelectSubset<T, CreditNoteUsageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditNoteUsagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CreditNoteUsage.
     * @param {CreditNoteUsageUpsertArgs} args - Arguments to update or create a CreditNoteUsage.
     * @example
     * // Update or create a CreditNoteUsage
     * const creditNoteUsage = await prisma.creditNoteUsage.upsert({
     *   create: {
     *     // ... data to create a CreditNoteUsage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CreditNoteUsage we want to update
     *   }
     * })
     */
    upsert<T extends CreditNoteUsageUpsertArgs>(args: SelectSubset<T, CreditNoteUsageUpsertArgs<ExtArgs>>): Prisma__CreditNoteUsageClient<$Result.GetResult<Prisma.$CreditNoteUsagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CreditNoteUsages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditNoteUsageCountArgs} args - Arguments to filter CreditNoteUsages to count.
     * @example
     * // Count the number of CreditNoteUsages
     * const count = await prisma.creditNoteUsage.count({
     *   where: {
     *     // ... the filter for the CreditNoteUsages we want to count
     *   }
     * })
    **/
    count<T extends CreditNoteUsageCountArgs>(
      args?: Subset<T, CreditNoteUsageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CreditNoteUsageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CreditNoteUsage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditNoteUsageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CreditNoteUsageAggregateArgs>(args: Subset<T, CreditNoteUsageAggregateArgs>): Prisma.PrismaPromise<GetCreditNoteUsageAggregateType<T>>

    /**
     * Group by CreditNoteUsage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditNoteUsageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CreditNoteUsageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CreditNoteUsageGroupByArgs['orderBy'] }
        : { orderBy?: CreditNoteUsageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CreditNoteUsageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCreditNoteUsageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CreditNoteUsage model
   */
  readonly fields: CreditNoteUsageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CreditNoteUsage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CreditNoteUsageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creditNote<T extends SupplierCreditNoteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SupplierCreditNoteDefaultArgs<ExtArgs>>): Prisma__SupplierCreditNoteClient<$Result.GetResult<Prisma.$SupplierCreditNotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    usedOnCostItemSupplier<T extends CostItemSupplierDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CostItemSupplierDefaultArgs<ExtArgs>>): Prisma__CostItemSupplierClient<$Result.GetResult<Prisma.$CostItemSupplierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CreditNoteUsage model
   */
  interface CreditNoteUsageFieldRefs {
    readonly id: FieldRef<"CreditNoteUsage", 'Int'>
    readonly amountUsed: FieldRef<"CreditNoteUsage", 'Float'>
    readonly usedAt: FieldRef<"CreditNoteUsage", 'DateTime'>
    readonly creditNoteId: FieldRef<"CreditNoteUsage", 'Int'>
    readonly usedOnCostItemSupplierId: FieldRef<"CreditNoteUsage", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * CreditNoteUsage findUnique
   */
  export type CreditNoteUsageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditNoteUsage
     */
    select?: CreditNoteUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditNoteUsage
     */
    omit?: CreditNoteUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditNoteUsageInclude<ExtArgs> | null
    /**
     * Filter, which CreditNoteUsage to fetch.
     */
    where: CreditNoteUsageWhereUniqueInput
  }

  /**
   * CreditNoteUsage findUniqueOrThrow
   */
  export type CreditNoteUsageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditNoteUsage
     */
    select?: CreditNoteUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditNoteUsage
     */
    omit?: CreditNoteUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditNoteUsageInclude<ExtArgs> | null
    /**
     * Filter, which CreditNoteUsage to fetch.
     */
    where: CreditNoteUsageWhereUniqueInput
  }

  /**
   * CreditNoteUsage findFirst
   */
  export type CreditNoteUsageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditNoteUsage
     */
    select?: CreditNoteUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditNoteUsage
     */
    omit?: CreditNoteUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditNoteUsageInclude<ExtArgs> | null
    /**
     * Filter, which CreditNoteUsage to fetch.
     */
    where?: CreditNoteUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditNoteUsages to fetch.
     */
    orderBy?: CreditNoteUsageOrderByWithRelationInput | CreditNoteUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CreditNoteUsages.
     */
    cursor?: CreditNoteUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditNoteUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditNoteUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CreditNoteUsages.
     */
    distinct?: CreditNoteUsageScalarFieldEnum | CreditNoteUsageScalarFieldEnum[]
  }

  /**
   * CreditNoteUsage findFirstOrThrow
   */
  export type CreditNoteUsageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditNoteUsage
     */
    select?: CreditNoteUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditNoteUsage
     */
    omit?: CreditNoteUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditNoteUsageInclude<ExtArgs> | null
    /**
     * Filter, which CreditNoteUsage to fetch.
     */
    where?: CreditNoteUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditNoteUsages to fetch.
     */
    orderBy?: CreditNoteUsageOrderByWithRelationInput | CreditNoteUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CreditNoteUsages.
     */
    cursor?: CreditNoteUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditNoteUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditNoteUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CreditNoteUsages.
     */
    distinct?: CreditNoteUsageScalarFieldEnum | CreditNoteUsageScalarFieldEnum[]
  }

  /**
   * CreditNoteUsage findMany
   */
  export type CreditNoteUsageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditNoteUsage
     */
    select?: CreditNoteUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditNoteUsage
     */
    omit?: CreditNoteUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditNoteUsageInclude<ExtArgs> | null
    /**
     * Filter, which CreditNoteUsages to fetch.
     */
    where?: CreditNoteUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditNoteUsages to fetch.
     */
    orderBy?: CreditNoteUsageOrderByWithRelationInput | CreditNoteUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CreditNoteUsages.
     */
    cursor?: CreditNoteUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditNoteUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditNoteUsages.
     */
    skip?: number
    distinct?: CreditNoteUsageScalarFieldEnum | CreditNoteUsageScalarFieldEnum[]
  }

  /**
   * CreditNoteUsage create
   */
  export type CreditNoteUsageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditNoteUsage
     */
    select?: CreditNoteUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditNoteUsage
     */
    omit?: CreditNoteUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditNoteUsageInclude<ExtArgs> | null
    /**
     * The data needed to create a CreditNoteUsage.
     */
    data: XOR<CreditNoteUsageCreateInput, CreditNoteUsageUncheckedCreateInput>
  }

  /**
   * CreditNoteUsage createMany
   */
  export type CreditNoteUsageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CreditNoteUsages.
     */
    data: CreditNoteUsageCreateManyInput | CreditNoteUsageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CreditNoteUsage createManyAndReturn
   */
  export type CreditNoteUsageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditNoteUsage
     */
    select?: CreditNoteUsageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CreditNoteUsage
     */
    omit?: CreditNoteUsageOmit<ExtArgs> | null
    /**
     * The data used to create many CreditNoteUsages.
     */
    data: CreditNoteUsageCreateManyInput | CreditNoteUsageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditNoteUsageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CreditNoteUsage update
   */
  export type CreditNoteUsageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditNoteUsage
     */
    select?: CreditNoteUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditNoteUsage
     */
    omit?: CreditNoteUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditNoteUsageInclude<ExtArgs> | null
    /**
     * The data needed to update a CreditNoteUsage.
     */
    data: XOR<CreditNoteUsageUpdateInput, CreditNoteUsageUncheckedUpdateInput>
    /**
     * Choose, which CreditNoteUsage to update.
     */
    where: CreditNoteUsageWhereUniqueInput
  }

  /**
   * CreditNoteUsage updateMany
   */
  export type CreditNoteUsageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CreditNoteUsages.
     */
    data: XOR<CreditNoteUsageUpdateManyMutationInput, CreditNoteUsageUncheckedUpdateManyInput>
    /**
     * Filter which CreditNoteUsages to update
     */
    where?: CreditNoteUsageWhereInput
    /**
     * Limit how many CreditNoteUsages to update.
     */
    limit?: number
  }

  /**
   * CreditNoteUsage updateManyAndReturn
   */
  export type CreditNoteUsageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditNoteUsage
     */
    select?: CreditNoteUsageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CreditNoteUsage
     */
    omit?: CreditNoteUsageOmit<ExtArgs> | null
    /**
     * The data used to update CreditNoteUsages.
     */
    data: XOR<CreditNoteUsageUpdateManyMutationInput, CreditNoteUsageUncheckedUpdateManyInput>
    /**
     * Filter which CreditNoteUsages to update
     */
    where?: CreditNoteUsageWhereInput
    /**
     * Limit how many CreditNoteUsages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditNoteUsageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CreditNoteUsage upsert
   */
  export type CreditNoteUsageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditNoteUsage
     */
    select?: CreditNoteUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditNoteUsage
     */
    omit?: CreditNoteUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditNoteUsageInclude<ExtArgs> | null
    /**
     * The filter to search for the CreditNoteUsage to update in case it exists.
     */
    where: CreditNoteUsageWhereUniqueInput
    /**
     * In case the CreditNoteUsage found by the `where` argument doesn't exist, create a new CreditNoteUsage with this data.
     */
    create: XOR<CreditNoteUsageCreateInput, CreditNoteUsageUncheckedCreateInput>
    /**
     * In case the CreditNoteUsage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CreditNoteUsageUpdateInput, CreditNoteUsageUncheckedUpdateInput>
  }

  /**
   * CreditNoteUsage delete
   */
  export type CreditNoteUsageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditNoteUsage
     */
    select?: CreditNoteUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditNoteUsage
     */
    omit?: CreditNoteUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditNoteUsageInclude<ExtArgs> | null
    /**
     * Filter which CreditNoteUsage to delete.
     */
    where: CreditNoteUsageWhereUniqueInput
  }

  /**
   * CreditNoteUsage deleteMany
   */
  export type CreditNoteUsageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CreditNoteUsages to delete
     */
    where?: CreditNoteUsageWhereInput
    /**
     * Limit how many CreditNoteUsages to delete.
     */
    limit?: number
  }

  /**
   * CreditNoteUsage without action
   */
  export type CreditNoteUsageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditNoteUsage
     */
    select?: CreditNoteUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditNoteUsage
     */
    omit?: CreditNoteUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditNoteUsageInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const BookingScalarFieldEnum: {
    id: 'id',
    folderNo: 'folderNo',
    refNo: 'refNo',
    paxName: 'paxName',
    agentName: 'agentName',
    teamName: 'teamName',
    pnr: 'pnr',
    airline: 'airline',
    fromTo: 'fromTo',
    bookingType: 'bookingType',
    bookingStatus: 'bookingStatus',
    pcDate: 'pcDate',
    issuedDate: 'issuedDate',
    paymentMethod: 'paymentMethod',
    lastPaymentDate: 'lastPaymentDate',
    travelDate: 'travelDate',
    revenue: 'revenue',
    prodCost: 'prodCost',
    transFee: 'transFee',
    surcharge: 'surcharge',
    received: 'received',
    transactionMethod: 'transactionMethod',
    receivedDate: 'receivedDate',
    balance: 'balance',
    profit: 'profit',
    invoiced: 'invoiced',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    numPax: 'numPax',
    initialDeposit: 'initialDeposit'
  };

  export type BookingScalarFieldEnum = (typeof BookingScalarFieldEnum)[keyof typeof BookingScalarFieldEnum]


  export const PendingBookingScalarFieldEnum: {
    id: 'id',
    refNo: 'refNo',
    paxName: 'paxName',
    agentName: 'agentName',
    teamName: 'teamName',
    pnr: 'pnr',
    airline: 'airline',
    fromTo: 'fromTo',
    bookingType: 'bookingType',
    bookingStatus: 'bookingStatus',
    pcDate: 'pcDate',
    issuedDate: 'issuedDate',
    paymentMethod: 'paymentMethod',
    lastPaymentDate: 'lastPaymentDate',
    travelDate: 'travelDate',
    revenue: 'revenue',
    prodCost: 'prodCost',
    transFee: 'transFee',
    surcharge: 'surcharge',
    received: 'received',
    transactionMethod: 'transactionMethod',
    receivedDate: 'receivedDate',
    balance: 'balance',
    profit: 'profit',
    invoiced: 'invoiced',
    description: 'description',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    numPax: 'numPax'
  };

  export type PendingBookingScalarFieldEnum = (typeof PendingBookingScalarFieldEnum)[keyof typeof PendingBookingScalarFieldEnum]


  export const InstalmentScalarFieldEnum: {
    id: 'id',
    bookingId: 'bookingId',
    dueDate: 'dueDate',
    amount: 'amount',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InstalmentScalarFieldEnum = (typeof InstalmentScalarFieldEnum)[keyof typeof InstalmentScalarFieldEnum]


  export const PendingInstalmentScalarFieldEnum: {
    id: 'id',
    pendingBookingId: 'pendingBookingId',
    dueDate: 'dueDate',
    amount: 'amount',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PendingInstalmentScalarFieldEnum = (typeof PendingInstalmentScalarFieldEnum)[keyof typeof PendingInstalmentScalarFieldEnum]


  export const InstalmentPaymentScalarFieldEnum: {
    id: 'id',
    instalmentId: 'instalmentId',
    amount: 'amount',
    transactionMethod: 'transactionMethod',
    paymentDate: 'paymentDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InstalmentPaymentScalarFieldEnum = (typeof InstalmentPaymentScalarFieldEnum)[keyof typeof InstalmentPaymentScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    title: 'title',
    firstName: 'firstName',
    lastName: 'lastName',
    contactNo: 'contactNo',
    role: 'role',
    createdAt: 'createdAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const CostItemScalarFieldEnum: {
    id: 'id',
    bookingId: 'bookingId',
    category: 'category',
    amount: 'amount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CostItemScalarFieldEnum = (typeof CostItemScalarFieldEnum)[keyof typeof CostItemScalarFieldEnum]


  export const PendingCostItemScalarFieldEnum: {
    id: 'id',
    pendingBookingId: 'pendingBookingId',
    category: 'category',
    amount: 'amount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PendingCostItemScalarFieldEnum = (typeof PendingCostItemScalarFieldEnum)[keyof typeof PendingCostItemScalarFieldEnum]


  export const PassengerScalarFieldEnum: {
    id: 'id',
    bookingId: 'bookingId',
    title: 'title',
    firstName: 'firstName',
    middleName: 'middleName',
    lastName: 'lastName',
    gender: 'gender',
    email: 'email',
    contactNo: 'contactNo',
    nationality: 'nationality',
    birthday: 'birthday',
    category: 'category',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PassengerScalarFieldEnum = (typeof PassengerScalarFieldEnum)[keyof typeof PassengerScalarFieldEnum]


  export const PendingPassengerScalarFieldEnum: {
    id: 'id',
    pendingBookingId: 'pendingBookingId',
    title: 'title',
    firstName: 'firstName',
    middleName: 'middleName',
    lastName: 'lastName',
    gender: 'gender',
    email: 'email',
    contactNo: 'contactNo',
    nationality: 'nationality',
    birthday: 'birthday',
    category: 'category',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PendingPassengerScalarFieldEnum = (typeof PendingPassengerScalarFieldEnum)[keyof typeof PendingPassengerScalarFieldEnum]


  export const CostItemSupplierScalarFieldEnum: {
    id: 'id',
    costItemId: 'costItemId',
    pendingCostItemId: 'pendingCostItemId',
    supplier: 'supplier',
    amount: 'amount',
    paymentMethod: 'paymentMethod',
    paidAmount: 'paidAmount',
    pendingAmount: 'pendingAmount',
    transactionMethod: 'transactionMethod',
    firstMethodAmount: 'firstMethodAmount',
    secondMethodAmount: 'secondMethodAmount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CostItemSupplierScalarFieldEnum = (typeof CostItemSupplierScalarFieldEnum)[keyof typeof CostItemSupplierScalarFieldEnum]


  export const SupplierPaymentSettlementScalarFieldEnum: {
    id: 'id',
    costItemSupplierId: 'costItemSupplierId',
    amount: 'amount',
    transactionMethod: 'transactionMethod',
    settlementDate: 'settlementDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SupplierPaymentSettlementScalarFieldEnum = (typeof SupplierPaymentSettlementScalarFieldEnum)[keyof typeof SupplierPaymentSettlementScalarFieldEnum]


  export const CancellationScalarFieldEnum: {
    id: 'id',
    originalBookingId: 'originalBookingId',
    folderNo: 'folderNo',
    refundTransactionMethod: 'refundTransactionMethod',
    originalRevenue: 'originalRevenue',
    originalProdCost: 'originalProdCost',
    supplierCancellationFee: 'supplierCancellationFee',
    refundToPassenger: 'refundToPassenger',
    creditNoteAmount: 'creditNoteAmount',
    profitOrLoss: 'profitOrLoss',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CancellationScalarFieldEnum = (typeof CancellationScalarFieldEnum)[keyof typeof CancellationScalarFieldEnum]


  export const SupplierCreditNoteScalarFieldEnum: {
    id: 'id',
    supplier: 'supplier',
    initialAmount: 'initialAmount',
    remainingAmount: 'remainingAmount',
    status: 'status',
    generatedFromCancellationId: 'generatedFromCancellationId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SupplierCreditNoteScalarFieldEnum = (typeof SupplierCreditNoteScalarFieldEnum)[keyof typeof SupplierCreditNoteScalarFieldEnum]


  export const CreditNoteUsageScalarFieldEnum: {
    id: 'id',
    amountUsed: 'amountUsed',
    usedAt: 'usedAt',
    creditNoteId: 'creditNoteId',
    usedOnCostItemSupplierId: 'usedOnCostItemSupplierId'
  };

  export type CreditNoteUsageScalarFieldEnum = (typeof CreditNoteUsageScalarFieldEnum)[keyof typeof CreditNoteUsageScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Teams'
   */
  export type EnumTeamsFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Teams'>
    


  /**
   * Reference to a field of type 'Teams[]'
   */
  export type ListEnumTeamsFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Teams[]'>
    


  /**
   * Reference to a field of type 'BookingType'
   */
  export type EnumBookingTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BookingType'>
    


  /**
   * Reference to a field of type 'BookingType[]'
   */
  export type ListEnumBookingTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BookingType[]'>
    


  /**
   * Reference to a field of type 'BookingStatus'
   */
  export type EnumBookingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BookingStatus'>
    


  /**
   * Reference to a field of type 'BookingStatus[]'
   */
  export type ListEnumBookingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BookingStatus[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'PaymentMethod'
   */
  export type EnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod'>
    


  /**
   * Reference to a field of type 'PaymentMethod[]'
   */
  export type ListEnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'PendingStatus'
   */
  export type EnumPendingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PendingStatus'>
    


  /**
   * Reference to a field of type 'PendingStatus[]'
   */
  export type ListEnumPendingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PendingStatus[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'Title'
   */
  export type EnumTitleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Title'>
    


  /**
   * Reference to a field of type 'Title[]'
   */
  export type ListEnumTitleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Title[]'>
    


  /**
   * Reference to a field of type 'Gender'
   */
  export type EnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender'>
    


  /**
   * Reference to a field of type 'Gender[]'
   */
  export type ListEnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender[]'>
    


  /**
   * Reference to a field of type 'PassengerCategory'
   */
  export type EnumPassengerCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PassengerCategory'>
    


  /**
   * Reference to a field of type 'PassengerCategory[]'
   */
  export type ListEnumPassengerCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PassengerCategory[]'>
    


  /**
   * Reference to a field of type 'Suppliers'
   */
  export type EnumSuppliersFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Suppliers'>
    


  /**
   * Reference to a field of type 'Suppliers[]'
   */
  export type ListEnumSuppliersFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Suppliers[]'>
    


  /**
   * Reference to a field of type 'CreditNoteStatus'
   */
  export type EnumCreditNoteStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CreditNoteStatus'>
    


  /**
   * Reference to a field of type 'CreditNoteStatus[]'
   */
  export type ListEnumCreditNoteStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CreditNoteStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type BookingWhereInput = {
    AND?: BookingWhereInput | BookingWhereInput[]
    OR?: BookingWhereInput[]
    NOT?: BookingWhereInput | BookingWhereInput[]
    id?: IntFilter<"Booking"> | number
    folderNo?: IntFilter<"Booking"> | number
    refNo?: StringFilter<"Booking"> | string
    paxName?: StringFilter<"Booking"> | string
    agentName?: StringFilter<"Booking"> | string
    teamName?: EnumTeamsNullableFilter<"Booking"> | $Enums.Teams | null
    pnr?: StringFilter<"Booking"> | string
    airline?: StringFilter<"Booking"> | string
    fromTo?: StringFilter<"Booking"> | string
    bookingType?: EnumBookingTypeFilter<"Booking"> | $Enums.BookingType
    bookingStatus?: EnumBookingStatusNullableFilter<"Booking"> | $Enums.BookingStatus | null
    pcDate?: DateTimeFilter<"Booking"> | Date | string
    issuedDate?: DateTimeNullableFilter<"Booking"> | Date | string | null
    paymentMethod?: EnumPaymentMethodFilter<"Booking"> | $Enums.PaymentMethod
    lastPaymentDate?: DateTimeNullableFilter<"Booking"> | Date | string | null
    travelDate?: DateTimeNullableFilter<"Booking"> | Date | string | null
    revenue?: FloatNullableFilter<"Booking"> | number | null
    prodCost?: FloatNullableFilter<"Booking"> | number | null
    transFee?: FloatNullableFilter<"Booking"> | number | null
    surcharge?: FloatNullableFilter<"Booking"> | number | null
    received?: FloatNullableFilter<"Booking"> | number | null
    transactionMethod?: StringNullableFilter<"Booking"> | string | null
    receivedDate?: DateTimeNullableFilter<"Booking"> | Date | string | null
    balance?: FloatNullableFilter<"Booking"> | number | null
    profit?: FloatNullableFilter<"Booking"> | number | null
    invoiced?: StringNullableFilter<"Booking"> | string | null
    description?: StringNullableFilter<"Booking"> | string | null
    createdAt?: DateTimeFilter<"Booking"> | Date | string
    updatedAt?: DateTimeFilter<"Booking"> | Date | string
    numPax?: IntFilter<"Booking"> | number
    initialDeposit?: FloatNullableFilter<"Booking"> | number | null
    costItems?: CostItemListRelationFilter
    instalments?: InstalmentListRelationFilter
    passengers?: PassengerListRelationFilter
    cancellation?: XOR<CancellationNullableScalarRelationFilter, CancellationWhereInput> | null
  }

  export type BookingOrderByWithRelationInput = {
    id?: SortOrder
    folderNo?: SortOrder
    refNo?: SortOrder
    paxName?: SortOrder
    agentName?: SortOrder
    teamName?: SortOrderInput | SortOrder
    pnr?: SortOrder
    airline?: SortOrder
    fromTo?: SortOrder
    bookingType?: SortOrder
    bookingStatus?: SortOrderInput | SortOrder
    pcDate?: SortOrder
    issuedDate?: SortOrderInput | SortOrder
    paymentMethod?: SortOrder
    lastPaymentDate?: SortOrderInput | SortOrder
    travelDate?: SortOrderInput | SortOrder
    revenue?: SortOrderInput | SortOrder
    prodCost?: SortOrderInput | SortOrder
    transFee?: SortOrderInput | SortOrder
    surcharge?: SortOrderInput | SortOrder
    received?: SortOrderInput | SortOrder
    transactionMethod?: SortOrderInput | SortOrder
    receivedDate?: SortOrderInput | SortOrder
    balance?: SortOrderInput | SortOrder
    profit?: SortOrderInput | SortOrder
    invoiced?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    numPax?: SortOrder
    initialDeposit?: SortOrderInput | SortOrder
    costItems?: CostItemOrderByRelationAggregateInput
    instalments?: InstalmentOrderByRelationAggregateInput
    passengers?: PassengerOrderByRelationAggregateInput
    cancellation?: CancellationOrderByWithRelationInput
  }

  export type BookingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    folderNo?: number
    AND?: BookingWhereInput | BookingWhereInput[]
    OR?: BookingWhereInput[]
    NOT?: BookingWhereInput | BookingWhereInput[]
    refNo?: StringFilter<"Booking"> | string
    paxName?: StringFilter<"Booking"> | string
    agentName?: StringFilter<"Booking"> | string
    teamName?: EnumTeamsNullableFilter<"Booking"> | $Enums.Teams | null
    pnr?: StringFilter<"Booking"> | string
    airline?: StringFilter<"Booking"> | string
    fromTo?: StringFilter<"Booking"> | string
    bookingType?: EnumBookingTypeFilter<"Booking"> | $Enums.BookingType
    bookingStatus?: EnumBookingStatusNullableFilter<"Booking"> | $Enums.BookingStatus | null
    pcDate?: DateTimeFilter<"Booking"> | Date | string
    issuedDate?: DateTimeNullableFilter<"Booking"> | Date | string | null
    paymentMethod?: EnumPaymentMethodFilter<"Booking"> | $Enums.PaymentMethod
    lastPaymentDate?: DateTimeNullableFilter<"Booking"> | Date | string | null
    travelDate?: DateTimeNullableFilter<"Booking"> | Date | string | null
    revenue?: FloatNullableFilter<"Booking"> | number | null
    prodCost?: FloatNullableFilter<"Booking"> | number | null
    transFee?: FloatNullableFilter<"Booking"> | number | null
    surcharge?: FloatNullableFilter<"Booking"> | number | null
    received?: FloatNullableFilter<"Booking"> | number | null
    transactionMethod?: StringNullableFilter<"Booking"> | string | null
    receivedDate?: DateTimeNullableFilter<"Booking"> | Date | string | null
    balance?: FloatNullableFilter<"Booking"> | number | null
    profit?: FloatNullableFilter<"Booking"> | number | null
    invoiced?: StringNullableFilter<"Booking"> | string | null
    description?: StringNullableFilter<"Booking"> | string | null
    createdAt?: DateTimeFilter<"Booking"> | Date | string
    updatedAt?: DateTimeFilter<"Booking"> | Date | string
    numPax?: IntFilter<"Booking"> | number
    initialDeposit?: FloatNullableFilter<"Booking"> | number | null
    costItems?: CostItemListRelationFilter
    instalments?: InstalmentListRelationFilter
    passengers?: PassengerListRelationFilter
    cancellation?: XOR<CancellationNullableScalarRelationFilter, CancellationWhereInput> | null
  }, "id" | "folderNo">

  export type BookingOrderByWithAggregationInput = {
    id?: SortOrder
    folderNo?: SortOrder
    refNo?: SortOrder
    paxName?: SortOrder
    agentName?: SortOrder
    teamName?: SortOrderInput | SortOrder
    pnr?: SortOrder
    airline?: SortOrder
    fromTo?: SortOrder
    bookingType?: SortOrder
    bookingStatus?: SortOrderInput | SortOrder
    pcDate?: SortOrder
    issuedDate?: SortOrderInput | SortOrder
    paymentMethod?: SortOrder
    lastPaymentDate?: SortOrderInput | SortOrder
    travelDate?: SortOrderInput | SortOrder
    revenue?: SortOrderInput | SortOrder
    prodCost?: SortOrderInput | SortOrder
    transFee?: SortOrderInput | SortOrder
    surcharge?: SortOrderInput | SortOrder
    received?: SortOrderInput | SortOrder
    transactionMethod?: SortOrderInput | SortOrder
    receivedDate?: SortOrderInput | SortOrder
    balance?: SortOrderInput | SortOrder
    profit?: SortOrderInput | SortOrder
    invoiced?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    numPax?: SortOrder
    initialDeposit?: SortOrderInput | SortOrder
    _count?: BookingCountOrderByAggregateInput
    _avg?: BookingAvgOrderByAggregateInput
    _max?: BookingMaxOrderByAggregateInput
    _min?: BookingMinOrderByAggregateInput
    _sum?: BookingSumOrderByAggregateInput
  }

  export type BookingScalarWhereWithAggregatesInput = {
    AND?: BookingScalarWhereWithAggregatesInput | BookingScalarWhereWithAggregatesInput[]
    OR?: BookingScalarWhereWithAggregatesInput[]
    NOT?: BookingScalarWhereWithAggregatesInput | BookingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Booking"> | number
    folderNo?: IntWithAggregatesFilter<"Booking"> | number
    refNo?: StringWithAggregatesFilter<"Booking"> | string
    paxName?: StringWithAggregatesFilter<"Booking"> | string
    agentName?: StringWithAggregatesFilter<"Booking"> | string
    teamName?: EnumTeamsNullableWithAggregatesFilter<"Booking"> | $Enums.Teams | null
    pnr?: StringWithAggregatesFilter<"Booking"> | string
    airline?: StringWithAggregatesFilter<"Booking"> | string
    fromTo?: StringWithAggregatesFilter<"Booking"> | string
    bookingType?: EnumBookingTypeWithAggregatesFilter<"Booking"> | $Enums.BookingType
    bookingStatus?: EnumBookingStatusNullableWithAggregatesFilter<"Booking"> | $Enums.BookingStatus | null
    pcDate?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
    issuedDate?: DateTimeNullableWithAggregatesFilter<"Booking"> | Date | string | null
    paymentMethod?: EnumPaymentMethodWithAggregatesFilter<"Booking"> | $Enums.PaymentMethod
    lastPaymentDate?: DateTimeNullableWithAggregatesFilter<"Booking"> | Date | string | null
    travelDate?: DateTimeNullableWithAggregatesFilter<"Booking"> | Date | string | null
    revenue?: FloatNullableWithAggregatesFilter<"Booking"> | number | null
    prodCost?: FloatNullableWithAggregatesFilter<"Booking"> | number | null
    transFee?: FloatNullableWithAggregatesFilter<"Booking"> | number | null
    surcharge?: FloatNullableWithAggregatesFilter<"Booking"> | number | null
    received?: FloatNullableWithAggregatesFilter<"Booking"> | number | null
    transactionMethod?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    receivedDate?: DateTimeNullableWithAggregatesFilter<"Booking"> | Date | string | null
    balance?: FloatNullableWithAggregatesFilter<"Booking"> | number | null
    profit?: FloatNullableWithAggregatesFilter<"Booking"> | number | null
    invoiced?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    description?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
    numPax?: IntWithAggregatesFilter<"Booking"> | number
    initialDeposit?: FloatNullableWithAggregatesFilter<"Booking"> | number | null
  }

  export type PendingBookingWhereInput = {
    AND?: PendingBookingWhereInput | PendingBookingWhereInput[]
    OR?: PendingBookingWhereInput[]
    NOT?: PendingBookingWhereInput | PendingBookingWhereInput[]
    id?: IntFilter<"PendingBooking"> | number
    refNo?: StringFilter<"PendingBooking"> | string
    paxName?: StringFilter<"PendingBooking"> | string
    agentName?: StringFilter<"PendingBooking"> | string
    teamName?: EnumTeamsNullableFilter<"PendingBooking"> | $Enums.Teams | null
    pnr?: StringFilter<"PendingBooking"> | string
    airline?: StringFilter<"PendingBooking"> | string
    fromTo?: StringFilter<"PendingBooking"> | string
    bookingType?: EnumBookingTypeFilter<"PendingBooking"> | $Enums.BookingType
    bookingStatus?: EnumBookingStatusNullableFilter<"PendingBooking"> | $Enums.BookingStatus | null
    pcDate?: DateTimeFilter<"PendingBooking"> | Date | string
    issuedDate?: DateTimeNullableFilter<"PendingBooking"> | Date | string | null
    paymentMethod?: EnumPaymentMethodFilter<"PendingBooking"> | $Enums.PaymentMethod
    lastPaymentDate?: DateTimeNullableFilter<"PendingBooking"> | Date | string | null
    travelDate?: DateTimeNullableFilter<"PendingBooking"> | Date | string | null
    revenue?: FloatNullableFilter<"PendingBooking"> | number | null
    prodCost?: FloatNullableFilter<"PendingBooking"> | number | null
    transFee?: FloatNullableFilter<"PendingBooking"> | number | null
    surcharge?: FloatNullableFilter<"PendingBooking"> | number | null
    received?: FloatNullableFilter<"PendingBooking"> | number | null
    transactionMethod?: StringNullableFilter<"PendingBooking"> | string | null
    receivedDate?: DateTimeNullableFilter<"PendingBooking"> | Date | string | null
    balance?: FloatNullableFilter<"PendingBooking"> | number | null
    profit?: FloatNullableFilter<"PendingBooking"> | number | null
    invoiced?: StringNullableFilter<"PendingBooking"> | string | null
    description?: StringNullableFilter<"PendingBooking"> | string | null
    status?: EnumPendingStatusFilter<"PendingBooking"> | $Enums.PendingStatus
    createdAt?: DateTimeFilter<"PendingBooking"> | Date | string
    updatedAt?: DateTimeFilter<"PendingBooking"> | Date | string
    numPax?: IntFilter<"PendingBooking"> | number
    costItems?: PendingCostItemListRelationFilter
    instalments?: PendingInstalmentListRelationFilter
    passengers?: PendingPassengerListRelationFilter
  }

  export type PendingBookingOrderByWithRelationInput = {
    id?: SortOrder
    refNo?: SortOrder
    paxName?: SortOrder
    agentName?: SortOrder
    teamName?: SortOrderInput | SortOrder
    pnr?: SortOrder
    airline?: SortOrder
    fromTo?: SortOrder
    bookingType?: SortOrder
    bookingStatus?: SortOrderInput | SortOrder
    pcDate?: SortOrder
    issuedDate?: SortOrderInput | SortOrder
    paymentMethod?: SortOrder
    lastPaymentDate?: SortOrderInput | SortOrder
    travelDate?: SortOrderInput | SortOrder
    revenue?: SortOrderInput | SortOrder
    prodCost?: SortOrderInput | SortOrder
    transFee?: SortOrderInput | SortOrder
    surcharge?: SortOrderInput | SortOrder
    received?: SortOrderInput | SortOrder
    transactionMethod?: SortOrderInput | SortOrder
    receivedDate?: SortOrderInput | SortOrder
    balance?: SortOrderInput | SortOrder
    profit?: SortOrderInput | SortOrder
    invoiced?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    numPax?: SortOrder
    costItems?: PendingCostItemOrderByRelationAggregateInput
    instalments?: PendingInstalmentOrderByRelationAggregateInput
    passengers?: PendingPassengerOrderByRelationAggregateInput
  }

  export type PendingBookingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PendingBookingWhereInput | PendingBookingWhereInput[]
    OR?: PendingBookingWhereInput[]
    NOT?: PendingBookingWhereInput | PendingBookingWhereInput[]
    refNo?: StringFilter<"PendingBooking"> | string
    paxName?: StringFilter<"PendingBooking"> | string
    agentName?: StringFilter<"PendingBooking"> | string
    teamName?: EnumTeamsNullableFilter<"PendingBooking"> | $Enums.Teams | null
    pnr?: StringFilter<"PendingBooking"> | string
    airline?: StringFilter<"PendingBooking"> | string
    fromTo?: StringFilter<"PendingBooking"> | string
    bookingType?: EnumBookingTypeFilter<"PendingBooking"> | $Enums.BookingType
    bookingStatus?: EnumBookingStatusNullableFilter<"PendingBooking"> | $Enums.BookingStatus | null
    pcDate?: DateTimeFilter<"PendingBooking"> | Date | string
    issuedDate?: DateTimeNullableFilter<"PendingBooking"> | Date | string | null
    paymentMethod?: EnumPaymentMethodFilter<"PendingBooking"> | $Enums.PaymentMethod
    lastPaymentDate?: DateTimeNullableFilter<"PendingBooking"> | Date | string | null
    travelDate?: DateTimeNullableFilter<"PendingBooking"> | Date | string | null
    revenue?: FloatNullableFilter<"PendingBooking"> | number | null
    prodCost?: FloatNullableFilter<"PendingBooking"> | number | null
    transFee?: FloatNullableFilter<"PendingBooking"> | number | null
    surcharge?: FloatNullableFilter<"PendingBooking"> | number | null
    received?: FloatNullableFilter<"PendingBooking"> | number | null
    transactionMethod?: StringNullableFilter<"PendingBooking"> | string | null
    receivedDate?: DateTimeNullableFilter<"PendingBooking"> | Date | string | null
    balance?: FloatNullableFilter<"PendingBooking"> | number | null
    profit?: FloatNullableFilter<"PendingBooking"> | number | null
    invoiced?: StringNullableFilter<"PendingBooking"> | string | null
    description?: StringNullableFilter<"PendingBooking"> | string | null
    status?: EnumPendingStatusFilter<"PendingBooking"> | $Enums.PendingStatus
    createdAt?: DateTimeFilter<"PendingBooking"> | Date | string
    updatedAt?: DateTimeFilter<"PendingBooking"> | Date | string
    numPax?: IntFilter<"PendingBooking"> | number
    costItems?: PendingCostItemListRelationFilter
    instalments?: PendingInstalmentListRelationFilter
    passengers?: PendingPassengerListRelationFilter
  }, "id">

  export type PendingBookingOrderByWithAggregationInput = {
    id?: SortOrder
    refNo?: SortOrder
    paxName?: SortOrder
    agentName?: SortOrder
    teamName?: SortOrderInput | SortOrder
    pnr?: SortOrder
    airline?: SortOrder
    fromTo?: SortOrder
    bookingType?: SortOrder
    bookingStatus?: SortOrderInput | SortOrder
    pcDate?: SortOrder
    issuedDate?: SortOrderInput | SortOrder
    paymentMethod?: SortOrder
    lastPaymentDate?: SortOrderInput | SortOrder
    travelDate?: SortOrderInput | SortOrder
    revenue?: SortOrderInput | SortOrder
    prodCost?: SortOrderInput | SortOrder
    transFee?: SortOrderInput | SortOrder
    surcharge?: SortOrderInput | SortOrder
    received?: SortOrderInput | SortOrder
    transactionMethod?: SortOrderInput | SortOrder
    receivedDate?: SortOrderInput | SortOrder
    balance?: SortOrderInput | SortOrder
    profit?: SortOrderInput | SortOrder
    invoiced?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    numPax?: SortOrder
    _count?: PendingBookingCountOrderByAggregateInput
    _avg?: PendingBookingAvgOrderByAggregateInput
    _max?: PendingBookingMaxOrderByAggregateInput
    _min?: PendingBookingMinOrderByAggregateInput
    _sum?: PendingBookingSumOrderByAggregateInput
  }

  export type PendingBookingScalarWhereWithAggregatesInput = {
    AND?: PendingBookingScalarWhereWithAggregatesInput | PendingBookingScalarWhereWithAggregatesInput[]
    OR?: PendingBookingScalarWhereWithAggregatesInput[]
    NOT?: PendingBookingScalarWhereWithAggregatesInput | PendingBookingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PendingBooking"> | number
    refNo?: StringWithAggregatesFilter<"PendingBooking"> | string
    paxName?: StringWithAggregatesFilter<"PendingBooking"> | string
    agentName?: StringWithAggregatesFilter<"PendingBooking"> | string
    teamName?: EnumTeamsNullableWithAggregatesFilter<"PendingBooking"> | $Enums.Teams | null
    pnr?: StringWithAggregatesFilter<"PendingBooking"> | string
    airline?: StringWithAggregatesFilter<"PendingBooking"> | string
    fromTo?: StringWithAggregatesFilter<"PendingBooking"> | string
    bookingType?: EnumBookingTypeWithAggregatesFilter<"PendingBooking"> | $Enums.BookingType
    bookingStatus?: EnumBookingStatusNullableWithAggregatesFilter<"PendingBooking"> | $Enums.BookingStatus | null
    pcDate?: DateTimeWithAggregatesFilter<"PendingBooking"> | Date | string
    issuedDate?: DateTimeNullableWithAggregatesFilter<"PendingBooking"> | Date | string | null
    paymentMethod?: EnumPaymentMethodWithAggregatesFilter<"PendingBooking"> | $Enums.PaymentMethod
    lastPaymentDate?: DateTimeNullableWithAggregatesFilter<"PendingBooking"> | Date | string | null
    travelDate?: DateTimeNullableWithAggregatesFilter<"PendingBooking"> | Date | string | null
    revenue?: FloatNullableWithAggregatesFilter<"PendingBooking"> | number | null
    prodCost?: FloatNullableWithAggregatesFilter<"PendingBooking"> | number | null
    transFee?: FloatNullableWithAggregatesFilter<"PendingBooking"> | number | null
    surcharge?: FloatNullableWithAggregatesFilter<"PendingBooking"> | number | null
    received?: FloatNullableWithAggregatesFilter<"PendingBooking"> | number | null
    transactionMethod?: StringNullableWithAggregatesFilter<"PendingBooking"> | string | null
    receivedDate?: DateTimeNullableWithAggregatesFilter<"PendingBooking"> | Date | string | null
    balance?: FloatNullableWithAggregatesFilter<"PendingBooking"> | number | null
    profit?: FloatNullableWithAggregatesFilter<"PendingBooking"> | number | null
    invoiced?: StringNullableWithAggregatesFilter<"PendingBooking"> | string | null
    description?: StringNullableWithAggregatesFilter<"PendingBooking"> | string | null
    status?: EnumPendingStatusWithAggregatesFilter<"PendingBooking"> | $Enums.PendingStatus
    createdAt?: DateTimeWithAggregatesFilter<"PendingBooking"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PendingBooking"> | Date | string
    numPax?: IntWithAggregatesFilter<"PendingBooking"> | number
  }

  export type InstalmentWhereInput = {
    AND?: InstalmentWhereInput | InstalmentWhereInput[]
    OR?: InstalmentWhereInput[]
    NOT?: InstalmentWhereInput | InstalmentWhereInput[]
    id?: IntFilter<"Instalment"> | number
    bookingId?: IntFilter<"Instalment"> | number
    dueDate?: DateTimeFilter<"Instalment"> | Date | string
    amount?: FloatFilter<"Instalment"> | number
    status?: StringFilter<"Instalment"> | string
    createdAt?: DateTimeFilter<"Instalment"> | Date | string
    updatedAt?: DateTimeFilter<"Instalment"> | Date | string
    booking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
    payments?: InstalmentPaymentListRelationFilter
  }

  export type InstalmentOrderByWithRelationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    dueDate?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    booking?: BookingOrderByWithRelationInput
    payments?: InstalmentPaymentOrderByRelationAggregateInput
  }

  export type InstalmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: InstalmentWhereInput | InstalmentWhereInput[]
    OR?: InstalmentWhereInput[]
    NOT?: InstalmentWhereInput | InstalmentWhereInput[]
    bookingId?: IntFilter<"Instalment"> | number
    dueDate?: DateTimeFilter<"Instalment"> | Date | string
    amount?: FloatFilter<"Instalment"> | number
    status?: StringFilter<"Instalment"> | string
    createdAt?: DateTimeFilter<"Instalment"> | Date | string
    updatedAt?: DateTimeFilter<"Instalment"> | Date | string
    booking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
    payments?: InstalmentPaymentListRelationFilter
  }, "id">

  export type InstalmentOrderByWithAggregationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    dueDate?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InstalmentCountOrderByAggregateInput
    _avg?: InstalmentAvgOrderByAggregateInput
    _max?: InstalmentMaxOrderByAggregateInput
    _min?: InstalmentMinOrderByAggregateInput
    _sum?: InstalmentSumOrderByAggregateInput
  }

  export type InstalmentScalarWhereWithAggregatesInput = {
    AND?: InstalmentScalarWhereWithAggregatesInput | InstalmentScalarWhereWithAggregatesInput[]
    OR?: InstalmentScalarWhereWithAggregatesInput[]
    NOT?: InstalmentScalarWhereWithAggregatesInput | InstalmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Instalment"> | number
    bookingId?: IntWithAggregatesFilter<"Instalment"> | number
    dueDate?: DateTimeWithAggregatesFilter<"Instalment"> | Date | string
    amount?: FloatWithAggregatesFilter<"Instalment"> | number
    status?: StringWithAggregatesFilter<"Instalment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Instalment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Instalment"> | Date | string
  }

  export type PendingInstalmentWhereInput = {
    AND?: PendingInstalmentWhereInput | PendingInstalmentWhereInput[]
    OR?: PendingInstalmentWhereInput[]
    NOT?: PendingInstalmentWhereInput | PendingInstalmentWhereInput[]
    id?: IntFilter<"PendingInstalment"> | number
    pendingBookingId?: IntFilter<"PendingInstalment"> | number
    dueDate?: DateTimeFilter<"PendingInstalment"> | Date | string
    amount?: FloatFilter<"PendingInstalment"> | number
    status?: StringFilter<"PendingInstalment"> | string
    createdAt?: DateTimeFilter<"PendingInstalment"> | Date | string
    updatedAt?: DateTimeFilter<"PendingInstalment"> | Date | string
    pendingBooking?: XOR<PendingBookingScalarRelationFilter, PendingBookingWhereInput>
  }

  export type PendingInstalmentOrderByWithRelationInput = {
    id?: SortOrder
    pendingBookingId?: SortOrder
    dueDate?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    pendingBooking?: PendingBookingOrderByWithRelationInput
  }

  export type PendingInstalmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PendingInstalmentWhereInput | PendingInstalmentWhereInput[]
    OR?: PendingInstalmentWhereInput[]
    NOT?: PendingInstalmentWhereInput | PendingInstalmentWhereInput[]
    pendingBookingId?: IntFilter<"PendingInstalment"> | number
    dueDate?: DateTimeFilter<"PendingInstalment"> | Date | string
    amount?: FloatFilter<"PendingInstalment"> | number
    status?: StringFilter<"PendingInstalment"> | string
    createdAt?: DateTimeFilter<"PendingInstalment"> | Date | string
    updatedAt?: DateTimeFilter<"PendingInstalment"> | Date | string
    pendingBooking?: XOR<PendingBookingScalarRelationFilter, PendingBookingWhereInput>
  }, "id">

  export type PendingInstalmentOrderByWithAggregationInput = {
    id?: SortOrder
    pendingBookingId?: SortOrder
    dueDate?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PendingInstalmentCountOrderByAggregateInput
    _avg?: PendingInstalmentAvgOrderByAggregateInput
    _max?: PendingInstalmentMaxOrderByAggregateInput
    _min?: PendingInstalmentMinOrderByAggregateInput
    _sum?: PendingInstalmentSumOrderByAggregateInput
  }

  export type PendingInstalmentScalarWhereWithAggregatesInput = {
    AND?: PendingInstalmentScalarWhereWithAggregatesInput | PendingInstalmentScalarWhereWithAggregatesInput[]
    OR?: PendingInstalmentScalarWhereWithAggregatesInput[]
    NOT?: PendingInstalmentScalarWhereWithAggregatesInput | PendingInstalmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PendingInstalment"> | number
    pendingBookingId?: IntWithAggregatesFilter<"PendingInstalment"> | number
    dueDate?: DateTimeWithAggregatesFilter<"PendingInstalment"> | Date | string
    amount?: FloatWithAggregatesFilter<"PendingInstalment"> | number
    status?: StringWithAggregatesFilter<"PendingInstalment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PendingInstalment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PendingInstalment"> | Date | string
  }

  export type InstalmentPaymentWhereInput = {
    AND?: InstalmentPaymentWhereInput | InstalmentPaymentWhereInput[]
    OR?: InstalmentPaymentWhereInput[]
    NOT?: InstalmentPaymentWhereInput | InstalmentPaymentWhereInput[]
    id?: IntFilter<"InstalmentPayment"> | number
    instalmentId?: IntFilter<"InstalmentPayment"> | number
    amount?: FloatFilter<"InstalmentPayment"> | number
    transactionMethod?: StringFilter<"InstalmentPayment"> | string
    paymentDate?: DateTimeFilter<"InstalmentPayment"> | Date | string
    createdAt?: DateTimeFilter<"InstalmentPayment"> | Date | string
    updatedAt?: DateTimeFilter<"InstalmentPayment"> | Date | string
    instalment?: XOR<InstalmentScalarRelationFilter, InstalmentWhereInput>
  }

  export type InstalmentPaymentOrderByWithRelationInput = {
    id?: SortOrder
    instalmentId?: SortOrder
    amount?: SortOrder
    transactionMethod?: SortOrder
    paymentDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    instalment?: InstalmentOrderByWithRelationInput
  }

  export type InstalmentPaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: InstalmentPaymentWhereInput | InstalmentPaymentWhereInput[]
    OR?: InstalmentPaymentWhereInput[]
    NOT?: InstalmentPaymentWhereInput | InstalmentPaymentWhereInput[]
    instalmentId?: IntFilter<"InstalmentPayment"> | number
    amount?: FloatFilter<"InstalmentPayment"> | number
    transactionMethod?: StringFilter<"InstalmentPayment"> | string
    paymentDate?: DateTimeFilter<"InstalmentPayment"> | Date | string
    createdAt?: DateTimeFilter<"InstalmentPayment"> | Date | string
    updatedAt?: DateTimeFilter<"InstalmentPayment"> | Date | string
    instalment?: XOR<InstalmentScalarRelationFilter, InstalmentWhereInput>
  }, "id">

  export type InstalmentPaymentOrderByWithAggregationInput = {
    id?: SortOrder
    instalmentId?: SortOrder
    amount?: SortOrder
    transactionMethod?: SortOrder
    paymentDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InstalmentPaymentCountOrderByAggregateInput
    _avg?: InstalmentPaymentAvgOrderByAggregateInput
    _max?: InstalmentPaymentMaxOrderByAggregateInput
    _min?: InstalmentPaymentMinOrderByAggregateInput
    _sum?: InstalmentPaymentSumOrderByAggregateInput
  }

  export type InstalmentPaymentScalarWhereWithAggregatesInput = {
    AND?: InstalmentPaymentScalarWhereWithAggregatesInput | InstalmentPaymentScalarWhereWithAggregatesInput[]
    OR?: InstalmentPaymentScalarWhereWithAggregatesInput[]
    NOT?: InstalmentPaymentScalarWhereWithAggregatesInput | InstalmentPaymentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"InstalmentPayment"> | number
    instalmentId?: IntWithAggregatesFilter<"InstalmentPayment"> | number
    amount?: FloatWithAggregatesFilter<"InstalmentPayment"> | number
    transactionMethod?: StringWithAggregatesFilter<"InstalmentPayment"> | string
    paymentDate?: DateTimeWithAggregatesFilter<"InstalmentPayment"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"InstalmentPayment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"InstalmentPayment"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    email?: StringNullableFilter<"User"> | string | null
    title?: StringNullableFilter<"User"> | string | null
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    contactNo?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    createdAt?: DateTimeFilter<"User"> | Date | string
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    contactNo?: SortOrderInput | SortOrder
    role?: SortOrder
    createdAt?: SortOrder
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    title?: StringNullableFilter<"User"> | string | null
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    contactNo?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    createdAt?: DateTimeFilter<"User"> | Date | string
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    contactNo?: SortOrderInput | SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    title?: StringNullableWithAggregatesFilter<"User"> | string | null
    firstName?: StringWithAggregatesFilter<"User"> | string
    lastName?: StringWithAggregatesFilter<"User"> | string
    contactNo?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type CostItemWhereInput = {
    AND?: CostItemWhereInput | CostItemWhereInput[]
    OR?: CostItemWhereInput[]
    NOT?: CostItemWhereInput | CostItemWhereInput[]
    id?: IntFilter<"CostItem"> | number
    bookingId?: IntFilter<"CostItem"> | number
    category?: StringFilter<"CostItem"> | string
    amount?: FloatFilter<"CostItem"> | number
    createdAt?: DateTimeFilter<"CostItem"> | Date | string
    updatedAt?: DateTimeFilter<"CostItem"> | Date | string
    booking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
    suppliers?: CostItemSupplierListRelationFilter
  }

  export type CostItemOrderByWithRelationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    category?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    booking?: BookingOrderByWithRelationInput
    suppliers?: CostItemSupplierOrderByRelationAggregateInput
  }

  export type CostItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CostItemWhereInput | CostItemWhereInput[]
    OR?: CostItemWhereInput[]
    NOT?: CostItemWhereInput | CostItemWhereInput[]
    bookingId?: IntFilter<"CostItem"> | number
    category?: StringFilter<"CostItem"> | string
    amount?: FloatFilter<"CostItem"> | number
    createdAt?: DateTimeFilter<"CostItem"> | Date | string
    updatedAt?: DateTimeFilter<"CostItem"> | Date | string
    booking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
    suppliers?: CostItemSupplierListRelationFilter
  }, "id">

  export type CostItemOrderByWithAggregationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    category?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CostItemCountOrderByAggregateInput
    _avg?: CostItemAvgOrderByAggregateInput
    _max?: CostItemMaxOrderByAggregateInput
    _min?: CostItemMinOrderByAggregateInput
    _sum?: CostItemSumOrderByAggregateInput
  }

  export type CostItemScalarWhereWithAggregatesInput = {
    AND?: CostItemScalarWhereWithAggregatesInput | CostItemScalarWhereWithAggregatesInput[]
    OR?: CostItemScalarWhereWithAggregatesInput[]
    NOT?: CostItemScalarWhereWithAggregatesInput | CostItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CostItem"> | number
    bookingId?: IntWithAggregatesFilter<"CostItem"> | number
    category?: StringWithAggregatesFilter<"CostItem"> | string
    amount?: FloatWithAggregatesFilter<"CostItem"> | number
    createdAt?: DateTimeWithAggregatesFilter<"CostItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CostItem"> | Date | string
  }

  export type PendingCostItemWhereInput = {
    AND?: PendingCostItemWhereInput | PendingCostItemWhereInput[]
    OR?: PendingCostItemWhereInput[]
    NOT?: PendingCostItemWhereInput | PendingCostItemWhereInput[]
    id?: IntFilter<"PendingCostItem"> | number
    pendingBookingId?: IntFilter<"PendingCostItem"> | number
    category?: StringFilter<"PendingCostItem"> | string
    amount?: FloatFilter<"PendingCostItem"> | number
    createdAt?: DateTimeFilter<"PendingCostItem"> | Date | string
    updatedAt?: DateTimeFilter<"PendingCostItem"> | Date | string
    pendingBooking?: XOR<PendingBookingScalarRelationFilter, PendingBookingWhereInput>
    suppliers?: CostItemSupplierListRelationFilter
  }

  export type PendingCostItemOrderByWithRelationInput = {
    id?: SortOrder
    pendingBookingId?: SortOrder
    category?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    pendingBooking?: PendingBookingOrderByWithRelationInput
    suppliers?: CostItemSupplierOrderByRelationAggregateInput
  }

  export type PendingCostItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PendingCostItemWhereInput | PendingCostItemWhereInput[]
    OR?: PendingCostItemWhereInput[]
    NOT?: PendingCostItemWhereInput | PendingCostItemWhereInput[]
    pendingBookingId?: IntFilter<"PendingCostItem"> | number
    category?: StringFilter<"PendingCostItem"> | string
    amount?: FloatFilter<"PendingCostItem"> | number
    createdAt?: DateTimeFilter<"PendingCostItem"> | Date | string
    updatedAt?: DateTimeFilter<"PendingCostItem"> | Date | string
    pendingBooking?: XOR<PendingBookingScalarRelationFilter, PendingBookingWhereInput>
    suppliers?: CostItemSupplierListRelationFilter
  }, "id">

  export type PendingCostItemOrderByWithAggregationInput = {
    id?: SortOrder
    pendingBookingId?: SortOrder
    category?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PendingCostItemCountOrderByAggregateInput
    _avg?: PendingCostItemAvgOrderByAggregateInput
    _max?: PendingCostItemMaxOrderByAggregateInput
    _min?: PendingCostItemMinOrderByAggregateInput
    _sum?: PendingCostItemSumOrderByAggregateInput
  }

  export type PendingCostItemScalarWhereWithAggregatesInput = {
    AND?: PendingCostItemScalarWhereWithAggregatesInput | PendingCostItemScalarWhereWithAggregatesInput[]
    OR?: PendingCostItemScalarWhereWithAggregatesInput[]
    NOT?: PendingCostItemScalarWhereWithAggregatesInput | PendingCostItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PendingCostItem"> | number
    pendingBookingId?: IntWithAggregatesFilter<"PendingCostItem"> | number
    category?: StringWithAggregatesFilter<"PendingCostItem"> | string
    amount?: FloatWithAggregatesFilter<"PendingCostItem"> | number
    createdAt?: DateTimeWithAggregatesFilter<"PendingCostItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PendingCostItem"> | Date | string
  }

  export type PassengerWhereInput = {
    AND?: PassengerWhereInput | PassengerWhereInput[]
    OR?: PassengerWhereInput[]
    NOT?: PassengerWhereInput | PassengerWhereInput[]
    id?: IntFilter<"Passenger"> | number
    bookingId?: IntFilter<"Passenger"> | number
    title?: EnumTitleFilter<"Passenger"> | $Enums.Title
    firstName?: StringFilter<"Passenger"> | string
    middleName?: StringNullableFilter<"Passenger"> | string | null
    lastName?: StringFilter<"Passenger"> | string
    gender?: EnumGenderFilter<"Passenger"> | $Enums.Gender
    email?: StringNullableFilter<"Passenger"> | string | null
    contactNo?: StringNullableFilter<"Passenger"> | string | null
    nationality?: StringNullableFilter<"Passenger"> | string | null
    birthday?: DateTimeNullableFilter<"Passenger"> | Date | string | null
    category?: EnumPassengerCategoryFilter<"Passenger"> | $Enums.PassengerCategory
    createdAt?: DateTimeFilter<"Passenger"> | Date | string
    updatedAt?: DateTimeFilter<"Passenger"> | Date | string
    booking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
  }

  export type PassengerOrderByWithRelationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    title?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrderInput | SortOrder
    lastName?: SortOrder
    gender?: SortOrder
    email?: SortOrderInput | SortOrder
    contactNo?: SortOrderInput | SortOrder
    nationality?: SortOrderInput | SortOrder
    birthday?: SortOrderInput | SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    booking?: BookingOrderByWithRelationInput
  }

  export type PassengerWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PassengerWhereInput | PassengerWhereInput[]
    OR?: PassengerWhereInput[]
    NOT?: PassengerWhereInput | PassengerWhereInput[]
    bookingId?: IntFilter<"Passenger"> | number
    title?: EnumTitleFilter<"Passenger"> | $Enums.Title
    firstName?: StringFilter<"Passenger"> | string
    middleName?: StringNullableFilter<"Passenger"> | string | null
    lastName?: StringFilter<"Passenger"> | string
    gender?: EnumGenderFilter<"Passenger"> | $Enums.Gender
    email?: StringNullableFilter<"Passenger"> | string | null
    contactNo?: StringNullableFilter<"Passenger"> | string | null
    nationality?: StringNullableFilter<"Passenger"> | string | null
    birthday?: DateTimeNullableFilter<"Passenger"> | Date | string | null
    category?: EnumPassengerCategoryFilter<"Passenger"> | $Enums.PassengerCategory
    createdAt?: DateTimeFilter<"Passenger"> | Date | string
    updatedAt?: DateTimeFilter<"Passenger"> | Date | string
    booking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
  }, "id">

  export type PassengerOrderByWithAggregationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    title?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrderInput | SortOrder
    lastName?: SortOrder
    gender?: SortOrder
    email?: SortOrderInput | SortOrder
    contactNo?: SortOrderInput | SortOrder
    nationality?: SortOrderInput | SortOrder
    birthday?: SortOrderInput | SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PassengerCountOrderByAggregateInput
    _avg?: PassengerAvgOrderByAggregateInput
    _max?: PassengerMaxOrderByAggregateInput
    _min?: PassengerMinOrderByAggregateInput
    _sum?: PassengerSumOrderByAggregateInput
  }

  export type PassengerScalarWhereWithAggregatesInput = {
    AND?: PassengerScalarWhereWithAggregatesInput | PassengerScalarWhereWithAggregatesInput[]
    OR?: PassengerScalarWhereWithAggregatesInput[]
    NOT?: PassengerScalarWhereWithAggregatesInput | PassengerScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Passenger"> | number
    bookingId?: IntWithAggregatesFilter<"Passenger"> | number
    title?: EnumTitleWithAggregatesFilter<"Passenger"> | $Enums.Title
    firstName?: StringWithAggregatesFilter<"Passenger"> | string
    middleName?: StringNullableWithAggregatesFilter<"Passenger"> | string | null
    lastName?: StringWithAggregatesFilter<"Passenger"> | string
    gender?: EnumGenderWithAggregatesFilter<"Passenger"> | $Enums.Gender
    email?: StringNullableWithAggregatesFilter<"Passenger"> | string | null
    contactNo?: StringNullableWithAggregatesFilter<"Passenger"> | string | null
    nationality?: StringNullableWithAggregatesFilter<"Passenger"> | string | null
    birthday?: DateTimeNullableWithAggregatesFilter<"Passenger"> | Date | string | null
    category?: EnumPassengerCategoryWithAggregatesFilter<"Passenger"> | $Enums.PassengerCategory
    createdAt?: DateTimeWithAggregatesFilter<"Passenger"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Passenger"> | Date | string
  }

  export type PendingPassengerWhereInput = {
    AND?: PendingPassengerWhereInput | PendingPassengerWhereInput[]
    OR?: PendingPassengerWhereInput[]
    NOT?: PendingPassengerWhereInput | PendingPassengerWhereInput[]
    id?: IntFilter<"PendingPassenger"> | number
    pendingBookingId?: IntFilter<"PendingPassenger"> | number
    title?: EnumTitleFilter<"PendingPassenger"> | $Enums.Title
    firstName?: StringFilter<"PendingPassenger"> | string
    middleName?: StringNullableFilter<"PendingPassenger"> | string | null
    lastName?: StringFilter<"PendingPassenger"> | string
    gender?: EnumGenderFilter<"PendingPassenger"> | $Enums.Gender
    email?: StringNullableFilter<"PendingPassenger"> | string | null
    contactNo?: StringNullableFilter<"PendingPassenger"> | string | null
    nationality?: StringNullableFilter<"PendingPassenger"> | string | null
    birthday?: DateTimeNullableFilter<"PendingPassenger"> | Date | string | null
    category?: EnumPassengerCategoryFilter<"PendingPassenger"> | $Enums.PassengerCategory
    createdAt?: DateTimeFilter<"PendingPassenger"> | Date | string
    updatedAt?: DateTimeFilter<"PendingPassenger"> | Date | string
    pendingBooking?: XOR<PendingBookingScalarRelationFilter, PendingBookingWhereInput>
  }

  export type PendingPassengerOrderByWithRelationInput = {
    id?: SortOrder
    pendingBookingId?: SortOrder
    title?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrderInput | SortOrder
    lastName?: SortOrder
    gender?: SortOrder
    email?: SortOrderInput | SortOrder
    contactNo?: SortOrderInput | SortOrder
    nationality?: SortOrderInput | SortOrder
    birthday?: SortOrderInput | SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    pendingBooking?: PendingBookingOrderByWithRelationInput
  }

  export type PendingPassengerWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PendingPassengerWhereInput | PendingPassengerWhereInput[]
    OR?: PendingPassengerWhereInput[]
    NOT?: PendingPassengerWhereInput | PendingPassengerWhereInput[]
    pendingBookingId?: IntFilter<"PendingPassenger"> | number
    title?: EnumTitleFilter<"PendingPassenger"> | $Enums.Title
    firstName?: StringFilter<"PendingPassenger"> | string
    middleName?: StringNullableFilter<"PendingPassenger"> | string | null
    lastName?: StringFilter<"PendingPassenger"> | string
    gender?: EnumGenderFilter<"PendingPassenger"> | $Enums.Gender
    email?: StringNullableFilter<"PendingPassenger"> | string | null
    contactNo?: StringNullableFilter<"PendingPassenger"> | string | null
    nationality?: StringNullableFilter<"PendingPassenger"> | string | null
    birthday?: DateTimeNullableFilter<"PendingPassenger"> | Date | string | null
    category?: EnumPassengerCategoryFilter<"PendingPassenger"> | $Enums.PassengerCategory
    createdAt?: DateTimeFilter<"PendingPassenger"> | Date | string
    updatedAt?: DateTimeFilter<"PendingPassenger"> | Date | string
    pendingBooking?: XOR<PendingBookingScalarRelationFilter, PendingBookingWhereInput>
  }, "id">

  export type PendingPassengerOrderByWithAggregationInput = {
    id?: SortOrder
    pendingBookingId?: SortOrder
    title?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrderInput | SortOrder
    lastName?: SortOrder
    gender?: SortOrder
    email?: SortOrderInput | SortOrder
    contactNo?: SortOrderInput | SortOrder
    nationality?: SortOrderInput | SortOrder
    birthday?: SortOrderInput | SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PendingPassengerCountOrderByAggregateInput
    _avg?: PendingPassengerAvgOrderByAggregateInput
    _max?: PendingPassengerMaxOrderByAggregateInput
    _min?: PendingPassengerMinOrderByAggregateInput
    _sum?: PendingPassengerSumOrderByAggregateInput
  }

  export type PendingPassengerScalarWhereWithAggregatesInput = {
    AND?: PendingPassengerScalarWhereWithAggregatesInput | PendingPassengerScalarWhereWithAggregatesInput[]
    OR?: PendingPassengerScalarWhereWithAggregatesInput[]
    NOT?: PendingPassengerScalarWhereWithAggregatesInput | PendingPassengerScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PendingPassenger"> | number
    pendingBookingId?: IntWithAggregatesFilter<"PendingPassenger"> | number
    title?: EnumTitleWithAggregatesFilter<"PendingPassenger"> | $Enums.Title
    firstName?: StringWithAggregatesFilter<"PendingPassenger"> | string
    middleName?: StringNullableWithAggregatesFilter<"PendingPassenger"> | string | null
    lastName?: StringWithAggregatesFilter<"PendingPassenger"> | string
    gender?: EnumGenderWithAggregatesFilter<"PendingPassenger"> | $Enums.Gender
    email?: StringNullableWithAggregatesFilter<"PendingPassenger"> | string | null
    contactNo?: StringNullableWithAggregatesFilter<"PendingPassenger"> | string | null
    nationality?: StringNullableWithAggregatesFilter<"PendingPassenger"> | string | null
    birthday?: DateTimeNullableWithAggregatesFilter<"PendingPassenger"> | Date | string | null
    category?: EnumPassengerCategoryWithAggregatesFilter<"PendingPassenger"> | $Enums.PassengerCategory
    createdAt?: DateTimeWithAggregatesFilter<"PendingPassenger"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PendingPassenger"> | Date | string
  }

  export type CostItemSupplierWhereInput = {
    AND?: CostItemSupplierWhereInput | CostItemSupplierWhereInput[]
    OR?: CostItemSupplierWhereInput[]
    NOT?: CostItemSupplierWhereInput | CostItemSupplierWhereInput[]
    id?: IntFilter<"CostItemSupplier"> | number
    costItemId?: IntNullableFilter<"CostItemSupplier"> | number | null
    pendingCostItemId?: IntNullableFilter<"CostItemSupplier"> | number | null
    supplier?: EnumSuppliersFilter<"CostItemSupplier"> | $Enums.Suppliers
    amount?: FloatFilter<"CostItemSupplier"> | number
    paymentMethod?: StringFilter<"CostItemSupplier"> | string
    paidAmount?: FloatFilter<"CostItemSupplier"> | number
    pendingAmount?: FloatFilter<"CostItemSupplier"> | number
    transactionMethod?: StringNullableFilter<"CostItemSupplier"> | string | null
    firstMethodAmount?: FloatNullableFilter<"CostItemSupplier"> | number | null
    secondMethodAmount?: FloatNullableFilter<"CostItemSupplier"> | number | null
    createdAt?: DateTimeFilter<"CostItemSupplier"> | Date | string
    updatedAt?: DateTimeFilter<"CostItemSupplier"> | Date | string
    costItem?: XOR<CostItemNullableScalarRelationFilter, CostItemWhereInput> | null
    pendingCostItem?: XOR<PendingCostItemNullableScalarRelationFilter, PendingCostItemWhereInput> | null
    settlements?: SupplierPaymentSettlementListRelationFilter
    paidByCreditNoteUsage?: CreditNoteUsageListRelationFilter
  }

  export type CostItemSupplierOrderByWithRelationInput = {
    id?: SortOrder
    costItemId?: SortOrderInput | SortOrder
    pendingCostItemId?: SortOrderInput | SortOrder
    supplier?: SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrder
    paidAmount?: SortOrder
    pendingAmount?: SortOrder
    transactionMethod?: SortOrderInput | SortOrder
    firstMethodAmount?: SortOrderInput | SortOrder
    secondMethodAmount?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    costItem?: CostItemOrderByWithRelationInput
    pendingCostItem?: PendingCostItemOrderByWithRelationInput
    settlements?: SupplierPaymentSettlementOrderByRelationAggregateInput
    paidByCreditNoteUsage?: CreditNoteUsageOrderByRelationAggregateInput
  }

  export type CostItemSupplierWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CostItemSupplierWhereInput | CostItemSupplierWhereInput[]
    OR?: CostItemSupplierWhereInput[]
    NOT?: CostItemSupplierWhereInput | CostItemSupplierWhereInput[]
    costItemId?: IntNullableFilter<"CostItemSupplier"> | number | null
    pendingCostItemId?: IntNullableFilter<"CostItemSupplier"> | number | null
    supplier?: EnumSuppliersFilter<"CostItemSupplier"> | $Enums.Suppliers
    amount?: FloatFilter<"CostItemSupplier"> | number
    paymentMethod?: StringFilter<"CostItemSupplier"> | string
    paidAmount?: FloatFilter<"CostItemSupplier"> | number
    pendingAmount?: FloatFilter<"CostItemSupplier"> | number
    transactionMethod?: StringNullableFilter<"CostItemSupplier"> | string | null
    firstMethodAmount?: FloatNullableFilter<"CostItemSupplier"> | number | null
    secondMethodAmount?: FloatNullableFilter<"CostItemSupplier"> | number | null
    createdAt?: DateTimeFilter<"CostItemSupplier"> | Date | string
    updatedAt?: DateTimeFilter<"CostItemSupplier"> | Date | string
    costItem?: XOR<CostItemNullableScalarRelationFilter, CostItemWhereInput> | null
    pendingCostItem?: XOR<PendingCostItemNullableScalarRelationFilter, PendingCostItemWhereInput> | null
    settlements?: SupplierPaymentSettlementListRelationFilter
    paidByCreditNoteUsage?: CreditNoteUsageListRelationFilter
  }, "id">

  export type CostItemSupplierOrderByWithAggregationInput = {
    id?: SortOrder
    costItemId?: SortOrderInput | SortOrder
    pendingCostItemId?: SortOrderInput | SortOrder
    supplier?: SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrder
    paidAmount?: SortOrder
    pendingAmount?: SortOrder
    transactionMethod?: SortOrderInput | SortOrder
    firstMethodAmount?: SortOrderInput | SortOrder
    secondMethodAmount?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CostItemSupplierCountOrderByAggregateInput
    _avg?: CostItemSupplierAvgOrderByAggregateInput
    _max?: CostItemSupplierMaxOrderByAggregateInput
    _min?: CostItemSupplierMinOrderByAggregateInput
    _sum?: CostItemSupplierSumOrderByAggregateInput
  }

  export type CostItemSupplierScalarWhereWithAggregatesInput = {
    AND?: CostItemSupplierScalarWhereWithAggregatesInput | CostItemSupplierScalarWhereWithAggregatesInput[]
    OR?: CostItemSupplierScalarWhereWithAggregatesInput[]
    NOT?: CostItemSupplierScalarWhereWithAggregatesInput | CostItemSupplierScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CostItemSupplier"> | number
    costItemId?: IntNullableWithAggregatesFilter<"CostItemSupplier"> | number | null
    pendingCostItemId?: IntNullableWithAggregatesFilter<"CostItemSupplier"> | number | null
    supplier?: EnumSuppliersWithAggregatesFilter<"CostItemSupplier"> | $Enums.Suppliers
    amount?: FloatWithAggregatesFilter<"CostItemSupplier"> | number
    paymentMethod?: StringWithAggregatesFilter<"CostItemSupplier"> | string
    paidAmount?: FloatWithAggregatesFilter<"CostItemSupplier"> | number
    pendingAmount?: FloatWithAggregatesFilter<"CostItemSupplier"> | number
    transactionMethod?: StringNullableWithAggregatesFilter<"CostItemSupplier"> | string | null
    firstMethodAmount?: FloatNullableWithAggregatesFilter<"CostItemSupplier"> | number | null
    secondMethodAmount?: FloatNullableWithAggregatesFilter<"CostItemSupplier"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"CostItemSupplier"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CostItemSupplier"> | Date | string
  }

  export type SupplierPaymentSettlementWhereInput = {
    AND?: SupplierPaymentSettlementWhereInput | SupplierPaymentSettlementWhereInput[]
    OR?: SupplierPaymentSettlementWhereInput[]
    NOT?: SupplierPaymentSettlementWhereInput | SupplierPaymentSettlementWhereInput[]
    id?: IntFilter<"SupplierPaymentSettlement"> | number
    costItemSupplierId?: IntFilter<"SupplierPaymentSettlement"> | number
    amount?: FloatFilter<"SupplierPaymentSettlement"> | number
    transactionMethod?: StringFilter<"SupplierPaymentSettlement"> | string
    settlementDate?: DateTimeFilter<"SupplierPaymentSettlement"> | Date | string
    createdAt?: DateTimeFilter<"SupplierPaymentSettlement"> | Date | string
    updatedAt?: DateTimeFilter<"SupplierPaymentSettlement"> | Date | string
    costItemSupplier?: XOR<CostItemSupplierScalarRelationFilter, CostItemSupplierWhereInput>
  }

  export type SupplierPaymentSettlementOrderByWithRelationInput = {
    id?: SortOrder
    costItemSupplierId?: SortOrder
    amount?: SortOrder
    transactionMethod?: SortOrder
    settlementDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    costItemSupplier?: CostItemSupplierOrderByWithRelationInput
  }

  export type SupplierPaymentSettlementWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SupplierPaymentSettlementWhereInput | SupplierPaymentSettlementWhereInput[]
    OR?: SupplierPaymentSettlementWhereInput[]
    NOT?: SupplierPaymentSettlementWhereInput | SupplierPaymentSettlementWhereInput[]
    costItemSupplierId?: IntFilter<"SupplierPaymentSettlement"> | number
    amount?: FloatFilter<"SupplierPaymentSettlement"> | number
    transactionMethod?: StringFilter<"SupplierPaymentSettlement"> | string
    settlementDate?: DateTimeFilter<"SupplierPaymentSettlement"> | Date | string
    createdAt?: DateTimeFilter<"SupplierPaymentSettlement"> | Date | string
    updatedAt?: DateTimeFilter<"SupplierPaymentSettlement"> | Date | string
    costItemSupplier?: XOR<CostItemSupplierScalarRelationFilter, CostItemSupplierWhereInput>
  }, "id">

  export type SupplierPaymentSettlementOrderByWithAggregationInput = {
    id?: SortOrder
    costItemSupplierId?: SortOrder
    amount?: SortOrder
    transactionMethod?: SortOrder
    settlementDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SupplierPaymentSettlementCountOrderByAggregateInput
    _avg?: SupplierPaymentSettlementAvgOrderByAggregateInput
    _max?: SupplierPaymentSettlementMaxOrderByAggregateInput
    _min?: SupplierPaymentSettlementMinOrderByAggregateInput
    _sum?: SupplierPaymentSettlementSumOrderByAggregateInput
  }

  export type SupplierPaymentSettlementScalarWhereWithAggregatesInput = {
    AND?: SupplierPaymentSettlementScalarWhereWithAggregatesInput | SupplierPaymentSettlementScalarWhereWithAggregatesInput[]
    OR?: SupplierPaymentSettlementScalarWhereWithAggregatesInput[]
    NOT?: SupplierPaymentSettlementScalarWhereWithAggregatesInput | SupplierPaymentSettlementScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SupplierPaymentSettlement"> | number
    costItemSupplierId?: IntWithAggregatesFilter<"SupplierPaymentSettlement"> | number
    amount?: FloatWithAggregatesFilter<"SupplierPaymentSettlement"> | number
    transactionMethod?: StringWithAggregatesFilter<"SupplierPaymentSettlement"> | string
    settlementDate?: DateTimeWithAggregatesFilter<"SupplierPaymentSettlement"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"SupplierPaymentSettlement"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SupplierPaymentSettlement"> | Date | string
  }

  export type CancellationWhereInput = {
    AND?: CancellationWhereInput | CancellationWhereInput[]
    OR?: CancellationWhereInput[]
    NOT?: CancellationWhereInput | CancellationWhereInput[]
    id?: IntFilter<"Cancellation"> | number
    originalBookingId?: IntFilter<"Cancellation"> | number
    folderNo?: StringFilter<"Cancellation"> | string
    refundTransactionMethod?: StringFilter<"Cancellation"> | string
    originalRevenue?: FloatFilter<"Cancellation"> | number
    originalProdCost?: FloatFilter<"Cancellation"> | number
    supplierCancellationFee?: FloatFilter<"Cancellation"> | number
    refundToPassenger?: FloatFilter<"Cancellation"> | number
    creditNoteAmount?: FloatNullableFilter<"Cancellation"> | number | null
    profitOrLoss?: FloatFilter<"Cancellation"> | number
    description?: StringNullableFilter<"Cancellation"> | string | null
    createdAt?: DateTimeFilter<"Cancellation"> | Date | string
    updatedAt?: DateTimeFilter<"Cancellation"> | Date | string
    originalBooking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
    generatedCreditNote?: XOR<SupplierCreditNoteNullableScalarRelationFilter, SupplierCreditNoteWhereInput> | null
  }

  export type CancellationOrderByWithRelationInput = {
    id?: SortOrder
    originalBookingId?: SortOrder
    folderNo?: SortOrder
    refundTransactionMethod?: SortOrder
    originalRevenue?: SortOrder
    originalProdCost?: SortOrder
    supplierCancellationFee?: SortOrder
    refundToPassenger?: SortOrder
    creditNoteAmount?: SortOrderInput | SortOrder
    profitOrLoss?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    originalBooking?: BookingOrderByWithRelationInput
    generatedCreditNote?: SupplierCreditNoteOrderByWithRelationInput
  }

  export type CancellationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    originalBookingId?: number
    folderNo?: string
    AND?: CancellationWhereInput | CancellationWhereInput[]
    OR?: CancellationWhereInput[]
    NOT?: CancellationWhereInput | CancellationWhereInput[]
    refundTransactionMethod?: StringFilter<"Cancellation"> | string
    originalRevenue?: FloatFilter<"Cancellation"> | number
    originalProdCost?: FloatFilter<"Cancellation"> | number
    supplierCancellationFee?: FloatFilter<"Cancellation"> | number
    refundToPassenger?: FloatFilter<"Cancellation"> | number
    creditNoteAmount?: FloatNullableFilter<"Cancellation"> | number | null
    profitOrLoss?: FloatFilter<"Cancellation"> | number
    description?: StringNullableFilter<"Cancellation"> | string | null
    createdAt?: DateTimeFilter<"Cancellation"> | Date | string
    updatedAt?: DateTimeFilter<"Cancellation"> | Date | string
    originalBooking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
    generatedCreditNote?: XOR<SupplierCreditNoteNullableScalarRelationFilter, SupplierCreditNoteWhereInput> | null
  }, "id" | "originalBookingId" | "folderNo">

  export type CancellationOrderByWithAggregationInput = {
    id?: SortOrder
    originalBookingId?: SortOrder
    folderNo?: SortOrder
    refundTransactionMethod?: SortOrder
    originalRevenue?: SortOrder
    originalProdCost?: SortOrder
    supplierCancellationFee?: SortOrder
    refundToPassenger?: SortOrder
    creditNoteAmount?: SortOrderInput | SortOrder
    profitOrLoss?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CancellationCountOrderByAggregateInput
    _avg?: CancellationAvgOrderByAggregateInput
    _max?: CancellationMaxOrderByAggregateInput
    _min?: CancellationMinOrderByAggregateInput
    _sum?: CancellationSumOrderByAggregateInput
  }

  export type CancellationScalarWhereWithAggregatesInput = {
    AND?: CancellationScalarWhereWithAggregatesInput | CancellationScalarWhereWithAggregatesInput[]
    OR?: CancellationScalarWhereWithAggregatesInput[]
    NOT?: CancellationScalarWhereWithAggregatesInput | CancellationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Cancellation"> | number
    originalBookingId?: IntWithAggregatesFilter<"Cancellation"> | number
    folderNo?: StringWithAggregatesFilter<"Cancellation"> | string
    refundTransactionMethod?: StringWithAggregatesFilter<"Cancellation"> | string
    originalRevenue?: FloatWithAggregatesFilter<"Cancellation"> | number
    originalProdCost?: FloatWithAggregatesFilter<"Cancellation"> | number
    supplierCancellationFee?: FloatWithAggregatesFilter<"Cancellation"> | number
    refundToPassenger?: FloatWithAggregatesFilter<"Cancellation"> | number
    creditNoteAmount?: FloatNullableWithAggregatesFilter<"Cancellation"> | number | null
    profitOrLoss?: FloatWithAggregatesFilter<"Cancellation"> | number
    description?: StringNullableWithAggregatesFilter<"Cancellation"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Cancellation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Cancellation"> | Date | string
  }

  export type SupplierCreditNoteWhereInput = {
    AND?: SupplierCreditNoteWhereInput | SupplierCreditNoteWhereInput[]
    OR?: SupplierCreditNoteWhereInput[]
    NOT?: SupplierCreditNoteWhereInput | SupplierCreditNoteWhereInput[]
    id?: IntFilter<"SupplierCreditNote"> | number
    supplier?: EnumSuppliersFilter<"SupplierCreditNote"> | $Enums.Suppliers
    initialAmount?: FloatFilter<"SupplierCreditNote"> | number
    remainingAmount?: FloatFilter<"SupplierCreditNote"> | number
    status?: EnumCreditNoteStatusFilter<"SupplierCreditNote"> | $Enums.CreditNoteStatus
    generatedFromCancellationId?: IntFilter<"SupplierCreditNote"> | number
    createdAt?: DateTimeFilter<"SupplierCreditNote"> | Date | string
    updatedAt?: DateTimeFilter<"SupplierCreditNote"> | Date | string
    generatedFromCancellation?: XOR<CancellationScalarRelationFilter, CancellationWhereInput>
    usageHistory?: CreditNoteUsageListRelationFilter
  }

  export type SupplierCreditNoteOrderByWithRelationInput = {
    id?: SortOrder
    supplier?: SortOrder
    initialAmount?: SortOrder
    remainingAmount?: SortOrder
    status?: SortOrder
    generatedFromCancellationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    generatedFromCancellation?: CancellationOrderByWithRelationInput
    usageHistory?: CreditNoteUsageOrderByRelationAggregateInput
  }

  export type SupplierCreditNoteWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    generatedFromCancellationId?: number
    AND?: SupplierCreditNoteWhereInput | SupplierCreditNoteWhereInput[]
    OR?: SupplierCreditNoteWhereInput[]
    NOT?: SupplierCreditNoteWhereInput | SupplierCreditNoteWhereInput[]
    supplier?: EnumSuppliersFilter<"SupplierCreditNote"> | $Enums.Suppliers
    initialAmount?: FloatFilter<"SupplierCreditNote"> | number
    remainingAmount?: FloatFilter<"SupplierCreditNote"> | number
    status?: EnumCreditNoteStatusFilter<"SupplierCreditNote"> | $Enums.CreditNoteStatus
    createdAt?: DateTimeFilter<"SupplierCreditNote"> | Date | string
    updatedAt?: DateTimeFilter<"SupplierCreditNote"> | Date | string
    generatedFromCancellation?: XOR<CancellationScalarRelationFilter, CancellationWhereInput>
    usageHistory?: CreditNoteUsageListRelationFilter
  }, "id" | "generatedFromCancellationId">

  export type SupplierCreditNoteOrderByWithAggregationInput = {
    id?: SortOrder
    supplier?: SortOrder
    initialAmount?: SortOrder
    remainingAmount?: SortOrder
    status?: SortOrder
    generatedFromCancellationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SupplierCreditNoteCountOrderByAggregateInput
    _avg?: SupplierCreditNoteAvgOrderByAggregateInput
    _max?: SupplierCreditNoteMaxOrderByAggregateInput
    _min?: SupplierCreditNoteMinOrderByAggregateInput
    _sum?: SupplierCreditNoteSumOrderByAggregateInput
  }

  export type SupplierCreditNoteScalarWhereWithAggregatesInput = {
    AND?: SupplierCreditNoteScalarWhereWithAggregatesInput | SupplierCreditNoteScalarWhereWithAggregatesInput[]
    OR?: SupplierCreditNoteScalarWhereWithAggregatesInput[]
    NOT?: SupplierCreditNoteScalarWhereWithAggregatesInput | SupplierCreditNoteScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SupplierCreditNote"> | number
    supplier?: EnumSuppliersWithAggregatesFilter<"SupplierCreditNote"> | $Enums.Suppliers
    initialAmount?: FloatWithAggregatesFilter<"SupplierCreditNote"> | number
    remainingAmount?: FloatWithAggregatesFilter<"SupplierCreditNote"> | number
    status?: EnumCreditNoteStatusWithAggregatesFilter<"SupplierCreditNote"> | $Enums.CreditNoteStatus
    generatedFromCancellationId?: IntWithAggregatesFilter<"SupplierCreditNote"> | number
    createdAt?: DateTimeWithAggregatesFilter<"SupplierCreditNote"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SupplierCreditNote"> | Date | string
  }

  export type CreditNoteUsageWhereInput = {
    AND?: CreditNoteUsageWhereInput | CreditNoteUsageWhereInput[]
    OR?: CreditNoteUsageWhereInput[]
    NOT?: CreditNoteUsageWhereInput | CreditNoteUsageWhereInput[]
    id?: IntFilter<"CreditNoteUsage"> | number
    amountUsed?: FloatFilter<"CreditNoteUsage"> | number
    usedAt?: DateTimeFilter<"CreditNoteUsage"> | Date | string
    creditNoteId?: IntFilter<"CreditNoteUsage"> | number
    usedOnCostItemSupplierId?: IntFilter<"CreditNoteUsage"> | number
    creditNote?: XOR<SupplierCreditNoteScalarRelationFilter, SupplierCreditNoteWhereInput>
    usedOnCostItemSupplier?: XOR<CostItemSupplierScalarRelationFilter, CostItemSupplierWhereInput>
  }

  export type CreditNoteUsageOrderByWithRelationInput = {
    id?: SortOrder
    amountUsed?: SortOrder
    usedAt?: SortOrder
    creditNoteId?: SortOrder
    usedOnCostItemSupplierId?: SortOrder
    creditNote?: SupplierCreditNoteOrderByWithRelationInput
    usedOnCostItemSupplier?: CostItemSupplierOrderByWithRelationInput
  }

  export type CreditNoteUsageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CreditNoteUsageWhereInput | CreditNoteUsageWhereInput[]
    OR?: CreditNoteUsageWhereInput[]
    NOT?: CreditNoteUsageWhereInput | CreditNoteUsageWhereInput[]
    amountUsed?: FloatFilter<"CreditNoteUsage"> | number
    usedAt?: DateTimeFilter<"CreditNoteUsage"> | Date | string
    creditNoteId?: IntFilter<"CreditNoteUsage"> | number
    usedOnCostItemSupplierId?: IntFilter<"CreditNoteUsage"> | number
    creditNote?: XOR<SupplierCreditNoteScalarRelationFilter, SupplierCreditNoteWhereInput>
    usedOnCostItemSupplier?: XOR<CostItemSupplierScalarRelationFilter, CostItemSupplierWhereInput>
  }, "id">

  export type CreditNoteUsageOrderByWithAggregationInput = {
    id?: SortOrder
    amountUsed?: SortOrder
    usedAt?: SortOrder
    creditNoteId?: SortOrder
    usedOnCostItemSupplierId?: SortOrder
    _count?: CreditNoteUsageCountOrderByAggregateInput
    _avg?: CreditNoteUsageAvgOrderByAggregateInput
    _max?: CreditNoteUsageMaxOrderByAggregateInput
    _min?: CreditNoteUsageMinOrderByAggregateInput
    _sum?: CreditNoteUsageSumOrderByAggregateInput
  }

  export type CreditNoteUsageScalarWhereWithAggregatesInput = {
    AND?: CreditNoteUsageScalarWhereWithAggregatesInput | CreditNoteUsageScalarWhereWithAggregatesInput[]
    OR?: CreditNoteUsageScalarWhereWithAggregatesInput[]
    NOT?: CreditNoteUsageScalarWhereWithAggregatesInput | CreditNoteUsageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CreditNoteUsage"> | number
    amountUsed?: FloatWithAggregatesFilter<"CreditNoteUsage"> | number
    usedAt?: DateTimeWithAggregatesFilter<"CreditNoteUsage"> | Date | string
    creditNoteId?: IntWithAggregatesFilter<"CreditNoteUsage"> | number
    usedOnCostItemSupplierId?: IntWithAggregatesFilter<"CreditNoteUsage"> | number
  }

  export type BookingCreateInput = {
    folderNo: number
    refNo: string
    paxName: string
    agentName: string
    teamName?: $Enums.Teams | null
    pnr: string
    airline: string
    fromTo: string
    bookingType: $Enums.BookingType
    bookingStatus?: $Enums.BookingStatus | null
    pcDate: Date | string
    issuedDate?: Date | string | null
    paymentMethod: $Enums.PaymentMethod
    lastPaymentDate?: Date | string | null
    travelDate?: Date | string | null
    revenue?: number | null
    prodCost?: number | null
    transFee?: number | null
    surcharge?: number | null
    received?: number | null
    transactionMethod?: string | null
    receivedDate?: Date | string | null
    balance?: number | null
    profit?: number | null
    invoiced?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    numPax: number
    initialDeposit?: number | null
    costItems?: CostItemCreateNestedManyWithoutBookingInput
    instalments?: InstalmentCreateNestedManyWithoutBookingInput
    passengers?: PassengerCreateNestedManyWithoutBookingInput
    cancellation?: CancellationCreateNestedOneWithoutOriginalBookingInput
  }

  export type BookingUncheckedCreateInput = {
    id?: number
    folderNo: number
    refNo: string
    paxName: string
    agentName: string
    teamName?: $Enums.Teams | null
    pnr: string
    airline: string
    fromTo: string
    bookingType: $Enums.BookingType
    bookingStatus?: $Enums.BookingStatus | null
    pcDate: Date | string
    issuedDate?: Date | string | null
    paymentMethod: $Enums.PaymentMethod
    lastPaymentDate?: Date | string | null
    travelDate?: Date | string | null
    revenue?: number | null
    prodCost?: number | null
    transFee?: number | null
    surcharge?: number | null
    received?: number | null
    transactionMethod?: string | null
    receivedDate?: Date | string | null
    balance?: number | null
    profit?: number | null
    invoiced?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    numPax: number
    initialDeposit?: number | null
    costItems?: CostItemUncheckedCreateNestedManyWithoutBookingInput
    instalments?: InstalmentUncheckedCreateNestedManyWithoutBookingInput
    passengers?: PassengerUncheckedCreateNestedManyWithoutBookingInput
    cancellation?: CancellationUncheckedCreateNestedOneWithoutOriginalBookingInput
  }

  export type BookingUpdateInput = {
    folderNo?: IntFieldUpdateOperationsInput | number
    refNo?: StringFieldUpdateOperationsInput | string
    paxName?: StringFieldUpdateOperationsInput | string
    agentName?: StringFieldUpdateOperationsInput | string
    teamName?: NullableEnumTeamsFieldUpdateOperationsInput | $Enums.Teams | null
    pnr?: StringFieldUpdateOperationsInput | string
    airline?: StringFieldUpdateOperationsInput | string
    fromTo?: StringFieldUpdateOperationsInput | string
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    bookingStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    pcDate?: DateTimeFieldUpdateOperationsInput | Date | string
    issuedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    travelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    prodCost?: NullableFloatFieldUpdateOperationsInput | number | null
    transFee?: NullableFloatFieldUpdateOperationsInput | number | null
    surcharge?: NullableFloatFieldUpdateOperationsInput | number | null
    received?: NullableFloatFieldUpdateOperationsInput | number | null
    transactionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    profit?: NullableFloatFieldUpdateOperationsInput | number | null
    invoiced?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    numPax?: IntFieldUpdateOperationsInput | number
    initialDeposit?: NullableFloatFieldUpdateOperationsInput | number | null
    costItems?: CostItemUpdateManyWithoutBookingNestedInput
    instalments?: InstalmentUpdateManyWithoutBookingNestedInput
    passengers?: PassengerUpdateManyWithoutBookingNestedInput
    cancellation?: CancellationUpdateOneWithoutOriginalBookingNestedInput
  }

  export type BookingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    folderNo?: IntFieldUpdateOperationsInput | number
    refNo?: StringFieldUpdateOperationsInput | string
    paxName?: StringFieldUpdateOperationsInput | string
    agentName?: StringFieldUpdateOperationsInput | string
    teamName?: NullableEnumTeamsFieldUpdateOperationsInput | $Enums.Teams | null
    pnr?: StringFieldUpdateOperationsInput | string
    airline?: StringFieldUpdateOperationsInput | string
    fromTo?: StringFieldUpdateOperationsInput | string
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    bookingStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    pcDate?: DateTimeFieldUpdateOperationsInput | Date | string
    issuedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    travelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    prodCost?: NullableFloatFieldUpdateOperationsInput | number | null
    transFee?: NullableFloatFieldUpdateOperationsInput | number | null
    surcharge?: NullableFloatFieldUpdateOperationsInput | number | null
    received?: NullableFloatFieldUpdateOperationsInput | number | null
    transactionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    profit?: NullableFloatFieldUpdateOperationsInput | number | null
    invoiced?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    numPax?: IntFieldUpdateOperationsInput | number
    initialDeposit?: NullableFloatFieldUpdateOperationsInput | number | null
    costItems?: CostItemUncheckedUpdateManyWithoutBookingNestedInput
    instalments?: InstalmentUncheckedUpdateManyWithoutBookingNestedInput
    passengers?: PassengerUncheckedUpdateManyWithoutBookingNestedInput
    cancellation?: CancellationUncheckedUpdateOneWithoutOriginalBookingNestedInput
  }

  export type BookingCreateManyInput = {
    id?: number
    folderNo: number
    refNo: string
    paxName: string
    agentName: string
    teamName?: $Enums.Teams | null
    pnr: string
    airline: string
    fromTo: string
    bookingType: $Enums.BookingType
    bookingStatus?: $Enums.BookingStatus | null
    pcDate: Date | string
    issuedDate?: Date | string | null
    paymentMethod: $Enums.PaymentMethod
    lastPaymentDate?: Date | string | null
    travelDate?: Date | string | null
    revenue?: number | null
    prodCost?: number | null
    transFee?: number | null
    surcharge?: number | null
    received?: number | null
    transactionMethod?: string | null
    receivedDate?: Date | string | null
    balance?: number | null
    profit?: number | null
    invoiced?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    numPax: number
    initialDeposit?: number | null
  }

  export type BookingUpdateManyMutationInput = {
    folderNo?: IntFieldUpdateOperationsInput | number
    refNo?: StringFieldUpdateOperationsInput | string
    paxName?: StringFieldUpdateOperationsInput | string
    agentName?: StringFieldUpdateOperationsInput | string
    teamName?: NullableEnumTeamsFieldUpdateOperationsInput | $Enums.Teams | null
    pnr?: StringFieldUpdateOperationsInput | string
    airline?: StringFieldUpdateOperationsInput | string
    fromTo?: StringFieldUpdateOperationsInput | string
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    bookingStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    pcDate?: DateTimeFieldUpdateOperationsInput | Date | string
    issuedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    travelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    prodCost?: NullableFloatFieldUpdateOperationsInput | number | null
    transFee?: NullableFloatFieldUpdateOperationsInput | number | null
    surcharge?: NullableFloatFieldUpdateOperationsInput | number | null
    received?: NullableFloatFieldUpdateOperationsInput | number | null
    transactionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    profit?: NullableFloatFieldUpdateOperationsInput | number | null
    invoiced?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    numPax?: IntFieldUpdateOperationsInput | number
    initialDeposit?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type BookingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    folderNo?: IntFieldUpdateOperationsInput | number
    refNo?: StringFieldUpdateOperationsInput | string
    paxName?: StringFieldUpdateOperationsInput | string
    agentName?: StringFieldUpdateOperationsInput | string
    teamName?: NullableEnumTeamsFieldUpdateOperationsInput | $Enums.Teams | null
    pnr?: StringFieldUpdateOperationsInput | string
    airline?: StringFieldUpdateOperationsInput | string
    fromTo?: StringFieldUpdateOperationsInput | string
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    bookingStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    pcDate?: DateTimeFieldUpdateOperationsInput | Date | string
    issuedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    travelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    prodCost?: NullableFloatFieldUpdateOperationsInput | number | null
    transFee?: NullableFloatFieldUpdateOperationsInput | number | null
    surcharge?: NullableFloatFieldUpdateOperationsInput | number | null
    received?: NullableFloatFieldUpdateOperationsInput | number | null
    transactionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    profit?: NullableFloatFieldUpdateOperationsInput | number | null
    invoiced?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    numPax?: IntFieldUpdateOperationsInput | number
    initialDeposit?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type PendingBookingCreateInput = {
    refNo: string
    paxName: string
    agentName: string
    teamName?: $Enums.Teams | null
    pnr: string
    airline: string
    fromTo: string
    bookingType: $Enums.BookingType
    bookingStatus?: $Enums.BookingStatus | null
    pcDate: Date | string
    issuedDate?: Date | string | null
    paymentMethod: $Enums.PaymentMethod
    lastPaymentDate?: Date | string | null
    travelDate?: Date | string | null
    revenue?: number | null
    prodCost?: number | null
    transFee?: number | null
    surcharge?: number | null
    received?: number | null
    transactionMethod?: string | null
    receivedDate?: Date | string | null
    balance?: number | null
    profit?: number | null
    invoiced?: string | null
    description?: string | null
    status?: $Enums.PendingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    numPax: number
    costItems?: PendingCostItemCreateNestedManyWithoutPendingBookingInput
    instalments?: PendingInstalmentCreateNestedManyWithoutPendingBookingInput
    passengers?: PendingPassengerCreateNestedManyWithoutPendingBookingInput
  }

  export type PendingBookingUncheckedCreateInput = {
    id?: number
    refNo: string
    paxName: string
    agentName: string
    teamName?: $Enums.Teams | null
    pnr: string
    airline: string
    fromTo: string
    bookingType: $Enums.BookingType
    bookingStatus?: $Enums.BookingStatus | null
    pcDate: Date | string
    issuedDate?: Date | string | null
    paymentMethod: $Enums.PaymentMethod
    lastPaymentDate?: Date | string | null
    travelDate?: Date | string | null
    revenue?: number | null
    prodCost?: number | null
    transFee?: number | null
    surcharge?: number | null
    received?: number | null
    transactionMethod?: string | null
    receivedDate?: Date | string | null
    balance?: number | null
    profit?: number | null
    invoiced?: string | null
    description?: string | null
    status?: $Enums.PendingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    numPax: number
    costItems?: PendingCostItemUncheckedCreateNestedManyWithoutPendingBookingInput
    instalments?: PendingInstalmentUncheckedCreateNestedManyWithoutPendingBookingInput
    passengers?: PendingPassengerUncheckedCreateNestedManyWithoutPendingBookingInput
  }

  export type PendingBookingUpdateInput = {
    refNo?: StringFieldUpdateOperationsInput | string
    paxName?: StringFieldUpdateOperationsInput | string
    agentName?: StringFieldUpdateOperationsInput | string
    teamName?: NullableEnumTeamsFieldUpdateOperationsInput | $Enums.Teams | null
    pnr?: StringFieldUpdateOperationsInput | string
    airline?: StringFieldUpdateOperationsInput | string
    fromTo?: StringFieldUpdateOperationsInput | string
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    bookingStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    pcDate?: DateTimeFieldUpdateOperationsInput | Date | string
    issuedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    travelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    prodCost?: NullableFloatFieldUpdateOperationsInput | number | null
    transFee?: NullableFloatFieldUpdateOperationsInput | number | null
    surcharge?: NullableFloatFieldUpdateOperationsInput | number | null
    received?: NullableFloatFieldUpdateOperationsInput | number | null
    transactionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    profit?: NullableFloatFieldUpdateOperationsInput | number | null
    invoiced?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPendingStatusFieldUpdateOperationsInput | $Enums.PendingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    numPax?: IntFieldUpdateOperationsInput | number
    costItems?: PendingCostItemUpdateManyWithoutPendingBookingNestedInput
    instalments?: PendingInstalmentUpdateManyWithoutPendingBookingNestedInput
    passengers?: PendingPassengerUpdateManyWithoutPendingBookingNestedInput
  }

  export type PendingBookingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    refNo?: StringFieldUpdateOperationsInput | string
    paxName?: StringFieldUpdateOperationsInput | string
    agentName?: StringFieldUpdateOperationsInput | string
    teamName?: NullableEnumTeamsFieldUpdateOperationsInput | $Enums.Teams | null
    pnr?: StringFieldUpdateOperationsInput | string
    airline?: StringFieldUpdateOperationsInput | string
    fromTo?: StringFieldUpdateOperationsInput | string
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    bookingStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    pcDate?: DateTimeFieldUpdateOperationsInput | Date | string
    issuedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    travelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    prodCost?: NullableFloatFieldUpdateOperationsInput | number | null
    transFee?: NullableFloatFieldUpdateOperationsInput | number | null
    surcharge?: NullableFloatFieldUpdateOperationsInput | number | null
    received?: NullableFloatFieldUpdateOperationsInput | number | null
    transactionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    profit?: NullableFloatFieldUpdateOperationsInput | number | null
    invoiced?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPendingStatusFieldUpdateOperationsInput | $Enums.PendingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    numPax?: IntFieldUpdateOperationsInput | number
    costItems?: PendingCostItemUncheckedUpdateManyWithoutPendingBookingNestedInput
    instalments?: PendingInstalmentUncheckedUpdateManyWithoutPendingBookingNestedInput
    passengers?: PendingPassengerUncheckedUpdateManyWithoutPendingBookingNestedInput
  }

  export type PendingBookingCreateManyInput = {
    id?: number
    refNo: string
    paxName: string
    agentName: string
    teamName?: $Enums.Teams | null
    pnr: string
    airline: string
    fromTo: string
    bookingType: $Enums.BookingType
    bookingStatus?: $Enums.BookingStatus | null
    pcDate: Date | string
    issuedDate?: Date | string | null
    paymentMethod: $Enums.PaymentMethod
    lastPaymentDate?: Date | string | null
    travelDate?: Date | string | null
    revenue?: number | null
    prodCost?: number | null
    transFee?: number | null
    surcharge?: number | null
    received?: number | null
    transactionMethod?: string | null
    receivedDate?: Date | string | null
    balance?: number | null
    profit?: number | null
    invoiced?: string | null
    description?: string | null
    status?: $Enums.PendingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    numPax: number
  }

  export type PendingBookingUpdateManyMutationInput = {
    refNo?: StringFieldUpdateOperationsInput | string
    paxName?: StringFieldUpdateOperationsInput | string
    agentName?: StringFieldUpdateOperationsInput | string
    teamName?: NullableEnumTeamsFieldUpdateOperationsInput | $Enums.Teams | null
    pnr?: StringFieldUpdateOperationsInput | string
    airline?: StringFieldUpdateOperationsInput | string
    fromTo?: StringFieldUpdateOperationsInput | string
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    bookingStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    pcDate?: DateTimeFieldUpdateOperationsInput | Date | string
    issuedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    travelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    prodCost?: NullableFloatFieldUpdateOperationsInput | number | null
    transFee?: NullableFloatFieldUpdateOperationsInput | number | null
    surcharge?: NullableFloatFieldUpdateOperationsInput | number | null
    received?: NullableFloatFieldUpdateOperationsInput | number | null
    transactionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    profit?: NullableFloatFieldUpdateOperationsInput | number | null
    invoiced?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPendingStatusFieldUpdateOperationsInput | $Enums.PendingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    numPax?: IntFieldUpdateOperationsInput | number
  }

  export type PendingBookingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    refNo?: StringFieldUpdateOperationsInput | string
    paxName?: StringFieldUpdateOperationsInput | string
    agentName?: StringFieldUpdateOperationsInput | string
    teamName?: NullableEnumTeamsFieldUpdateOperationsInput | $Enums.Teams | null
    pnr?: StringFieldUpdateOperationsInput | string
    airline?: StringFieldUpdateOperationsInput | string
    fromTo?: StringFieldUpdateOperationsInput | string
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    bookingStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    pcDate?: DateTimeFieldUpdateOperationsInput | Date | string
    issuedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    travelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    prodCost?: NullableFloatFieldUpdateOperationsInput | number | null
    transFee?: NullableFloatFieldUpdateOperationsInput | number | null
    surcharge?: NullableFloatFieldUpdateOperationsInput | number | null
    received?: NullableFloatFieldUpdateOperationsInput | number | null
    transactionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    profit?: NullableFloatFieldUpdateOperationsInput | number | null
    invoiced?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPendingStatusFieldUpdateOperationsInput | $Enums.PendingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    numPax?: IntFieldUpdateOperationsInput | number
  }

  export type InstalmentCreateInput = {
    dueDate: Date | string
    amount: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    booking: BookingCreateNestedOneWithoutInstalmentsInput
    payments?: InstalmentPaymentCreateNestedManyWithoutInstalmentInput
  }

  export type InstalmentUncheckedCreateInput = {
    id?: number
    bookingId: number
    dueDate: Date | string
    amount: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: InstalmentPaymentUncheckedCreateNestedManyWithoutInstalmentInput
  }

  export type InstalmentUpdateInput = {
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUpdateOneRequiredWithoutInstalmentsNestedInput
    payments?: InstalmentPaymentUpdateManyWithoutInstalmentNestedInput
  }

  export type InstalmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookingId?: IntFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: InstalmentPaymentUncheckedUpdateManyWithoutInstalmentNestedInput
  }

  export type InstalmentCreateManyInput = {
    id?: number
    bookingId: number
    dueDate: Date | string
    amount: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InstalmentUpdateManyMutationInput = {
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstalmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookingId?: IntFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PendingInstalmentCreateInput = {
    dueDate: Date | string
    amount: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    pendingBooking: PendingBookingCreateNestedOneWithoutInstalmentsInput
  }

  export type PendingInstalmentUncheckedCreateInput = {
    id?: number
    pendingBookingId: number
    dueDate: Date | string
    amount: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PendingInstalmentUpdateInput = {
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pendingBooking?: PendingBookingUpdateOneRequiredWithoutInstalmentsNestedInput
  }

  export type PendingInstalmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    pendingBookingId?: IntFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PendingInstalmentCreateManyInput = {
    id?: number
    pendingBookingId: number
    dueDate: Date | string
    amount: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PendingInstalmentUpdateManyMutationInput = {
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PendingInstalmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    pendingBookingId?: IntFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstalmentPaymentCreateInput = {
    amount: number
    transactionMethod: string
    paymentDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    instalment: InstalmentCreateNestedOneWithoutPaymentsInput
  }

  export type InstalmentPaymentUncheckedCreateInput = {
    id?: number
    instalmentId: number
    amount: number
    transactionMethod: string
    paymentDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InstalmentPaymentUpdateInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    transactionMethod?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instalment?: InstalmentUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type InstalmentPaymentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    instalmentId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    transactionMethod?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstalmentPaymentCreateManyInput = {
    id?: number
    instalmentId: number
    amount: number
    transactionMethod: string
    paymentDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InstalmentPaymentUpdateManyMutationInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    transactionMethod?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstalmentPaymentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    instalmentId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    transactionMethod?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    email?: string | null
    title?: string | null
    firstName: string
    lastName: string
    contactNo?: string | null
    role: $Enums.Role
    createdAt?: Date | string
  }

  export type UserUncheckedCreateInput = {
    id?: number
    email?: string | null
    title?: string | null
    firstName: string
    lastName: string
    contactNo?: string | null
    role: $Enums.Role
    createdAt?: Date | string
  }

  export type UserUpdateInput = {
    email?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateManyInput = {
    id?: number
    email?: string | null
    title?: string | null
    firstName: string
    lastName: string
    contactNo?: string | null
    role: $Enums.Role
    createdAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    email?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CostItemCreateInput = {
    category: string
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    booking: BookingCreateNestedOneWithoutCostItemsInput
    suppliers?: CostItemSupplierCreateNestedManyWithoutCostItemInput
  }

  export type CostItemUncheckedCreateInput = {
    id?: number
    bookingId: number
    category: string
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    suppliers?: CostItemSupplierUncheckedCreateNestedManyWithoutCostItemInput
  }

  export type CostItemUpdateInput = {
    category?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUpdateOneRequiredWithoutCostItemsNestedInput
    suppliers?: CostItemSupplierUpdateManyWithoutCostItemNestedInput
  }

  export type CostItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookingId?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    suppliers?: CostItemSupplierUncheckedUpdateManyWithoutCostItemNestedInput
  }

  export type CostItemCreateManyInput = {
    id?: number
    bookingId: number
    category: string
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CostItemUpdateManyMutationInput = {
    category?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CostItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookingId?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PendingCostItemCreateInput = {
    category: string
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    pendingBooking: PendingBookingCreateNestedOneWithoutCostItemsInput
    suppliers?: CostItemSupplierCreateNestedManyWithoutPendingCostItemInput
  }

  export type PendingCostItemUncheckedCreateInput = {
    id?: number
    pendingBookingId: number
    category: string
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    suppliers?: CostItemSupplierUncheckedCreateNestedManyWithoutPendingCostItemInput
  }

  export type PendingCostItemUpdateInput = {
    category?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pendingBooking?: PendingBookingUpdateOneRequiredWithoutCostItemsNestedInput
    suppliers?: CostItemSupplierUpdateManyWithoutPendingCostItemNestedInput
  }

  export type PendingCostItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    pendingBookingId?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    suppliers?: CostItemSupplierUncheckedUpdateManyWithoutPendingCostItemNestedInput
  }

  export type PendingCostItemCreateManyInput = {
    id?: number
    pendingBookingId: number
    category: string
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PendingCostItemUpdateManyMutationInput = {
    category?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PendingCostItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    pendingBookingId?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PassengerCreateInput = {
    title: $Enums.Title
    firstName: string
    middleName?: string | null
    lastName: string
    gender: $Enums.Gender
    email?: string | null
    contactNo?: string | null
    nationality?: string | null
    birthday?: Date | string | null
    category: $Enums.PassengerCategory
    createdAt?: Date | string
    updatedAt?: Date | string
    booking: BookingCreateNestedOneWithoutPassengersInput
  }

  export type PassengerUncheckedCreateInput = {
    id?: number
    bookingId: number
    title: $Enums.Title
    firstName: string
    middleName?: string | null
    lastName: string
    gender: $Enums.Gender
    email?: string | null
    contactNo?: string | null
    nationality?: string | null
    birthday?: Date | string | null
    category: $Enums.PassengerCategory
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PassengerUpdateInput = {
    title?: EnumTitleFieldUpdateOperationsInput | $Enums.Title
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: EnumPassengerCategoryFieldUpdateOperationsInput | $Enums.PassengerCategory
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUpdateOneRequiredWithoutPassengersNestedInput
  }

  export type PassengerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookingId?: IntFieldUpdateOperationsInput | number
    title?: EnumTitleFieldUpdateOperationsInput | $Enums.Title
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: EnumPassengerCategoryFieldUpdateOperationsInput | $Enums.PassengerCategory
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PassengerCreateManyInput = {
    id?: number
    bookingId: number
    title: $Enums.Title
    firstName: string
    middleName?: string | null
    lastName: string
    gender: $Enums.Gender
    email?: string | null
    contactNo?: string | null
    nationality?: string | null
    birthday?: Date | string | null
    category: $Enums.PassengerCategory
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PassengerUpdateManyMutationInput = {
    title?: EnumTitleFieldUpdateOperationsInput | $Enums.Title
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: EnumPassengerCategoryFieldUpdateOperationsInput | $Enums.PassengerCategory
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PassengerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookingId?: IntFieldUpdateOperationsInput | number
    title?: EnumTitleFieldUpdateOperationsInput | $Enums.Title
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: EnumPassengerCategoryFieldUpdateOperationsInput | $Enums.PassengerCategory
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PendingPassengerCreateInput = {
    title: $Enums.Title
    firstName: string
    middleName?: string | null
    lastName: string
    gender: $Enums.Gender
    email?: string | null
    contactNo?: string | null
    nationality?: string | null
    birthday?: Date | string | null
    category: $Enums.PassengerCategory
    createdAt?: Date | string
    updatedAt?: Date | string
    pendingBooking: PendingBookingCreateNestedOneWithoutPassengersInput
  }

  export type PendingPassengerUncheckedCreateInput = {
    id?: number
    pendingBookingId: number
    title: $Enums.Title
    firstName: string
    middleName?: string | null
    lastName: string
    gender: $Enums.Gender
    email?: string | null
    contactNo?: string | null
    nationality?: string | null
    birthday?: Date | string | null
    category: $Enums.PassengerCategory
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PendingPassengerUpdateInput = {
    title?: EnumTitleFieldUpdateOperationsInput | $Enums.Title
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: EnumPassengerCategoryFieldUpdateOperationsInput | $Enums.PassengerCategory
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pendingBooking?: PendingBookingUpdateOneRequiredWithoutPassengersNestedInput
  }

  export type PendingPassengerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    pendingBookingId?: IntFieldUpdateOperationsInput | number
    title?: EnumTitleFieldUpdateOperationsInput | $Enums.Title
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: EnumPassengerCategoryFieldUpdateOperationsInput | $Enums.PassengerCategory
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PendingPassengerCreateManyInput = {
    id?: number
    pendingBookingId: number
    title: $Enums.Title
    firstName: string
    middleName?: string | null
    lastName: string
    gender: $Enums.Gender
    email?: string | null
    contactNo?: string | null
    nationality?: string | null
    birthday?: Date | string | null
    category: $Enums.PassengerCategory
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PendingPassengerUpdateManyMutationInput = {
    title?: EnumTitleFieldUpdateOperationsInput | $Enums.Title
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: EnumPassengerCategoryFieldUpdateOperationsInput | $Enums.PassengerCategory
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PendingPassengerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    pendingBookingId?: IntFieldUpdateOperationsInput | number
    title?: EnumTitleFieldUpdateOperationsInput | $Enums.Title
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: EnumPassengerCategoryFieldUpdateOperationsInput | $Enums.PassengerCategory
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CostItemSupplierCreateInput = {
    supplier: $Enums.Suppliers
    amount: number
    paymentMethod?: string
    paidAmount?: number
    pendingAmount?: number
    transactionMethod?: string | null
    firstMethodAmount?: number | null
    secondMethodAmount?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    costItem?: CostItemCreateNestedOneWithoutSuppliersInput
    pendingCostItem?: PendingCostItemCreateNestedOneWithoutSuppliersInput
    settlements?: SupplierPaymentSettlementCreateNestedManyWithoutCostItemSupplierInput
    paidByCreditNoteUsage?: CreditNoteUsageCreateNestedManyWithoutUsedOnCostItemSupplierInput
  }

  export type CostItemSupplierUncheckedCreateInput = {
    id?: number
    costItemId?: number | null
    pendingCostItemId?: number | null
    supplier: $Enums.Suppliers
    amount: number
    paymentMethod?: string
    paidAmount?: number
    pendingAmount?: number
    transactionMethod?: string | null
    firstMethodAmount?: number | null
    secondMethodAmount?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    settlements?: SupplierPaymentSettlementUncheckedCreateNestedManyWithoutCostItemSupplierInput
    paidByCreditNoteUsage?: CreditNoteUsageUncheckedCreateNestedManyWithoutUsedOnCostItemSupplierInput
  }

  export type CostItemSupplierUpdateInput = {
    supplier?: EnumSuppliersFieldUpdateOperationsInput | $Enums.Suppliers
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: StringFieldUpdateOperationsInput | string
    paidAmount?: FloatFieldUpdateOperationsInput | number
    pendingAmount?: FloatFieldUpdateOperationsInput | number
    transactionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    firstMethodAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    secondMethodAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    costItem?: CostItemUpdateOneWithoutSuppliersNestedInput
    pendingCostItem?: PendingCostItemUpdateOneWithoutSuppliersNestedInput
    settlements?: SupplierPaymentSettlementUpdateManyWithoutCostItemSupplierNestedInput
    paidByCreditNoteUsage?: CreditNoteUsageUpdateManyWithoutUsedOnCostItemSupplierNestedInput
  }

  export type CostItemSupplierUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    costItemId?: NullableIntFieldUpdateOperationsInput | number | null
    pendingCostItemId?: NullableIntFieldUpdateOperationsInput | number | null
    supplier?: EnumSuppliersFieldUpdateOperationsInput | $Enums.Suppliers
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: StringFieldUpdateOperationsInput | string
    paidAmount?: FloatFieldUpdateOperationsInput | number
    pendingAmount?: FloatFieldUpdateOperationsInput | number
    transactionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    firstMethodAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    secondMethodAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settlements?: SupplierPaymentSettlementUncheckedUpdateManyWithoutCostItemSupplierNestedInput
    paidByCreditNoteUsage?: CreditNoteUsageUncheckedUpdateManyWithoutUsedOnCostItemSupplierNestedInput
  }

  export type CostItemSupplierCreateManyInput = {
    id?: number
    costItemId?: number | null
    pendingCostItemId?: number | null
    supplier: $Enums.Suppliers
    amount: number
    paymentMethod?: string
    paidAmount?: number
    pendingAmount?: number
    transactionMethod?: string | null
    firstMethodAmount?: number | null
    secondMethodAmount?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CostItemSupplierUpdateManyMutationInput = {
    supplier?: EnumSuppliersFieldUpdateOperationsInput | $Enums.Suppliers
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: StringFieldUpdateOperationsInput | string
    paidAmount?: FloatFieldUpdateOperationsInput | number
    pendingAmount?: FloatFieldUpdateOperationsInput | number
    transactionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    firstMethodAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    secondMethodAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CostItemSupplierUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    costItemId?: NullableIntFieldUpdateOperationsInput | number | null
    pendingCostItemId?: NullableIntFieldUpdateOperationsInput | number | null
    supplier?: EnumSuppliersFieldUpdateOperationsInput | $Enums.Suppliers
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: StringFieldUpdateOperationsInput | string
    paidAmount?: FloatFieldUpdateOperationsInput | number
    pendingAmount?: FloatFieldUpdateOperationsInput | number
    transactionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    firstMethodAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    secondMethodAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierPaymentSettlementCreateInput = {
    amount: number
    transactionMethod: string
    settlementDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    costItemSupplier: CostItemSupplierCreateNestedOneWithoutSettlementsInput
  }

  export type SupplierPaymentSettlementUncheckedCreateInput = {
    id?: number
    costItemSupplierId: number
    amount: number
    transactionMethod: string
    settlementDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupplierPaymentSettlementUpdateInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    transactionMethod?: StringFieldUpdateOperationsInput | string
    settlementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    costItemSupplier?: CostItemSupplierUpdateOneRequiredWithoutSettlementsNestedInput
  }

  export type SupplierPaymentSettlementUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    costItemSupplierId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    transactionMethod?: StringFieldUpdateOperationsInput | string
    settlementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierPaymentSettlementCreateManyInput = {
    id?: number
    costItemSupplierId: number
    amount: number
    transactionMethod: string
    settlementDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupplierPaymentSettlementUpdateManyMutationInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    transactionMethod?: StringFieldUpdateOperationsInput | string
    settlementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierPaymentSettlementUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    costItemSupplierId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    transactionMethod?: StringFieldUpdateOperationsInput | string
    settlementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CancellationCreateInput = {
    folderNo: string
    refundTransactionMethod: string
    originalRevenue: number
    originalProdCost: number
    supplierCancellationFee: number
    refundToPassenger: number
    creditNoteAmount?: number | null
    profitOrLoss: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    originalBooking: BookingCreateNestedOneWithoutCancellationInput
    generatedCreditNote?: SupplierCreditNoteCreateNestedOneWithoutGeneratedFromCancellationInput
  }

  export type CancellationUncheckedCreateInput = {
    id?: number
    originalBookingId: number
    folderNo: string
    refundTransactionMethod: string
    originalRevenue: number
    originalProdCost: number
    supplierCancellationFee: number
    refundToPassenger: number
    creditNoteAmount?: number | null
    profitOrLoss: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    generatedCreditNote?: SupplierCreditNoteUncheckedCreateNestedOneWithoutGeneratedFromCancellationInput
  }

  export type CancellationUpdateInput = {
    folderNo?: StringFieldUpdateOperationsInput | string
    refundTransactionMethod?: StringFieldUpdateOperationsInput | string
    originalRevenue?: FloatFieldUpdateOperationsInput | number
    originalProdCost?: FloatFieldUpdateOperationsInput | number
    supplierCancellationFee?: FloatFieldUpdateOperationsInput | number
    refundToPassenger?: FloatFieldUpdateOperationsInput | number
    creditNoteAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    profitOrLoss?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    originalBooking?: BookingUpdateOneRequiredWithoutCancellationNestedInput
    generatedCreditNote?: SupplierCreditNoteUpdateOneWithoutGeneratedFromCancellationNestedInput
  }

  export type CancellationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    originalBookingId?: IntFieldUpdateOperationsInput | number
    folderNo?: StringFieldUpdateOperationsInput | string
    refundTransactionMethod?: StringFieldUpdateOperationsInput | string
    originalRevenue?: FloatFieldUpdateOperationsInput | number
    originalProdCost?: FloatFieldUpdateOperationsInput | number
    supplierCancellationFee?: FloatFieldUpdateOperationsInput | number
    refundToPassenger?: FloatFieldUpdateOperationsInput | number
    creditNoteAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    profitOrLoss?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    generatedCreditNote?: SupplierCreditNoteUncheckedUpdateOneWithoutGeneratedFromCancellationNestedInput
  }

  export type CancellationCreateManyInput = {
    id?: number
    originalBookingId: number
    folderNo: string
    refundTransactionMethod: string
    originalRevenue: number
    originalProdCost: number
    supplierCancellationFee: number
    refundToPassenger: number
    creditNoteAmount?: number | null
    profitOrLoss: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CancellationUpdateManyMutationInput = {
    folderNo?: StringFieldUpdateOperationsInput | string
    refundTransactionMethod?: StringFieldUpdateOperationsInput | string
    originalRevenue?: FloatFieldUpdateOperationsInput | number
    originalProdCost?: FloatFieldUpdateOperationsInput | number
    supplierCancellationFee?: FloatFieldUpdateOperationsInput | number
    refundToPassenger?: FloatFieldUpdateOperationsInput | number
    creditNoteAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    profitOrLoss?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CancellationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    originalBookingId?: IntFieldUpdateOperationsInput | number
    folderNo?: StringFieldUpdateOperationsInput | string
    refundTransactionMethod?: StringFieldUpdateOperationsInput | string
    originalRevenue?: FloatFieldUpdateOperationsInput | number
    originalProdCost?: FloatFieldUpdateOperationsInput | number
    supplierCancellationFee?: FloatFieldUpdateOperationsInput | number
    refundToPassenger?: FloatFieldUpdateOperationsInput | number
    creditNoteAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    profitOrLoss?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierCreditNoteCreateInput = {
    supplier: $Enums.Suppliers
    initialAmount: number
    remainingAmount: number
    status?: $Enums.CreditNoteStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    generatedFromCancellation: CancellationCreateNestedOneWithoutGeneratedCreditNoteInput
    usageHistory?: CreditNoteUsageCreateNestedManyWithoutCreditNoteInput
  }

  export type SupplierCreditNoteUncheckedCreateInput = {
    id?: number
    supplier: $Enums.Suppliers
    initialAmount: number
    remainingAmount: number
    status?: $Enums.CreditNoteStatus
    generatedFromCancellationId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    usageHistory?: CreditNoteUsageUncheckedCreateNestedManyWithoutCreditNoteInput
  }

  export type SupplierCreditNoteUpdateInput = {
    supplier?: EnumSuppliersFieldUpdateOperationsInput | $Enums.Suppliers
    initialAmount?: FloatFieldUpdateOperationsInput | number
    remainingAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumCreditNoteStatusFieldUpdateOperationsInput | $Enums.CreditNoteStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    generatedFromCancellation?: CancellationUpdateOneRequiredWithoutGeneratedCreditNoteNestedInput
    usageHistory?: CreditNoteUsageUpdateManyWithoutCreditNoteNestedInput
  }

  export type SupplierCreditNoteUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplier?: EnumSuppliersFieldUpdateOperationsInput | $Enums.Suppliers
    initialAmount?: FloatFieldUpdateOperationsInput | number
    remainingAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumCreditNoteStatusFieldUpdateOperationsInput | $Enums.CreditNoteStatus
    generatedFromCancellationId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usageHistory?: CreditNoteUsageUncheckedUpdateManyWithoutCreditNoteNestedInput
  }

  export type SupplierCreditNoteCreateManyInput = {
    id?: number
    supplier: $Enums.Suppliers
    initialAmount: number
    remainingAmount: number
    status?: $Enums.CreditNoteStatus
    generatedFromCancellationId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupplierCreditNoteUpdateManyMutationInput = {
    supplier?: EnumSuppliersFieldUpdateOperationsInput | $Enums.Suppliers
    initialAmount?: FloatFieldUpdateOperationsInput | number
    remainingAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumCreditNoteStatusFieldUpdateOperationsInput | $Enums.CreditNoteStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierCreditNoteUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplier?: EnumSuppliersFieldUpdateOperationsInput | $Enums.Suppliers
    initialAmount?: FloatFieldUpdateOperationsInput | number
    remainingAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumCreditNoteStatusFieldUpdateOperationsInput | $Enums.CreditNoteStatus
    generatedFromCancellationId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditNoteUsageCreateInput = {
    amountUsed: number
    usedAt?: Date | string
    creditNote: SupplierCreditNoteCreateNestedOneWithoutUsageHistoryInput
    usedOnCostItemSupplier: CostItemSupplierCreateNestedOneWithoutPaidByCreditNoteUsageInput
  }

  export type CreditNoteUsageUncheckedCreateInput = {
    id?: number
    amountUsed: number
    usedAt?: Date | string
    creditNoteId: number
    usedOnCostItemSupplierId: number
  }

  export type CreditNoteUsageUpdateInput = {
    amountUsed?: FloatFieldUpdateOperationsInput | number
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creditNote?: SupplierCreditNoteUpdateOneRequiredWithoutUsageHistoryNestedInput
    usedOnCostItemSupplier?: CostItemSupplierUpdateOneRequiredWithoutPaidByCreditNoteUsageNestedInput
  }

  export type CreditNoteUsageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    amountUsed?: FloatFieldUpdateOperationsInput | number
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creditNoteId?: IntFieldUpdateOperationsInput | number
    usedOnCostItemSupplierId?: IntFieldUpdateOperationsInput | number
  }

  export type CreditNoteUsageCreateManyInput = {
    id?: number
    amountUsed: number
    usedAt?: Date | string
    creditNoteId: number
    usedOnCostItemSupplierId: number
  }

  export type CreditNoteUsageUpdateManyMutationInput = {
    amountUsed?: FloatFieldUpdateOperationsInput | number
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditNoteUsageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    amountUsed?: FloatFieldUpdateOperationsInput | number
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creditNoteId?: IntFieldUpdateOperationsInput | number
    usedOnCostItemSupplierId?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumTeamsNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Teams | EnumTeamsFieldRefInput<$PrismaModel> | null
    in?: $Enums.Teams[] | ListEnumTeamsFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Teams[] | ListEnumTeamsFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTeamsNullableFilter<$PrismaModel> | $Enums.Teams | null
  }

  export type EnumBookingTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingType | EnumBookingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BookingType[] | ListEnumBookingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingType[] | ListEnumBookingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingTypeFilter<$PrismaModel> | $Enums.BookingType
  }

  export type EnumBookingStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumBookingStatusNullableFilter<$PrismaModel> | $Enums.BookingStatus | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type CostItemListRelationFilter = {
    every?: CostItemWhereInput
    some?: CostItemWhereInput
    none?: CostItemWhereInput
  }

  export type InstalmentListRelationFilter = {
    every?: InstalmentWhereInput
    some?: InstalmentWhereInput
    none?: InstalmentWhereInput
  }

  export type PassengerListRelationFilter = {
    every?: PassengerWhereInput
    some?: PassengerWhereInput
    none?: PassengerWhereInput
  }

  export type CancellationNullableScalarRelationFilter = {
    is?: CancellationWhereInput | null
    isNot?: CancellationWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type CostItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InstalmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PassengerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BookingCountOrderByAggregateInput = {
    id?: SortOrder
    folderNo?: SortOrder
    refNo?: SortOrder
    paxName?: SortOrder
    agentName?: SortOrder
    teamName?: SortOrder
    pnr?: SortOrder
    airline?: SortOrder
    fromTo?: SortOrder
    bookingType?: SortOrder
    bookingStatus?: SortOrder
    pcDate?: SortOrder
    issuedDate?: SortOrder
    paymentMethod?: SortOrder
    lastPaymentDate?: SortOrder
    travelDate?: SortOrder
    revenue?: SortOrder
    prodCost?: SortOrder
    transFee?: SortOrder
    surcharge?: SortOrder
    received?: SortOrder
    transactionMethod?: SortOrder
    receivedDate?: SortOrder
    balance?: SortOrder
    profit?: SortOrder
    invoiced?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    numPax?: SortOrder
    initialDeposit?: SortOrder
  }

  export type BookingAvgOrderByAggregateInput = {
    id?: SortOrder
    folderNo?: SortOrder
    revenue?: SortOrder
    prodCost?: SortOrder
    transFee?: SortOrder
    surcharge?: SortOrder
    received?: SortOrder
    balance?: SortOrder
    profit?: SortOrder
    numPax?: SortOrder
    initialDeposit?: SortOrder
  }

  export type BookingMaxOrderByAggregateInput = {
    id?: SortOrder
    folderNo?: SortOrder
    refNo?: SortOrder
    paxName?: SortOrder
    agentName?: SortOrder
    teamName?: SortOrder
    pnr?: SortOrder
    airline?: SortOrder
    fromTo?: SortOrder
    bookingType?: SortOrder
    bookingStatus?: SortOrder
    pcDate?: SortOrder
    issuedDate?: SortOrder
    paymentMethod?: SortOrder
    lastPaymentDate?: SortOrder
    travelDate?: SortOrder
    revenue?: SortOrder
    prodCost?: SortOrder
    transFee?: SortOrder
    surcharge?: SortOrder
    received?: SortOrder
    transactionMethod?: SortOrder
    receivedDate?: SortOrder
    balance?: SortOrder
    profit?: SortOrder
    invoiced?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    numPax?: SortOrder
    initialDeposit?: SortOrder
  }

  export type BookingMinOrderByAggregateInput = {
    id?: SortOrder
    folderNo?: SortOrder
    refNo?: SortOrder
    paxName?: SortOrder
    agentName?: SortOrder
    teamName?: SortOrder
    pnr?: SortOrder
    airline?: SortOrder
    fromTo?: SortOrder
    bookingType?: SortOrder
    bookingStatus?: SortOrder
    pcDate?: SortOrder
    issuedDate?: SortOrder
    paymentMethod?: SortOrder
    lastPaymentDate?: SortOrder
    travelDate?: SortOrder
    revenue?: SortOrder
    prodCost?: SortOrder
    transFee?: SortOrder
    surcharge?: SortOrder
    received?: SortOrder
    transactionMethod?: SortOrder
    receivedDate?: SortOrder
    balance?: SortOrder
    profit?: SortOrder
    invoiced?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    numPax?: SortOrder
    initialDeposit?: SortOrder
  }

  export type BookingSumOrderByAggregateInput = {
    id?: SortOrder
    folderNo?: SortOrder
    revenue?: SortOrder
    prodCost?: SortOrder
    transFee?: SortOrder
    surcharge?: SortOrder
    received?: SortOrder
    balance?: SortOrder
    profit?: SortOrder
    numPax?: SortOrder
    initialDeposit?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumTeamsNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Teams | EnumTeamsFieldRefInput<$PrismaModel> | null
    in?: $Enums.Teams[] | ListEnumTeamsFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Teams[] | ListEnumTeamsFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTeamsNullableWithAggregatesFilter<$PrismaModel> | $Enums.Teams | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumTeamsNullableFilter<$PrismaModel>
    _max?: NestedEnumTeamsNullableFilter<$PrismaModel>
  }

  export type EnumBookingTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingType | EnumBookingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BookingType[] | ListEnumBookingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingType[] | ListEnumBookingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingTypeWithAggregatesFilter<$PrismaModel> | $Enums.BookingType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBookingTypeFilter<$PrismaModel>
    _max?: NestedEnumBookingTypeFilter<$PrismaModel>
  }

  export type EnumBookingStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumBookingStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.BookingStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumBookingStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumBookingStatusNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumPendingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PendingStatus | EnumPendingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PendingStatus[] | ListEnumPendingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PendingStatus[] | ListEnumPendingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPendingStatusFilter<$PrismaModel> | $Enums.PendingStatus
  }

  export type PendingCostItemListRelationFilter = {
    every?: PendingCostItemWhereInput
    some?: PendingCostItemWhereInput
    none?: PendingCostItemWhereInput
  }

  export type PendingInstalmentListRelationFilter = {
    every?: PendingInstalmentWhereInput
    some?: PendingInstalmentWhereInput
    none?: PendingInstalmentWhereInput
  }

  export type PendingPassengerListRelationFilter = {
    every?: PendingPassengerWhereInput
    some?: PendingPassengerWhereInput
    none?: PendingPassengerWhereInput
  }

  export type PendingCostItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PendingInstalmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PendingPassengerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PendingBookingCountOrderByAggregateInput = {
    id?: SortOrder
    refNo?: SortOrder
    paxName?: SortOrder
    agentName?: SortOrder
    teamName?: SortOrder
    pnr?: SortOrder
    airline?: SortOrder
    fromTo?: SortOrder
    bookingType?: SortOrder
    bookingStatus?: SortOrder
    pcDate?: SortOrder
    issuedDate?: SortOrder
    paymentMethod?: SortOrder
    lastPaymentDate?: SortOrder
    travelDate?: SortOrder
    revenue?: SortOrder
    prodCost?: SortOrder
    transFee?: SortOrder
    surcharge?: SortOrder
    received?: SortOrder
    transactionMethod?: SortOrder
    receivedDate?: SortOrder
    balance?: SortOrder
    profit?: SortOrder
    invoiced?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    numPax?: SortOrder
  }

  export type PendingBookingAvgOrderByAggregateInput = {
    id?: SortOrder
    revenue?: SortOrder
    prodCost?: SortOrder
    transFee?: SortOrder
    surcharge?: SortOrder
    received?: SortOrder
    balance?: SortOrder
    profit?: SortOrder
    numPax?: SortOrder
  }

  export type PendingBookingMaxOrderByAggregateInput = {
    id?: SortOrder
    refNo?: SortOrder
    paxName?: SortOrder
    agentName?: SortOrder
    teamName?: SortOrder
    pnr?: SortOrder
    airline?: SortOrder
    fromTo?: SortOrder
    bookingType?: SortOrder
    bookingStatus?: SortOrder
    pcDate?: SortOrder
    issuedDate?: SortOrder
    paymentMethod?: SortOrder
    lastPaymentDate?: SortOrder
    travelDate?: SortOrder
    revenue?: SortOrder
    prodCost?: SortOrder
    transFee?: SortOrder
    surcharge?: SortOrder
    received?: SortOrder
    transactionMethod?: SortOrder
    receivedDate?: SortOrder
    balance?: SortOrder
    profit?: SortOrder
    invoiced?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    numPax?: SortOrder
  }

  export type PendingBookingMinOrderByAggregateInput = {
    id?: SortOrder
    refNo?: SortOrder
    paxName?: SortOrder
    agentName?: SortOrder
    teamName?: SortOrder
    pnr?: SortOrder
    airline?: SortOrder
    fromTo?: SortOrder
    bookingType?: SortOrder
    bookingStatus?: SortOrder
    pcDate?: SortOrder
    issuedDate?: SortOrder
    paymentMethod?: SortOrder
    lastPaymentDate?: SortOrder
    travelDate?: SortOrder
    revenue?: SortOrder
    prodCost?: SortOrder
    transFee?: SortOrder
    surcharge?: SortOrder
    received?: SortOrder
    transactionMethod?: SortOrder
    receivedDate?: SortOrder
    balance?: SortOrder
    profit?: SortOrder
    invoiced?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    numPax?: SortOrder
  }

  export type PendingBookingSumOrderByAggregateInput = {
    id?: SortOrder
    revenue?: SortOrder
    prodCost?: SortOrder
    transFee?: SortOrder
    surcharge?: SortOrder
    received?: SortOrder
    balance?: SortOrder
    profit?: SortOrder
    numPax?: SortOrder
  }

  export type EnumPendingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PendingStatus | EnumPendingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PendingStatus[] | ListEnumPendingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PendingStatus[] | ListEnumPendingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPendingStatusWithAggregatesFilter<$PrismaModel> | $Enums.PendingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPendingStatusFilter<$PrismaModel>
    _max?: NestedEnumPendingStatusFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type BookingScalarRelationFilter = {
    is?: BookingWhereInput
    isNot?: BookingWhereInput
  }

  export type InstalmentPaymentListRelationFilter = {
    every?: InstalmentPaymentWhereInput
    some?: InstalmentPaymentWhereInput
    none?: InstalmentPaymentWhereInput
  }

  export type InstalmentPaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InstalmentCountOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    dueDate?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InstalmentAvgOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    amount?: SortOrder
  }

  export type InstalmentMaxOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    dueDate?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InstalmentMinOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    dueDate?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InstalmentSumOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    amount?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type PendingBookingScalarRelationFilter = {
    is?: PendingBookingWhereInput
    isNot?: PendingBookingWhereInput
  }

  export type PendingInstalmentCountOrderByAggregateInput = {
    id?: SortOrder
    pendingBookingId?: SortOrder
    dueDate?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PendingInstalmentAvgOrderByAggregateInput = {
    id?: SortOrder
    pendingBookingId?: SortOrder
    amount?: SortOrder
  }

  export type PendingInstalmentMaxOrderByAggregateInput = {
    id?: SortOrder
    pendingBookingId?: SortOrder
    dueDate?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PendingInstalmentMinOrderByAggregateInput = {
    id?: SortOrder
    pendingBookingId?: SortOrder
    dueDate?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PendingInstalmentSumOrderByAggregateInput = {
    id?: SortOrder
    pendingBookingId?: SortOrder
    amount?: SortOrder
  }

  export type InstalmentScalarRelationFilter = {
    is?: InstalmentWhereInput
    isNot?: InstalmentWhereInput
  }

  export type InstalmentPaymentCountOrderByAggregateInput = {
    id?: SortOrder
    instalmentId?: SortOrder
    amount?: SortOrder
    transactionMethod?: SortOrder
    paymentDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InstalmentPaymentAvgOrderByAggregateInput = {
    id?: SortOrder
    instalmentId?: SortOrder
    amount?: SortOrder
  }

  export type InstalmentPaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    instalmentId?: SortOrder
    amount?: SortOrder
    transactionMethod?: SortOrder
    paymentDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InstalmentPaymentMinOrderByAggregateInput = {
    id?: SortOrder
    instalmentId?: SortOrder
    amount?: SortOrder
    transactionMethod?: SortOrder
    paymentDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InstalmentPaymentSumOrderByAggregateInput = {
    id?: SortOrder
    instalmentId?: SortOrder
    amount?: SortOrder
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    title?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    contactNo?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    title?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    contactNo?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    title?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    contactNo?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type CostItemSupplierListRelationFilter = {
    every?: CostItemSupplierWhereInput
    some?: CostItemSupplierWhereInput
    none?: CostItemSupplierWhereInput
  }

  export type CostItemSupplierOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CostItemCountOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    category?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CostItemAvgOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    amount?: SortOrder
  }

  export type CostItemMaxOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    category?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CostItemMinOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    category?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CostItemSumOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    amount?: SortOrder
  }

  export type PendingCostItemCountOrderByAggregateInput = {
    id?: SortOrder
    pendingBookingId?: SortOrder
    category?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PendingCostItemAvgOrderByAggregateInput = {
    id?: SortOrder
    pendingBookingId?: SortOrder
    amount?: SortOrder
  }

  export type PendingCostItemMaxOrderByAggregateInput = {
    id?: SortOrder
    pendingBookingId?: SortOrder
    category?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PendingCostItemMinOrderByAggregateInput = {
    id?: SortOrder
    pendingBookingId?: SortOrder
    category?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PendingCostItemSumOrderByAggregateInput = {
    id?: SortOrder
    pendingBookingId?: SortOrder
    amount?: SortOrder
  }

  export type EnumTitleFilter<$PrismaModel = never> = {
    equals?: $Enums.Title | EnumTitleFieldRefInput<$PrismaModel>
    in?: $Enums.Title[] | ListEnumTitleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Title[] | ListEnumTitleFieldRefInput<$PrismaModel>
    not?: NestedEnumTitleFilter<$PrismaModel> | $Enums.Title
  }

  export type EnumGenderFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderFilter<$PrismaModel> | $Enums.Gender
  }

  export type EnumPassengerCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.PassengerCategory | EnumPassengerCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.PassengerCategory[] | ListEnumPassengerCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.PassengerCategory[] | ListEnumPassengerCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumPassengerCategoryFilter<$PrismaModel> | $Enums.PassengerCategory
  }

  export type PassengerCountOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    title?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrder
    lastName?: SortOrder
    gender?: SortOrder
    email?: SortOrder
    contactNo?: SortOrder
    nationality?: SortOrder
    birthday?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PassengerAvgOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
  }

  export type PassengerMaxOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    title?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrder
    lastName?: SortOrder
    gender?: SortOrder
    email?: SortOrder
    contactNo?: SortOrder
    nationality?: SortOrder
    birthday?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PassengerMinOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    title?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrder
    lastName?: SortOrder
    gender?: SortOrder
    email?: SortOrder
    contactNo?: SortOrder
    nationality?: SortOrder
    birthday?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PassengerSumOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
  }

  export type EnumTitleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Title | EnumTitleFieldRefInput<$PrismaModel>
    in?: $Enums.Title[] | ListEnumTitleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Title[] | ListEnumTitleFieldRefInput<$PrismaModel>
    not?: NestedEnumTitleWithAggregatesFilter<$PrismaModel> | $Enums.Title
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTitleFilter<$PrismaModel>
    _max?: NestedEnumTitleFilter<$PrismaModel>
  }

  export type EnumGenderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderWithAggregatesFilter<$PrismaModel> | $Enums.Gender
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGenderFilter<$PrismaModel>
    _max?: NestedEnumGenderFilter<$PrismaModel>
  }

  export type EnumPassengerCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PassengerCategory | EnumPassengerCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.PassengerCategory[] | ListEnumPassengerCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.PassengerCategory[] | ListEnumPassengerCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumPassengerCategoryWithAggregatesFilter<$PrismaModel> | $Enums.PassengerCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPassengerCategoryFilter<$PrismaModel>
    _max?: NestedEnumPassengerCategoryFilter<$PrismaModel>
  }

  export type PendingPassengerCountOrderByAggregateInput = {
    id?: SortOrder
    pendingBookingId?: SortOrder
    title?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrder
    lastName?: SortOrder
    gender?: SortOrder
    email?: SortOrder
    contactNo?: SortOrder
    nationality?: SortOrder
    birthday?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PendingPassengerAvgOrderByAggregateInput = {
    id?: SortOrder
    pendingBookingId?: SortOrder
  }

  export type PendingPassengerMaxOrderByAggregateInput = {
    id?: SortOrder
    pendingBookingId?: SortOrder
    title?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrder
    lastName?: SortOrder
    gender?: SortOrder
    email?: SortOrder
    contactNo?: SortOrder
    nationality?: SortOrder
    birthday?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PendingPassengerMinOrderByAggregateInput = {
    id?: SortOrder
    pendingBookingId?: SortOrder
    title?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrder
    lastName?: SortOrder
    gender?: SortOrder
    email?: SortOrder
    contactNo?: SortOrder
    nationality?: SortOrder
    birthday?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PendingPassengerSumOrderByAggregateInput = {
    id?: SortOrder
    pendingBookingId?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type EnumSuppliersFilter<$PrismaModel = never> = {
    equals?: $Enums.Suppliers | EnumSuppliersFieldRefInput<$PrismaModel>
    in?: $Enums.Suppliers[] | ListEnumSuppliersFieldRefInput<$PrismaModel>
    notIn?: $Enums.Suppliers[] | ListEnumSuppliersFieldRefInput<$PrismaModel>
    not?: NestedEnumSuppliersFilter<$PrismaModel> | $Enums.Suppliers
  }

  export type CostItemNullableScalarRelationFilter = {
    is?: CostItemWhereInput | null
    isNot?: CostItemWhereInput | null
  }

  export type PendingCostItemNullableScalarRelationFilter = {
    is?: PendingCostItemWhereInput | null
    isNot?: PendingCostItemWhereInput | null
  }

  export type SupplierPaymentSettlementListRelationFilter = {
    every?: SupplierPaymentSettlementWhereInput
    some?: SupplierPaymentSettlementWhereInput
    none?: SupplierPaymentSettlementWhereInput
  }

  export type CreditNoteUsageListRelationFilter = {
    every?: CreditNoteUsageWhereInput
    some?: CreditNoteUsageWhereInput
    none?: CreditNoteUsageWhereInput
  }

  export type SupplierPaymentSettlementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CreditNoteUsageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CostItemSupplierCountOrderByAggregateInput = {
    id?: SortOrder
    costItemId?: SortOrder
    pendingCostItemId?: SortOrder
    supplier?: SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrder
    paidAmount?: SortOrder
    pendingAmount?: SortOrder
    transactionMethod?: SortOrder
    firstMethodAmount?: SortOrder
    secondMethodAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CostItemSupplierAvgOrderByAggregateInput = {
    id?: SortOrder
    costItemId?: SortOrder
    pendingCostItemId?: SortOrder
    amount?: SortOrder
    paidAmount?: SortOrder
    pendingAmount?: SortOrder
    firstMethodAmount?: SortOrder
    secondMethodAmount?: SortOrder
  }

  export type CostItemSupplierMaxOrderByAggregateInput = {
    id?: SortOrder
    costItemId?: SortOrder
    pendingCostItemId?: SortOrder
    supplier?: SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrder
    paidAmount?: SortOrder
    pendingAmount?: SortOrder
    transactionMethod?: SortOrder
    firstMethodAmount?: SortOrder
    secondMethodAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CostItemSupplierMinOrderByAggregateInput = {
    id?: SortOrder
    costItemId?: SortOrder
    pendingCostItemId?: SortOrder
    supplier?: SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrder
    paidAmount?: SortOrder
    pendingAmount?: SortOrder
    transactionMethod?: SortOrder
    firstMethodAmount?: SortOrder
    secondMethodAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CostItemSupplierSumOrderByAggregateInput = {
    id?: SortOrder
    costItemId?: SortOrder
    pendingCostItemId?: SortOrder
    amount?: SortOrder
    paidAmount?: SortOrder
    pendingAmount?: SortOrder
    firstMethodAmount?: SortOrder
    secondMethodAmount?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumSuppliersWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Suppliers | EnumSuppliersFieldRefInput<$PrismaModel>
    in?: $Enums.Suppliers[] | ListEnumSuppliersFieldRefInput<$PrismaModel>
    notIn?: $Enums.Suppliers[] | ListEnumSuppliersFieldRefInput<$PrismaModel>
    not?: NestedEnumSuppliersWithAggregatesFilter<$PrismaModel> | $Enums.Suppliers
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSuppliersFilter<$PrismaModel>
    _max?: NestedEnumSuppliersFilter<$PrismaModel>
  }

  export type CostItemSupplierScalarRelationFilter = {
    is?: CostItemSupplierWhereInput
    isNot?: CostItemSupplierWhereInput
  }

  export type SupplierPaymentSettlementCountOrderByAggregateInput = {
    id?: SortOrder
    costItemSupplierId?: SortOrder
    amount?: SortOrder
    transactionMethod?: SortOrder
    settlementDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupplierPaymentSettlementAvgOrderByAggregateInput = {
    id?: SortOrder
    costItemSupplierId?: SortOrder
    amount?: SortOrder
  }

  export type SupplierPaymentSettlementMaxOrderByAggregateInput = {
    id?: SortOrder
    costItemSupplierId?: SortOrder
    amount?: SortOrder
    transactionMethod?: SortOrder
    settlementDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupplierPaymentSettlementMinOrderByAggregateInput = {
    id?: SortOrder
    costItemSupplierId?: SortOrder
    amount?: SortOrder
    transactionMethod?: SortOrder
    settlementDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupplierPaymentSettlementSumOrderByAggregateInput = {
    id?: SortOrder
    costItemSupplierId?: SortOrder
    amount?: SortOrder
  }

  export type SupplierCreditNoteNullableScalarRelationFilter = {
    is?: SupplierCreditNoteWhereInput | null
    isNot?: SupplierCreditNoteWhereInput | null
  }

  export type CancellationCountOrderByAggregateInput = {
    id?: SortOrder
    originalBookingId?: SortOrder
    folderNo?: SortOrder
    refundTransactionMethod?: SortOrder
    originalRevenue?: SortOrder
    originalProdCost?: SortOrder
    supplierCancellationFee?: SortOrder
    refundToPassenger?: SortOrder
    creditNoteAmount?: SortOrder
    profitOrLoss?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CancellationAvgOrderByAggregateInput = {
    id?: SortOrder
    originalBookingId?: SortOrder
    originalRevenue?: SortOrder
    originalProdCost?: SortOrder
    supplierCancellationFee?: SortOrder
    refundToPassenger?: SortOrder
    creditNoteAmount?: SortOrder
    profitOrLoss?: SortOrder
  }

  export type CancellationMaxOrderByAggregateInput = {
    id?: SortOrder
    originalBookingId?: SortOrder
    folderNo?: SortOrder
    refundTransactionMethod?: SortOrder
    originalRevenue?: SortOrder
    originalProdCost?: SortOrder
    supplierCancellationFee?: SortOrder
    refundToPassenger?: SortOrder
    creditNoteAmount?: SortOrder
    profitOrLoss?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CancellationMinOrderByAggregateInput = {
    id?: SortOrder
    originalBookingId?: SortOrder
    folderNo?: SortOrder
    refundTransactionMethod?: SortOrder
    originalRevenue?: SortOrder
    originalProdCost?: SortOrder
    supplierCancellationFee?: SortOrder
    refundToPassenger?: SortOrder
    creditNoteAmount?: SortOrder
    profitOrLoss?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CancellationSumOrderByAggregateInput = {
    id?: SortOrder
    originalBookingId?: SortOrder
    originalRevenue?: SortOrder
    originalProdCost?: SortOrder
    supplierCancellationFee?: SortOrder
    refundToPassenger?: SortOrder
    creditNoteAmount?: SortOrder
    profitOrLoss?: SortOrder
  }

  export type EnumCreditNoteStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CreditNoteStatus | EnumCreditNoteStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CreditNoteStatus[] | ListEnumCreditNoteStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CreditNoteStatus[] | ListEnumCreditNoteStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCreditNoteStatusFilter<$PrismaModel> | $Enums.CreditNoteStatus
  }

  export type CancellationScalarRelationFilter = {
    is?: CancellationWhereInput
    isNot?: CancellationWhereInput
  }

  export type SupplierCreditNoteCountOrderByAggregateInput = {
    id?: SortOrder
    supplier?: SortOrder
    initialAmount?: SortOrder
    remainingAmount?: SortOrder
    status?: SortOrder
    generatedFromCancellationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupplierCreditNoteAvgOrderByAggregateInput = {
    id?: SortOrder
    initialAmount?: SortOrder
    remainingAmount?: SortOrder
    generatedFromCancellationId?: SortOrder
  }

  export type SupplierCreditNoteMaxOrderByAggregateInput = {
    id?: SortOrder
    supplier?: SortOrder
    initialAmount?: SortOrder
    remainingAmount?: SortOrder
    status?: SortOrder
    generatedFromCancellationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupplierCreditNoteMinOrderByAggregateInput = {
    id?: SortOrder
    supplier?: SortOrder
    initialAmount?: SortOrder
    remainingAmount?: SortOrder
    status?: SortOrder
    generatedFromCancellationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupplierCreditNoteSumOrderByAggregateInput = {
    id?: SortOrder
    initialAmount?: SortOrder
    remainingAmount?: SortOrder
    generatedFromCancellationId?: SortOrder
  }

  export type EnumCreditNoteStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CreditNoteStatus | EnumCreditNoteStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CreditNoteStatus[] | ListEnumCreditNoteStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CreditNoteStatus[] | ListEnumCreditNoteStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCreditNoteStatusWithAggregatesFilter<$PrismaModel> | $Enums.CreditNoteStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCreditNoteStatusFilter<$PrismaModel>
    _max?: NestedEnumCreditNoteStatusFilter<$PrismaModel>
  }

  export type SupplierCreditNoteScalarRelationFilter = {
    is?: SupplierCreditNoteWhereInput
    isNot?: SupplierCreditNoteWhereInput
  }

  export type CreditNoteUsageCountOrderByAggregateInput = {
    id?: SortOrder
    amountUsed?: SortOrder
    usedAt?: SortOrder
    creditNoteId?: SortOrder
    usedOnCostItemSupplierId?: SortOrder
  }

  export type CreditNoteUsageAvgOrderByAggregateInput = {
    id?: SortOrder
    amountUsed?: SortOrder
    creditNoteId?: SortOrder
    usedOnCostItemSupplierId?: SortOrder
  }

  export type CreditNoteUsageMaxOrderByAggregateInput = {
    id?: SortOrder
    amountUsed?: SortOrder
    usedAt?: SortOrder
    creditNoteId?: SortOrder
    usedOnCostItemSupplierId?: SortOrder
  }

  export type CreditNoteUsageMinOrderByAggregateInput = {
    id?: SortOrder
    amountUsed?: SortOrder
    usedAt?: SortOrder
    creditNoteId?: SortOrder
    usedOnCostItemSupplierId?: SortOrder
  }

  export type CreditNoteUsageSumOrderByAggregateInput = {
    id?: SortOrder
    amountUsed?: SortOrder
    creditNoteId?: SortOrder
    usedOnCostItemSupplierId?: SortOrder
  }

  export type CostItemCreateNestedManyWithoutBookingInput = {
    create?: XOR<CostItemCreateWithoutBookingInput, CostItemUncheckedCreateWithoutBookingInput> | CostItemCreateWithoutBookingInput[] | CostItemUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: CostItemCreateOrConnectWithoutBookingInput | CostItemCreateOrConnectWithoutBookingInput[]
    createMany?: CostItemCreateManyBookingInputEnvelope
    connect?: CostItemWhereUniqueInput | CostItemWhereUniqueInput[]
  }

  export type InstalmentCreateNestedManyWithoutBookingInput = {
    create?: XOR<InstalmentCreateWithoutBookingInput, InstalmentUncheckedCreateWithoutBookingInput> | InstalmentCreateWithoutBookingInput[] | InstalmentUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: InstalmentCreateOrConnectWithoutBookingInput | InstalmentCreateOrConnectWithoutBookingInput[]
    createMany?: InstalmentCreateManyBookingInputEnvelope
    connect?: InstalmentWhereUniqueInput | InstalmentWhereUniqueInput[]
  }

  export type PassengerCreateNestedManyWithoutBookingInput = {
    create?: XOR<PassengerCreateWithoutBookingInput, PassengerUncheckedCreateWithoutBookingInput> | PassengerCreateWithoutBookingInput[] | PassengerUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: PassengerCreateOrConnectWithoutBookingInput | PassengerCreateOrConnectWithoutBookingInput[]
    createMany?: PassengerCreateManyBookingInputEnvelope
    connect?: PassengerWhereUniqueInput | PassengerWhereUniqueInput[]
  }

  export type CancellationCreateNestedOneWithoutOriginalBookingInput = {
    create?: XOR<CancellationCreateWithoutOriginalBookingInput, CancellationUncheckedCreateWithoutOriginalBookingInput>
    connectOrCreate?: CancellationCreateOrConnectWithoutOriginalBookingInput
    connect?: CancellationWhereUniqueInput
  }

  export type CostItemUncheckedCreateNestedManyWithoutBookingInput = {
    create?: XOR<CostItemCreateWithoutBookingInput, CostItemUncheckedCreateWithoutBookingInput> | CostItemCreateWithoutBookingInput[] | CostItemUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: CostItemCreateOrConnectWithoutBookingInput | CostItemCreateOrConnectWithoutBookingInput[]
    createMany?: CostItemCreateManyBookingInputEnvelope
    connect?: CostItemWhereUniqueInput | CostItemWhereUniqueInput[]
  }

  export type InstalmentUncheckedCreateNestedManyWithoutBookingInput = {
    create?: XOR<InstalmentCreateWithoutBookingInput, InstalmentUncheckedCreateWithoutBookingInput> | InstalmentCreateWithoutBookingInput[] | InstalmentUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: InstalmentCreateOrConnectWithoutBookingInput | InstalmentCreateOrConnectWithoutBookingInput[]
    createMany?: InstalmentCreateManyBookingInputEnvelope
    connect?: InstalmentWhereUniqueInput | InstalmentWhereUniqueInput[]
  }

  export type PassengerUncheckedCreateNestedManyWithoutBookingInput = {
    create?: XOR<PassengerCreateWithoutBookingInput, PassengerUncheckedCreateWithoutBookingInput> | PassengerCreateWithoutBookingInput[] | PassengerUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: PassengerCreateOrConnectWithoutBookingInput | PassengerCreateOrConnectWithoutBookingInput[]
    createMany?: PassengerCreateManyBookingInputEnvelope
    connect?: PassengerWhereUniqueInput | PassengerWhereUniqueInput[]
  }

  export type CancellationUncheckedCreateNestedOneWithoutOriginalBookingInput = {
    create?: XOR<CancellationCreateWithoutOriginalBookingInput, CancellationUncheckedCreateWithoutOriginalBookingInput>
    connectOrCreate?: CancellationCreateOrConnectWithoutOriginalBookingInput
    connect?: CancellationWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableEnumTeamsFieldUpdateOperationsInput = {
    set?: $Enums.Teams | null
  }

  export type EnumBookingTypeFieldUpdateOperationsInput = {
    set?: $Enums.BookingType
  }

  export type NullableEnumBookingStatusFieldUpdateOperationsInput = {
    set?: $Enums.BookingStatus | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EnumPaymentMethodFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMethod
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type CostItemUpdateManyWithoutBookingNestedInput = {
    create?: XOR<CostItemCreateWithoutBookingInput, CostItemUncheckedCreateWithoutBookingInput> | CostItemCreateWithoutBookingInput[] | CostItemUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: CostItemCreateOrConnectWithoutBookingInput | CostItemCreateOrConnectWithoutBookingInput[]
    upsert?: CostItemUpsertWithWhereUniqueWithoutBookingInput | CostItemUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: CostItemCreateManyBookingInputEnvelope
    set?: CostItemWhereUniqueInput | CostItemWhereUniqueInput[]
    disconnect?: CostItemWhereUniqueInput | CostItemWhereUniqueInput[]
    delete?: CostItemWhereUniqueInput | CostItemWhereUniqueInput[]
    connect?: CostItemWhereUniqueInput | CostItemWhereUniqueInput[]
    update?: CostItemUpdateWithWhereUniqueWithoutBookingInput | CostItemUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: CostItemUpdateManyWithWhereWithoutBookingInput | CostItemUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: CostItemScalarWhereInput | CostItemScalarWhereInput[]
  }

  export type InstalmentUpdateManyWithoutBookingNestedInput = {
    create?: XOR<InstalmentCreateWithoutBookingInput, InstalmentUncheckedCreateWithoutBookingInput> | InstalmentCreateWithoutBookingInput[] | InstalmentUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: InstalmentCreateOrConnectWithoutBookingInput | InstalmentCreateOrConnectWithoutBookingInput[]
    upsert?: InstalmentUpsertWithWhereUniqueWithoutBookingInput | InstalmentUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: InstalmentCreateManyBookingInputEnvelope
    set?: InstalmentWhereUniqueInput | InstalmentWhereUniqueInput[]
    disconnect?: InstalmentWhereUniqueInput | InstalmentWhereUniqueInput[]
    delete?: InstalmentWhereUniqueInput | InstalmentWhereUniqueInput[]
    connect?: InstalmentWhereUniqueInput | InstalmentWhereUniqueInput[]
    update?: InstalmentUpdateWithWhereUniqueWithoutBookingInput | InstalmentUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: InstalmentUpdateManyWithWhereWithoutBookingInput | InstalmentUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: InstalmentScalarWhereInput | InstalmentScalarWhereInput[]
  }

  export type PassengerUpdateManyWithoutBookingNestedInput = {
    create?: XOR<PassengerCreateWithoutBookingInput, PassengerUncheckedCreateWithoutBookingInput> | PassengerCreateWithoutBookingInput[] | PassengerUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: PassengerCreateOrConnectWithoutBookingInput | PassengerCreateOrConnectWithoutBookingInput[]
    upsert?: PassengerUpsertWithWhereUniqueWithoutBookingInput | PassengerUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: PassengerCreateManyBookingInputEnvelope
    set?: PassengerWhereUniqueInput | PassengerWhereUniqueInput[]
    disconnect?: PassengerWhereUniqueInput | PassengerWhereUniqueInput[]
    delete?: PassengerWhereUniqueInput | PassengerWhereUniqueInput[]
    connect?: PassengerWhereUniqueInput | PassengerWhereUniqueInput[]
    update?: PassengerUpdateWithWhereUniqueWithoutBookingInput | PassengerUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: PassengerUpdateManyWithWhereWithoutBookingInput | PassengerUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: PassengerScalarWhereInput | PassengerScalarWhereInput[]
  }

  export type CancellationUpdateOneWithoutOriginalBookingNestedInput = {
    create?: XOR<CancellationCreateWithoutOriginalBookingInput, CancellationUncheckedCreateWithoutOriginalBookingInput>
    connectOrCreate?: CancellationCreateOrConnectWithoutOriginalBookingInput
    upsert?: CancellationUpsertWithoutOriginalBookingInput
    disconnect?: CancellationWhereInput | boolean
    delete?: CancellationWhereInput | boolean
    connect?: CancellationWhereUniqueInput
    update?: XOR<XOR<CancellationUpdateToOneWithWhereWithoutOriginalBookingInput, CancellationUpdateWithoutOriginalBookingInput>, CancellationUncheckedUpdateWithoutOriginalBookingInput>
  }

  export type CostItemUncheckedUpdateManyWithoutBookingNestedInput = {
    create?: XOR<CostItemCreateWithoutBookingInput, CostItemUncheckedCreateWithoutBookingInput> | CostItemCreateWithoutBookingInput[] | CostItemUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: CostItemCreateOrConnectWithoutBookingInput | CostItemCreateOrConnectWithoutBookingInput[]
    upsert?: CostItemUpsertWithWhereUniqueWithoutBookingInput | CostItemUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: CostItemCreateManyBookingInputEnvelope
    set?: CostItemWhereUniqueInput | CostItemWhereUniqueInput[]
    disconnect?: CostItemWhereUniqueInput | CostItemWhereUniqueInput[]
    delete?: CostItemWhereUniqueInput | CostItemWhereUniqueInput[]
    connect?: CostItemWhereUniqueInput | CostItemWhereUniqueInput[]
    update?: CostItemUpdateWithWhereUniqueWithoutBookingInput | CostItemUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: CostItemUpdateManyWithWhereWithoutBookingInput | CostItemUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: CostItemScalarWhereInput | CostItemScalarWhereInput[]
  }

  export type InstalmentUncheckedUpdateManyWithoutBookingNestedInput = {
    create?: XOR<InstalmentCreateWithoutBookingInput, InstalmentUncheckedCreateWithoutBookingInput> | InstalmentCreateWithoutBookingInput[] | InstalmentUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: InstalmentCreateOrConnectWithoutBookingInput | InstalmentCreateOrConnectWithoutBookingInput[]
    upsert?: InstalmentUpsertWithWhereUniqueWithoutBookingInput | InstalmentUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: InstalmentCreateManyBookingInputEnvelope
    set?: InstalmentWhereUniqueInput | InstalmentWhereUniqueInput[]
    disconnect?: InstalmentWhereUniqueInput | InstalmentWhereUniqueInput[]
    delete?: InstalmentWhereUniqueInput | InstalmentWhereUniqueInput[]
    connect?: InstalmentWhereUniqueInput | InstalmentWhereUniqueInput[]
    update?: InstalmentUpdateWithWhereUniqueWithoutBookingInput | InstalmentUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: InstalmentUpdateManyWithWhereWithoutBookingInput | InstalmentUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: InstalmentScalarWhereInput | InstalmentScalarWhereInput[]
  }

  export type PassengerUncheckedUpdateManyWithoutBookingNestedInput = {
    create?: XOR<PassengerCreateWithoutBookingInput, PassengerUncheckedCreateWithoutBookingInput> | PassengerCreateWithoutBookingInput[] | PassengerUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: PassengerCreateOrConnectWithoutBookingInput | PassengerCreateOrConnectWithoutBookingInput[]
    upsert?: PassengerUpsertWithWhereUniqueWithoutBookingInput | PassengerUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: PassengerCreateManyBookingInputEnvelope
    set?: PassengerWhereUniqueInput | PassengerWhereUniqueInput[]
    disconnect?: PassengerWhereUniqueInput | PassengerWhereUniqueInput[]
    delete?: PassengerWhereUniqueInput | PassengerWhereUniqueInput[]
    connect?: PassengerWhereUniqueInput | PassengerWhereUniqueInput[]
    update?: PassengerUpdateWithWhereUniqueWithoutBookingInput | PassengerUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: PassengerUpdateManyWithWhereWithoutBookingInput | PassengerUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: PassengerScalarWhereInput | PassengerScalarWhereInput[]
  }

  export type CancellationUncheckedUpdateOneWithoutOriginalBookingNestedInput = {
    create?: XOR<CancellationCreateWithoutOriginalBookingInput, CancellationUncheckedCreateWithoutOriginalBookingInput>
    connectOrCreate?: CancellationCreateOrConnectWithoutOriginalBookingInput
    upsert?: CancellationUpsertWithoutOriginalBookingInput
    disconnect?: CancellationWhereInput | boolean
    delete?: CancellationWhereInput | boolean
    connect?: CancellationWhereUniqueInput
    update?: XOR<XOR<CancellationUpdateToOneWithWhereWithoutOriginalBookingInput, CancellationUpdateWithoutOriginalBookingInput>, CancellationUncheckedUpdateWithoutOriginalBookingInput>
  }

  export type PendingCostItemCreateNestedManyWithoutPendingBookingInput = {
    create?: XOR<PendingCostItemCreateWithoutPendingBookingInput, PendingCostItemUncheckedCreateWithoutPendingBookingInput> | PendingCostItemCreateWithoutPendingBookingInput[] | PendingCostItemUncheckedCreateWithoutPendingBookingInput[]
    connectOrCreate?: PendingCostItemCreateOrConnectWithoutPendingBookingInput | PendingCostItemCreateOrConnectWithoutPendingBookingInput[]
    createMany?: PendingCostItemCreateManyPendingBookingInputEnvelope
    connect?: PendingCostItemWhereUniqueInput | PendingCostItemWhereUniqueInput[]
  }

  export type PendingInstalmentCreateNestedManyWithoutPendingBookingInput = {
    create?: XOR<PendingInstalmentCreateWithoutPendingBookingInput, PendingInstalmentUncheckedCreateWithoutPendingBookingInput> | PendingInstalmentCreateWithoutPendingBookingInput[] | PendingInstalmentUncheckedCreateWithoutPendingBookingInput[]
    connectOrCreate?: PendingInstalmentCreateOrConnectWithoutPendingBookingInput | PendingInstalmentCreateOrConnectWithoutPendingBookingInput[]
    createMany?: PendingInstalmentCreateManyPendingBookingInputEnvelope
    connect?: PendingInstalmentWhereUniqueInput | PendingInstalmentWhereUniqueInput[]
  }

  export type PendingPassengerCreateNestedManyWithoutPendingBookingInput = {
    create?: XOR<PendingPassengerCreateWithoutPendingBookingInput, PendingPassengerUncheckedCreateWithoutPendingBookingInput> | PendingPassengerCreateWithoutPendingBookingInput[] | PendingPassengerUncheckedCreateWithoutPendingBookingInput[]
    connectOrCreate?: PendingPassengerCreateOrConnectWithoutPendingBookingInput | PendingPassengerCreateOrConnectWithoutPendingBookingInput[]
    createMany?: PendingPassengerCreateManyPendingBookingInputEnvelope
    connect?: PendingPassengerWhereUniqueInput | PendingPassengerWhereUniqueInput[]
  }

  export type PendingCostItemUncheckedCreateNestedManyWithoutPendingBookingInput = {
    create?: XOR<PendingCostItemCreateWithoutPendingBookingInput, PendingCostItemUncheckedCreateWithoutPendingBookingInput> | PendingCostItemCreateWithoutPendingBookingInput[] | PendingCostItemUncheckedCreateWithoutPendingBookingInput[]
    connectOrCreate?: PendingCostItemCreateOrConnectWithoutPendingBookingInput | PendingCostItemCreateOrConnectWithoutPendingBookingInput[]
    createMany?: PendingCostItemCreateManyPendingBookingInputEnvelope
    connect?: PendingCostItemWhereUniqueInput | PendingCostItemWhereUniqueInput[]
  }

  export type PendingInstalmentUncheckedCreateNestedManyWithoutPendingBookingInput = {
    create?: XOR<PendingInstalmentCreateWithoutPendingBookingInput, PendingInstalmentUncheckedCreateWithoutPendingBookingInput> | PendingInstalmentCreateWithoutPendingBookingInput[] | PendingInstalmentUncheckedCreateWithoutPendingBookingInput[]
    connectOrCreate?: PendingInstalmentCreateOrConnectWithoutPendingBookingInput | PendingInstalmentCreateOrConnectWithoutPendingBookingInput[]
    createMany?: PendingInstalmentCreateManyPendingBookingInputEnvelope
    connect?: PendingInstalmentWhereUniqueInput | PendingInstalmentWhereUniqueInput[]
  }

  export type PendingPassengerUncheckedCreateNestedManyWithoutPendingBookingInput = {
    create?: XOR<PendingPassengerCreateWithoutPendingBookingInput, PendingPassengerUncheckedCreateWithoutPendingBookingInput> | PendingPassengerCreateWithoutPendingBookingInput[] | PendingPassengerUncheckedCreateWithoutPendingBookingInput[]
    connectOrCreate?: PendingPassengerCreateOrConnectWithoutPendingBookingInput | PendingPassengerCreateOrConnectWithoutPendingBookingInput[]
    createMany?: PendingPassengerCreateManyPendingBookingInputEnvelope
    connect?: PendingPassengerWhereUniqueInput | PendingPassengerWhereUniqueInput[]
  }

  export type EnumPendingStatusFieldUpdateOperationsInput = {
    set?: $Enums.PendingStatus
  }

  export type PendingCostItemUpdateManyWithoutPendingBookingNestedInput = {
    create?: XOR<PendingCostItemCreateWithoutPendingBookingInput, PendingCostItemUncheckedCreateWithoutPendingBookingInput> | PendingCostItemCreateWithoutPendingBookingInput[] | PendingCostItemUncheckedCreateWithoutPendingBookingInput[]
    connectOrCreate?: PendingCostItemCreateOrConnectWithoutPendingBookingInput | PendingCostItemCreateOrConnectWithoutPendingBookingInput[]
    upsert?: PendingCostItemUpsertWithWhereUniqueWithoutPendingBookingInput | PendingCostItemUpsertWithWhereUniqueWithoutPendingBookingInput[]
    createMany?: PendingCostItemCreateManyPendingBookingInputEnvelope
    set?: PendingCostItemWhereUniqueInput | PendingCostItemWhereUniqueInput[]
    disconnect?: PendingCostItemWhereUniqueInput | PendingCostItemWhereUniqueInput[]
    delete?: PendingCostItemWhereUniqueInput | PendingCostItemWhereUniqueInput[]
    connect?: PendingCostItemWhereUniqueInput | PendingCostItemWhereUniqueInput[]
    update?: PendingCostItemUpdateWithWhereUniqueWithoutPendingBookingInput | PendingCostItemUpdateWithWhereUniqueWithoutPendingBookingInput[]
    updateMany?: PendingCostItemUpdateManyWithWhereWithoutPendingBookingInput | PendingCostItemUpdateManyWithWhereWithoutPendingBookingInput[]
    deleteMany?: PendingCostItemScalarWhereInput | PendingCostItemScalarWhereInput[]
  }

  export type PendingInstalmentUpdateManyWithoutPendingBookingNestedInput = {
    create?: XOR<PendingInstalmentCreateWithoutPendingBookingInput, PendingInstalmentUncheckedCreateWithoutPendingBookingInput> | PendingInstalmentCreateWithoutPendingBookingInput[] | PendingInstalmentUncheckedCreateWithoutPendingBookingInput[]
    connectOrCreate?: PendingInstalmentCreateOrConnectWithoutPendingBookingInput | PendingInstalmentCreateOrConnectWithoutPendingBookingInput[]
    upsert?: PendingInstalmentUpsertWithWhereUniqueWithoutPendingBookingInput | PendingInstalmentUpsertWithWhereUniqueWithoutPendingBookingInput[]
    createMany?: PendingInstalmentCreateManyPendingBookingInputEnvelope
    set?: PendingInstalmentWhereUniqueInput | PendingInstalmentWhereUniqueInput[]
    disconnect?: PendingInstalmentWhereUniqueInput | PendingInstalmentWhereUniqueInput[]
    delete?: PendingInstalmentWhereUniqueInput | PendingInstalmentWhereUniqueInput[]
    connect?: PendingInstalmentWhereUniqueInput | PendingInstalmentWhereUniqueInput[]
    update?: PendingInstalmentUpdateWithWhereUniqueWithoutPendingBookingInput | PendingInstalmentUpdateWithWhereUniqueWithoutPendingBookingInput[]
    updateMany?: PendingInstalmentUpdateManyWithWhereWithoutPendingBookingInput | PendingInstalmentUpdateManyWithWhereWithoutPendingBookingInput[]
    deleteMany?: PendingInstalmentScalarWhereInput | PendingInstalmentScalarWhereInput[]
  }

  export type PendingPassengerUpdateManyWithoutPendingBookingNestedInput = {
    create?: XOR<PendingPassengerCreateWithoutPendingBookingInput, PendingPassengerUncheckedCreateWithoutPendingBookingInput> | PendingPassengerCreateWithoutPendingBookingInput[] | PendingPassengerUncheckedCreateWithoutPendingBookingInput[]
    connectOrCreate?: PendingPassengerCreateOrConnectWithoutPendingBookingInput | PendingPassengerCreateOrConnectWithoutPendingBookingInput[]
    upsert?: PendingPassengerUpsertWithWhereUniqueWithoutPendingBookingInput | PendingPassengerUpsertWithWhereUniqueWithoutPendingBookingInput[]
    createMany?: PendingPassengerCreateManyPendingBookingInputEnvelope
    set?: PendingPassengerWhereUniqueInput | PendingPassengerWhereUniqueInput[]
    disconnect?: PendingPassengerWhereUniqueInput | PendingPassengerWhereUniqueInput[]
    delete?: PendingPassengerWhereUniqueInput | PendingPassengerWhereUniqueInput[]
    connect?: PendingPassengerWhereUniqueInput | PendingPassengerWhereUniqueInput[]
    update?: PendingPassengerUpdateWithWhereUniqueWithoutPendingBookingInput | PendingPassengerUpdateWithWhereUniqueWithoutPendingBookingInput[]
    updateMany?: PendingPassengerUpdateManyWithWhereWithoutPendingBookingInput | PendingPassengerUpdateManyWithWhereWithoutPendingBookingInput[]
    deleteMany?: PendingPassengerScalarWhereInput | PendingPassengerScalarWhereInput[]
  }

  export type PendingCostItemUncheckedUpdateManyWithoutPendingBookingNestedInput = {
    create?: XOR<PendingCostItemCreateWithoutPendingBookingInput, PendingCostItemUncheckedCreateWithoutPendingBookingInput> | PendingCostItemCreateWithoutPendingBookingInput[] | PendingCostItemUncheckedCreateWithoutPendingBookingInput[]
    connectOrCreate?: PendingCostItemCreateOrConnectWithoutPendingBookingInput | PendingCostItemCreateOrConnectWithoutPendingBookingInput[]
    upsert?: PendingCostItemUpsertWithWhereUniqueWithoutPendingBookingInput | PendingCostItemUpsertWithWhereUniqueWithoutPendingBookingInput[]
    createMany?: PendingCostItemCreateManyPendingBookingInputEnvelope
    set?: PendingCostItemWhereUniqueInput | PendingCostItemWhereUniqueInput[]
    disconnect?: PendingCostItemWhereUniqueInput | PendingCostItemWhereUniqueInput[]
    delete?: PendingCostItemWhereUniqueInput | PendingCostItemWhereUniqueInput[]
    connect?: PendingCostItemWhereUniqueInput | PendingCostItemWhereUniqueInput[]
    update?: PendingCostItemUpdateWithWhereUniqueWithoutPendingBookingInput | PendingCostItemUpdateWithWhereUniqueWithoutPendingBookingInput[]
    updateMany?: PendingCostItemUpdateManyWithWhereWithoutPendingBookingInput | PendingCostItemUpdateManyWithWhereWithoutPendingBookingInput[]
    deleteMany?: PendingCostItemScalarWhereInput | PendingCostItemScalarWhereInput[]
  }

  export type PendingInstalmentUncheckedUpdateManyWithoutPendingBookingNestedInput = {
    create?: XOR<PendingInstalmentCreateWithoutPendingBookingInput, PendingInstalmentUncheckedCreateWithoutPendingBookingInput> | PendingInstalmentCreateWithoutPendingBookingInput[] | PendingInstalmentUncheckedCreateWithoutPendingBookingInput[]
    connectOrCreate?: PendingInstalmentCreateOrConnectWithoutPendingBookingInput | PendingInstalmentCreateOrConnectWithoutPendingBookingInput[]
    upsert?: PendingInstalmentUpsertWithWhereUniqueWithoutPendingBookingInput | PendingInstalmentUpsertWithWhereUniqueWithoutPendingBookingInput[]
    createMany?: PendingInstalmentCreateManyPendingBookingInputEnvelope
    set?: PendingInstalmentWhereUniqueInput | PendingInstalmentWhereUniqueInput[]
    disconnect?: PendingInstalmentWhereUniqueInput | PendingInstalmentWhereUniqueInput[]
    delete?: PendingInstalmentWhereUniqueInput | PendingInstalmentWhereUniqueInput[]
    connect?: PendingInstalmentWhereUniqueInput | PendingInstalmentWhereUniqueInput[]
    update?: PendingInstalmentUpdateWithWhereUniqueWithoutPendingBookingInput | PendingInstalmentUpdateWithWhereUniqueWithoutPendingBookingInput[]
    updateMany?: PendingInstalmentUpdateManyWithWhereWithoutPendingBookingInput | PendingInstalmentUpdateManyWithWhereWithoutPendingBookingInput[]
    deleteMany?: PendingInstalmentScalarWhereInput | PendingInstalmentScalarWhereInput[]
  }

  export type PendingPassengerUncheckedUpdateManyWithoutPendingBookingNestedInput = {
    create?: XOR<PendingPassengerCreateWithoutPendingBookingInput, PendingPassengerUncheckedCreateWithoutPendingBookingInput> | PendingPassengerCreateWithoutPendingBookingInput[] | PendingPassengerUncheckedCreateWithoutPendingBookingInput[]
    connectOrCreate?: PendingPassengerCreateOrConnectWithoutPendingBookingInput | PendingPassengerCreateOrConnectWithoutPendingBookingInput[]
    upsert?: PendingPassengerUpsertWithWhereUniqueWithoutPendingBookingInput | PendingPassengerUpsertWithWhereUniqueWithoutPendingBookingInput[]
    createMany?: PendingPassengerCreateManyPendingBookingInputEnvelope
    set?: PendingPassengerWhereUniqueInput | PendingPassengerWhereUniqueInput[]
    disconnect?: PendingPassengerWhereUniqueInput | PendingPassengerWhereUniqueInput[]
    delete?: PendingPassengerWhereUniqueInput | PendingPassengerWhereUniqueInput[]
    connect?: PendingPassengerWhereUniqueInput | PendingPassengerWhereUniqueInput[]
    update?: PendingPassengerUpdateWithWhereUniqueWithoutPendingBookingInput | PendingPassengerUpdateWithWhereUniqueWithoutPendingBookingInput[]
    updateMany?: PendingPassengerUpdateManyWithWhereWithoutPendingBookingInput | PendingPassengerUpdateManyWithWhereWithoutPendingBookingInput[]
    deleteMany?: PendingPassengerScalarWhereInput | PendingPassengerScalarWhereInput[]
  }

  export type BookingCreateNestedOneWithoutInstalmentsInput = {
    create?: XOR<BookingCreateWithoutInstalmentsInput, BookingUncheckedCreateWithoutInstalmentsInput>
    connectOrCreate?: BookingCreateOrConnectWithoutInstalmentsInput
    connect?: BookingWhereUniqueInput
  }

  export type InstalmentPaymentCreateNestedManyWithoutInstalmentInput = {
    create?: XOR<InstalmentPaymentCreateWithoutInstalmentInput, InstalmentPaymentUncheckedCreateWithoutInstalmentInput> | InstalmentPaymentCreateWithoutInstalmentInput[] | InstalmentPaymentUncheckedCreateWithoutInstalmentInput[]
    connectOrCreate?: InstalmentPaymentCreateOrConnectWithoutInstalmentInput | InstalmentPaymentCreateOrConnectWithoutInstalmentInput[]
    createMany?: InstalmentPaymentCreateManyInstalmentInputEnvelope
    connect?: InstalmentPaymentWhereUniqueInput | InstalmentPaymentWhereUniqueInput[]
  }

  export type InstalmentPaymentUncheckedCreateNestedManyWithoutInstalmentInput = {
    create?: XOR<InstalmentPaymentCreateWithoutInstalmentInput, InstalmentPaymentUncheckedCreateWithoutInstalmentInput> | InstalmentPaymentCreateWithoutInstalmentInput[] | InstalmentPaymentUncheckedCreateWithoutInstalmentInput[]
    connectOrCreate?: InstalmentPaymentCreateOrConnectWithoutInstalmentInput | InstalmentPaymentCreateOrConnectWithoutInstalmentInput[]
    createMany?: InstalmentPaymentCreateManyInstalmentInputEnvelope
    connect?: InstalmentPaymentWhereUniqueInput | InstalmentPaymentWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BookingUpdateOneRequiredWithoutInstalmentsNestedInput = {
    create?: XOR<BookingCreateWithoutInstalmentsInput, BookingUncheckedCreateWithoutInstalmentsInput>
    connectOrCreate?: BookingCreateOrConnectWithoutInstalmentsInput
    upsert?: BookingUpsertWithoutInstalmentsInput
    connect?: BookingWhereUniqueInput
    update?: XOR<XOR<BookingUpdateToOneWithWhereWithoutInstalmentsInput, BookingUpdateWithoutInstalmentsInput>, BookingUncheckedUpdateWithoutInstalmentsInput>
  }

  export type InstalmentPaymentUpdateManyWithoutInstalmentNestedInput = {
    create?: XOR<InstalmentPaymentCreateWithoutInstalmentInput, InstalmentPaymentUncheckedCreateWithoutInstalmentInput> | InstalmentPaymentCreateWithoutInstalmentInput[] | InstalmentPaymentUncheckedCreateWithoutInstalmentInput[]
    connectOrCreate?: InstalmentPaymentCreateOrConnectWithoutInstalmentInput | InstalmentPaymentCreateOrConnectWithoutInstalmentInput[]
    upsert?: InstalmentPaymentUpsertWithWhereUniqueWithoutInstalmentInput | InstalmentPaymentUpsertWithWhereUniqueWithoutInstalmentInput[]
    createMany?: InstalmentPaymentCreateManyInstalmentInputEnvelope
    set?: InstalmentPaymentWhereUniqueInput | InstalmentPaymentWhereUniqueInput[]
    disconnect?: InstalmentPaymentWhereUniqueInput | InstalmentPaymentWhereUniqueInput[]
    delete?: InstalmentPaymentWhereUniqueInput | InstalmentPaymentWhereUniqueInput[]
    connect?: InstalmentPaymentWhereUniqueInput | InstalmentPaymentWhereUniqueInput[]
    update?: InstalmentPaymentUpdateWithWhereUniqueWithoutInstalmentInput | InstalmentPaymentUpdateWithWhereUniqueWithoutInstalmentInput[]
    updateMany?: InstalmentPaymentUpdateManyWithWhereWithoutInstalmentInput | InstalmentPaymentUpdateManyWithWhereWithoutInstalmentInput[]
    deleteMany?: InstalmentPaymentScalarWhereInput | InstalmentPaymentScalarWhereInput[]
  }

  export type InstalmentPaymentUncheckedUpdateManyWithoutInstalmentNestedInput = {
    create?: XOR<InstalmentPaymentCreateWithoutInstalmentInput, InstalmentPaymentUncheckedCreateWithoutInstalmentInput> | InstalmentPaymentCreateWithoutInstalmentInput[] | InstalmentPaymentUncheckedCreateWithoutInstalmentInput[]
    connectOrCreate?: InstalmentPaymentCreateOrConnectWithoutInstalmentInput | InstalmentPaymentCreateOrConnectWithoutInstalmentInput[]
    upsert?: InstalmentPaymentUpsertWithWhereUniqueWithoutInstalmentInput | InstalmentPaymentUpsertWithWhereUniqueWithoutInstalmentInput[]
    createMany?: InstalmentPaymentCreateManyInstalmentInputEnvelope
    set?: InstalmentPaymentWhereUniqueInput | InstalmentPaymentWhereUniqueInput[]
    disconnect?: InstalmentPaymentWhereUniqueInput | InstalmentPaymentWhereUniqueInput[]
    delete?: InstalmentPaymentWhereUniqueInput | InstalmentPaymentWhereUniqueInput[]
    connect?: InstalmentPaymentWhereUniqueInput | InstalmentPaymentWhereUniqueInput[]
    update?: InstalmentPaymentUpdateWithWhereUniqueWithoutInstalmentInput | InstalmentPaymentUpdateWithWhereUniqueWithoutInstalmentInput[]
    updateMany?: InstalmentPaymentUpdateManyWithWhereWithoutInstalmentInput | InstalmentPaymentUpdateManyWithWhereWithoutInstalmentInput[]
    deleteMany?: InstalmentPaymentScalarWhereInput | InstalmentPaymentScalarWhereInput[]
  }

  export type PendingBookingCreateNestedOneWithoutInstalmentsInput = {
    create?: XOR<PendingBookingCreateWithoutInstalmentsInput, PendingBookingUncheckedCreateWithoutInstalmentsInput>
    connectOrCreate?: PendingBookingCreateOrConnectWithoutInstalmentsInput
    connect?: PendingBookingWhereUniqueInput
  }

  export type PendingBookingUpdateOneRequiredWithoutInstalmentsNestedInput = {
    create?: XOR<PendingBookingCreateWithoutInstalmentsInput, PendingBookingUncheckedCreateWithoutInstalmentsInput>
    connectOrCreate?: PendingBookingCreateOrConnectWithoutInstalmentsInput
    upsert?: PendingBookingUpsertWithoutInstalmentsInput
    connect?: PendingBookingWhereUniqueInput
    update?: XOR<XOR<PendingBookingUpdateToOneWithWhereWithoutInstalmentsInput, PendingBookingUpdateWithoutInstalmentsInput>, PendingBookingUncheckedUpdateWithoutInstalmentsInput>
  }

  export type InstalmentCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<InstalmentCreateWithoutPaymentsInput, InstalmentUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: InstalmentCreateOrConnectWithoutPaymentsInput
    connect?: InstalmentWhereUniqueInput
  }

  export type InstalmentUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<InstalmentCreateWithoutPaymentsInput, InstalmentUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: InstalmentCreateOrConnectWithoutPaymentsInput
    upsert?: InstalmentUpsertWithoutPaymentsInput
    connect?: InstalmentWhereUniqueInput
    update?: XOR<XOR<InstalmentUpdateToOneWithWhereWithoutPaymentsInput, InstalmentUpdateWithoutPaymentsInput>, InstalmentUncheckedUpdateWithoutPaymentsInput>
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type BookingCreateNestedOneWithoutCostItemsInput = {
    create?: XOR<BookingCreateWithoutCostItemsInput, BookingUncheckedCreateWithoutCostItemsInput>
    connectOrCreate?: BookingCreateOrConnectWithoutCostItemsInput
    connect?: BookingWhereUniqueInput
  }

  export type CostItemSupplierCreateNestedManyWithoutCostItemInput = {
    create?: XOR<CostItemSupplierCreateWithoutCostItemInput, CostItemSupplierUncheckedCreateWithoutCostItemInput> | CostItemSupplierCreateWithoutCostItemInput[] | CostItemSupplierUncheckedCreateWithoutCostItemInput[]
    connectOrCreate?: CostItemSupplierCreateOrConnectWithoutCostItemInput | CostItemSupplierCreateOrConnectWithoutCostItemInput[]
    createMany?: CostItemSupplierCreateManyCostItemInputEnvelope
    connect?: CostItemSupplierWhereUniqueInput | CostItemSupplierWhereUniqueInput[]
  }

  export type CostItemSupplierUncheckedCreateNestedManyWithoutCostItemInput = {
    create?: XOR<CostItemSupplierCreateWithoutCostItemInput, CostItemSupplierUncheckedCreateWithoutCostItemInput> | CostItemSupplierCreateWithoutCostItemInput[] | CostItemSupplierUncheckedCreateWithoutCostItemInput[]
    connectOrCreate?: CostItemSupplierCreateOrConnectWithoutCostItemInput | CostItemSupplierCreateOrConnectWithoutCostItemInput[]
    createMany?: CostItemSupplierCreateManyCostItemInputEnvelope
    connect?: CostItemSupplierWhereUniqueInput | CostItemSupplierWhereUniqueInput[]
  }

  export type BookingUpdateOneRequiredWithoutCostItemsNestedInput = {
    create?: XOR<BookingCreateWithoutCostItemsInput, BookingUncheckedCreateWithoutCostItemsInput>
    connectOrCreate?: BookingCreateOrConnectWithoutCostItemsInput
    upsert?: BookingUpsertWithoutCostItemsInput
    connect?: BookingWhereUniqueInput
    update?: XOR<XOR<BookingUpdateToOneWithWhereWithoutCostItemsInput, BookingUpdateWithoutCostItemsInput>, BookingUncheckedUpdateWithoutCostItemsInput>
  }

  export type CostItemSupplierUpdateManyWithoutCostItemNestedInput = {
    create?: XOR<CostItemSupplierCreateWithoutCostItemInput, CostItemSupplierUncheckedCreateWithoutCostItemInput> | CostItemSupplierCreateWithoutCostItemInput[] | CostItemSupplierUncheckedCreateWithoutCostItemInput[]
    connectOrCreate?: CostItemSupplierCreateOrConnectWithoutCostItemInput | CostItemSupplierCreateOrConnectWithoutCostItemInput[]
    upsert?: CostItemSupplierUpsertWithWhereUniqueWithoutCostItemInput | CostItemSupplierUpsertWithWhereUniqueWithoutCostItemInput[]
    createMany?: CostItemSupplierCreateManyCostItemInputEnvelope
    set?: CostItemSupplierWhereUniqueInput | CostItemSupplierWhereUniqueInput[]
    disconnect?: CostItemSupplierWhereUniqueInput | CostItemSupplierWhereUniqueInput[]
    delete?: CostItemSupplierWhereUniqueInput | CostItemSupplierWhereUniqueInput[]
    connect?: CostItemSupplierWhereUniqueInput | CostItemSupplierWhereUniqueInput[]
    update?: CostItemSupplierUpdateWithWhereUniqueWithoutCostItemInput | CostItemSupplierUpdateWithWhereUniqueWithoutCostItemInput[]
    updateMany?: CostItemSupplierUpdateManyWithWhereWithoutCostItemInput | CostItemSupplierUpdateManyWithWhereWithoutCostItemInput[]
    deleteMany?: CostItemSupplierScalarWhereInput | CostItemSupplierScalarWhereInput[]
  }

  export type CostItemSupplierUncheckedUpdateManyWithoutCostItemNestedInput = {
    create?: XOR<CostItemSupplierCreateWithoutCostItemInput, CostItemSupplierUncheckedCreateWithoutCostItemInput> | CostItemSupplierCreateWithoutCostItemInput[] | CostItemSupplierUncheckedCreateWithoutCostItemInput[]
    connectOrCreate?: CostItemSupplierCreateOrConnectWithoutCostItemInput | CostItemSupplierCreateOrConnectWithoutCostItemInput[]
    upsert?: CostItemSupplierUpsertWithWhereUniqueWithoutCostItemInput | CostItemSupplierUpsertWithWhereUniqueWithoutCostItemInput[]
    createMany?: CostItemSupplierCreateManyCostItemInputEnvelope
    set?: CostItemSupplierWhereUniqueInput | CostItemSupplierWhereUniqueInput[]
    disconnect?: CostItemSupplierWhereUniqueInput | CostItemSupplierWhereUniqueInput[]
    delete?: CostItemSupplierWhereUniqueInput | CostItemSupplierWhereUniqueInput[]
    connect?: CostItemSupplierWhereUniqueInput | CostItemSupplierWhereUniqueInput[]
    update?: CostItemSupplierUpdateWithWhereUniqueWithoutCostItemInput | CostItemSupplierUpdateWithWhereUniqueWithoutCostItemInput[]
    updateMany?: CostItemSupplierUpdateManyWithWhereWithoutCostItemInput | CostItemSupplierUpdateManyWithWhereWithoutCostItemInput[]
    deleteMany?: CostItemSupplierScalarWhereInput | CostItemSupplierScalarWhereInput[]
  }

  export type PendingBookingCreateNestedOneWithoutCostItemsInput = {
    create?: XOR<PendingBookingCreateWithoutCostItemsInput, PendingBookingUncheckedCreateWithoutCostItemsInput>
    connectOrCreate?: PendingBookingCreateOrConnectWithoutCostItemsInput
    connect?: PendingBookingWhereUniqueInput
  }

  export type CostItemSupplierCreateNestedManyWithoutPendingCostItemInput = {
    create?: XOR<CostItemSupplierCreateWithoutPendingCostItemInput, CostItemSupplierUncheckedCreateWithoutPendingCostItemInput> | CostItemSupplierCreateWithoutPendingCostItemInput[] | CostItemSupplierUncheckedCreateWithoutPendingCostItemInput[]
    connectOrCreate?: CostItemSupplierCreateOrConnectWithoutPendingCostItemInput | CostItemSupplierCreateOrConnectWithoutPendingCostItemInput[]
    createMany?: CostItemSupplierCreateManyPendingCostItemInputEnvelope
    connect?: CostItemSupplierWhereUniqueInput | CostItemSupplierWhereUniqueInput[]
  }

  export type CostItemSupplierUncheckedCreateNestedManyWithoutPendingCostItemInput = {
    create?: XOR<CostItemSupplierCreateWithoutPendingCostItemInput, CostItemSupplierUncheckedCreateWithoutPendingCostItemInput> | CostItemSupplierCreateWithoutPendingCostItemInput[] | CostItemSupplierUncheckedCreateWithoutPendingCostItemInput[]
    connectOrCreate?: CostItemSupplierCreateOrConnectWithoutPendingCostItemInput | CostItemSupplierCreateOrConnectWithoutPendingCostItemInput[]
    createMany?: CostItemSupplierCreateManyPendingCostItemInputEnvelope
    connect?: CostItemSupplierWhereUniqueInput | CostItemSupplierWhereUniqueInput[]
  }

  export type PendingBookingUpdateOneRequiredWithoutCostItemsNestedInput = {
    create?: XOR<PendingBookingCreateWithoutCostItemsInput, PendingBookingUncheckedCreateWithoutCostItemsInput>
    connectOrCreate?: PendingBookingCreateOrConnectWithoutCostItemsInput
    upsert?: PendingBookingUpsertWithoutCostItemsInput
    connect?: PendingBookingWhereUniqueInput
    update?: XOR<XOR<PendingBookingUpdateToOneWithWhereWithoutCostItemsInput, PendingBookingUpdateWithoutCostItemsInput>, PendingBookingUncheckedUpdateWithoutCostItemsInput>
  }

  export type CostItemSupplierUpdateManyWithoutPendingCostItemNestedInput = {
    create?: XOR<CostItemSupplierCreateWithoutPendingCostItemInput, CostItemSupplierUncheckedCreateWithoutPendingCostItemInput> | CostItemSupplierCreateWithoutPendingCostItemInput[] | CostItemSupplierUncheckedCreateWithoutPendingCostItemInput[]
    connectOrCreate?: CostItemSupplierCreateOrConnectWithoutPendingCostItemInput | CostItemSupplierCreateOrConnectWithoutPendingCostItemInput[]
    upsert?: CostItemSupplierUpsertWithWhereUniqueWithoutPendingCostItemInput | CostItemSupplierUpsertWithWhereUniqueWithoutPendingCostItemInput[]
    createMany?: CostItemSupplierCreateManyPendingCostItemInputEnvelope
    set?: CostItemSupplierWhereUniqueInput | CostItemSupplierWhereUniqueInput[]
    disconnect?: CostItemSupplierWhereUniqueInput | CostItemSupplierWhereUniqueInput[]
    delete?: CostItemSupplierWhereUniqueInput | CostItemSupplierWhereUniqueInput[]
    connect?: CostItemSupplierWhereUniqueInput | CostItemSupplierWhereUniqueInput[]
    update?: CostItemSupplierUpdateWithWhereUniqueWithoutPendingCostItemInput | CostItemSupplierUpdateWithWhereUniqueWithoutPendingCostItemInput[]
    updateMany?: CostItemSupplierUpdateManyWithWhereWithoutPendingCostItemInput | CostItemSupplierUpdateManyWithWhereWithoutPendingCostItemInput[]
    deleteMany?: CostItemSupplierScalarWhereInput | CostItemSupplierScalarWhereInput[]
  }

  export type CostItemSupplierUncheckedUpdateManyWithoutPendingCostItemNestedInput = {
    create?: XOR<CostItemSupplierCreateWithoutPendingCostItemInput, CostItemSupplierUncheckedCreateWithoutPendingCostItemInput> | CostItemSupplierCreateWithoutPendingCostItemInput[] | CostItemSupplierUncheckedCreateWithoutPendingCostItemInput[]
    connectOrCreate?: CostItemSupplierCreateOrConnectWithoutPendingCostItemInput | CostItemSupplierCreateOrConnectWithoutPendingCostItemInput[]
    upsert?: CostItemSupplierUpsertWithWhereUniqueWithoutPendingCostItemInput | CostItemSupplierUpsertWithWhereUniqueWithoutPendingCostItemInput[]
    createMany?: CostItemSupplierCreateManyPendingCostItemInputEnvelope
    set?: CostItemSupplierWhereUniqueInput | CostItemSupplierWhereUniqueInput[]
    disconnect?: CostItemSupplierWhereUniqueInput | CostItemSupplierWhereUniqueInput[]
    delete?: CostItemSupplierWhereUniqueInput | CostItemSupplierWhereUniqueInput[]
    connect?: CostItemSupplierWhereUniqueInput | CostItemSupplierWhereUniqueInput[]
    update?: CostItemSupplierUpdateWithWhereUniqueWithoutPendingCostItemInput | CostItemSupplierUpdateWithWhereUniqueWithoutPendingCostItemInput[]
    updateMany?: CostItemSupplierUpdateManyWithWhereWithoutPendingCostItemInput | CostItemSupplierUpdateManyWithWhereWithoutPendingCostItemInput[]
    deleteMany?: CostItemSupplierScalarWhereInput | CostItemSupplierScalarWhereInput[]
  }

  export type BookingCreateNestedOneWithoutPassengersInput = {
    create?: XOR<BookingCreateWithoutPassengersInput, BookingUncheckedCreateWithoutPassengersInput>
    connectOrCreate?: BookingCreateOrConnectWithoutPassengersInput
    connect?: BookingWhereUniqueInput
  }

  export type EnumTitleFieldUpdateOperationsInput = {
    set?: $Enums.Title
  }

  export type EnumGenderFieldUpdateOperationsInput = {
    set?: $Enums.Gender
  }

  export type EnumPassengerCategoryFieldUpdateOperationsInput = {
    set?: $Enums.PassengerCategory
  }

  export type BookingUpdateOneRequiredWithoutPassengersNestedInput = {
    create?: XOR<BookingCreateWithoutPassengersInput, BookingUncheckedCreateWithoutPassengersInput>
    connectOrCreate?: BookingCreateOrConnectWithoutPassengersInput
    upsert?: BookingUpsertWithoutPassengersInput
    connect?: BookingWhereUniqueInput
    update?: XOR<XOR<BookingUpdateToOneWithWhereWithoutPassengersInput, BookingUpdateWithoutPassengersInput>, BookingUncheckedUpdateWithoutPassengersInput>
  }

  export type PendingBookingCreateNestedOneWithoutPassengersInput = {
    create?: XOR<PendingBookingCreateWithoutPassengersInput, PendingBookingUncheckedCreateWithoutPassengersInput>
    connectOrCreate?: PendingBookingCreateOrConnectWithoutPassengersInput
    connect?: PendingBookingWhereUniqueInput
  }

  export type PendingBookingUpdateOneRequiredWithoutPassengersNestedInput = {
    create?: XOR<PendingBookingCreateWithoutPassengersInput, PendingBookingUncheckedCreateWithoutPassengersInput>
    connectOrCreate?: PendingBookingCreateOrConnectWithoutPassengersInput
    upsert?: PendingBookingUpsertWithoutPassengersInput
    connect?: PendingBookingWhereUniqueInput
    update?: XOR<XOR<PendingBookingUpdateToOneWithWhereWithoutPassengersInput, PendingBookingUpdateWithoutPassengersInput>, PendingBookingUncheckedUpdateWithoutPassengersInput>
  }

  export type CostItemCreateNestedOneWithoutSuppliersInput = {
    create?: XOR<CostItemCreateWithoutSuppliersInput, CostItemUncheckedCreateWithoutSuppliersInput>
    connectOrCreate?: CostItemCreateOrConnectWithoutSuppliersInput
    connect?: CostItemWhereUniqueInput
  }

  export type PendingCostItemCreateNestedOneWithoutSuppliersInput = {
    create?: XOR<PendingCostItemCreateWithoutSuppliersInput, PendingCostItemUncheckedCreateWithoutSuppliersInput>
    connectOrCreate?: PendingCostItemCreateOrConnectWithoutSuppliersInput
    connect?: PendingCostItemWhereUniqueInput
  }

  export type SupplierPaymentSettlementCreateNestedManyWithoutCostItemSupplierInput = {
    create?: XOR<SupplierPaymentSettlementCreateWithoutCostItemSupplierInput, SupplierPaymentSettlementUncheckedCreateWithoutCostItemSupplierInput> | SupplierPaymentSettlementCreateWithoutCostItemSupplierInput[] | SupplierPaymentSettlementUncheckedCreateWithoutCostItemSupplierInput[]
    connectOrCreate?: SupplierPaymentSettlementCreateOrConnectWithoutCostItemSupplierInput | SupplierPaymentSettlementCreateOrConnectWithoutCostItemSupplierInput[]
    createMany?: SupplierPaymentSettlementCreateManyCostItemSupplierInputEnvelope
    connect?: SupplierPaymentSettlementWhereUniqueInput | SupplierPaymentSettlementWhereUniqueInput[]
  }

  export type CreditNoteUsageCreateNestedManyWithoutUsedOnCostItemSupplierInput = {
    create?: XOR<CreditNoteUsageCreateWithoutUsedOnCostItemSupplierInput, CreditNoteUsageUncheckedCreateWithoutUsedOnCostItemSupplierInput> | CreditNoteUsageCreateWithoutUsedOnCostItemSupplierInput[] | CreditNoteUsageUncheckedCreateWithoutUsedOnCostItemSupplierInput[]
    connectOrCreate?: CreditNoteUsageCreateOrConnectWithoutUsedOnCostItemSupplierInput | CreditNoteUsageCreateOrConnectWithoutUsedOnCostItemSupplierInput[]
    createMany?: CreditNoteUsageCreateManyUsedOnCostItemSupplierInputEnvelope
    connect?: CreditNoteUsageWhereUniqueInput | CreditNoteUsageWhereUniqueInput[]
  }

  export type SupplierPaymentSettlementUncheckedCreateNestedManyWithoutCostItemSupplierInput = {
    create?: XOR<SupplierPaymentSettlementCreateWithoutCostItemSupplierInput, SupplierPaymentSettlementUncheckedCreateWithoutCostItemSupplierInput> | SupplierPaymentSettlementCreateWithoutCostItemSupplierInput[] | SupplierPaymentSettlementUncheckedCreateWithoutCostItemSupplierInput[]
    connectOrCreate?: SupplierPaymentSettlementCreateOrConnectWithoutCostItemSupplierInput | SupplierPaymentSettlementCreateOrConnectWithoutCostItemSupplierInput[]
    createMany?: SupplierPaymentSettlementCreateManyCostItemSupplierInputEnvelope
    connect?: SupplierPaymentSettlementWhereUniqueInput | SupplierPaymentSettlementWhereUniqueInput[]
  }

  export type CreditNoteUsageUncheckedCreateNestedManyWithoutUsedOnCostItemSupplierInput = {
    create?: XOR<CreditNoteUsageCreateWithoutUsedOnCostItemSupplierInput, CreditNoteUsageUncheckedCreateWithoutUsedOnCostItemSupplierInput> | CreditNoteUsageCreateWithoutUsedOnCostItemSupplierInput[] | CreditNoteUsageUncheckedCreateWithoutUsedOnCostItemSupplierInput[]
    connectOrCreate?: CreditNoteUsageCreateOrConnectWithoutUsedOnCostItemSupplierInput | CreditNoteUsageCreateOrConnectWithoutUsedOnCostItemSupplierInput[]
    createMany?: CreditNoteUsageCreateManyUsedOnCostItemSupplierInputEnvelope
    connect?: CreditNoteUsageWhereUniqueInput | CreditNoteUsageWhereUniqueInput[]
  }

  export type EnumSuppliersFieldUpdateOperationsInput = {
    set?: $Enums.Suppliers
  }

  export type CostItemUpdateOneWithoutSuppliersNestedInput = {
    create?: XOR<CostItemCreateWithoutSuppliersInput, CostItemUncheckedCreateWithoutSuppliersInput>
    connectOrCreate?: CostItemCreateOrConnectWithoutSuppliersInput
    upsert?: CostItemUpsertWithoutSuppliersInput
    disconnect?: CostItemWhereInput | boolean
    delete?: CostItemWhereInput | boolean
    connect?: CostItemWhereUniqueInput
    update?: XOR<XOR<CostItemUpdateToOneWithWhereWithoutSuppliersInput, CostItemUpdateWithoutSuppliersInput>, CostItemUncheckedUpdateWithoutSuppliersInput>
  }

  export type PendingCostItemUpdateOneWithoutSuppliersNestedInput = {
    create?: XOR<PendingCostItemCreateWithoutSuppliersInput, PendingCostItemUncheckedCreateWithoutSuppliersInput>
    connectOrCreate?: PendingCostItemCreateOrConnectWithoutSuppliersInput
    upsert?: PendingCostItemUpsertWithoutSuppliersInput
    disconnect?: PendingCostItemWhereInput | boolean
    delete?: PendingCostItemWhereInput | boolean
    connect?: PendingCostItemWhereUniqueInput
    update?: XOR<XOR<PendingCostItemUpdateToOneWithWhereWithoutSuppliersInput, PendingCostItemUpdateWithoutSuppliersInput>, PendingCostItemUncheckedUpdateWithoutSuppliersInput>
  }

  export type SupplierPaymentSettlementUpdateManyWithoutCostItemSupplierNestedInput = {
    create?: XOR<SupplierPaymentSettlementCreateWithoutCostItemSupplierInput, SupplierPaymentSettlementUncheckedCreateWithoutCostItemSupplierInput> | SupplierPaymentSettlementCreateWithoutCostItemSupplierInput[] | SupplierPaymentSettlementUncheckedCreateWithoutCostItemSupplierInput[]
    connectOrCreate?: SupplierPaymentSettlementCreateOrConnectWithoutCostItemSupplierInput | SupplierPaymentSettlementCreateOrConnectWithoutCostItemSupplierInput[]
    upsert?: SupplierPaymentSettlementUpsertWithWhereUniqueWithoutCostItemSupplierInput | SupplierPaymentSettlementUpsertWithWhereUniqueWithoutCostItemSupplierInput[]
    createMany?: SupplierPaymentSettlementCreateManyCostItemSupplierInputEnvelope
    set?: SupplierPaymentSettlementWhereUniqueInput | SupplierPaymentSettlementWhereUniqueInput[]
    disconnect?: SupplierPaymentSettlementWhereUniqueInput | SupplierPaymentSettlementWhereUniqueInput[]
    delete?: SupplierPaymentSettlementWhereUniqueInput | SupplierPaymentSettlementWhereUniqueInput[]
    connect?: SupplierPaymentSettlementWhereUniqueInput | SupplierPaymentSettlementWhereUniqueInput[]
    update?: SupplierPaymentSettlementUpdateWithWhereUniqueWithoutCostItemSupplierInput | SupplierPaymentSettlementUpdateWithWhereUniqueWithoutCostItemSupplierInput[]
    updateMany?: SupplierPaymentSettlementUpdateManyWithWhereWithoutCostItemSupplierInput | SupplierPaymentSettlementUpdateManyWithWhereWithoutCostItemSupplierInput[]
    deleteMany?: SupplierPaymentSettlementScalarWhereInput | SupplierPaymentSettlementScalarWhereInput[]
  }

  export type CreditNoteUsageUpdateManyWithoutUsedOnCostItemSupplierNestedInput = {
    create?: XOR<CreditNoteUsageCreateWithoutUsedOnCostItemSupplierInput, CreditNoteUsageUncheckedCreateWithoutUsedOnCostItemSupplierInput> | CreditNoteUsageCreateWithoutUsedOnCostItemSupplierInput[] | CreditNoteUsageUncheckedCreateWithoutUsedOnCostItemSupplierInput[]
    connectOrCreate?: CreditNoteUsageCreateOrConnectWithoutUsedOnCostItemSupplierInput | CreditNoteUsageCreateOrConnectWithoutUsedOnCostItemSupplierInput[]
    upsert?: CreditNoteUsageUpsertWithWhereUniqueWithoutUsedOnCostItemSupplierInput | CreditNoteUsageUpsertWithWhereUniqueWithoutUsedOnCostItemSupplierInput[]
    createMany?: CreditNoteUsageCreateManyUsedOnCostItemSupplierInputEnvelope
    set?: CreditNoteUsageWhereUniqueInput | CreditNoteUsageWhereUniqueInput[]
    disconnect?: CreditNoteUsageWhereUniqueInput | CreditNoteUsageWhereUniqueInput[]
    delete?: CreditNoteUsageWhereUniqueInput | CreditNoteUsageWhereUniqueInput[]
    connect?: CreditNoteUsageWhereUniqueInput | CreditNoteUsageWhereUniqueInput[]
    update?: CreditNoteUsageUpdateWithWhereUniqueWithoutUsedOnCostItemSupplierInput | CreditNoteUsageUpdateWithWhereUniqueWithoutUsedOnCostItemSupplierInput[]
    updateMany?: CreditNoteUsageUpdateManyWithWhereWithoutUsedOnCostItemSupplierInput | CreditNoteUsageUpdateManyWithWhereWithoutUsedOnCostItemSupplierInput[]
    deleteMany?: CreditNoteUsageScalarWhereInput | CreditNoteUsageScalarWhereInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type SupplierPaymentSettlementUncheckedUpdateManyWithoutCostItemSupplierNestedInput = {
    create?: XOR<SupplierPaymentSettlementCreateWithoutCostItemSupplierInput, SupplierPaymentSettlementUncheckedCreateWithoutCostItemSupplierInput> | SupplierPaymentSettlementCreateWithoutCostItemSupplierInput[] | SupplierPaymentSettlementUncheckedCreateWithoutCostItemSupplierInput[]
    connectOrCreate?: SupplierPaymentSettlementCreateOrConnectWithoutCostItemSupplierInput | SupplierPaymentSettlementCreateOrConnectWithoutCostItemSupplierInput[]
    upsert?: SupplierPaymentSettlementUpsertWithWhereUniqueWithoutCostItemSupplierInput | SupplierPaymentSettlementUpsertWithWhereUniqueWithoutCostItemSupplierInput[]
    createMany?: SupplierPaymentSettlementCreateManyCostItemSupplierInputEnvelope
    set?: SupplierPaymentSettlementWhereUniqueInput | SupplierPaymentSettlementWhereUniqueInput[]
    disconnect?: SupplierPaymentSettlementWhereUniqueInput | SupplierPaymentSettlementWhereUniqueInput[]
    delete?: SupplierPaymentSettlementWhereUniqueInput | SupplierPaymentSettlementWhereUniqueInput[]
    connect?: SupplierPaymentSettlementWhereUniqueInput | SupplierPaymentSettlementWhereUniqueInput[]
    update?: SupplierPaymentSettlementUpdateWithWhereUniqueWithoutCostItemSupplierInput | SupplierPaymentSettlementUpdateWithWhereUniqueWithoutCostItemSupplierInput[]
    updateMany?: SupplierPaymentSettlementUpdateManyWithWhereWithoutCostItemSupplierInput | SupplierPaymentSettlementUpdateManyWithWhereWithoutCostItemSupplierInput[]
    deleteMany?: SupplierPaymentSettlementScalarWhereInput | SupplierPaymentSettlementScalarWhereInput[]
  }

  export type CreditNoteUsageUncheckedUpdateManyWithoutUsedOnCostItemSupplierNestedInput = {
    create?: XOR<CreditNoteUsageCreateWithoutUsedOnCostItemSupplierInput, CreditNoteUsageUncheckedCreateWithoutUsedOnCostItemSupplierInput> | CreditNoteUsageCreateWithoutUsedOnCostItemSupplierInput[] | CreditNoteUsageUncheckedCreateWithoutUsedOnCostItemSupplierInput[]
    connectOrCreate?: CreditNoteUsageCreateOrConnectWithoutUsedOnCostItemSupplierInput | CreditNoteUsageCreateOrConnectWithoutUsedOnCostItemSupplierInput[]
    upsert?: CreditNoteUsageUpsertWithWhereUniqueWithoutUsedOnCostItemSupplierInput | CreditNoteUsageUpsertWithWhereUniqueWithoutUsedOnCostItemSupplierInput[]
    createMany?: CreditNoteUsageCreateManyUsedOnCostItemSupplierInputEnvelope
    set?: CreditNoteUsageWhereUniqueInput | CreditNoteUsageWhereUniqueInput[]
    disconnect?: CreditNoteUsageWhereUniqueInput | CreditNoteUsageWhereUniqueInput[]
    delete?: CreditNoteUsageWhereUniqueInput | CreditNoteUsageWhereUniqueInput[]
    connect?: CreditNoteUsageWhereUniqueInput | CreditNoteUsageWhereUniqueInput[]
    update?: CreditNoteUsageUpdateWithWhereUniqueWithoutUsedOnCostItemSupplierInput | CreditNoteUsageUpdateWithWhereUniqueWithoutUsedOnCostItemSupplierInput[]
    updateMany?: CreditNoteUsageUpdateManyWithWhereWithoutUsedOnCostItemSupplierInput | CreditNoteUsageUpdateManyWithWhereWithoutUsedOnCostItemSupplierInput[]
    deleteMany?: CreditNoteUsageScalarWhereInput | CreditNoteUsageScalarWhereInput[]
  }

  export type CostItemSupplierCreateNestedOneWithoutSettlementsInput = {
    create?: XOR<CostItemSupplierCreateWithoutSettlementsInput, CostItemSupplierUncheckedCreateWithoutSettlementsInput>
    connectOrCreate?: CostItemSupplierCreateOrConnectWithoutSettlementsInput
    connect?: CostItemSupplierWhereUniqueInput
  }

  export type CostItemSupplierUpdateOneRequiredWithoutSettlementsNestedInput = {
    create?: XOR<CostItemSupplierCreateWithoutSettlementsInput, CostItemSupplierUncheckedCreateWithoutSettlementsInput>
    connectOrCreate?: CostItemSupplierCreateOrConnectWithoutSettlementsInput
    upsert?: CostItemSupplierUpsertWithoutSettlementsInput
    connect?: CostItemSupplierWhereUniqueInput
    update?: XOR<XOR<CostItemSupplierUpdateToOneWithWhereWithoutSettlementsInput, CostItemSupplierUpdateWithoutSettlementsInput>, CostItemSupplierUncheckedUpdateWithoutSettlementsInput>
  }

  export type BookingCreateNestedOneWithoutCancellationInput = {
    create?: XOR<BookingCreateWithoutCancellationInput, BookingUncheckedCreateWithoutCancellationInput>
    connectOrCreate?: BookingCreateOrConnectWithoutCancellationInput
    connect?: BookingWhereUniqueInput
  }

  export type SupplierCreditNoteCreateNestedOneWithoutGeneratedFromCancellationInput = {
    create?: XOR<SupplierCreditNoteCreateWithoutGeneratedFromCancellationInput, SupplierCreditNoteUncheckedCreateWithoutGeneratedFromCancellationInput>
    connectOrCreate?: SupplierCreditNoteCreateOrConnectWithoutGeneratedFromCancellationInput
    connect?: SupplierCreditNoteWhereUniqueInput
  }

  export type SupplierCreditNoteUncheckedCreateNestedOneWithoutGeneratedFromCancellationInput = {
    create?: XOR<SupplierCreditNoteCreateWithoutGeneratedFromCancellationInput, SupplierCreditNoteUncheckedCreateWithoutGeneratedFromCancellationInput>
    connectOrCreate?: SupplierCreditNoteCreateOrConnectWithoutGeneratedFromCancellationInput
    connect?: SupplierCreditNoteWhereUniqueInput
  }

  export type BookingUpdateOneRequiredWithoutCancellationNestedInput = {
    create?: XOR<BookingCreateWithoutCancellationInput, BookingUncheckedCreateWithoutCancellationInput>
    connectOrCreate?: BookingCreateOrConnectWithoutCancellationInput
    upsert?: BookingUpsertWithoutCancellationInput
    connect?: BookingWhereUniqueInput
    update?: XOR<XOR<BookingUpdateToOneWithWhereWithoutCancellationInput, BookingUpdateWithoutCancellationInput>, BookingUncheckedUpdateWithoutCancellationInput>
  }

  export type SupplierCreditNoteUpdateOneWithoutGeneratedFromCancellationNestedInput = {
    create?: XOR<SupplierCreditNoteCreateWithoutGeneratedFromCancellationInput, SupplierCreditNoteUncheckedCreateWithoutGeneratedFromCancellationInput>
    connectOrCreate?: SupplierCreditNoteCreateOrConnectWithoutGeneratedFromCancellationInput
    upsert?: SupplierCreditNoteUpsertWithoutGeneratedFromCancellationInput
    disconnect?: SupplierCreditNoteWhereInput | boolean
    delete?: SupplierCreditNoteWhereInput | boolean
    connect?: SupplierCreditNoteWhereUniqueInput
    update?: XOR<XOR<SupplierCreditNoteUpdateToOneWithWhereWithoutGeneratedFromCancellationInput, SupplierCreditNoteUpdateWithoutGeneratedFromCancellationInput>, SupplierCreditNoteUncheckedUpdateWithoutGeneratedFromCancellationInput>
  }

  export type SupplierCreditNoteUncheckedUpdateOneWithoutGeneratedFromCancellationNestedInput = {
    create?: XOR<SupplierCreditNoteCreateWithoutGeneratedFromCancellationInput, SupplierCreditNoteUncheckedCreateWithoutGeneratedFromCancellationInput>
    connectOrCreate?: SupplierCreditNoteCreateOrConnectWithoutGeneratedFromCancellationInput
    upsert?: SupplierCreditNoteUpsertWithoutGeneratedFromCancellationInput
    disconnect?: SupplierCreditNoteWhereInput | boolean
    delete?: SupplierCreditNoteWhereInput | boolean
    connect?: SupplierCreditNoteWhereUniqueInput
    update?: XOR<XOR<SupplierCreditNoteUpdateToOneWithWhereWithoutGeneratedFromCancellationInput, SupplierCreditNoteUpdateWithoutGeneratedFromCancellationInput>, SupplierCreditNoteUncheckedUpdateWithoutGeneratedFromCancellationInput>
  }

  export type CancellationCreateNestedOneWithoutGeneratedCreditNoteInput = {
    create?: XOR<CancellationCreateWithoutGeneratedCreditNoteInput, CancellationUncheckedCreateWithoutGeneratedCreditNoteInput>
    connectOrCreate?: CancellationCreateOrConnectWithoutGeneratedCreditNoteInput
    connect?: CancellationWhereUniqueInput
  }

  export type CreditNoteUsageCreateNestedManyWithoutCreditNoteInput = {
    create?: XOR<CreditNoteUsageCreateWithoutCreditNoteInput, CreditNoteUsageUncheckedCreateWithoutCreditNoteInput> | CreditNoteUsageCreateWithoutCreditNoteInput[] | CreditNoteUsageUncheckedCreateWithoutCreditNoteInput[]
    connectOrCreate?: CreditNoteUsageCreateOrConnectWithoutCreditNoteInput | CreditNoteUsageCreateOrConnectWithoutCreditNoteInput[]
    createMany?: CreditNoteUsageCreateManyCreditNoteInputEnvelope
    connect?: CreditNoteUsageWhereUniqueInput | CreditNoteUsageWhereUniqueInput[]
  }

  export type CreditNoteUsageUncheckedCreateNestedManyWithoutCreditNoteInput = {
    create?: XOR<CreditNoteUsageCreateWithoutCreditNoteInput, CreditNoteUsageUncheckedCreateWithoutCreditNoteInput> | CreditNoteUsageCreateWithoutCreditNoteInput[] | CreditNoteUsageUncheckedCreateWithoutCreditNoteInput[]
    connectOrCreate?: CreditNoteUsageCreateOrConnectWithoutCreditNoteInput | CreditNoteUsageCreateOrConnectWithoutCreditNoteInput[]
    createMany?: CreditNoteUsageCreateManyCreditNoteInputEnvelope
    connect?: CreditNoteUsageWhereUniqueInput | CreditNoteUsageWhereUniqueInput[]
  }

  export type EnumCreditNoteStatusFieldUpdateOperationsInput = {
    set?: $Enums.CreditNoteStatus
  }

  export type CancellationUpdateOneRequiredWithoutGeneratedCreditNoteNestedInput = {
    create?: XOR<CancellationCreateWithoutGeneratedCreditNoteInput, CancellationUncheckedCreateWithoutGeneratedCreditNoteInput>
    connectOrCreate?: CancellationCreateOrConnectWithoutGeneratedCreditNoteInput
    upsert?: CancellationUpsertWithoutGeneratedCreditNoteInput
    connect?: CancellationWhereUniqueInput
    update?: XOR<XOR<CancellationUpdateToOneWithWhereWithoutGeneratedCreditNoteInput, CancellationUpdateWithoutGeneratedCreditNoteInput>, CancellationUncheckedUpdateWithoutGeneratedCreditNoteInput>
  }

  export type CreditNoteUsageUpdateManyWithoutCreditNoteNestedInput = {
    create?: XOR<CreditNoteUsageCreateWithoutCreditNoteInput, CreditNoteUsageUncheckedCreateWithoutCreditNoteInput> | CreditNoteUsageCreateWithoutCreditNoteInput[] | CreditNoteUsageUncheckedCreateWithoutCreditNoteInput[]
    connectOrCreate?: CreditNoteUsageCreateOrConnectWithoutCreditNoteInput | CreditNoteUsageCreateOrConnectWithoutCreditNoteInput[]
    upsert?: CreditNoteUsageUpsertWithWhereUniqueWithoutCreditNoteInput | CreditNoteUsageUpsertWithWhereUniqueWithoutCreditNoteInput[]
    createMany?: CreditNoteUsageCreateManyCreditNoteInputEnvelope
    set?: CreditNoteUsageWhereUniqueInput | CreditNoteUsageWhereUniqueInput[]
    disconnect?: CreditNoteUsageWhereUniqueInput | CreditNoteUsageWhereUniqueInput[]
    delete?: CreditNoteUsageWhereUniqueInput | CreditNoteUsageWhereUniqueInput[]
    connect?: CreditNoteUsageWhereUniqueInput | CreditNoteUsageWhereUniqueInput[]
    update?: CreditNoteUsageUpdateWithWhereUniqueWithoutCreditNoteInput | CreditNoteUsageUpdateWithWhereUniqueWithoutCreditNoteInput[]
    updateMany?: CreditNoteUsageUpdateManyWithWhereWithoutCreditNoteInput | CreditNoteUsageUpdateManyWithWhereWithoutCreditNoteInput[]
    deleteMany?: CreditNoteUsageScalarWhereInput | CreditNoteUsageScalarWhereInput[]
  }

  export type CreditNoteUsageUncheckedUpdateManyWithoutCreditNoteNestedInput = {
    create?: XOR<CreditNoteUsageCreateWithoutCreditNoteInput, CreditNoteUsageUncheckedCreateWithoutCreditNoteInput> | CreditNoteUsageCreateWithoutCreditNoteInput[] | CreditNoteUsageUncheckedCreateWithoutCreditNoteInput[]
    connectOrCreate?: CreditNoteUsageCreateOrConnectWithoutCreditNoteInput | CreditNoteUsageCreateOrConnectWithoutCreditNoteInput[]
    upsert?: CreditNoteUsageUpsertWithWhereUniqueWithoutCreditNoteInput | CreditNoteUsageUpsertWithWhereUniqueWithoutCreditNoteInput[]
    createMany?: CreditNoteUsageCreateManyCreditNoteInputEnvelope
    set?: CreditNoteUsageWhereUniqueInput | CreditNoteUsageWhereUniqueInput[]
    disconnect?: CreditNoteUsageWhereUniqueInput | CreditNoteUsageWhereUniqueInput[]
    delete?: CreditNoteUsageWhereUniqueInput | CreditNoteUsageWhereUniqueInput[]
    connect?: CreditNoteUsageWhereUniqueInput | CreditNoteUsageWhereUniqueInput[]
    update?: CreditNoteUsageUpdateWithWhereUniqueWithoutCreditNoteInput | CreditNoteUsageUpdateWithWhereUniqueWithoutCreditNoteInput[]
    updateMany?: CreditNoteUsageUpdateManyWithWhereWithoutCreditNoteInput | CreditNoteUsageUpdateManyWithWhereWithoutCreditNoteInput[]
    deleteMany?: CreditNoteUsageScalarWhereInput | CreditNoteUsageScalarWhereInput[]
  }

  export type SupplierCreditNoteCreateNestedOneWithoutUsageHistoryInput = {
    create?: XOR<SupplierCreditNoteCreateWithoutUsageHistoryInput, SupplierCreditNoteUncheckedCreateWithoutUsageHistoryInput>
    connectOrCreate?: SupplierCreditNoteCreateOrConnectWithoutUsageHistoryInput
    connect?: SupplierCreditNoteWhereUniqueInput
  }

  export type CostItemSupplierCreateNestedOneWithoutPaidByCreditNoteUsageInput = {
    create?: XOR<CostItemSupplierCreateWithoutPaidByCreditNoteUsageInput, CostItemSupplierUncheckedCreateWithoutPaidByCreditNoteUsageInput>
    connectOrCreate?: CostItemSupplierCreateOrConnectWithoutPaidByCreditNoteUsageInput
    connect?: CostItemSupplierWhereUniqueInput
  }

  export type SupplierCreditNoteUpdateOneRequiredWithoutUsageHistoryNestedInput = {
    create?: XOR<SupplierCreditNoteCreateWithoutUsageHistoryInput, SupplierCreditNoteUncheckedCreateWithoutUsageHistoryInput>
    connectOrCreate?: SupplierCreditNoteCreateOrConnectWithoutUsageHistoryInput
    upsert?: SupplierCreditNoteUpsertWithoutUsageHistoryInput
    connect?: SupplierCreditNoteWhereUniqueInput
    update?: XOR<XOR<SupplierCreditNoteUpdateToOneWithWhereWithoutUsageHistoryInput, SupplierCreditNoteUpdateWithoutUsageHistoryInput>, SupplierCreditNoteUncheckedUpdateWithoutUsageHistoryInput>
  }

  export type CostItemSupplierUpdateOneRequiredWithoutPaidByCreditNoteUsageNestedInput = {
    create?: XOR<CostItemSupplierCreateWithoutPaidByCreditNoteUsageInput, CostItemSupplierUncheckedCreateWithoutPaidByCreditNoteUsageInput>
    connectOrCreate?: CostItemSupplierCreateOrConnectWithoutPaidByCreditNoteUsageInput
    upsert?: CostItemSupplierUpsertWithoutPaidByCreditNoteUsageInput
    connect?: CostItemSupplierWhereUniqueInput
    update?: XOR<XOR<CostItemSupplierUpdateToOneWithWhereWithoutPaidByCreditNoteUsageInput, CostItemSupplierUpdateWithoutPaidByCreditNoteUsageInput>, CostItemSupplierUncheckedUpdateWithoutPaidByCreditNoteUsageInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumTeamsNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Teams | EnumTeamsFieldRefInput<$PrismaModel> | null
    in?: $Enums.Teams[] | ListEnumTeamsFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Teams[] | ListEnumTeamsFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTeamsNullableFilter<$PrismaModel> | $Enums.Teams | null
  }

  export type NestedEnumBookingTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingType | EnumBookingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BookingType[] | ListEnumBookingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingType[] | ListEnumBookingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingTypeFilter<$PrismaModel> | $Enums.BookingType
  }

  export type NestedEnumBookingStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumBookingStatusNullableFilter<$PrismaModel> | $Enums.BookingStatus | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedEnumTeamsNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Teams | EnumTeamsFieldRefInput<$PrismaModel> | null
    in?: $Enums.Teams[] | ListEnumTeamsFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Teams[] | ListEnumTeamsFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTeamsNullableWithAggregatesFilter<$PrismaModel> | $Enums.Teams | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumTeamsNullableFilter<$PrismaModel>
    _max?: NestedEnumTeamsNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumBookingTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingType | EnumBookingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BookingType[] | ListEnumBookingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingType[] | ListEnumBookingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingTypeWithAggregatesFilter<$PrismaModel> | $Enums.BookingType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBookingTypeFilter<$PrismaModel>
    _max?: NestedEnumBookingTypeFilter<$PrismaModel>
  }

  export type NestedEnumBookingStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumBookingStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.BookingStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumBookingStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumBookingStatusNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedEnumPendingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PendingStatus | EnumPendingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PendingStatus[] | ListEnumPendingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PendingStatus[] | ListEnumPendingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPendingStatusFilter<$PrismaModel> | $Enums.PendingStatus
  }

  export type NestedEnumPendingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PendingStatus | EnumPendingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PendingStatus[] | ListEnumPendingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PendingStatus[] | ListEnumPendingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPendingStatusWithAggregatesFilter<$PrismaModel> | $Enums.PendingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPendingStatusFilter<$PrismaModel>
    _max?: NestedEnumPendingStatusFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedEnumTitleFilter<$PrismaModel = never> = {
    equals?: $Enums.Title | EnumTitleFieldRefInput<$PrismaModel>
    in?: $Enums.Title[] | ListEnumTitleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Title[] | ListEnumTitleFieldRefInput<$PrismaModel>
    not?: NestedEnumTitleFilter<$PrismaModel> | $Enums.Title
  }

  export type NestedEnumGenderFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderFilter<$PrismaModel> | $Enums.Gender
  }

  export type NestedEnumPassengerCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.PassengerCategory | EnumPassengerCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.PassengerCategory[] | ListEnumPassengerCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.PassengerCategory[] | ListEnumPassengerCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumPassengerCategoryFilter<$PrismaModel> | $Enums.PassengerCategory
  }

  export type NestedEnumTitleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Title | EnumTitleFieldRefInput<$PrismaModel>
    in?: $Enums.Title[] | ListEnumTitleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Title[] | ListEnumTitleFieldRefInput<$PrismaModel>
    not?: NestedEnumTitleWithAggregatesFilter<$PrismaModel> | $Enums.Title
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTitleFilter<$PrismaModel>
    _max?: NestedEnumTitleFilter<$PrismaModel>
  }

  export type NestedEnumGenderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderWithAggregatesFilter<$PrismaModel> | $Enums.Gender
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGenderFilter<$PrismaModel>
    _max?: NestedEnumGenderFilter<$PrismaModel>
  }

  export type NestedEnumPassengerCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PassengerCategory | EnumPassengerCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.PassengerCategory[] | ListEnumPassengerCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.PassengerCategory[] | ListEnumPassengerCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumPassengerCategoryWithAggregatesFilter<$PrismaModel> | $Enums.PassengerCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPassengerCategoryFilter<$PrismaModel>
    _max?: NestedEnumPassengerCategoryFilter<$PrismaModel>
  }

  export type NestedEnumSuppliersFilter<$PrismaModel = never> = {
    equals?: $Enums.Suppliers | EnumSuppliersFieldRefInput<$PrismaModel>
    in?: $Enums.Suppliers[] | ListEnumSuppliersFieldRefInput<$PrismaModel>
    notIn?: $Enums.Suppliers[] | ListEnumSuppliersFieldRefInput<$PrismaModel>
    not?: NestedEnumSuppliersFilter<$PrismaModel> | $Enums.Suppliers
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedEnumSuppliersWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Suppliers | EnumSuppliersFieldRefInput<$PrismaModel>
    in?: $Enums.Suppliers[] | ListEnumSuppliersFieldRefInput<$PrismaModel>
    notIn?: $Enums.Suppliers[] | ListEnumSuppliersFieldRefInput<$PrismaModel>
    not?: NestedEnumSuppliersWithAggregatesFilter<$PrismaModel> | $Enums.Suppliers
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSuppliersFilter<$PrismaModel>
    _max?: NestedEnumSuppliersFilter<$PrismaModel>
  }

  export type NestedEnumCreditNoteStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CreditNoteStatus | EnumCreditNoteStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CreditNoteStatus[] | ListEnumCreditNoteStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CreditNoteStatus[] | ListEnumCreditNoteStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCreditNoteStatusFilter<$PrismaModel> | $Enums.CreditNoteStatus
  }

  export type NestedEnumCreditNoteStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CreditNoteStatus | EnumCreditNoteStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CreditNoteStatus[] | ListEnumCreditNoteStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CreditNoteStatus[] | ListEnumCreditNoteStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCreditNoteStatusWithAggregatesFilter<$PrismaModel> | $Enums.CreditNoteStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCreditNoteStatusFilter<$PrismaModel>
    _max?: NestedEnumCreditNoteStatusFilter<$PrismaModel>
  }

  export type CostItemCreateWithoutBookingInput = {
    category: string
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    suppliers?: CostItemSupplierCreateNestedManyWithoutCostItemInput
  }

  export type CostItemUncheckedCreateWithoutBookingInput = {
    id?: number
    category: string
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    suppliers?: CostItemSupplierUncheckedCreateNestedManyWithoutCostItemInput
  }

  export type CostItemCreateOrConnectWithoutBookingInput = {
    where: CostItemWhereUniqueInput
    create: XOR<CostItemCreateWithoutBookingInput, CostItemUncheckedCreateWithoutBookingInput>
  }

  export type CostItemCreateManyBookingInputEnvelope = {
    data: CostItemCreateManyBookingInput | CostItemCreateManyBookingInput[]
    skipDuplicates?: boolean
  }

  export type InstalmentCreateWithoutBookingInput = {
    dueDate: Date | string
    amount: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: InstalmentPaymentCreateNestedManyWithoutInstalmentInput
  }

  export type InstalmentUncheckedCreateWithoutBookingInput = {
    id?: number
    dueDate: Date | string
    amount: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: InstalmentPaymentUncheckedCreateNestedManyWithoutInstalmentInput
  }

  export type InstalmentCreateOrConnectWithoutBookingInput = {
    where: InstalmentWhereUniqueInput
    create: XOR<InstalmentCreateWithoutBookingInput, InstalmentUncheckedCreateWithoutBookingInput>
  }

  export type InstalmentCreateManyBookingInputEnvelope = {
    data: InstalmentCreateManyBookingInput | InstalmentCreateManyBookingInput[]
    skipDuplicates?: boolean
  }

  export type PassengerCreateWithoutBookingInput = {
    title: $Enums.Title
    firstName: string
    middleName?: string | null
    lastName: string
    gender: $Enums.Gender
    email?: string | null
    contactNo?: string | null
    nationality?: string | null
    birthday?: Date | string | null
    category: $Enums.PassengerCategory
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PassengerUncheckedCreateWithoutBookingInput = {
    id?: number
    title: $Enums.Title
    firstName: string
    middleName?: string | null
    lastName: string
    gender: $Enums.Gender
    email?: string | null
    contactNo?: string | null
    nationality?: string | null
    birthday?: Date | string | null
    category: $Enums.PassengerCategory
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PassengerCreateOrConnectWithoutBookingInput = {
    where: PassengerWhereUniqueInput
    create: XOR<PassengerCreateWithoutBookingInput, PassengerUncheckedCreateWithoutBookingInput>
  }

  export type PassengerCreateManyBookingInputEnvelope = {
    data: PassengerCreateManyBookingInput | PassengerCreateManyBookingInput[]
    skipDuplicates?: boolean
  }

  export type CancellationCreateWithoutOriginalBookingInput = {
    folderNo: string
    refundTransactionMethod: string
    originalRevenue: number
    originalProdCost: number
    supplierCancellationFee: number
    refundToPassenger: number
    creditNoteAmount?: number | null
    profitOrLoss: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    generatedCreditNote?: SupplierCreditNoteCreateNestedOneWithoutGeneratedFromCancellationInput
  }

  export type CancellationUncheckedCreateWithoutOriginalBookingInput = {
    id?: number
    folderNo: string
    refundTransactionMethod: string
    originalRevenue: number
    originalProdCost: number
    supplierCancellationFee: number
    refundToPassenger: number
    creditNoteAmount?: number | null
    profitOrLoss: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    generatedCreditNote?: SupplierCreditNoteUncheckedCreateNestedOneWithoutGeneratedFromCancellationInput
  }

  export type CancellationCreateOrConnectWithoutOriginalBookingInput = {
    where: CancellationWhereUniqueInput
    create: XOR<CancellationCreateWithoutOriginalBookingInput, CancellationUncheckedCreateWithoutOriginalBookingInput>
  }

  export type CostItemUpsertWithWhereUniqueWithoutBookingInput = {
    where: CostItemWhereUniqueInput
    update: XOR<CostItemUpdateWithoutBookingInput, CostItemUncheckedUpdateWithoutBookingInput>
    create: XOR<CostItemCreateWithoutBookingInput, CostItemUncheckedCreateWithoutBookingInput>
  }

  export type CostItemUpdateWithWhereUniqueWithoutBookingInput = {
    where: CostItemWhereUniqueInput
    data: XOR<CostItemUpdateWithoutBookingInput, CostItemUncheckedUpdateWithoutBookingInput>
  }

  export type CostItemUpdateManyWithWhereWithoutBookingInput = {
    where: CostItemScalarWhereInput
    data: XOR<CostItemUpdateManyMutationInput, CostItemUncheckedUpdateManyWithoutBookingInput>
  }

  export type CostItemScalarWhereInput = {
    AND?: CostItemScalarWhereInput | CostItemScalarWhereInput[]
    OR?: CostItemScalarWhereInput[]
    NOT?: CostItemScalarWhereInput | CostItemScalarWhereInput[]
    id?: IntFilter<"CostItem"> | number
    bookingId?: IntFilter<"CostItem"> | number
    category?: StringFilter<"CostItem"> | string
    amount?: FloatFilter<"CostItem"> | number
    createdAt?: DateTimeFilter<"CostItem"> | Date | string
    updatedAt?: DateTimeFilter<"CostItem"> | Date | string
  }

  export type InstalmentUpsertWithWhereUniqueWithoutBookingInput = {
    where: InstalmentWhereUniqueInput
    update: XOR<InstalmentUpdateWithoutBookingInput, InstalmentUncheckedUpdateWithoutBookingInput>
    create: XOR<InstalmentCreateWithoutBookingInput, InstalmentUncheckedCreateWithoutBookingInput>
  }

  export type InstalmentUpdateWithWhereUniqueWithoutBookingInput = {
    where: InstalmentWhereUniqueInput
    data: XOR<InstalmentUpdateWithoutBookingInput, InstalmentUncheckedUpdateWithoutBookingInput>
  }

  export type InstalmentUpdateManyWithWhereWithoutBookingInput = {
    where: InstalmentScalarWhereInput
    data: XOR<InstalmentUpdateManyMutationInput, InstalmentUncheckedUpdateManyWithoutBookingInput>
  }

  export type InstalmentScalarWhereInput = {
    AND?: InstalmentScalarWhereInput | InstalmentScalarWhereInput[]
    OR?: InstalmentScalarWhereInput[]
    NOT?: InstalmentScalarWhereInput | InstalmentScalarWhereInput[]
    id?: IntFilter<"Instalment"> | number
    bookingId?: IntFilter<"Instalment"> | number
    dueDate?: DateTimeFilter<"Instalment"> | Date | string
    amount?: FloatFilter<"Instalment"> | number
    status?: StringFilter<"Instalment"> | string
    createdAt?: DateTimeFilter<"Instalment"> | Date | string
    updatedAt?: DateTimeFilter<"Instalment"> | Date | string
  }

  export type PassengerUpsertWithWhereUniqueWithoutBookingInput = {
    where: PassengerWhereUniqueInput
    update: XOR<PassengerUpdateWithoutBookingInput, PassengerUncheckedUpdateWithoutBookingInput>
    create: XOR<PassengerCreateWithoutBookingInput, PassengerUncheckedCreateWithoutBookingInput>
  }

  export type PassengerUpdateWithWhereUniqueWithoutBookingInput = {
    where: PassengerWhereUniqueInput
    data: XOR<PassengerUpdateWithoutBookingInput, PassengerUncheckedUpdateWithoutBookingInput>
  }

  export type PassengerUpdateManyWithWhereWithoutBookingInput = {
    where: PassengerScalarWhereInput
    data: XOR<PassengerUpdateManyMutationInput, PassengerUncheckedUpdateManyWithoutBookingInput>
  }

  export type PassengerScalarWhereInput = {
    AND?: PassengerScalarWhereInput | PassengerScalarWhereInput[]
    OR?: PassengerScalarWhereInput[]
    NOT?: PassengerScalarWhereInput | PassengerScalarWhereInput[]
    id?: IntFilter<"Passenger"> | number
    bookingId?: IntFilter<"Passenger"> | number
    title?: EnumTitleFilter<"Passenger"> | $Enums.Title
    firstName?: StringFilter<"Passenger"> | string
    middleName?: StringNullableFilter<"Passenger"> | string | null
    lastName?: StringFilter<"Passenger"> | string
    gender?: EnumGenderFilter<"Passenger"> | $Enums.Gender
    email?: StringNullableFilter<"Passenger"> | string | null
    contactNo?: StringNullableFilter<"Passenger"> | string | null
    nationality?: StringNullableFilter<"Passenger"> | string | null
    birthday?: DateTimeNullableFilter<"Passenger"> | Date | string | null
    category?: EnumPassengerCategoryFilter<"Passenger"> | $Enums.PassengerCategory
    createdAt?: DateTimeFilter<"Passenger"> | Date | string
    updatedAt?: DateTimeFilter<"Passenger"> | Date | string
  }

  export type CancellationUpsertWithoutOriginalBookingInput = {
    update: XOR<CancellationUpdateWithoutOriginalBookingInput, CancellationUncheckedUpdateWithoutOriginalBookingInput>
    create: XOR<CancellationCreateWithoutOriginalBookingInput, CancellationUncheckedCreateWithoutOriginalBookingInput>
    where?: CancellationWhereInput
  }

  export type CancellationUpdateToOneWithWhereWithoutOriginalBookingInput = {
    where?: CancellationWhereInput
    data: XOR<CancellationUpdateWithoutOriginalBookingInput, CancellationUncheckedUpdateWithoutOriginalBookingInput>
  }

  export type CancellationUpdateWithoutOriginalBookingInput = {
    folderNo?: StringFieldUpdateOperationsInput | string
    refundTransactionMethod?: StringFieldUpdateOperationsInput | string
    originalRevenue?: FloatFieldUpdateOperationsInput | number
    originalProdCost?: FloatFieldUpdateOperationsInput | number
    supplierCancellationFee?: FloatFieldUpdateOperationsInput | number
    refundToPassenger?: FloatFieldUpdateOperationsInput | number
    creditNoteAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    profitOrLoss?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    generatedCreditNote?: SupplierCreditNoteUpdateOneWithoutGeneratedFromCancellationNestedInput
  }

  export type CancellationUncheckedUpdateWithoutOriginalBookingInput = {
    id?: IntFieldUpdateOperationsInput | number
    folderNo?: StringFieldUpdateOperationsInput | string
    refundTransactionMethod?: StringFieldUpdateOperationsInput | string
    originalRevenue?: FloatFieldUpdateOperationsInput | number
    originalProdCost?: FloatFieldUpdateOperationsInput | number
    supplierCancellationFee?: FloatFieldUpdateOperationsInput | number
    refundToPassenger?: FloatFieldUpdateOperationsInput | number
    creditNoteAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    profitOrLoss?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    generatedCreditNote?: SupplierCreditNoteUncheckedUpdateOneWithoutGeneratedFromCancellationNestedInput
  }

  export type PendingCostItemCreateWithoutPendingBookingInput = {
    category: string
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    suppliers?: CostItemSupplierCreateNestedManyWithoutPendingCostItemInput
  }

  export type PendingCostItemUncheckedCreateWithoutPendingBookingInput = {
    id?: number
    category: string
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    suppliers?: CostItemSupplierUncheckedCreateNestedManyWithoutPendingCostItemInput
  }

  export type PendingCostItemCreateOrConnectWithoutPendingBookingInput = {
    where: PendingCostItemWhereUniqueInput
    create: XOR<PendingCostItemCreateWithoutPendingBookingInput, PendingCostItemUncheckedCreateWithoutPendingBookingInput>
  }

  export type PendingCostItemCreateManyPendingBookingInputEnvelope = {
    data: PendingCostItemCreateManyPendingBookingInput | PendingCostItemCreateManyPendingBookingInput[]
    skipDuplicates?: boolean
  }

  export type PendingInstalmentCreateWithoutPendingBookingInput = {
    dueDate: Date | string
    amount: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PendingInstalmentUncheckedCreateWithoutPendingBookingInput = {
    id?: number
    dueDate: Date | string
    amount: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PendingInstalmentCreateOrConnectWithoutPendingBookingInput = {
    where: PendingInstalmentWhereUniqueInput
    create: XOR<PendingInstalmentCreateWithoutPendingBookingInput, PendingInstalmentUncheckedCreateWithoutPendingBookingInput>
  }

  export type PendingInstalmentCreateManyPendingBookingInputEnvelope = {
    data: PendingInstalmentCreateManyPendingBookingInput | PendingInstalmentCreateManyPendingBookingInput[]
    skipDuplicates?: boolean
  }

  export type PendingPassengerCreateWithoutPendingBookingInput = {
    title: $Enums.Title
    firstName: string
    middleName?: string | null
    lastName: string
    gender: $Enums.Gender
    email?: string | null
    contactNo?: string | null
    nationality?: string | null
    birthday?: Date | string | null
    category: $Enums.PassengerCategory
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PendingPassengerUncheckedCreateWithoutPendingBookingInput = {
    id?: number
    title: $Enums.Title
    firstName: string
    middleName?: string | null
    lastName: string
    gender: $Enums.Gender
    email?: string | null
    contactNo?: string | null
    nationality?: string | null
    birthday?: Date | string | null
    category: $Enums.PassengerCategory
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PendingPassengerCreateOrConnectWithoutPendingBookingInput = {
    where: PendingPassengerWhereUniqueInput
    create: XOR<PendingPassengerCreateWithoutPendingBookingInput, PendingPassengerUncheckedCreateWithoutPendingBookingInput>
  }

  export type PendingPassengerCreateManyPendingBookingInputEnvelope = {
    data: PendingPassengerCreateManyPendingBookingInput | PendingPassengerCreateManyPendingBookingInput[]
    skipDuplicates?: boolean
  }

  export type PendingCostItemUpsertWithWhereUniqueWithoutPendingBookingInput = {
    where: PendingCostItemWhereUniqueInput
    update: XOR<PendingCostItemUpdateWithoutPendingBookingInput, PendingCostItemUncheckedUpdateWithoutPendingBookingInput>
    create: XOR<PendingCostItemCreateWithoutPendingBookingInput, PendingCostItemUncheckedCreateWithoutPendingBookingInput>
  }

  export type PendingCostItemUpdateWithWhereUniqueWithoutPendingBookingInput = {
    where: PendingCostItemWhereUniqueInput
    data: XOR<PendingCostItemUpdateWithoutPendingBookingInput, PendingCostItemUncheckedUpdateWithoutPendingBookingInput>
  }

  export type PendingCostItemUpdateManyWithWhereWithoutPendingBookingInput = {
    where: PendingCostItemScalarWhereInput
    data: XOR<PendingCostItemUpdateManyMutationInput, PendingCostItemUncheckedUpdateManyWithoutPendingBookingInput>
  }

  export type PendingCostItemScalarWhereInput = {
    AND?: PendingCostItemScalarWhereInput | PendingCostItemScalarWhereInput[]
    OR?: PendingCostItemScalarWhereInput[]
    NOT?: PendingCostItemScalarWhereInput | PendingCostItemScalarWhereInput[]
    id?: IntFilter<"PendingCostItem"> | number
    pendingBookingId?: IntFilter<"PendingCostItem"> | number
    category?: StringFilter<"PendingCostItem"> | string
    amount?: FloatFilter<"PendingCostItem"> | number
    createdAt?: DateTimeFilter<"PendingCostItem"> | Date | string
    updatedAt?: DateTimeFilter<"PendingCostItem"> | Date | string
  }

  export type PendingInstalmentUpsertWithWhereUniqueWithoutPendingBookingInput = {
    where: PendingInstalmentWhereUniqueInput
    update: XOR<PendingInstalmentUpdateWithoutPendingBookingInput, PendingInstalmentUncheckedUpdateWithoutPendingBookingInput>
    create: XOR<PendingInstalmentCreateWithoutPendingBookingInput, PendingInstalmentUncheckedCreateWithoutPendingBookingInput>
  }

  export type PendingInstalmentUpdateWithWhereUniqueWithoutPendingBookingInput = {
    where: PendingInstalmentWhereUniqueInput
    data: XOR<PendingInstalmentUpdateWithoutPendingBookingInput, PendingInstalmentUncheckedUpdateWithoutPendingBookingInput>
  }

  export type PendingInstalmentUpdateManyWithWhereWithoutPendingBookingInput = {
    where: PendingInstalmentScalarWhereInput
    data: XOR<PendingInstalmentUpdateManyMutationInput, PendingInstalmentUncheckedUpdateManyWithoutPendingBookingInput>
  }

  export type PendingInstalmentScalarWhereInput = {
    AND?: PendingInstalmentScalarWhereInput | PendingInstalmentScalarWhereInput[]
    OR?: PendingInstalmentScalarWhereInput[]
    NOT?: PendingInstalmentScalarWhereInput | PendingInstalmentScalarWhereInput[]
    id?: IntFilter<"PendingInstalment"> | number
    pendingBookingId?: IntFilter<"PendingInstalment"> | number
    dueDate?: DateTimeFilter<"PendingInstalment"> | Date | string
    amount?: FloatFilter<"PendingInstalment"> | number
    status?: StringFilter<"PendingInstalment"> | string
    createdAt?: DateTimeFilter<"PendingInstalment"> | Date | string
    updatedAt?: DateTimeFilter<"PendingInstalment"> | Date | string
  }

  export type PendingPassengerUpsertWithWhereUniqueWithoutPendingBookingInput = {
    where: PendingPassengerWhereUniqueInput
    update: XOR<PendingPassengerUpdateWithoutPendingBookingInput, PendingPassengerUncheckedUpdateWithoutPendingBookingInput>
    create: XOR<PendingPassengerCreateWithoutPendingBookingInput, PendingPassengerUncheckedCreateWithoutPendingBookingInput>
  }

  export type PendingPassengerUpdateWithWhereUniqueWithoutPendingBookingInput = {
    where: PendingPassengerWhereUniqueInput
    data: XOR<PendingPassengerUpdateWithoutPendingBookingInput, PendingPassengerUncheckedUpdateWithoutPendingBookingInput>
  }

  export type PendingPassengerUpdateManyWithWhereWithoutPendingBookingInput = {
    where: PendingPassengerScalarWhereInput
    data: XOR<PendingPassengerUpdateManyMutationInput, PendingPassengerUncheckedUpdateManyWithoutPendingBookingInput>
  }

  export type PendingPassengerScalarWhereInput = {
    AND?: PendingPassengerScalarWhereInput | PendingPassengerScalarWhereInput[]
    OR?: PendingPassengerScalarWhereInput[]
    NOT?: PendingPassengerScalarWhereInput | PendingPassengerScalarWhereInput[]
    id?: IntFilter<"PendingPassenger"> | number
    pendingBookingId?: IntFilter<"PendingPassenger"> | number
    title?: EnumTitleFilter<"PendingPassenger"> | $Enums.Title
    firstName?: StringFilter<"PendingPassenger"> | string
    middleName?: StringNullableFilter<"PendingPassenger"> | string | null
    lastName?: StringFilter<"PendingPassenger"> | string
    gender?: EnumGenderFilter<"PendingPassenger"> | $Enums.Gender
    email?: StringNullableFilter<"PendingPassenger"> | string | null
    contactNo?: StringNullableFilter<"PendingPassenger"> | string | null
    nationality?: StringNullableFilter<"PendingPassenger"> | string | null
    birthday?: DateTimeNullableFilter<"PendingPassenger"> | Date | string | null
    category?: EnumPassengerCategoryFilter<"PendingPassenger"> | $Enums.PassengerCategory
    createdAt?: DateTimeFilter<"PendingPassenger"> | Date | string
    updatedAt?: DateTimeFilter<"PendingPassenger"> | Date | string
  }

  export type BookingCreateWithoutInstalmentsInput = {
    folderNo: number
    refNo: string
    paxName: string
    agentName: string
    teamName?: $Enums.Teams | null
    pnr: string
    airline: string
    fromTo: string
    bookingType: $Enums.BookingType
    bookingStatus?: $Enums.BookingStatus | null
    pcDate: Date | string
    issuedDate?: Date | string | null
    paymentMethod: $Enums.PaymentMethod
    lastPaymentDate?: Date | string | null
    travelDate?: Date | string | null
    revenue?: number | null
    prodCost?: number | null
    transFee?: number | null
    surcharge?: number | null
    received?: number | null
    transactionMethod?: string | null
    receivedDate?: Date | string | null
    balance?: number | null
    profit?: number | null
    invoiced?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    numPax: number
    initialDeposit?: number | null
    costItems?: CostItemCreateNestedManyWithoutBookingInput
    passengers?: PassengerCreateNestedManyWithoutBookingInput
    cancellation?: CancellationCreateNestedOneWithoutOriginalBookingInput
  }

  export type BookingUncheckedCreateWithoutInstalmentsInput = {
    id?: number
    folderNo: number
    refNo: string
    paxName: string
    agentName: string
    teamName?: $Enums.Teams | null
    pnr: string
    airline: string
    fromTo: string
    bookingType: $Enums.BookingType
    bookingStatus?: $Enums.BookingStatus | null
    pcDate: Date | string
    issuedDate?: Date | string | null
    paymentMethod: $Enums.PaymentMethod
    lastPaymentDate?: Date | string | null
    travelDate?: Date | string | null
    revenue?: number | null
    prodCost?: number | null
    transFee?: number | null
    surcharge?: number | null
    received?: number | null
    transactionMethod?: string | null
    receivedDate?: Date | string | null
    balance?: number | null
    profit?: number | null
    invoiced?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    numPax: number
    initialDeposit?: number | null
    costItems?: CostItemUncheckedCreateNestedManyWithoutBookingInput
    passengers?: PassengerUncheckedCreateNestedManyWithoutBookingInput
    cancellation?: CancellationUncheckedCreateNestedOneWithoutOriginalBookingInput
  }

  export type BookingCreateOrConnectWithoutInstalmentsInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutInstalmentsInput, BookingUncheckedCreateWithoutInstalmentsInput>
  }

  export type InstalmentPaymentCreateWithoutInstalmentInput = {
    amount: number
    transactionMethod: string
    paymentDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InstalmentPaymentUncheckedCreateWithoutInstalmentInput = {
    id?: number
    amount: number
    transactionMethod: string
    paymentDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InstalmentPaymentCreateOrConnectWithoutInstalmentInput = {
    where: InstalmentPaymentWhereUniqueInput
    create: XOR<InstalmentPaymentCreateWithoutInstalmentInput, InstalmentPaymentUncheckedCreateWithoutInstalmentInput>
  }

  export type InstalmentPaymentCreateManyInstalmentInputEnvelope = {
    data: InstalmentPaymentCreateManyInstalmentInput | InstalmentPaymentCreateManyInstalmentInput[]
    skipDuplicates?: boolean
  }

  export type BookingUpsertWithoutInstalmentsInput = {
    update: XOR<BookingUpdateWithoutInstalmentsInput, BookingUncheckedUpdateWithoutInstalmentsInput>
    create: XOR<BookingCreateWithoutInstalmentsInput, BookingUncheckedCreateWithoutInstalmentsInput>
    where?: BookingWhereInput
  }

  export type BookingUpdateToOneWithWhereWithoutInstalmentsInput = {
    where?: BookingWhereInput
    data: XOR<BookingUpdateWithoutInstalmentsInput, BookingUncheckedUpdateWithoutInstalmentsInput>
  }

  export type BookingUpdateWithoutInstalmentsInput = {
    folderNo?: IntFieldUpdateOperationsInput | number
    refNo?: StringFieldUpdateOperationsInput | string
    paxName?: StringFieldUpdateOperationsInput | string
    agentName?: StringFieldUpdateOperationsInput | string
    teamName?: NullableEnumTeamsFieldUpdateOperationsInput | $Enums.Teams | null
    pnr?: StringFieldUpdateOperationsInput | string
    airline?: StringFieldUpdateOperationsInput | string
    fromTo?: StringFieldUpdateOperationsInput | string
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    bookingStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    pcDate?: DateTimeFieldUpdateOperationsInput | Date | string
    issuedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    travelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    prodCost?: NullableFloatFieldUpdateOperationsInput | number | null
    transFee?: NullableFloatFieldUpdateOperationsInput | number | null
    surcharge?: NullableFloatFieldUpdateOperationsInput | number | null
    received?: NullableFloatFieldUpdateOperationsInput | number | null
    transactionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    profit?: NullableFloatFieldUpdateOperationsInput | number | null
    invoiced?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    numPax?: IntFieldUpdateOperationsInput | number
    initialDeposit?: NullableFloatFieldUpdateOperationsInput | number | null
    costItems?: CostItemUpdateManyWithoutBookingNestedInput
    passengers?: PassengerUpdateManyWithoutBookingNestedInput
    cancellation?: CancellationUpdateOneWithoutOriginalBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutInstalmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    folderNo?: IntFieldUpdateOperationsInput | number
    refNo?: StringFieldUpdateOperationsInput | string
    paxName?: StringFieldUpdateOperationsInput | string
    agentName?: StringFieldUpdateOperationsInput | string
    teamName?: NullableEnumTeamsFieldUpdateOperationsInput | $Enums.Teams | null
    pnr?: StringFieldUpdateOperationsInput | string
    airline?: StringFieldUpdateOperationsInput | string
    fromTo?: StringFieldUpdateOperationsInput | string
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    bookingStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    pcDate?: DateTimeFieldUpdateOperationsInput | Date | string
    issuedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    travelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    prodCost?: NullableFloatFieldUpdateOperationsInput | number | null
    transFee?: NullableFloatFieldUpdateOperationsInput | number | null
    surcharge?: NullableFloatFieldUpdateOperationsInput | number | null
    received?: NullableFloatFieldUpdateOperationsInput | number | null
    transactionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    profit?: NullableFloatFieldUpdateOperationsInput | number | null
    invoiced?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    numPax?: IntFieldUpdateOperationsInput | number
    initialDeposit?: NullableFloatFieldUpdateOperationsInput | number | null
    costItems?: CostItemUncheckedUpdateManyWithoutBookingNestedInput
    passengers?: PassengerUncheckedUpdateManyWithoutBookingNestedInput
    cancellation?: CancellationUncheckedUpdateOneWithoutOriginalBookingNestedInput
  }

  export type InstalmentPaymentUpsertWithWhereUniqueWithoutInstalmentInput = {
    where: InstalmentPaymentWhereUniqueInput
    update: XOR<InstalmentPaymentUpdateWithoutInstalmentInput, InstalmentPaymentUncheckedUpdateWithoutInstalmentInput>
    create: XOR<InstalmentPaymentCreateWithoutInstalmentInput, InstalmentPaymentUncheckedCreateWithoutInstalmentInput>
  }

  export type InstalmentPaymentUpdateWithWhereUniqueWithoutInstalmentInput = {
    where: InstalmentPaymentWhereUniqueInput
    data: XOR<InstalmentPaymentUpdateWithoutInstalmentInput, InstalmentPaymentUncheckedUpdateWithoutInstalmentInput>
  }

  export type InstalmentPaymentUpdateManyWithWhereWithoutInstalmentInput = {
    where: InstalmentPaymentScalarWhereInput
    data: XOR<InstalmentPaymentUpdateManyMutationInput, InstalmentPaymentUncheckedUpdateManyWithoutInstalmentInput>
  }

  export type InstalmentPaymentScalarWhereInput = {
    AND?: InstalmentPaymentScalarWhereInput | InstalmentPaymentScalarWhereInput[]
    OR?: InstalmentPaymentScalarWhereInput[]
    NOT?: InstalmentPaymentScalarWhereInput | InstalmentPaymentScalarWhereInput[]
    id?: IntFilter<"InstalmentPayment"> | number
    instalmentId?: IntFilter<"InstalmentPayment"> | number
    amount?: FloatFilter<"InstalmentPayment"> | number
    transactionMethod?: StringFilter<"InstalmentPayment"> | string
    paymentDate?: DateTimeFilter<"InstalmentPayment"> | Date | string
    createdAt?: DateTimeFilter<"InstalmentPayment"> | Date | string
    updatedAt?: DateTimeFilter<"InstalmentPayment"> | Date | string
  }

  export type PendingBookingCreateWithoutInstalmentsInput = {
    refNo: string
    paxName: string
    agentName: string
    teamName?: $Enums.Teams | null
    pnr: string
    airline: string
    fromTo: string
    bookingType: $Enums.BookingType
    bookingStatus?: $Enums.BookingStatus | null
    pcDate: Date | string
    issuedDate?: Date | string | null
    paymentMethod: $Enums.PaymentMethod
    lastPaymentDate?: Date | string | null
    travelDate?: Date | string | null
    revenue?: number | null
    prodCost?: number | null
    transFee?: number | null
    surcharge?: number | null
    received?: number | null
    transactionMethod?: string | null
    receivedDate?: Date | string | null
    balance?: number | null
    profit?: number | null
    invoiced?: string | null
    description?: string | null
    status?: $Enums.PendingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    numPax: number
    costItems?: PendingCostItemCreateNestedManyWithoutPendingBookingInput
    passengers?: PendingPassengerCreateNestedManyWithoutPendingBookingInput
  }

  export type PendingBookingUncheckedCreateWithoutInstalmentsInput = {
    id?: number
    refNo: string
    paxName: string
    agentName: string
    teamName?: $Enums.Teams | null
    pnr: string
    airline: string
    fromTo: string
    bookingType: $Enums.BookingType
    bookingStatus?: $Enums.BookingStatus | null
    pcDate: Date | string
    issuedDate?: Date | string | null
    paymentMethod: $Enums.PaymentMethod
    lastPaymentDate?: Date | string | null
    travelDate?: Date | string | null
    revenue?: number | null
    prodCost?: number | null
    transFee?: number | null
    surcharge?: number | null
    received?: number | null
    transactionMethod?: string | null
    receivedDate?: Date | string | null
    balance?: number | null
    profit?: number | null
    invoiced?: string | null
    description?: string | null
    status?: $Enums.PendingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    numPax: number
    costItems?: PendingCostItemUncheckedCreateNestedManyWithoutPendingBookingInput
    passengers?: PendingPassengerUncheckedCreateNestedManyWithoutPendingBookingInput
  }

  export type PendingBookingCreateOrConnectWithoutInstalmentsInput = {
    where: PendingBookingWhereUniqueInput
    create: XOR<PendingBookingCreateWithoutInstalmentsInput, PendingBookingUncheckedCreateWithoutInstalmentsInput>
  }

  export type PendingBookingUpsertWithoutInstalmentsInput = {
    update: XOR<PendingBookingUpdateWithoutInstalmentsInput, PendingBookingUncheckedUpdateWithoutInstalmentsInput>
    create: XOR<PendingBookingCreateWithoutInstalmentsInput, PendingBookingUncheckedCreateWithoutInstalmentsInput>
    where?: PendingBookingWhereInput
  }

  export type PendingBookingUpdateToOneWithWhereWithoutInstalmentsInput = {
    where?: PendingBookingWhereInput
    data: XOR<PendingBookingUpdateWithoutInstalmentsInput, PendingBookingUncheckedUpdateWithoutInstalmentsInput>
  }

  export type PendingBookingUpdateWithoutInstalmentsInput = {
    refNo?: StringFieldUpdateOperationsInput | string
    paxName?: StringFieldUpdateOperationsInput | string
    agentName?: StringFieldUpdateOperationsInput | string
    teamName?: NullableEnumTeamsFieldUpdateOperationsInput | $Enums.Teams | null
    pnr?: StringFieldUpdateOperationsInput | string
    airline?: StringFieldUpdateOperationsInput | string
    fromTo?: StringFieldUpdateOperationsInput | string
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    bookingStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    pcDate?: DateTimeFieldUpdateOperationsInput | Date | string
    issuedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    travelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    prodCost?: NullableFloatFieldUpdateOperationsInput | number | null
    transFee?: NullableFloatFieldUpdateOperationsInput | number | null
    surcharge?: NullableFloatFieldUpdateOperationsInput | number | null
    received?: NullableFloatFieldUpdateOperationsInput | number | null
    transactionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    profit?: NullableFloatFieldUpdateOperationsInput | number | null
    invoiced?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPendingStatusFieldUpdateOperationsInput | $Enums.PendingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    numPax?: IntFieldUpdateOperationsInput | number
    costItems?: PendingCostItemUpdateManyWithoutPendingBookingNestedInput
    passengers?: PendingPassengerUpdateManyWithoutPendingBookingNestedInput
  }

  export type PendingBookingUncheckedUpdateWithoutInstalmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    refNo?: StringFieldUpdateOperationsInput | string
    paxName?: StringFieldUpdateOperationsInput | string
    agentName?: StringFieldUpdateOperationsInput | string
    teamName?: NullableEnumTeamsFieldUpdateOperationsInput | $Enums.Teams | null
    pnr?: StringFieldUpdateOperationsInput | string
    airline?: StringFieldUpdateOperationsInput | string
    fromTo?: StringFieldUpdateOperationsInput | string
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    bookingStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    pcDate?: DateTimeFieldUpdateOperationsInput | Date | string
    issuedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    travelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    prodCost?: NullableFloatFieldUpdateOperationsInput | number | null
    transFee?: NullableFloatFieldUpdateOperationsInput | number | null
    surcharge?: NullableFloatFieldUpdateOperationsInput | number | null
    received?: NullableFloatFieldUpdateOperationsInput | number | null
    transactionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    profit?: NullableFloatFieldUpdateOperationsInput | number | null
    invoiced?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPendingStatusFieldUpdateOperationsInput | $Enums.PendingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    numPax?: IntFieldUpdateOperationsInput | number
    costItems?: PendingCostItemUncheckedUpdateManyWithoutPendingBookingNestedInput
    passengers?: PendingPassengerUncheckedUpdateManyWithoutPendingBookingNestedInput
  }

  export type InstalmentCreateWithoutPaymentsInput = {
    dueDate: Date | string
    amount: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    booking: BookingCreateNestedOneWithoutInstalmentsInput
  }

  export type InstalmentUncheckedCreateWithoutPaymentsInput = {
    id?: number
    bookingId: number
    dueDate: Date | string
    amount: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InstalmentCreateOrConnectWithoutPaymentsInput = {
    where: InstalmentWhereUniqueInput
    create: XOR<InstalmentCreateWithoutPaymentsInput, InstalmentUncheckedCreateWithoutPaymentsInput>
  }

  export type InstalmentUpsertWithoutPaymentsInput = {
    update: XOR<InstalmentUpdateWithoutPaymentsInput, InstalmentUncheckedUpdateWithoutPaymentsInput>
    create: XOR<InstalmentCreateWithoutPaymentsInput, InstalmentUncheckedCreateWithoutPaymentsInput>
    where?: InstalmentWhereInput
  }

  export type InstalmentUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: InstalmentWhereInput
    data: XOR<InstalmentUpdateWithoutPaymentsInput, InstalmentUncheckedUpdateWithoutPaymentsInput>
  }

  export type InstalmentUpdateWithoutPaymentsInput = {
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUpdateOneRequiredWithoutInstalmentsNestedInput
  }

  export type InstalmentUncheckedUpdateWithoutPaymentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookingId?: IntFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingCreateWithoutCostItemsInput = {
    folderNo: number
    refNo: string
    paxName: string
    agentName: string
    teamName?: $Enums.Teams | null
    pnr: string
    airline: string
    fromTo: string
    bookingType: $Enums.BookingType
    bookingStatus?: $Enums.BookingStatus | null
    pcDate: Date | string
    issuedDate?: Date | string | null
    paymentMethod: $Enums.PaymentMethod
    lastPaymentDate?: Date | string | null
    travelDate?: Date | string | null
    revenue?: number | null
    prodCost?: number | null
    transFee?: number | null
    surcharge?: number | null
    received?: number | null
    transactionMethod?: string | null
    receivedDate?: Date | string | null
    balance?: number | null
    profit?: number | null
    invoiced?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    numPax: number
    initialDeposit?: number | null
    instalments?: InstalmentCreateNestedManyWithoutBookingInput
    passengers?: PassengerCreateNestedManyWithoutBookingInput
    cancellation?: CancellationCreateNestedOneWithoutOriginalBookingInput
  }

  export type BookingUncheckedCreateWithoutCostItemsInput = {
    id?: number
    folderNo: number
    refNo: string
    paxName: string
    agentName: string
    teamName?: $Enums.Teams | null
    pnr: string
    airline: string
    fromTo: string
    bookingType: $Enums.BookingType
    bookingStatus?: $Enums.BookingStatus | null
    pcDate: Date | string
    issuedDate?: Date | string | null
    paymentMethod: $Enums.PaymentMethod
    lastPaymentDate?: Date | string | null
    travelDate?: Date | string | null
    revenue?: number | null
    prodCost?: number | null
    transFee?: number | null
    surcharge?: number | null
    received?: number | null
    transactionMethod?: string | null
    receivedDate?: Date | string | null
    balance?: number | null
    profit?: number | null
    invoiced?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    numPax: number
    initialDeposit?: number | null
    instalments?: InstalmentUncheckedCreateNestedManyWithoutBookingInput
    passengers?: PassengerUncheckedCreateNestedManyWithoutBookingInput
    cancellation?: CancellationUncheckedCreateNestedOneWithoutOriginalBookingInput
  }

  export type BookingCreateOrConnectWithoutCostItemsInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutCostItemsInput, BookingUncheckedCreateWithoutCostItemsInput>
  }

  export type CostItemSupplierCreateWithoutCostItemInput = {
    supplier: $Enums.Suppliers
    amount: number
    paymentMethod?: string
    paidAmount?: number
    pendingAmount?: number
    transactionMethod?: string | null
    firstMethodAmount?: number | null
    secondMethodAmount?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pendingCostItem?: PendingCostItemCreateNestedOneWithoutSuppliersInput
    settlements?: SupplierPaymentSettlementCreateNestedManyWithoutCostItemSupplierInput
    paidByCreditNoteUsage?: CreditNoteUsageCreateNestedManyWithoutUsedOnCostItemSupplierInput
  }

  export type CostItemSupplierUncheckedCreateWithoutCostItemInput = {
    id?: number
    pendingCostItemId?: number | null
    supplier: $Enums.Suppliers
    amount: number
    paymentMethod?: string
    paidAmount?: number
    pendingAmount?: number
    transactionMethod?: string | null
    firstMethodAmount?: number | null
    secondMethodAmount?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    settlements?: SupplierPaymentSettlementUncheckedCreateNestedManyWithoutCostItemSupplierInput
    paidByCreditNoteUsage?: CreditNoteUsageUncheckedCreateNestedManyWithoutUsedOnCostItemSupplierInput
  }

  export type CostItemSupplierCreateOrConnectWithoutCostItemInput = {
    where: CostItemSupplierWhereUniqueInput
    create: XOR<CostItemSupplierCreateWithoutCostItemInput, CostItemSupplierUncheckedCreateWithoutCostItemInput>
  }

  export type CostItemSupplierCreateManyCostItemInputEnvelope = {
    data: CostItemSupplierCreateManyCostItemInput | CostItemSupplierCreateManyCostItemInput[]
    skipDuplicates?: boolean
  }

  export type BookingUpsertWithoutCostItemsInput = {
    update: XOR<BookingUpdateWithoutCostItemsInput, BookingUncheckedUpdateWithoutCostItemsInput>
    create: XOR<BookingCreateWithoutCostItemsInput, BookingUncheckedCreateWithoutCostItemsInput>
    where?: BookingWhereInput
  }

  export type BookingUpdateToOneWithWhereWithoutCostItemsInput = {
    where?: BookingWhereInput
    data: XOR<BookingUpdateWithoutCostItemsInput, BookingUncheckedUpdateWithoutCostItemsInput>
  }

  export type BookingUpdateWithoutCostItemsInput = {
    folderNo?: IntFieldUpdateOperationsInput | number
    refNo?: StringFieldUpdateOperationsInput | string
    paxName?: StringFieldUpdateOperationsInput | string
    agentName?: StringFieldUpdateOperationsInput | string
    teamName?: NullableEnumTeamsFieldUpdateOperationsInput | $Enums.Teams | null
    pnr?: StringFieldUpdateOperationsInput | string
    airline?: StringFieldUpdateOperationsInput | string
    fromTo?: StringFieldUpdateOperationsInput | string
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    bookingStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    pcDate?: DateTimeFieldUpdateOperationsInput | Date | string
    issuedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    travelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    prodCost?: NullableFloatFieldUpdateOperationsInput | number | null
    transFee?: NullableFloatFieldUpdateOperationsInput | number | null
    surcharge?: NullableFloatFieldUpdateOperationsInput | number | null
    received?: NullableFloatFieldUpdateOperationsInput | number | null
    transactionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    profit?: NullableFloatFieldUpdateOperationsInput | number | null
    invoiced?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    numPax?: IntFieldUpdateOperationsInput | number
    initialDeposit?: NullableFloatFieldUpdateOperationsInput | number | null
    instalments?: InstalmentUpdateManyWithoutBookingNestedInput
    passengers?: PassengerUpdateManyWithoutBookingNestedInput
    cancellation?: CancellationUpdateOneWithoutOriginalBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutCostItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    folderNo?: IntFieldUpdateOperationsInput | number
    refNo?: StringFieldUpdateOperationsInput | string
    paxName?: StringFieldUpdateOperationsInput | string
    agentName?: StringFieldUpdateOperationsInput | string
    teamName?: NullableEnumTeamsFieldUpdateOperationsInput | $Enums.Teams | null
    pnr?: StringFieldUpdateOperationsInput | string
    airline?: StringFieldUpdateOperationsInput | string
    fromTo?: StringFieldUpdateOperationsInput | string
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    bookingStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    pcDate?: DateTimeFieldUpdateOperationsInput | Date | string
    issuedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    travelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    prodCost?: NullableFloatFieldUpdateOperationsInput | number | null
    transFee?: NullableFloatFieldUpdateOperationsInput | number | null
    surcharge?: NullableFloatFieldUpdateOperationsInput | number | null
    received?: NullableFloatFieldUpdateOperationsInput | number | null
    transactionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    profit?: NullableFloatFieldUpdateOperationsInput | number | null
    invoiced?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    numPax?: IntFieldUpdateOperationsInput | number
    initialDeposit?: NullableFloatFieldUpdateOperationsInput | number | null
    instalments?: InstalmentUncheckedUpdateManyWithoutBookingNestedInput
    passengers?: PassengerUncheckedUpdateManyWithoutBookingNestedInput
    cancellation?: CancellationUncheckedUpdateOneWithoutOriginalBookingNestedInput
  }

  export type CostItemSupplierUpsertWithWhereUniqueWithoutCostItemInput = {
    where: CostItemSupplierWhereUniqueInput
    update: XOR<CostItemSupplierUpdateWithoutCostItemInput, CostItemSupplierUncheckedUpdateWithoutCostItemInput>
    create: XOR<CostItemSupplierCreateWithoutCostItemInput, CostItemSupplierUncheckedCreateWithoutCostItemInput>
  }

  export type CostItemSupplierUpdateWithWhereUniqueWithoutCostItemInput = {
    where: CostItemSupplierWhereUniqueInput
    data: XOR<CostItemSupplierUpdateWithoutCostItemInput, CostItemSupplierUncheckedUpdateWithoutCostItemInput>
  }

  export type CostItemSupplierUpdateManyWithWhereWithoutCostItemInput = {
    where: CostItemSupplierScalarWhereInput
    data: XOR<CostItemSupplierUpdateManyMutationInput, CostItemSupplierUncheckedUpdateManyWithoutCostItemInput>
  }

  export type CostItemSupplierScalarWhereInput = {
    AND?: CostItemSupplierScalarWhereInput | CostItemSupplierScalarWhereInput[]
    OR?: CostItemSupplierScalarWhereInput[]
    NOT?: CostItemSupplierScalarWhereInput | CostItemSupplierScalarWhereInput[]
    id?: IntFilter<"CostItemSupplier"> | number
    costItemId?: IntNullableFilter<"CostItemSupplier"> | number | null
    pendingCostItemId?: IntNullableFilter<"CostItemSupplier"> | number | null
    supplier?: EnumSuppliersFilter<"CostItemSupplier"> | $Enums.Suppliers
    amount?: FloatFilter<"CostItemSupplier"> | number
    paymentMethod?: StringFilter<"CostItemSupplier"> | string
    paidAmount?: FloatFilter<"CostItemSupplier"> | number
    pendingAmount?: FloatFilter<"CostItemSupplier"> | number
    transactionMethod?: StringNullableFilter<"CostItemSupplier"> | string | null
    firstMethodAmount?: FloatNullableFilter<"CostItemSupplier"> | number | null
    secondMethodAmount?: FloatNullableFilter<"CostItemSupplier"> | number | null
    createdAt?: DateTimeFilter<"CostItemSupplier"> | Date | string
    updatedAt?: DateTimeFilter<"CostItemSupplier"> | Date | string
  }

  export type PendingBookingCreateWithoutCostItemsInput = {
    refNo: string
    paxName: string
    agentName: string
    teamName?: $Enums.Teams | null
    pnr: string
    airline: string
    fromTo: string
    bookingType: $Enums.BookingType
    bookingStatus?: $Enums.BookingStatus | null
    pcDate: Date | string
    issuedDate?: Date | string | null
    paymentMethod: $Enums.PaymentMethod
    lastPaymentDate?: Date | string | null
    travelDate?: Date | string | null
    revenue?: number | null
    prodCost?: number | null
    transFee?: number | null
    surcharge?: number | null
    received?: number | null
    transactionMethod?: string | null
    receivedDate?: Date | string | null
    balance?: number | null
    profit?: number | null
    invoiced?: string | null
    description?: string | null
    status?: $Enums.PendingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    numPax: number
    instalments?: PendingInstalmentCreateNestedManyWithoutPendingBookingInput
    passengers?: PendingPassengerCreateNestedManyWithoutPendingBookingInput
  }

  export type PendingBookingUncheckedCreateWithoutCostItemsInput = {
    id?: number
    refNo: string
    paxName: string
    agentName: string
    teamName?: $Enums.Teams | null
    pnr: string
    airline: string
    fromTo: string
    bookingType: $Enums.BookingType
    bookingStatus?: $Enums.BookingStatus | null
    pcDate: Date | string
    issuedDate?: Date | string | null
    paymentMethod: $Enums.PaymentMethod
    lastPaymentDate?: Date | string | null
    travelDate?: Date | string | null
    revenue?: number | null
    prodCost?: number | null
    transFee?: number | null
    surcharge?: number | null
    received?: number | null
    transactionMethod?: string | null
    receivedDate?: Date | string | null
    balance?: number | null
    profit?: number | null
    invoiced?: string | null
    description?: string | null
    status?: $Enums.PendingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    numPax: number
    instalments?: PendingInstalmentUncheckedCreateNestedManyWithoutPendingBookingInput
    passengers?: PendingPassengerUncheckedCreateNestedManyWithoutPendingBookingInput
  }

  export type PendingBookingCreateOrConnectWithoutCostItemsInput = {
    where: PendingBookingWhereUniqueInput
    create: XOR<PendingBookingCreateWithoutCostItemsInput, PendingBookingUncheckedCreateWithoutCostItemsInput>
  }

  export type CostItemSupplierCreateWithoutPendingCostItemInput = {
    supplier: $Enums.Suppliers
    amount: number
    paymentMethod?: string
    paidAmount?: number
    pendingAmount?: number
    transactionMethod?: string | null
    firstMethodAmount?: number | null
    secondMethodAmount?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    costItem?: CostItemCreateNestedOneWithoutSuppliersInput
    settlements?: SupplierPaymentSettlementCreateNestedManyWithoutCostItemSupplierInput
    paidByCreditNoteUsage?: CreditNoteUsageCreateNestedManyWithoutUsedOnCostItemSupplierInput
  }

  export type CostItemSupplierUncheckedCreateWithoutPendingCostItemInput = {
    id?: number
    costItemId?: number | null
    supplier: $Enums.Suppliers
    amount: number
    paymentMethod?: string
    paidAmount?: number
    pendingAmount?: number
    transactionMethod?: string | null
    firstMethodAmount?: number | null
    secondMethodAmount?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    settlements?: SupplierPaymentSettlementUncheckedCreateNestedManyWithoutCostItemSupplierInput
    paidByCreditNoteUsage?: CreditNoteUsageUncheckedCreateNestedManyWithoutUsedOnCostItemSupplierInput
  }

  export type CostItemSupplierCreateOrConnectWithoutPendingCostItemInput = {
    where: CostItemSupplierWhereUniqueInput
    create: XOR<CostItemSupplierCreateWithoutPendingCostItemInput, CostItemSupplierUncheckedCreateWithoutPendingCostItemInput>
  }

  export type CostItemSupplierCreateManyPendingCostItemInputEnvelope = {
    data: CostItemSupplierCreateManyPendingCostItemInput | CostItemSupplierCreateManyPendingCostItemInput[]
    skipDuplicates?: boolean
  }

  export type PendingBookingUpsertWithoutCostItemsInput = {
    update: XOR<PendingBookingUpdateWithoutCostItemsInput, PendingBookingUncheckedUpdateWithoutCostItemsInput>
    create: XOR<PendingBookingCreateWithoutCostItemsInput, PendingBookingUncheckedCreateWithoutCostItemsInput>
    where?: PendingBookingWhereInput
  }

  export type PendingBookingUpdateToOneWithWhereWithoutCostItemsInput = {
    where?: PendingBookingWhereInput
    data: XOR<PendingBookingUpdateWithoutCostItemsInput, PendingBookingUncheckedUpdateWithoutCostItemsInput>
  }

  export type PendingBookingUpdateWithoutCostItemsInput = {
    refNo?: StringFieldUpdateOperationsInput | string
    paxName?: StringFieldUpdateOperationsInput | string
    agentName?: StringFieldUpdateOperationsInput | string
    teamName?: NullableEnumTeamsFieldUpdateOperationsInput | $Enums.Teams | null
    pnr?: StringFieldUpdateOperationsInput | string
    airline?: StringFieldUpdateOperationsInput | string
    fromTo?: StringFieldUpdateOperationsInput | string
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    bookingStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    pcDate?: DateTimeFieldUpdateOperationsInput | Date | string
    issuedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    travelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    prodCost?: NullableFloatFieldUpdateOperationsInput | number | null
    transFee?: NullableFloatFieldUpdateOperationsInput | number | null
    surcharge?: NullableFloatFieldUpdateOperationsInput | number | null
    received?: NullableFloatFieldUpdateOperationsInput | number | null
    transactionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    profit?: NullableFloatFieldUpdateOperationsInput | number | null
    invoiced?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPendingStatusFieldUpdateOperationsInput | $Enums.PendingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    numPax?: IntFieldUpdateOperationsInput | number
    instalments?: PendingInstalmentUpdateManyWithoutPendingBookingNestedInput
    passengers?: PendingPassengerUpdateManyWithoutPendingBookingNestedInput
  }

  export type PendingBookingUncheckedUpdateWithoutCostItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    refNo?: StringFieldUpdateOperationsInput | string
    paxName?: StringFieldUpdateOperationsInput | string
    agentName?: StringFieldUpdateOperationsInput | string
    teamName?: NullableEnumTeamsFieldUpdateOperationsInput | $Enums.Teams | null
    pnr?: StringFieldUpdateOperationsInput | string
    airline?: StringFieldUpdateOperationsInput | string
    fromTo?: StringFieldUpdateOperationsInput | string
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    bookingStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    pcDate?: DateTimeFieldUpdateOperationsInput | Date | string
    issuedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    travelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    prodCost?: NullableFloatFieldUpdateOperationsInput | number | null
    transFee?: NullableFloatFieldUpdateOperationsInput | number | null
    surcharge?: NullableFloatFieldUpdateOperationsInput | number | null
    received?: NullableFloatFieldUpdateOperationsInput | number | null
    transactionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    profit?: NullableFloatFieldUpdateOperationsInput | number | null
    invoiced?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPendingStatusFieldUpdateOperationsInput | $Enums.PendingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    numPax?: IntFieldUpdateOperationsInput | number
    instalments?: PendingInstalmentUncheckedUpdateManyWithoutPendingBookingNestedInput
    passengers?: PendingPassengerUncheckedUpdateManyWithoutPendingBookingNestedInput
  }

  export type CostItemSupplierUpsertWithWhereUniqueWithoutPendingCostItemInput = {
    where: CostItemSupplierWhereUniqueInput
    update: XOR<CostItemSupplierUpdateWithoutPendingCostItemInput, CostItemSupplierUncheckedUpdateWithoutPendingCostItemInput>
    create: XOR<CostItemSupplierCreateWithoutPendingCostItemInput, CostItemSupplierUncheckedCreateWithoutPendingCostItemInput>
  }

  export type CostItemSupplierUpdateWithWhereUniqueWithoutPendingCostItemInput = {
    where: CostItemSupplierWhereUniqueInput
    data: XOR<CostItemSupplierUpdateWithoutPendingCostItemInput, CostItemSupplierUncheckedUpdateWithoutPendingCostItemInput>
  }

  export type CostItemSupplierUpdateManyWithWhereWithoutPendingCostItemInput = {
    where: CostItemSupplierScalarWhereInput
    data: XOR<CostItemSupplierUpdateManyMutationInput, CostItemSupplierUncheckedUpdateManyWithoutPendingCostItemInput>
  }

  export type BookingCreateWithoutPassengersInput = {
    folderNo: number
    refNo: string
    paxName: string
    agentName: string
    teamName?: $Enums.Teams | null
    pnr: string
    airline: string
    fromTo: string
    bookingType: $Enums.BookingType
    bookingStatus?: $Enums.BookingStatus | null
    pcDate: Date | string
    issuedDate?: Date | string | null
    paymentMethod: $Enums.PaymentMethod
    lastPaymentDate?: Date | string | null
    travelDate?: Date | string | null
    revenue?: number | null
    prodCost?: number | null
    transFee?: number | null
    surcharge?: number | null
    received?: number | null
    transactionMethod?: string | null
    receivedDate?: Date | string | null
    balance?: number | null
    profit?: number | null
    invoiced?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    numPax: number
    initialDeposit?: number | null
    costItems?: CostItemCreateNestedManyWithoutBookingInput
    instalments?: InstalmentCreateNestedManyWithoutBookingInput
    cancellation?: CancellationCreateNestedOneWithoutOriginalBookingInput
  }

  export type BookingUncheckedCreateWithoutPassengersInput = {
    id?: number
    folderNo: number
    refNo: string
    paxName: string
    agentName: string
    teamName?: $Enums.Teams | null
    pnr: string
    airline: string
    fromTo: string
    bookingType: $Enums.BookingType
    bookingStatus?: $Enums.BookingStatus | null
    pcDate: Date | string
    issuedDate?: Date | string | null
    paymentMethod: $Enums.PaymentMethod
    lastPaymentDate?: Date | string | null
    travelDate?: Date | string | null
    revenue?: number | null
    prodCost?: number | null
    transFee?: number | null
    surcharge?: number | null
    received?: number | null
    transactionMethod?: string | null
    receivedDate?: Date | string | null
    balance?: number | null
    profit?: number | null
    invoiced?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    numPax: number
    initialDeposit?: number | null
    costItems?: CostItemUncheckedCreateNestedManyWithoutBookingInput
    instalments?: InstalmentUncheckedCreateNestedManyWithoutBookingInput
    cancellation?: CancellationUncheckedCreateNestedOneWithoutOriginalBookingInput
  }

  export type BookingCreateOrConnectWithoutPassengersInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutPassengersInput, BookingUncheckedCreateWithoutPassengersInput>
  }

  export type BookingUpsertWithoutPassengersInput = {
    update: XOR<BookingUpdateWithoutPassengersInput, BookingUncheckedUpdateWithoutPassengersInput>
    create: XOR<BookingCreateWithoutPassengersInput, BookingUncheckedCreateWithoutPassengersInput>
    where?: BookingWhereInput
  }

  export type BookingUpdateToOneWithWhereWithoutPassengersInput = {
    where?: BookingWhereInput
    data: XOR<BookingUpdateWithoutPassengersInput, BookingUncheckedUpdateWithoutPassengersInput>
  }

  export type BookingUpdateWithoutPassengersInput = {
    folderNo?: IntFieldUpdateOperationsInput | number
    refNo?: StringFieldUpdateOperationsInput | string
    paxName?: StringFieldUpdateOperationsInput | string
    agentName?: StringFieldUpdateOperationsInput | string
    teamName?: NullableEnumTeamsFieldUpdateOperationsInput | $Enums.Teams | null
    pnr?: StringFieldUpdateOperationsInput | string
    airline?: StringFieldUpdateOperationsInput | string
    fromTo?: StringFieldUpdateOperationsInput | string
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    bookingStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    pcDate?: DateTimeFieldUpdateOperationsInput | Date | string
    issuedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    travelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    prodCost?: NullableFloatFieldUpdateOperationsInput | number | null
    transFee?: NullableFloatFieldUpdateOperationsInput | number | null
    surcharge?: NullableFloatFieldUpdateOperationsInput | number | null
    received?: NullableFloatFieldUpdateOperationsInput | number | null
    transactionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    profit?: NullableFloatFieldUpdateOperationsInput | number | null
    invoiced?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    numPax?: IntFieldUpdateOperationsInput | number
    initialDeposit?: NullableFloatFieldUpdateOperationsInput | number | null
    costItems?: CostItemUpdateManyWithoutBookingNestedInput
    instalments?: InstalmentUpdateManyWithoutBookingNestedInput
    cancellation?: CancellationUpdateOneWithoutOriginalBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutPassengersInput = {
    id?: IntFieldUpdateOperationsInput | number
    folderNo?: IntFieldUpdateOperationsInput | number
    refNo?: StringFieldUpdateOperationsInput | string
    paxName?: StringFieldUpdateOperationsInput | string
    agentName?: StringFieldUpdateOperationsInput | string
    teamName?: NullableEnumTeamsFieldUpdateOperationsInput | $Enums.Teams | null
    pnr?: StringFieldUpdateOperationsInput | string
    airline?: StringFieldUpdateOperationsInput | string
    fromTo?: StringFieldUpdateOperationsInput | string
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    bookingStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    pcDate?: DateTimeFieldUpdateOperationsInput | Date | string
    issuedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    travelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    prodCost?: NullableFloatFieldUpdateOperationsInput | number | null
    transFee?: NullableFloatFieldUpdateOperationsInput | number | null
    surcharge?: NullableFloatFieldUpdateOperationsInput | number | null
    received?: NullableFloatFieldUpdateOperationsInput | number | null
    transactionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    profit?: NullableFloatFieldUpdateOperationsInput | number | null
    invoiced?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    numPax?: IntFieldUpdateOperationsInput | number
    initialDeposit?: NullableFloatFieldUpdateOperationsInput | number | null
    costItems?: CostItemUncheckedUpdateManyWithoutBookingNestedInput
    instalments?: InstalmentUncheckedUpdateManyWithoutBookingNestedInput
    cancellation?: CancellationUncheckedUpdateOneWithoutOriginalBookingNestedInput
  }

  export type PendingBookingCreateWithoutPassengersInput = {
    refNo: string
    paxName: string
    agentName: string
    teamName?: $Enums.Teams | null
    pnr: string
    airline: string
    fromTo: string
    bookingType: $Enums.BookingType
    bookingStatus?: $Enums.BookingStatus | null
    pcDate: Date | string
    issuedDate?: Date | string | null
    paymentMethod: $Enums.PaymentMethod
    lastPaymentDate?: Date | string | null
    travelDate?: Date | string | null
    revenue?: number | null
    prodCost?: number | null
    transFee?: number | null
    surcharge?: number | null
    received?: number | null
    transactionMethod?: string | null
    receivedDate?: Date | string | null
    balance?: number | null
    profit?: number | null
    invoiced?: string | null
    description?: string | null
    status?: $Enums.PendingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    numPax: number
    costItems?: PendingCostItemCreateNestedManyWithoutPendingBookingInput
    instalments?: PendingInstalmentCreateNestedManyWithoutPendingBookingInput
  }

  export type PendingBookingUncheckedCreateWithoutPassengersInput = {
    id?: number
    refNo: string
    paxName: string
    agentName: string
    teamName?: $Enums.Teams | null
    pnr: string
    airline: string
    fromTo: string
    bookingType: $Enums.BookingType
    bookingStatus?: $Enums.BookingStatus | null
    pcDate: Date | string
    issuedDate?: Date | string | null
    paymentMethod: $Enums.PaymentMethod
    lastPaymentDate?: Date | string | null
    travelDate?: Date | string | null
    revenue?: number | null
    prodCost?: number | null
    transFee?: number | null
    surcharge?: number | null
    received?: number | null
    transactionMethod?: string | null
    receivedDate?: Date | string | null
    balance?: number | null
    profit?: number | null
    invoiced?: string | null
    description?: string | null
    status?: $Enums.PendingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    numPax: number
    costItems?: PendingCostItemUncheckedCreateNestedManyWithoutPendingBookingInput
    instalments?: PendingInstalmentUncheckedCreateNestedManyWithoutPendingBookingInput
  }

  export type PendingBookingCreateOrConnectWithoutPassengersInput = {
    where: PendingBookingWhereUniqueInput
    create: XOR<PendingBookingCreateWithoutPassengersInput, PendingBookingUncheckedCreateWithoutPassengersInput>
  }

  export type PendingBookingUpsertWithoutPassengersInput = {
    update: XOR<PendingBookingUpdateWithoutPassengersInput, PendingBookingUncheckedUpdateWithoutPassengersInput>
    create: XOR<PendingBookingCreateWithoutPassengersInput, PendingBookingUncheckedCreateWithoutPassengersInput>
    where?: PendingBookingWhereInput
  }

  export type PendingBookingUpdateToOneWithWhereWithoutPassengersInput = {
    where?: PendingBookingWhereInput
    data: XOR<PendingBookingUpdateWithoutPassengersInput, PendingBookingUncheckedUpdateWithoutPassengersInput>
  }

  export type PendingBookingUpdateWithoutPassengersInput = {
    refNo?: StringFieldUpdateOperationsInput | string
    paxName?: StringFieldUpdateOperationsInput | string
    agentName?: StringFieldUpdateOperationsInput | string
    teamName?: NullableEnumTeamsFieldUpdateOperationsInput | $Enums.Teams | null
    pnr?: StringFieldUpdateOperationsInput | string
    airline?: StringFieldUpdateOperationsInput | string
    fromTo?: StringFieldUpdateOperationsInput | string
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    bookingStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    pcDate?: DateTimeFieldUpdateOperationsInput | Date | string
    issuedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    travelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    prodCost?: NullableFloatFieldUpdateOperationsInput | number | null
    transFee?: NullableFloatFieldUpdateOperationsInput | number | null
    surcharge?: NullableFloatFieldUpdateOperationsInput | number | null
    received?: NullableFloatFieldUpdateOperationsInput | number | null
    transactionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    profit?: NullableFloatFieldUpdateOperationsInput | number | null
    invoiced?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPendingStatusFieldUpdateOperationsInput | $Enums.PendingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    numPax?: IntFieldUpdateOperationsInput | number
    costItems?: PendingCostItemUpdateManyWithoutPendingBookingNestedInput
    instalments?: PendingInstalmentUpdateManyWithoutPendingBookingNestedInput
  }

  export type PendingBookingUncheckedUpdateWithoutPassengersInput = {
    id?: IntFieldUpdateOperationsInput | number
    refNo?: StringFieldUpdateOperationsInput | string
    paxName?: StringFieldUpdateOperationsInput | string
    agentName?: StringFieldUpdateOperationsInput | string
    teamName?: NullableEnumTeamsFieldUpdateOperationsInput | $Enums.Teams | null
    pnr?: StringFieldUpdateOperationsInput | string
    airline?: StringFieldUpdateOperationsInput | string
    fromTo?: StringFieldUpdateOperationsInput | string
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    bookingStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    pcDate?: DateTimeFieldUpdateOperationsInput | Date | string
    issuedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    travelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    prodCost?: NullableFloatFieldUpdateOperationsInput | number | null
    transFee?: NullableFloatFieldUpdateOperationsInput | number | null
    surcharge?: NullableFloatFieldUpdateOperationsInput | number | null
    received?: NullableFloatFieldUpdateOperationsInput | number | null
    transactionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    profit?: NullableFloatFieldUpdateOperationsInput | number | null
    invoiced?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPendingStatusFieldUpdateOperationsInput | $Enums.PendingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    numPax?: IntFieldUpdateOperationsInput | number
    costItems?: PendingCostItemUncheckedUpdateManyWithoutPendingBookingNestedInput
    instalments?: PendingInstalmentUncheckedUpdateManyWithoutPendingBookingNestedInput
  }

  export type CostItemCreateWithoutSuppliersInput = {
    category: string
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    booking: BookingCreateNestedOneWithoutCostItemsInput
  }

  export type CostItemUncheckedCreateWithoutSuppliersInput = {
    id?: number
    bookingId: number
    category: string
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CostItemCreateOrConnectWithoutSuppliersInput = {
    where: CostItemWhereUniqueInput
    create: XOR<CostItemCreateWithoutSuppliersInput, CostItemUncheckedCreateWithoutSuppliersInput>
  }

  export type PendingCostItemCreateWithoutSuppliersInput = {
    category: string
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    pendingBooking: PendingBookingCreateNestedOneWithoutCostItemsInput
  }

  export type PendingCostItemUncheckedCreateWithoutSuppliersInput = {
    id?: number
    pendingBookingId: number
    category: string
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PendingCostItemCreateOrConnectWithoutSuppliersInput = {
    where: PendingCostItemWhereUniqueInput
    create: XOR<PendingCostItemCreateWithoutSuppliersInput, PendingCostItemUncheckedCreateWithoutSuppliersInput>
  }

  export type SupplierPaymentSettlementCreateWithoutCostItemSupplierInput = {
    amount: number
    transactionMethod: string
    settlementDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupplierPaymentSettlementUncheckedCreateWithoutCostItemSupplierInput = {
    id?: number
    amount: number
    transactionMethod: string
    settlementDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupplierPaymentSettlementCreateOrConnectWithoutCostItemSupplierInput = {
    where: SupplierPaymentSettlementWhereUniqueInput
    create: XOR<SupplierPaymentSettlementCreateWithoutCostItemSupplierInput, SupplierPaymentSettlementUncheckedCreateWithoutCostItemSupplierInput>
  }

  export type SupplierPaymentSettlementCreateManyCostItemSupplierInputEnvelope = {
    data: SupplierPaymentSettlementCreateManyCostItemSupplierInput | SupplierPaymentSettlementCreateManyCostItemSupplierInput[]
    skipDuplicates?: boolean
  }

  export type CreditNoteUsageCreateWithoutUsedOnCostItemSupplierInput = {
    amountUsed: number
    usedAt?: Date | string
    creditNote: SupplierCreditNoteCreateNestedOneWithoutUsageHistoryInput
  }

  export type CreditNoteUsageUncheckedCreateWithoutUsedOnCostItemSupplierInput = {
    id?: number
    amountUsed: number
    usedAt?: Date | string
    creditNoteId: number
  }

  export type CreditNoteUsageCreateOrConnectWithoutUsedOnCostItemSupplierInput = {
    where: CreditNoteUsageWhereUniqueInput
    create: XOR<CreditNoteUsageCreateWithoutUsedOnCostItemSupplierInput, CreditNoteUsageUncheckedCreateWithoutUsedOnCostItemSupplierInput>
  }

  export type CreditNoteUsageCreateManyUsedOnCostItemSupplierInputEnvelope = {
    data: CreditNoteUsageCreateManyUsedOnCostItemSupplierInput | CreditNoteUsageCreateManyUsedOnCostItemSupplierInput[]
    skipDuplicates?: boolean
  }

  export type CostItemUpsertWithoutSuppliersInput = {
    update: XOR<CostItemUpdateWithoutSuppliersInput, CostItemUncheckedUpdateWithoutSuppliersInput>
    create: XOR<CostItemCreateWithoutSuppliersInput, CostItemUncheckedCreateWithoutSuppliersInput>
    where?: CostItemWhereInput
  }

  export type CostItemUpdateToOneWithWhereWithoutSuppliersInput = {
    where?: CostItemWhereInput
    data: XOR<CostItemUpdateWithoutSuppliersInput, CostItemUncheckedUpdateWithoutSuppliersInput>
  }

  export type CostItemUpdateWithoutSuppliersInput = {
    category?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUpdateOneRequiredWithoutCostItemsNestedInput
  }

  export type CostItemUncheckedUpdateWithoutSuppliersInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookingId?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PendingCostItemUpsertWithoutSuppliersInput = {
    update: XOR<PendingCostItemUpdateWithoutSuppliersInput, PendingCostItemUncheckedUpdateWithoutSuppliersInput>
    create: XOR<PendingCostItemCreateWithoutSuppliersInput, PendingCostItemUncheckedCreateWithoutSuppliersInput>
    where?: PendingCostItemWhereInput
  }

  export type PendingCostItemUpdateToOneWithWhereWithoutSuppliersInput = {
    where?: PendingCostItemWhereInput
    data: XOR<PendingCostItemUpdateWithoutSuppliersInput, PendingCostItemUncheckedUpdateWithoutSuppliersInput>
  }

  export type PendingCostItemUpdateWithoutSuppliersInput = {
    category?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pendingBooking?: PendingBookingUpdateOneRequiredWithoutCostItemsNestedInput
  }

  export type PendingCostItemUncheckedUpdateWithoutSuppliersInput = {
    id?: IntFieldUpdateOperationsInput | number
    pendingBookingId?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierPaymentSettlementUpsertWithWhereUniqueWithoutCostItemSupplierInput = {
    where: SupplierPaymentSettlementWhereUniqueInput
    update: XOR<SupplierPaymentSettlementUpdateWithoutCostItemSupplierInput, SupplierPaymentSettlementUncheckedUpdateWithoutCostItemSupplierInput>
    create: XOR<SupplierPaymentSettlementCreateWithoutCostItemSupplierInput, SupplierPaymentSettlementUncheckedCreateWithoutCostItemSupplierInput>
  }

  export type SupplierPaymentSettlementUpdateWithWhereUniqueWithoutCostItemSupplierInput = {
    where: SupplierPaymentSettlementWhereUniqueInput
    data: XOR<SupplierPaymentSettlementUpdateWithoutCostItemSupplierInput, SupplierPaymentSettlementUncheckedUpdateWithoutCostItemSupplierInput>
  }

  export type SupplierPaymentSettlementUpdateManyWithWhereWithoutCostItemSupplierInput = {
    where: SupplierPaymentSettlementScalarWhereInput
    data: XOR<SupplierPaymentSettlementUpdateManyMutationInput, SupplierPaymentSettlementUncheckedUpdateManyWithoutCostItemSupplierInput>
  }

  export type SupplierPaymentSettlementScalarWhereInput = {
    AND?: SupplierPaymentSettlementScalarWhereInput | SupplierPaymentSettlementScalarWhereInput[]
    OR?: SupplierPaymentSettlementScalarWhereInput[]
    NOT?: SupplierPaymentSettlementScalarWhereInput | SupplierPaymentSettlementScalarWhereInput[]
    id?: IntFilter<"SupplierPaymentSettlement"> | number
    costItemSupplierId?: IntFilter<"SupplierPaymentSettlement"> | number
    amount?: FloatFilter<"SupplierPaymentSettlement"> | number
    transactionMethod?: StringFilter<"SupplierPaymentSettlement"> | string
    settlementDate?: DateTimeFilter<"SupplierPaymentSettlement"> | Date | string
    createdAt?: DateTimeFilter<"SupplierPaymentSettlement"> | Date | string
    updatedAt?: DateTimeFilter<"SupplierPaymentSettlement"> | Date | string
  }

  export type CreditNoteUsageUpsertWithWhereUniqueWithoutUsedOnCostItemSupplierInput = {
    where: CreditNoteUsageWhereUniqueInput
    update: XOR<CreditNoteUsageUpdateWithoutUsedOnCostItemSupplierInput, CreditNoteUsageUncheckedUpdateWithoutUsedOnCostItemSupplierInput>
    create: XOR<CreditNoteUsageCreateWithoutUsedOnCostItemSupplierInput, CreditNoteUsageUncheckedCreateWithoutUsedOnCostItemSupplierInput>
  }

  export type CreditNoteUsageUpdateWithWhereUniqueWithoutUsedOnCostItemSupplierInput = {
    where: CreditNoteUsageWhereUniqueInput
    data: XOR<CreditNoteUsageUpdateWithoutUsedOnCostItemSupplierInput, CreditNoteUsageUncheckedUpdateWithoutUsedOnCostItemSupplierInput>
  }

  export type CreditNoteUsageUpdateManyWithWhereWithoutUsedOnCostItemSupplierInput = {
    where: CreditNoteUsageScalarWhereInput
    data: XOR<CreditNoteUsageUpdateManyMutationInput, CreditNoteUsageUncheckedUpdateManyWithoutUsedOnCostItemSupplierInput>
  }

  export type CreditNoteUsageScalarWhereInput = {
    AND?: CreditNoteUsageScalarWhereInput | CreditNoteUsageScalarWhereInput[]
    OR?: CreditNoteUsageScalarWhereInput[]
    NOT?: CreditNoteUsageScalarWhereInput | CreditNoteUsageScalarWhereInput[]
    id?: IntFilter<"CreditNoteUsage"> | number
    amountUsed?: FloatFilter<"CreditNoteUsage"> | number
    usedAt?: DateTimeFilter<"CreditNoteUsage"> | Date | string
    creditNoteId?: IntFilter<"CreditNoteUsage"> | number
    usedOnCostItemSupplierId?: IntFilter<"CreditNoteUsage"> | number
  }

  export type CostItemSupplierCreateWithoutSettlementsInput = {
    supplier: $Enums.Suppliers
    amount: number
    paymentMethod?: string
    paidAmount?: number
    pendingAmount?: number
    transactionMethod?: string | null
    firstMethodAmount?: number | null
    secondMethodAmount?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    costItem?: CostItemCreateNestedOneWithoutSuppliersInput
    pendingCostItem?: PendingCostItemCreateNestedOneWithoutSuppliersInput
    paidByCreditNoteUsage?: CreditNoteUsageCreateNestedManyWithoutUsedOnCostItemSupplierInput
  }

  export type CostItemSupplierUncheckedCreateWithoutSettlementsInput = {
    id?: number
    costItemId?: number | null
    pendingCostItemId?: number | null
    supplier: $Enums.Suppliers
    amount: number
    paymentMethod?: string
    paidAmount?: number
    pendingAmount?: number
    transactionMethod?: string | null
    firstMethodAmount?: number | null
    secondMethodAmount?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    paidByCreditNoteUsage?: CreditNoteUsageUncheckedCreateNestedManyWithoutUsedOnCostItemSupplierInput
  }

  export type CostItemSupplierCreateOrConnectWithoutSettlementsInput = {
    where: CostItemSupplierWhereUniqueInput
    create: XOR<CostItemSupplierCreateWithoutSettlementsInput, CostItemSupplierUncheckedCreateWithoutSettlementsInput>
  }

  export type CostItemSupplierUpsertWithoutSettlementsInput = {
    update: XOR<CostItemSupplierUpdateWithoutSettlementsInput, CostItemSupplierUncheckedUpdateWithoutSettlementsInput>
    create: XOR<CostItemSupplierCreateWithoutSettlementsInput, CostItemSupplierUncheckedCreateWithoutSettlementsInput>
    where?: CostItemSupplierWhereInput
  }

  export type CostItemSupplierUpdateToOneWithWhereWithoutSettlementsInput = {
    where?: CostItemSupplierWhereInput
    data: XOR<CostItemSupplierUpdateWithoutSettlementsInput, CostItemSupplierUncheckedUpdateWithoutSettlementsInput>
  }

  export type CostItemSupplierUpdateWithoutSettlementsInput = {
    supplier?: EnumSuppliersFieldUpdateOperationsInput | $Enums.Suppliers
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: StringFieldUpdateOperationsInput | string
    paidAmount?: FloatFieldUpdateOperationsInput | number
    pendingAmount?: FloatFieldUpdateOperationsInput | number
    transactionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    firstMethodAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    secondMethodAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    costItem?: CostItemUpdateOneWithoutSuppliersNestedInput
    pendingCostItem?: PendingCostItemUpdateOneWithoutSuppliersNestedInput
    paidByCreditNoteUsage?: CreditNoteUsageUpdateManyWithoutUsedOnCostItemSupplierNestedInput
  }

  export type CostItemSupplierUncheckedUpdateWithoutSettlementsInput = {
    id?: IntFieldUpdateOperationsInput | number
    costItemId?: NullableIntFieldUpdateOperationsInput | number | null
    pendingCostItemId?: NullableIntFieldUpdateOperationsInput | number | null
    supplier?: EnumSuppliersFieldUpdateOperationsInput | $Enums.Suppliers
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: StringFieldUpdateOperationsInput | string
    paidAmount?: FloatFieldUpdateOperationsInput | number
    pendingAmount?: FloatFieldUpdateOperationsInput | number
    transactionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    firstMethodAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    secondMethodAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paidByCreditNoteUsage?: CreditNoteUsageUncheckedUpdateManyWithoutUsedOnCostItemSupplierNestedInput
  }

  export type BookingCreateWithoutCancellationInput = {
    folderNo: number
    refNo: string
    paxName: string
    agentName: string
    teamName?: $Enums.Teams | null
    pnr: string
    airline: string
    fromTo: string
    bookingType: $Enums.BookingType
    bookingStatus?: $Enums.BookingStatus | null
    pcDate: Date | string
    issuedDate?: Date | string | null
    paymentMethod: $Enums.PaymentMethod
    lastPaymentDate?: Date | string | null
    travelDate?: Date | string | null
    revenue?: number | null
    prodCost?: number | null
    transFee?: number | null
    surcharge?: number | null
    received?: number | null
    transactionMethod?: string | null
    receivedDate?: Date | string | null
    balance?: number | null
    profit?: number | null
    invoiced?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    numPax: number
    initialDeposit?: number | null
    costItems?: CostItemCreateNestedManyWithoutBookingInput
    instalments?: InstalmentCreateNestedManyWithoutBookingInput
    passengers?: PassengerCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutCancellationInput = {
    id?: number
    folderNo: number
    refNo: string
    paxName: string
    agentName: string
    teamName?: $Enums.Teams | null
    pnr: string
    airline: string
    fromTo: string
    bookingType: $Enums.BookingType
    bookingStatus?: $Enums.BookingStatus | null
    pcDate: Date | string
    issuedDate?: Date | string | null
    paymentMethod: $Enums.PaymentMethod
    lastPaymentDate?: Date | string | null
    travelDate?: Date | string | null
    revenue?: number | null
    prodCost?: number | null
    transFee?: number | null
    surcharge?: number | null
    received?: number | null
    transactionMethod?: string | null
    receivedDate?: Date | string | null
    balance?: number | null
    profit?: number | null
    invoiced?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    numPax: number
    initialDeposit?: number | null
    costItems?: CostItemUncheckedCreateNestedManyWithoutBookingInput
    instalments?: InstalmentUncheckedCreateNestedManyWithoutBookingInput
    passengers?: PassengerUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutCancellationInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutCancellationInput, BookingUncheckedCreateWithoutCancellationInput>
  }

  export type SupplierCreditNoteCreateWithoutGeneratedFromCancellationInput = {
    supplier: $Enums.Suppliers
    initialAmount: number
    remainingAmount: number
    status?: $Enums.CreditNoteStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    usageHistory?: CreditNoteUsageCreateNestedManyWithoutCreditNoteInput
  }

  export type SupplierCreditNoteUncheckedCreateWithoutGeneratedFromCancellationInput = {
    id?: number
    supplier: $Enums.Suppliers
    initialAmount: number
    remainingAmount: number
    status?: $Enums.CreditNoteStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    usageHistory?: CreditNoteUsageUncheckedCreateNestedManyWithoutCreditNoteInput
  }

  export type SupplierCreditNoteCreateOrConnectWithoutGeneratedFromCancellationInput = {
    where: SupplierCreditNoteWhereUniqueInput
    create: XOR<SupplierCreditNoteCreateWithoutGeneratedFromCancellationInput, SupplierCreditNoteUncheckedCreateWithoutGeneratedFromCancellationInput>
  }

  export type BookingUpsertWithoutCancellationInput = {
    update: XOR<BookingUpdateWithoutCancellationInput, BookingUncheckedUpdateWithoutCancellationInput>
    create: XOR<BookingCreateWithoutCancellationInput, BookingUncheckedCreateWithoutCancellationInput>
    where?: BookingWhereInput
  }

  export type BookingUpdateToOneWithWhereWithoutCancellationInput = {
    where?: BookingWhereInput
    data: XOR<BookingUpdateWithoutCancellationInput, BookingUncheckedUpdateWithoutCancellationInput>
  }

  export type BookingUpdateWithoutCancellationInput = {
    folderNo?: IntFieldUpdateOperationsInput | number
    refNo?: StringFieldUpdateOperationsInput | string
    paxName?: StringFieldUpdateOperationsInput | string
    agentName?: StringFieldUpdateOperationsInput | string
    teamName?: NullableEnumTeamsFieldUpdateOperationsInput | $Enums.Teams | null
    pnr?: StringFieldUpdateOperationsInput | string
    airline?: StringFieldUpdateOperationsInput | string
    fromTo?: StringFieldUpdateOperationsInput | string
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    bookingStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    pcDate?: DateTimeFieldUpdateOperationsInput | Date | string
    issuedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    travelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    prodCost?: NullableFloatFieldUpdateOperationsInput | number | null
    transFee?: NullableFloatFieldUpdateOperationsInput | number | null
    surcharge?: NullableFloatFieldUpdateOperationsInput | number | null
    received?: NullableFloatFieldUpdateOperationsInput | number | null
    transactionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    profit?: NullableFloatFieldUpdateOperationsInput | number | null
    invoiced?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    numPax?: IntFieldUpdateOperationsInput | number
    initialDeposit?: NullableFloatFieldUpdateOperationsInput | number | null
    costItems?: CostItemUpdateManyWithoutBookingNestedInput
    instalments?: InstalmentUpdateManyWithoutBookingNestedInput
    passengers?: PassengerUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutCancellationInput = {
    id?: IntFieldUpdateOperationsInput | number
    folderNo?: IntFieldUpdateOperationsInput | number
    refNo?: StringFieldUpdateOperationsInput | string
    paxName?: StringFieldUpdateOperationsInput | string
    agentName?: StringFieldUpdateOperationsInput | string
    teamName?: NullableEnumTeamsFieldUpdateOperationsInput | $Enums.Teams | null
    pnr?: StringFieldUpdateOperationsInput | string
    airline?: StringFieldUpdateOperationsInput | string
    fromTo?: StringFieldUpdateOperationsInput | string
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    bookingStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    pcDate?: DateTimeFieldUpdateOperationsInput | Date | string
    issuedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    travelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    prodCost?: NullableFloatFieldUpdateOperationsInput | number | null
    transFee?: NullableFloatFieldUpdateOperationsInput | number | null
    surcharge?: NullableFloatFieldUpdateOperationsInput | number | null
    received?: NullableFloatFieldUpdateOperationsInput | number | null
    transactionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    profit?: NullableFloatFieldUpdateOperationsInput | number | null
    invoiced?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    numPax?: IntFieldUpdateOperationsInput | number
    initialDeposit?: NullableFloatFieldUpdateOperationsInput | number | null
    costItems?: CostItemUncheckedUpdateManyWithoutBookingNestedInput
    instalments?: InstalmentUncheckedUpdateManyWithoutBookingNestedInput
    passengers?: PassengerUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type SupplierCreditNoteUpsertWithoutGeneratedFromCancellationInput = {
    update: XOR<SupplierCreditNoteUpdateWithoutGeneratedFromCancellationInput, SupplierCreditNoteUncheckedUpdateWithoutGeneratedFromCancellationInput>
    create: XOR<SupplierCreditNoteCreateWithoutGeneratedFromCancellationInput, SupplierCreditNoteUncheckedCreateWithoutGeneratedFromCancellationInput>
    where?: SupplierCreditNoteWhereInput
  }

  export type SupplierCreditNoteUpdateToOneWithWhereWithoutGeneratedFromCancellationInput = {
    where?: SupplierCreditNoteWhereInput
    data: XOR<SupplierCreditNoteUpdateWithoutGeneratedFromCancellationInput, SupplierCreditNoteUncheckedUpdateWithoutGeneratedFromCancellationInput>
  }

  export type SupplierCreditNoteUpdateWithoutGeneratedFromCancellationInput = {
    supplier?: EnumSuppliersFieldUpdateOperationsInput | $Enums.Suppliers
    initialAmount?: FloatFieldUpdateOperationsInput | number
    remainingAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumCreditNoteStatusFieldUpdateOperationsInput | $Enums.CreditNoteStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usageHistory?: CreditNoteUsageUpdateManyWithoutCreditNoteNestedInput
  }

  export type SupplierCreditNoteUncheckedUpdateWithoutGeneratedFromCancellationInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplier?: EnumSuppliersFieldUpdateOperationsInput | $Enums.Suppliers
    initialAmount?: FloatFieldUpdateOperationsInput | number
    remainingAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumCreditNoteStatusFieldUpdateOperationsInput | $Enums.CreditNoteStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usageHistory?: CreditNoteUsageUncheckedUpdateManyWithoutCreditNoteNestedInput
  }

  export type CancellationCreateWithoutGeneratedCreditNoteInput = {
    folderNo: string
    refundTransactionMethod: string
    originalRevenue: number
    originalProdCost: number
    supplierCancellationFee: number
    refundToPassenger: number
    creditNoteAmount?: number | null
    profitOrLoss: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    originalBooking: BookingCreateNestedOneWithoutCancellationInput
  }

  export type CancellationUncheckedCreateWithoutGeneratedCreditNoteInput = {
    id?: number
    originalBookingId: number
    folderNo: string
    refundTransactionMethod: string
    originalRevenue: number
    originalProdCost: number
    supplierCancellationFee: number
    refundToPassenger: number
    creditNoteAmount?: number | null
    profitOrLoss: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CancellationCreateOrConnectWithoutGeneratedCreditNoteInput = {
    where: CancellationWhereUniqueInput
    create: XOR<CancellationCreateWithoutGeneratedCreditNoteInput, CancellationUncheckedCreateWithoutGeneratedCreditNoteInput>
  }

  export type CreditNoteUsageCreateWithoutCreditNoteInput = {
    amountUsed: number
    usedAt?: Date | string
    usedOnCostItemSupplier: CostItemSupplierCreateNestedOneWithoutPaidByCreditNoteUsageInput
  }

  export type CreditNoteUsageUncheckedCreateWithoutCreditNoteInput = {
    id?: number
    amountUsed: number
    usedAt?: Date | string
    usedOnCostItemSupplierId: number
  }

  export type CreditNoteUsageCreateOrConnectWithoutCreditNoteInput = {
    where: CreditNoteUsageWhereUniqueInput
    create: XOR<CreditNoteUsageCreateWithoutCreditNoteInput, CreditNoteUsageUncheckedCreateWithoutCreditNoteInput>
  }

  export type CreditNoteUsageCreateManyCreditNoteInputEnvelope = {
    data: CreditNoteUsageCreateManyCreditNoteInput | CreditNoteUsageCreateManyCreditNoteInput[]
    skipDuplicates?: boolean
  }

  export type CancellationUpsertWithoutGeneratedCreditNoteInput = {
    update: XOR<CancellationUpdateWithoutGeneratedCreditNoteInput, CancellationUncheckedUpdateWithoutGeneratedCreditNoteInput>
    create: XOR<CancellationCreateWithoutGeneratedCreditNoteInput, CancellationUncheckedCreateWithoutGeneratedCreditNoteInput>
    where?: CancellationWhereInput
  }

  export type CancellationUpdateToOneWithWhereWithoutGeneratedCreditNoteInput = {
    where?: CancellationWhereInput
    data: XOR<CancellationUpdateWithoutGeneratedCreditNoteInput, CancellationUncheckedUpdateWithoutGeneratedCreditNoteInput>
  }

  export type CancellationUpdateWithoutGeneratedCreditNoteInput = {
    folderNo?: StringFieldUpdateOperationsInput | string
    refundTransactionMethod?: StringFieldUpdateOperationsInput | string
    originalRevenue?: FloatFieldUpdateOperationsInput | number
    originalProdCost?: FloatFieldUpdateOperationsInput | number
    supplierCancellationFee?: FloatFieldUpdateOperationsInput | number
    refundToPassenger?: FloatFieldUpdateOperationsInput | number
    creditNoteAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    profitOrLoss?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    originalBooking?: BookingUpdateOneRequiredWithoutCancellationNestedInput
  }

  export type CancellationUncheckedUpdateWithoutGeneratedCreditNoteInput = {
    id?: IntFieldUpdateOperationsInput | number
    originalBookingId?: IntFieldUpdateOperationsInput | number
    folderNo?: StringFieldUpdateOperationsInput | string
    refundTransactionMethod?: StringFieldUpdateOperationsInput | string
    originalRevenue?: FloatFieldUpdateOperationsInput | number
    originalProdCost?: FloatFieldUpdateOperationsInput | number
    supplierCancellationFee?: FloatFieldUpdateOperationsInput | number
    refundToPassenger?: FloatFieldUpdateOperationsInput | number
    creditNoteAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    profitOrLoss?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditNoteUsageUpsertWithWhereUniqueWithoutCreditNoteInput = {
    where: CreditNoteUsageWhereUniqueInput
    update: XOR<CreditNoteUsageUpdateWithoutCreditNoteInput, CreditNoteUsageUncheckedUpdateWithoutCreditNoteInput>
    create: XOR<CreditNoteUsageCreateWithoutCreditNoteInput, CreditNoteUsageUncheckedCreateWithoutCreditNoteInput>
  }

  export type CreditNoteUsageUpdateWithWhereUniqueWithoutCreditNoteInput = {
    where: CreditNoteUsageWhereUniqueInput
    data: XOR<CreditNoteUsageUpdateWithoutCreditNoteInput, CreditNoteUsageUncheckedUpdateWithoutCreditNoteInput>
  }

  export type CreditNoteUsageUpdateManyWithWhereWithoutCreditNoteInput = {
    where: CreditNoteUsageScalarWhereInput
    data: XOR<CreditNoteUsageUpdateManyMutationInput, CreditNoteUsageUncheckedUpdateManyWithoutCreditNoteInput>
  }

  export type SupplierCreditNoteCreateWithoutUsageHistoryInput = {
    supplier: $Enums.Suppliers
    initialAmount: number
    remainingAmount: number
    status?: $Enums.CreditNoteStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    generatedFromCancellation: CancellationCreateNestedOneWithoutGeneratedCreditNoteInput
  }

  export type SupplierCreditNoteUncheckedCreateWithoutUsageHistoryInput = {
    id?: number
    supplier: $Enums.Suppliers
    initialAmount: number
    remainingAmount: number
    status?: $Enums.CreditNoteStatus
    generatedFromCancellationId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupplierCreditNoteCreateOrConnectWithoutUsageHistoryInput = {
    where: SupplierCreditNoteWhereUniqueInput
    create: XOR<SupplierCreditNoteCreateWithoutUsageHistoryInput, SupplierCreditNoteUncheckedCreateWithoutUsageHistoryInput>
  }

  export type CostItemSupplierCreateWithoutPaidByCreditNoteUsageInput = {
    supplier: $Enums.Suppliers
    amount: number
    paymentMethod?: string
    paidAmount?: number
    pendingAmount?: number
    transactionMethod?: string | null
    firstMethodAmount?: number | null
    secondMethodAmount?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    costItem?: CostItemCreateNestedOneWithoutSuppliersInput
    pendingCostItem?: PendingCostItemCreateNestedOneWithoutSuppliersInput
    settlements?: SupplierPaymentSettlementCreateNestedManyWithoutCostItemSupplierInput
  }

  export type CostItemSupplierUncheckedCreateWithoutPaidByCreditNoteUsageInput = {
    id?: number
    costItemId?: number | null
    pendingCostItemId?: number | null
    supplier: $Enums.Suppliers
    amount: number
    paymentMethod?: string
    paidAmount?: number
    pendingAmount?: number
    transactionMethod?: string | null
    firstMethodAmount?: number | null
    secondMethodAmount?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    settlements?: SupplierPaymentSettlementUncheckedCreateNestedManyWithoutCostItemSupplierInput
  }

  export type CostItemSupplierCreateOrConnectWithoutPaidByCreditNoteUsageInput = {
    where: CostItemSupplierWhereUniqueInput
    create: XOR<CostItemSupplierCreateWithoutPaidByCreditNoteUsageInput, CostItemSupplierUncheckedCreateWithoutPaidByCreditNoteUsageInput>
  }

  export type SupplierCreditNoteUpsertWithoutUsageHistoryInput = {
    update: XOR<SupplierCreditNoteUpdateWithoutUsageHistoryInput, SupplierCreditNoteUncheckedUpdateWithoutUsageHistoryInput>
    create: XOR<SupplierCreditNoteCreateWithoutUsageHistoryInput, SupplierCreditNoteUncheckedCreateWithoutUsageHistoryInput>
    where?: SupplierCreditNoteWhereInput
  }

  export type SupplierCreditNoteUpdateToOneWithWhereWithoutUsageHistoryInput = {
    where?: SupplierCreditNoteWhereInput
    data: XOR<SupplierCreditNoteUpdateWithoutUsageHistoryInput, SupplierCreditNoteUncheckedUpdateWithoutUsageHistoryInput>
  }

  export type SupplierCreditNoteUpdateWithoutUsageHistoryInput = {
    supplier?: EnumSuppliersFieldUpdateOperationsInput | $Enums.Suppliers
    initialAmount?: FloatFieldUpdateOperationsInput | number
    remainingAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumCreditNoteStatusFieldUpdateOperationsInput | $Enums.CreditNoteStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    generatedFromCancellation?: CancellationUpdateOneRequiredWithoutGeneratedCreditNoteNestedInput
  }

  export type SupplierCreditNoteUncheckedUpdateWithoutUsageHistoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplier?: EnumSuppliersFieldUpdateOperationsInput | $Enums.Suppliers
    initialAmount?: FloatFieldUpdateOperationsInput | number
    remainingAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumCreditNoteStatusFieldUpdateOperationsInput | $Enums.CreditNoteStatus
    generatedFromCancellationId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CostItemSupplierUpsertWithoutPaidByCreditNoteUsageInput = {
    update: XOR<CostItemSupplierUpdateWithoutPaidByCreditNoteUsageInput, CostItemSupplierUncheckedUpdateWithoutPaidByCreditNoteUsageInput>
    create: XOR<CostItemSupplierCreateWithoutPaidByCreditNoteUsageInput, CostItemSupplierUncheckedCreateWithoutPaidByCreditNoteUsageInput>
    where?: CostItemSupplierWhereInput
  }

  export type CostItemSupplierUpdateToOneWithWhereWithoutPaidByCreditNoteUsageInput = {
    where?: CostItemSupplierWhereInput
    data: XOR<CostItemSupplierUpdateWithoutPaidByCreditNoteUsageInput, CostItemSupplierUncheckedUpdateWithoutPaidByCreditNoteUsageInput>
  }

  export type CostItemSupplierUpdateWithoutPaidByCreditNoteUsageInput = {
    supplier?: EnumSuppliersFieldUpdateOperationsInput | $Enums.Suppliers
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: StringFieldUpdateOperationsInput | string
    paidAmount?: FloatFieldUpdateOperationsInput | number
    pendingAmount?: FloatFieldUpdateOperationsInput | number
    transactionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    firstMethodAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    secondMethodAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    costItem?: CostItemUpdateOneWithoutSuppliersNestedInput
    pendingCostItem?: PendingCostItemUpdateOneWithoutSuppliersNestedInput
    settlements?: SupplierPaymentSettlementUpdateManyWithoutCostItemSupplierNestedInput
  }

  export type CostItemSupplierUncheckedUpdateWithoutPaidByCreditNoteUsageInput = {
    id?: IntFieldUpdateOperationsInput | number
    costItemId?: NullableIntFieldUpdateOperationsInput | number | null
    pendingCostItemId?: NullableIntFieldUpdateOperationsInput | number | null
    supplier?: EnumSuppliersFieldUpdateOperationsInput | $Enums.Suppliers
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: StringFieldUpdateOperationsInput | string
    paidAmount?: FloatFieldUpdateOperationsInput | number
    pendingAmount?: FloatFieldUpdateOperationsInput | number
    transactionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    firstMethodAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    secondMethodAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settlements?: SupplierPaymentSettlementUncheckedUpdateManyWithoutCostItemSupplierNestedInput
  }

  export type CostItemCreateManyBookingInput = {
    id?: number
    category: string
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InstalmentCreateManyBookingInput = {
    id?: number
    dueDate: Date | string
    amount: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PassengerCreateManyBookingInput = {
    id?: number
    title: $Enums.Title
    firstName: string
    middleName?: string | null
    lastName: string
    gender: $Enums.Gender
    email?: string | null
    contactNo?: string | null
    nationality?: string | null
    birthday?: Date | string | null
    category: $Enums.PassengerCategory
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CostItemUpdateWithoutBookingInput = {
    category?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    suppliers?: CostItemSupplierUpdateManyWithoutCostItemNestedInput
  }

  export type CostItemUncheckedUpdateWithoutBookingInput = {
    id?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    suppliers?: CostItemSupplierUncheckedUpdateManyWithoutCostItemNestedInput
  }

  export type CostItemUncheckedUpdateManyWithoutBookingInput = {
    id?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstalmentUpdateWithoutBookingInput = {
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: InstalmentPaymentUpdateManyWithoutInstalmentNestedInput
  }

  export type InstalmentUncheckedUpdateWithoutBookingInput = {
    id?: IntFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: InstalmentPaymentUncheckedUpdateManyWithoutInstalmentNestedInput
  }

  export type InstalmentUncheckedUpdateManyWithoutBookingInput = {
    id?: IntFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PassengerUpdateWithoutBookingInput = {
    title?: EnumTitleFieldUpdateOperationsInput | $Enums.Title
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: EnumPassengerCategoryFieldUpdateOperationsInput | $Enums.PassengerCategory
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PassengerUncheckedUpdateWithoutBookingInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: EnumTitleFieldUpdateOperationsInput | $Enums.Title
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: EnumPassengerCategoryFieldUpdateOperationsInput | $Enums.PassengerCategory
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PassengerUncheckedUpdateManyWithoutBookingInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: EnumTitleFieldUpdateOperationsInput | $Enums.Title
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: EnumPassengerCategoryFieldUpdateOperationsInput | $Enums.PassengerCategory
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PendingCostItemCreateManyPendingBookingInput = {
    id?: number
    category: string
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PendingInstalmentCreateManyPendingBookingInput = {
    id?: number
    dueDate: Date | string
    amount: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PendingPassengerCreateManyPendingBookingInput = {
    id?: number
    title: $Enums.Title
    firstName: string
    middleName?: string | null
    lastName: string
    gender: $Enums.Gender
    email?: string | null
    contactNo?: string | null
    nationality?: string | null
    birthday?: Date | string | null
    category: $Enums.PassengerCategory
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PendingCostItemUpdateWithoutPendingBookingInput = {
    category?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    suppliers?: CostItemSupplierUpdateManyWithoutPendingCostItemNestedInput
  }

  export type PendingCostItemUncheckedUpdateWithoutPendingBookingInput = {
    id?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    suppliers?: CostItemSupplierUncheckedUpdateManyWithoutPendingCostItemNestedInput
  }

  export type PendingCostItemUncheckedUpdateManyWithoutPendingBookingInput = {
    id?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PendingInstalmentUpdateWithoutPendingBookingInput = {
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PendingInstalmentUncheckedUpdateWithoutPendingBookingInput = {
    id?: IntFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PendingInstalmentUncheckedUpdateManyWithoutPendingBookingInput = {
    id?: IntFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PendingPassengerUpdateWithoutPendingBookingInput = {
    title?: EnumTitleFieldUpdateOperationsInput | $Enums.Title
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: EnumPassengerCategoryFieldUpdateOperationsInput | $Enums.PassengerCategory
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PendingPassengerUncheckedUpdateWithoutPendingBookingInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: EnumTitleFieldUpdateOperationsInput | $Enums.Title
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: EnumPassengerCategoryFieldUpdateOperationsInput | $Enums.PassengerCategory
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PendingPassengerUncheckedUpdateManyWithoutPendingBookingInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: EnumTitleFieldUpdateOperationsInput | $Enums.Title
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: EnumPassengerCategoryFieldUpdateOperationsInput | $Enums.PassengerCategory
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstalmentPaymentCreateManyInstalmentInput = {
    id?: number
    amount: number
    transactionMethod: string
    paymentDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InstalmentPaymentUpdateWithoutInstalmentInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    transactionMethod?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstalmentPaymentUncheckedUpdateWithoutInstalmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    transactionMethod?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstalmentPaymentUncheckedUpdateManyWithoutInstalmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    transactionMethod?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CostItemSupplierCreateManyCostItemInput = {
    id?: number
    pendingCostItemId?: number | null
    supplier: $Enums.Suppliers
    amount: number
    paymentMethod?: string
    paidAmount?: number
    pendingAmount?: number
    transactionMethod?: string | null
    firstMethodAmount?: number | null
    secondMethodAmount?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CostItemSupplierUpdateWithoutCostItemInput = {
    supplier?: EnumSuppliersFieldUpdateOperationsInput | $Enums.Suppliers
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: StringFieldUpdateOperationsInput | string
    paidAmount?: FloatFieldUpdateOperationsInput | number
    pendingAmount?: FloatFieldUpdateOperationsInput | number
    transactionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    firstMethodAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    secondMethodAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pendingCostItem?: PendingCostItemUpdateOneWithoutSuppliersNestedInput
    settlements?: SupplierPaymentSettlementUpdateManyWithoutCostItemSupplierNestedInput
    paidByCreditNoteUsage?: CreditNoteUsageUpdateManyWithoutUsedOnCostItemSupplierNestedInput
  }

  export type CostItemSupplierUncheckedUpdateWithoutCostItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    pendingCostItemId?: NullableIntFieldUpdateOperationsInput | number | null
    supplier?: EnumSuppliersFieldUpdateOperationsInput | $Enums.Suppliers
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: StringFieldUpdateOperationsInput | string
    paidAmount?: FloatFieldUpdateOperationsInput | number
    pendingAmount?: FloatFieldUpdateOperationsInput | number
    transactionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    firstMethodAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    secondMethodAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settlements?: SupplierPaymentSettlementUncheckedUpdateManyWithoutCostItemSupplierNestedInput
    paidByCreditNoteUsage?: CreditNoteUsageUncheckedUpdateManyWithoutUsedOnCostItemSupplierNestedInput
  }

  export type CostItemSupplierUncheckedUpdateManyWithoutCostItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    pendingCostItemId?: NullableIntFieldUpdateOperationsInput | number | null
    supplier?: EnumSuppliersFieldUpdateOperationsInput | $Enums.Suppliers
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: StringFieldUpdateOperationsInput | string
    paidAmount?: FloatFieldUpdateOperationsInput | number
    pendingAmount?: FloatFieldUpdateOperationsInput | number
    transactionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    firstMethodAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    secondMethodAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CostItemSupplierCreateManyPendingCostItemInput = {
    id?: number
    costItemId?: number | null
    supplier: $Enums.Suppliers
    amount: number
    paymentMethod?: string
    paidAmount?: number
    pendingAmount?: number
    transactionMethod?: string | null
    firstMethodAmount?: number | null
    secondMethodAmount?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CostItemSupplierUpdateWithoutPendingCostItemInput = {
    supplier?: EnumSuppliersFieldUpdateOperationsInput | $Enums.Suppliers
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: StringFieldUpdateOperationsInput | string
    paidAmount?: FloatFieldUpdateOperationsInput | number
    pendingAmount?: FloatFieldUpdateOperationsInput | number
    transactionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    firstMethodAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    secondMethodAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    costItem?: CostItemUpdateOneWithoutSuppliersNestedInput
    settlements?: SupplierPaymentSettlementUpdateManyWithoutCostItemSupplierNestedInput
    paidByCreditNoteUsage?: CreditNoteUsageUpdateManyWithoutUsedOnCostItemSupplierNestedInput
  }

  export type CostItemSupplierUncheckedUpdateWithoutPendingCostItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    costItemId?: NullableIntFieldUpdateOperationsInput | number | null
    supplier?: EnumSuppliersFieldUpdateOperationsInput | $Enums.Suppliers
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: StringFieldUpdateOperationsInput | string
    paidAmount?: FloatFieldUpdateOperationsInput | number
    pendingAmount?: FloatFieldUpdateOperationsInput | number
    transactionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    firstMethodAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    secondMethodAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settlements?: SupplierPaymentSettlementUncheckedUpdateManyWithoutCostItemSupplierNestedInput
    paidByCreditNoteUsage?: CreditNoteUsageUncheckedUpdateManyWithoutUsedOnCostItemSupplierNestedInput
  }

  export type CostItemSupplierUncheckedUpdateManyWithoutPendingCostItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    costItemId?: NullableIntFieldUpdateOperationsInput | number | null
    supplier?: EnumSuppliersFieldUpdateOperationsInput | $Enums.Suppliers
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: StringFieldUpdateOperationsInput | string
    paidAmount?: FloatFieldUpdateOperationsInput | number
    pendingAmount?: FloatFieldUpdateOperationsInput | number
    transactionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    firstMethodAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    secondMethodAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierPaymentSettlementCreateManyCostItemSupplierInput = {
    id?: number
    amount: number
    transactionMethod: string
    settlementDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CreditNoteUsageCreateManyUsedOnCostItemSupplierInput = {
    id?: number
    amountUsed: number
    usedAt?: Date | string
    creditNoteId: number
  }

  export type SupplierPaymentSettlementUpdateWithoutCostItemSupplierInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    transactionMethod?: StringFieldUpdateOperationsInput | string
    settlementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierPaymentSettlementUncheckedUpdateWithoutCostItemSupplierInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    transactionMethod?: StringFieldUpdateOperationsInput | string
    settlementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierPaymentSettlementUncheckedUpdateManyWithoutCostItemSupplierInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    transactionMethod?: StringFieldUpdateOperationsInput | string
    settlementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditNoteUsageUpdateWithoutUsedOnCostItemSupplierInput = {
    amountUsed?: FloatFieldUpdateOperationsInput | number
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creditNote?: SupplierCreditNoteUpdateOneRequiredWithoutUsageHistoryNestedInput
  }

  export type CreditNoteUsageUncheckedUpdateWithoutUsedOnCostItemSupplierInput = {
    id?: IntFieldUpdateOperationsInput | number
    amountUsed?: FloatFieldUpdateOperationsInput | number
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creditNoteId?: IntFieldUpdateOperationsInput | number
  }

  export type CreditNoteUsageUncheckedUpdateManyWithoutUsedOnCostItemSupplierInput = {
    id?: IntFieldUpdateOperationsInput | number
    amountUsed?: FloatFieldUpdateOperationsInput | number
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creditNoteId?: IntFieldUpdateOperationsInput | number
  }

  export type CreditNoteUsageCreateManyCreditNoteInput = {
    id?: number
    amountUsed: number
    usedAt?: Date | string
    usedOnCostItemSupplierId: number
  }

  export type CreditNoteUsageUpdateWithoutCreditNoteInput = {
    amountUsed?: FloatFieldUpdateOperationsInput | number
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedOnCostItemSupplier?: CostItemSupplierUpdateOneRequiredWithoutPaidByCreditNoteUsageNestedInput
  }

  export type CreditNoteUsageUncheckedUpdateWithoutCreditNoteInput = {
    id?: IntFieldUpdateOperationsInput | number
    amountUsed?: FloatFieldUpdateOperationsInput | number
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedOnCostItemSupplierId?: IntFieldUpdateOperationsInput | number
  }

  export type CreditNoteUsageUncheckedUpdateManyWithoutCreditNoteInput = {
    id?: IntFieldUpdateOperationsInput | number
    amountUsed?: FloatFieldUpdateOperationsInput | number
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedOnCostItemSupplierId?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}