
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Booking
 * 
 */
export type Booking = $Result.DefaultSelection<Prisma.$BookingPayload>
/**
 * Model PendingBooking
 * 
 */
export type PendingBooking = $Result.DefaultSelection<Prisma.$PendingBookingPayload>
/**
 * Model Instalment
 * 
 */
export type Instalment = $Result.DefaultSelection<Prisma.$InstalmentPayload>
/**
 * Model PendingInstalment
 * 
 */
export type PendingInstalment = $Result.DefaultSelection<Prisma.$PendingInstalmentPayload>
/**
 * Model InstalmentPayment
 * 
 */
export type InstalmentPayment = $Result.DefaultSelection<Prisma.$InstalmentPaymentPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model CostItem
 * 
 */
export type CostItem = $Result.DefaultSelection<Prisma.$CostItemPayload>
/**
 * Model PendingCostItem
 * 
 */
export type PendingCostItem = $Result.DefaultSelection<Prisma.$PendingCostItemPayload>
/**
 * Model Passenger
 * 
 */
export type Passenger = $Result.DefaultSelection<Prisma.$PassengerPayload>
/**
 * Model PendingPassenger
 * 
 */
export type PendingPassenger = $Result.DefaultSelection<Prisma.$PendingPassengerPayload>
/**
 * Model CostItemSupplier
 * 
 */
export type CostItemSupplier = $Result.DefaultSelection<Prisma.$CostItemSupplierPayload>
/**
 * Model SupplierPaymentSettlement
 * 
 */
export type SupplierPaymentSettlement = $Result.DefaultSelection<Prisma.$SupplierPaymentSettlementPayload>
/**
 * Model Cancellation
 * 
 */
export type Cancellation = $Result.DefaultSelection<Prisma.$CancellationPayload>
/**
 * Model SupplierCreditNote
 * 
 */
export type SupplierCreditNote = $Result.DefaultSelection<Prisma.$SupplierCreditNotePayload>
/**
 * Model CreditNoteUsage
 * 
 */
export type CreditNoteUsage = $Result.DefaultSelection<Prisma.$CreditNoteUsagePayload>
/**
 * Model SupplierPayable
 * 
 */
export type SupplierPayable = $Result.DefaultSelection<Prisma.$SupplierPayablePayload>
/**
 * Model SupplierPayableSettlement
 * 
 */
export type SupplierPayableSettlement = $Result.DefaultSelection<Prisma.$SupplierPayableSettlementPayload>
/**
 * Model CustomerPayable
 * 
 */
export type CustomerPayable = $Result.DefaultSelection<Prisma.$CustomerPayablePayload>
/**
 * Model CustomerPayableSettlement
 * 
 */
export type CustomerPayableSettlement = $Result.DefaultSelection<Prisma.$CustomerPayableSettlementPayload>
/**
 * Model PassengerRefundPayment
 * 
 */
export type PassengerRefundPayment = $Result.DefaultSelection<Prisma.$PassengerRefundPaymentPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const InstalmentStatus: {
  PENDING: 'PENDING',
  PAID: 'PAID',
  OVERDUE: 'OVERDUE'
};

export type InstalmentStatus = (typeof InstalmentStatus)[keyof typeof InstalmentStatus]


export const Teams: {
  PH: 'PH',
  TOURS: 'TOURS',
  MARKETING: 'MARKETING',
  QC: 'QC',
  IT: 'IT'
};

export type Teams = (typeof Teams)[keyof typeof Teams]


export const Role: {
  ADMIN: 'ADMIN',
  CONSULTANT: 'CONSULTANT',
  MANAGEMENT: 'MANAGEMENT',
  SUPER_MANAGER: 'SUPER_MANAGER',
  SUPER_ADMIN: 'SUPER_ADMIN'
};

export type Role = (typeof Role)[keyof typeof Role]


export const Suppliers: {
  BTRES: 'BTRES',
  LYCA: 'LYCA',
  CEBU: 'CEBU',
  BTRES_LYCA: 'BTRES_LYCA',
  BA: 'BA',
  TRAINLINE: 'TRAINLINE',
  EASYJET: 'EASYJET',
  FLYDUBAI: 'FLYDUBAI'
};

export type Suppliers = (typeof Suppliers)[keyof typeof Suppliers]


export const BookingType: {
  FRESH: 'FRESH',
  DATE_CHANGE: 'DATE_CHANGE',
  CANCELLATION: 'CANCELLATION'
};

export type BookingType = (typeof BookingType)[keyof typeof BookingType]


export const PaxType: {
  FRESH: 'FRESH',
  REFERRAL: 'REFERRAL',
  REPEAT: 'REPEAT'
};

export type PaxType = (typeof PaxType)[keyof typeof PaxType]


export const PaymentMethod: {
  FULL: 'FULL',
  INTERNAL: 'INTERNAL',
  REFUND: 'REFUND',
  HUMM: 'HUMM',
  FULL_HUMM: 'FULL_HUMM',
  INTERNAL_HUMM: 'INTERNAL_HUMM'
};

export type PaymentMethod = (typeof PaymentMethod)[keyof typeof PaymentMethod]


export const BookingStatus: {
  PENDING: 'PENDING',
  CONFIRMED: 'CONFIRMED',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED',
  VOID: 'VOID'
};

export type BookingStatus = (typeof BookingStatus)[keyof typeof BookingStatus]


export const PendingStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED'
};

export type PendingStatus = (typeof PendingStatus)[keyof typeof PendingStatus]


export const Title: {
  MR: 'MR',
  MRS: 'MRS',
  MS: 'MS',
  MASTER: 'MASTER'
};

export type Title = (typeof Title)[keyof typeof Title]


export const Gender: {
  MALE: 'MALE',
  FEMALE: 'FEMALE',
  OTHER: 'OTHER'
};

export type Gender = (typeof Gender)[keyof typeof Gender]


export const PassengerCategory: {
  ADULT: 'ADULT',
  CHILD: 'CHILD',
  INFANT: 'INFANT'
};

export type PassengerCategory = (typeof PassengerCategory)[keyof typeof PassengerCategory]


export const CreditNoteStatus: {
  AVAILABLE: 'AVAILABLE',
  PARTIALLY_USED: 'PARTIALLY_USED',
  USED: 'USED'
};

export type CreditNoteStatus = (typeof CreditNoteStatus)[keyof typeof CreditNoteStatus]


export const ActionType: {
  CREATE: 'CREATE',
  CREATE_PENDING: 'CREATE_PENDING',
  UPDATE: 'UPDATE',
  DELETE: 'DELETE',
  APPROVE_PENDING: 'APPROVE_PENDING',
  REJECT_PENDING: 'REJECT_PENDING',
  DATE_CHANGE: 'DATE_CHANGE',
  VOID_BOOKING: 'VOID_BOOKING',
  UNVOID_BOOKING: 'UNVOID_BOOKING',
  CREATE_CANCELLATION: 'CREATE_CANCELLATION',
  SETTLEMENT_PAYMENT: 'SETTLEMENT_PAYMENT',
  REFUND_PAYMENT: 'REFUND_PAYMENT'
};

export type ActionType = (typeof ActionType)[keyof typeof ActionType]

}

export type InstalmentStatus = $Enums.InstalmentStatus

export const InstalmentStatus: typeof $Enums.InstalmentStatus

export type Teams = $Enums.Teams

export const Teams: typeof $Enums.Teams

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type Suppliers = $Enums.Suppliers

export const Suppliers: typeof $Enums.Suppliers

export type BookingType = $Enums.BookingType

export const BookingType: typeof $Enums.BookingType

export type PaxType = $Enums.PaxType

export const PaxType: typeof $Enums.PaxType

export type PaymentMethod = $Enums.PaymentMethod

export const PaymentMethod: typeof $Enums.PaymentMethod

export type BookingStatus = $Enums.BookingStatus

export const BookingStatus: typeof $Enums.BookingStatus

export type PendingStatus = $Enums.PendingStatus

export const PendingStatus: typeof $Enums.PendingStatus

export type Title = $Enums.Title

export const Title: typeof $Enums.Title

export type Gender = $Enums.Gender

export const Gender: typeof $Enums.Gender

export type PassengerCategory = $Enums.PassengerCategory

export const PassengerCategory: typeof $Enums.PassengerCategory

export type CreditNoteStatus = $Enums.CreditNoteStatus

export const CreditNoteStatus: typeof $Enums.CreditNoteStatus

export type ActionType = $Enums.ActionType

export const ActionType: typeof $Enums.ActionType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Bookings
 * const bookings = await prisma.booking.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Bookings
   * const bookings = await prisma.booking.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.booking`: Exposes CRUD operations for the **Booking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bookings
    * const bookings = await prisma.booking.findMany()
    * ```
    */
  get booking(): Prisma.BookingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pendingBooking`: Exposes CRUD operations for the **PendingBooking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PendingBookings
    * const pendingBookings = await prisma.pendingBooking.findMany()
    * ```
    */
  get pendingBooking(): Prisma.PendingBookingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.instalment`: Exposes CRUD operations for the **Instalment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Instalments
    * const instalments = await prisma.instalment.findMany()
    * ```
    */
  get instalment(): Prisma.InstalmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pendingInstalment`: Exposes CRUD operations for the **PendingInstalment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PendingInstalments
    * const pendingInstalments = await prisma.pendingInstalment.findMany()
    * ```
    */
  get pendingInstalment(): Prisma.PendingInstalmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.instalmentPayment`: Exposes CRUD operations for the **InstalmentPayment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InstalmentPayments
    * const instalmentPayments = await prisma.instalmentPayment.findMany()
    * ```
    */
  get instalmentPayment(): Prisma.InstalmentPaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.costItem`: Exposes CRUD operations for the **CostItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CostItems
    * const costItems = await prisma.costItem.findMany()
    * ```
    */
  get costItem(): Prisma.CostItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pendingCostItem`: Exposes CRUD operations for the **PendingCostItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PendingCostItems
    * const pendingCostItems = await prisma.pendingCostItem.findMany()
    * ```
    */
  get pendingCostItem(): Prisma.PendingCostItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.passenger`: Exposes CRUD operations for the **Passenger** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Passengers
    * const passengers = await prisma.passenger.findMany()
    * ```
    */
  get passenger(): Prisma.PassengerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pendingPassenger`: Exposes CRUD operations for the **PendingPassenger** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PendingPassengers
    * const pendingPassengers = await prisma.pendingPassenger.findMany()
    * ```
    */
  get pendingPassenger(): Prisma.PendingPassengerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.costItemSupplier`: Exposes CRUD operations for the **CostItemSupplier** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CostItemSuppliers
    * const costItemSuppliers = await prisma.costItemSupplier.findMany()
    * ```
    */
  get costItemSupplier(): Prisma.CostItemSupplierDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.supplierPaymentSettlement`: Exposes CRUD operations for the **SupplierPaymentSettlement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SupplierPaymentSettlements
    * const supplierPaymentSettlements = await prisma.supplierPaymentSettlement.findMany()
    * ```
    */
  get supplierPaymentSettlement(): Prisma.SupplierPaymentSettlementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cancellation`: Exposes CRUD operations for the **Cancellation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cancellations
    * const cancellations = await prisma.cancellation.findMany()
    * ```
    */
  get cancellation(): Prisma.CancellationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.supplierCreditNote`: Exposes CRUD operations for the **SupplierCreditNote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SupplierCreditNotes
    * const supplierCreditNotes = await prisma.supplierCreditNote.findMany()
    * ```
    */
  get supplierCreditNote(): Prisma.SupplierCreditNoteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.creditNoteUsage`: Exposes CRUD operations for the **CreditNoteUsage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CreditNoteUsages
    * const creditNoteUsages = await prisma.creditNoteUsage.findMany()
    * ```
    */
  get creditNoteUsage(): Prisma.CreditNoteUsageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.supplierPayable`: Exposes CRUD operations for the **SupplierPayable** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SupplierPayables
    * const supplierPayables = await prisma.supplierPayable.findMany()
    * ```
    */
  get supplierPayable(): Prisma.SupplierPayableDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.supplierPayableSettlement`: Exposes CRUD operations for the **SupplierPayableSettlement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SupplierPayableSettlements
    * const supplierPayableSettlements = await prisma.supplierPayableSettlement.findMany()
    * ```
    */
  get supplierPayableSettlement(): Prisma.SupplierPayableSettlementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customerPayable`: Exposes CRUD operations for the **CustomerPayable** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomerPayables
    * const customerPayables = await prisma.customerPayable.findMany()
    * ```
    */
  get customerPayable(): Prisma.CustomerPayableDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customerPayableSettlement`: Exposes CRUD operations for the **CustomerPayableSettlement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CustomerPayableSettlements
    * const customerPayableSettlements = await prisma.customerPayableSettlement.findMany()
    * ```
    */
  get customerPayableSettlement(): Prisma.CustomerPayableSettlementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.passengerRefundPayment`: Exposes CRUD operations for the **PassengerRefundPayment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PassengerRefundPayments
    * const passengerRefundPayments = await prisma.passengerRefundPayment.findMany()
    * ```
    */
  get passengerRefundPayment(): Prisma.PassengerRefundPaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.11.0
   * Query Engine version: 9c30299f5a0ea26a96790e13f796dc6094db3173
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Booking: 'Booking',
    PendingBooking: 'PendingBooking',
    Instalment: 'Instalment',
    PendingInstalment: 'PendingInstalment',
    InstalmentPayment: 'InstalmentPayment',
    User: 'User',
    CostItem: 'CostItem',
    PendingCostItem: 'PendingCostItem',
    Passenger: 'Passenger',
    PendingPassenger: 'PendingPassenger',
    CostItemSupplier: 'CostItemSupplier',
    SupplierPaymentSettlement: 'SupplierPaymentSettlement',
    Cancellation: 'Cancellation',
    SupplierCreditNote: 'SupplierCreditNote',
    CreditNoteUsage: 'CreditNoteUsage',
    SupplierPayable: 'SupplierPayable',
    SupplierPayableSettlement: 'SupplierPayableSettlement',
    CustomerPayable: 'CustomerPayable',
    CustomerPayableSettlement: 'CustomerPayableSettlement',
    PassengerRefundPayment: 'PassengerRefundPayment',
    AuditLog: 'AuditLog'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "booking" | "pendingBooking" | "instalment" | "pendingInstalment" | "instalmentPayment" | "user" | "costItem" | "pendingCostItem" | "passenger" | "pendingPassenger" | "costItemSupplier" | "supplierPaymentSettlement" | "cancellation" | "supplierCreditNote" | "creditNoteUsage" | "supplierPayable" | "supplierPayableSettlement" | "customerPayable" | "customerPayableSettlement" | "passengerRefundPayment" | "auditLog"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Booking: {
        payload: Prisma.$BookingPayload<ExtArgs>
        fields: Prisma.BookingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          findFirst: {
            args: Prisma.BookingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          findMany: {
            args: Prisma.BookingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          create: {
            args: Prisma.BookingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          createMany: {
            args: Prisma.BookingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BookingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          delete: {
            args: Prisma.BookingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          update: {
            args: Prisma.BookingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          deleteMany: {
            args: Prisma.BookingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BookingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          upsert: {
            args: Prisma.BookingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          aggregate: {
            args: Prisma.BookingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBooking>
          }
          groupBy: {
            args: Prisma.BookingGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookingGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookingCountArgs<ExtArgs>
            result: $Utils.Optional<BookingCountAggregateOutputType> | number
          }
        }
      }
      PendingBooking: {
        payload: Prisma.$PendingBookingPayload<ExtArgs>
        fields: Prisma.PendingBookingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PendingBookingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingBookingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PendingBookingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingBookingPayload>
          }
          findFirst: {
            args: Prisma.PendingBookingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingBookingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PendingBookingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingBookingPayload>
          }
          findMany: {
            args: Prisma.PendingBookingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingBookingPayload>[]
          }
          create: {
            args: Prisma.PendingBookingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingBookingPayload>
          }
          createMany: {
            args: Prisma.PendingBookingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PendingBookingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingBookingPayload>[]
          }
          delete: {
            args: Prisma.PendingBookingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingBookingPayload>
          }
          update: {
            args: Prisma.PendingBookingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingBookingPayload>
          }
          deleteMany: {
            args: Prisma.PendingBookingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PendingBookingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PendingBookingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingBookingPayload>[]
          }
          upsert: {
            args: Prisma.PendingBookingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingBookingPayload>
          }
          aggregate: {
            args: Prisma.PendingBookingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePendingBooking>
          }
          groupBy: {
            args: Prisma.PendingBookingGroupByArgs<ExtArgs>
            result: $Utils.Optional<PendingBookingGroupByOutputType>[]
          }
          count: {
            args: Prisma.PendingBookingCountArgs<ExtArgs>
            result: $Utils.Optional<PendingBookingCountAggregateOutputType> | number
          }
        }
      }
      Instalment: {
        payload: Prisma.$InstalmentPayload<ExtArgs>
        fields: Prisma.InstalmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InstalmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstalmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InstalmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstalmentPayload>
          }
          findFirst: {
            args: Prisma.InstalmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstalmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InstalmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstalmentPayload>
          }
          findMany: {
            args: Prisma.InstalmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstalmentPayload>[]
          }
          create: {
            args: Prisma.InstalmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstalmentPayload>
          }
          createMany: {
            args: Prisma.InstalmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InstalmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstalmentPayload>[]
          }
          delete: {
            args: Prisma.InstalmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstalmentPayload>
          }
          update: {
            args: Prisma.InstalmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstalmentPayload>
          }
          deleteMany: {
            args: Prisma.InstalmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InstalmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InstalmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstalmentPayload>[]
          }
          upsert: {
            args: Prisma.InstalmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstalmentPayload>
          }
          aggregate: {
            args: Prisma.InstalmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInstalment>
          }
          groupBy: {
            args: Prisma.InstalmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<InstalmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.InstalmentCountArgs<ExtArgs>
            result: $Utils.Optional<InstalmentCountAggregateOutputType> | number
          }
        }
      }
      PendingInstalment: {
        payload: Prisma.$PendingInstalmentPayload<ExtArgs>
        fields: Prisma.PendingInstalmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PendingInstalmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingInstalmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PendingInstalmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingInstalmentPayload>
          }
          findFirst: {
            args: Prisma.PendingInstalmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingInstalmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PendingInstalmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingInstalmentPayload>
          }
          findMany: {
            args: Prisma.PendingInstalmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingInstalmentPayload>[]
          }
          create: {
            args: Prisma.PendingInstalmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingInstalmentPayload>
          }
          createMany: {
            args: Prisma.PendingInstalmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PendingInstalmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingInstalmentPayload>[]
          }
          delete: {
            args: Prisma.PendingInstalmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingInstalmentPayload>
          }
          update: {
            args: Prisma.PendingInstalmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingInstalmentPayload>
          }
          deleteMany: {
            args: Prisma.PendingInstalmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PendingInstalmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PendingInstalmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingInstalmentPayload>[]
          }
          upsert: {
            args: Prisma.PendingInstalmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingInstalmentPayload>
          }
          aggregate: {
            args: Prisma.PendingInstalmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePendingInstalment>
          }
          groupBy: {
            args: Prisma.PendingInstalmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PendingInstalmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PendingInstalmentCountArgs<ExtArgs>
            result: $Utils.Optional<PendingInstalmentCountAggregateOutputType> | number
          }
        }
      }
      InstalmentPayment: {
        payload: Prisma.$InstalmentPaymentPayload<ExtArgs>
        fields: Prisma.InstalmentPaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InstalmentPaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstalmentPaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InstalmentPaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstalmentPaymentPayload>
          }
          findFirst: {
            args: Prisma.InstalmentPaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstalmentPaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InstalmentPaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstalmentPaymentPayload>
          }
          findMany: {
            args: Prisma.InstalmentPaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstalmentPaymentPayload>[]
          }
          create: {
            args: Prisma.InstalmentPaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstalmentPaymentPayload>
          }
          createMany: {
            args: Prisma.InstalmentPaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InstalmentPaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstalmentPaymentPayload>[]
          }
          delete: {
            args: Prisma.InstalmentPaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstalmentPaymentPayload>
          }
          update: {
            args: Prisma.InstalmentPaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstalmentPaymentPayload>
          }
          deleteMany: {
            args: Prisma.InstalmentPaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InstalmentPaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InstalmentPaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstalmentPaymentPayload>[]
          }
          upsert: {
            args: Prisma.InstalmentPaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InstalmentPaymentPayload>
          }
          aggregate: {
            args: Prisma.InstalmentPaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInstalmentPayment>
          }
          groupBy: {
            args: Prisma.InstalmentPaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<InstalmentPaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.InstalmentPaymentCountArgs<ExtArgs>
            result: $Utils.Optional<InstalmentPaymentCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      CostItem: {
        payload: Prisma.$CostItemPayload<ExtArgs>
        fields: Prisma.CostItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CostItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CostItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostItemPayload>
          }
          findFirst: {
            args: Prisma.CostItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CostItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostItemPayload>
          }
          findMany: {
            args: Prisma.CostItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostItemPayload>[]
          }
          create: {
            args: Prisma.CostItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostItemPayload>
          }
          createMany: {
            args: Prisma.CostItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CostItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostItemPayload>[]
          }
          delete: {
            args: Prisma.CostItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostItemPayload>
          }
          update: {
            args: Prisma.CostItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostItemPayload>
          }
          deleteMany: {
            args: Prisma.CostItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CostItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CostItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostItemPayload>[]
          }
          upsert: {
            args: Prisma.CostItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostItemPayload>
          }
          aggregate: {
            args: Prisma.CostItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCostItem>
          }
          groupBy: {
            args: Prisma.CostItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<CostItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.CostItemCountArgs<ExtArgs>
            result: $Utils.Optional<CostItemCountAggregateOutputType> | number
          }
        }
      }
      PendingCostItem: {
        payload: Prisma.$PendingCostItemPayload<ExtArgs>
        fields: Prisma.PendingCostItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PendingCostItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingCostItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PendingCostItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingCostItemPayload>
          }
          findFirst: {
            args: Prisma.PendingCostItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingCostItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PendingCostItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingCostItemPayload>
          }
          findMany: {
            args: Prisma.PendingCostItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingCostItemPayload>[]
          }
          create: {
            args: Prisma.PendingCostItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingCostItemPayload>
          }
          createMany: {
            args: Prisma.PendingCostItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PendingCostItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingCostItemPayload>[]
          }
          delete: {
            args: Prisma.PendingCostItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingCostItemPayload>
          }
          update: {
            args: Prisma.PendingCostItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingCostItemPayload>
          }
          deleteMany: {
            args: Prisma.PendingCostItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PendingCostItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PendingCostItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingCostItemPayload>[]
          }
          upsert: {
            args: Prisma.PendingCostItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingCostItemPayload>
          }
          aggregate: {
            args: Prisma.PendingCostItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePendingCostItem>
          }
          groupBy: {
            args: Prisma.PendingCostItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<PendingCostItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.PendingCostItemCountArgs<ExtArgs>
            result: $Utils.Optional<PendingCostItemCountAggregateOutputType> | number
          }
        }
      }
      Passenger: {
        payload: Prisma.$PassengerPayload<ExtArgs>
        fields: Prisma.PassengerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PassengerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PassengerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PassengerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PassengerPayload>
          }
          findFirst: {
            args: Prisma.PassengerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PassengerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PassengerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PassengerPayload>
          }
          findMany: {
            args: Prisma.PassengerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PassengerPayload>[]
          }
          create: {
            args: Prisma.PassengerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PassengerPayload>
          }
          createMany: {
            args: Prisma.PassengerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PassengerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PassengerPayload>[]
          }
          delete: {
            args: Prisma.PassengerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PassengerPayload>
          }
          update: {
            args: Prisma.PassengerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PassengerPayload>
          }
          deleteMany: {
            args: Prisma.PassengerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PassengerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PassengerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PassengerPayload>[]
          }
          upsert: {
            args: Prisma.PassengerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PassengerPayload>
          }
          aggregate: {
            args: Prisma.PassengerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePassenger>
          }
          groupBy: {
            args: Prisma.PassengerGroupByArgs<ExtArgs>
            result: $Utils.Optional<PassengerGroupByOutputType>[]
          }
          count: {
            args: Prisma.PassengerCountArgs<ExtArgs>
            result: $Utils.Optional<PassengerCountAggregateOutputType> | number
          }
        }
      }
      PendingPassenger: {
        payload: Prisma.$PendingPassengerPayload<ExtArgs>
        fields: Prisma.PendingPassengerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PendingPassengerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingPassengerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PendingPassengerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingPassengerPayload>
          }
          findFirst: {
            args: Prisma.PendingPassengerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingPassengerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PendingPassengerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingPassengerPayload>
          }
          findMany: {
            args: Prisma.PendingPassengerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingPassengerPayload>[]
          }
          create: {
            args: Prisma.PendingPassengerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingPassengerPayload>
          }
          createMany: {
            args: Prisma.PendingPassengerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PendingPassengerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingPassengerPayload>[]
          }
          delete: {
            args: Prisma.PendingPassengerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingPassengerPayload>
          }
          update: {
            args: Prisma.PendingPassengerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingPassengerPayload>
          }
          deleteMany: {
            args: Prisma.PendingPassengerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PendingPassengerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PendingPassengerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingPassengerPayload>[]
          }
          upsert: {
            args: Prisma.PendingPassengerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingPassengerPayload>
          }
          aggregate: {
            args: Prisma.PendingPassengerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePendingPassenger>
          }
          groupBy: {
            args: Prisma.PendingPassengerGroupByArgs<ExtArgs>
            result: $Utils.Optional<PendingPassengerGroupByOutputType>[]
          }
          count: {
            args: Prisma.PendingPassengerCountArgs<ExtArgs>
            result: $Utils.Optional<PendingPassengerCountAggregateOutputType> | number
          }
        }
      }
      CostItemSupplier: {
        payload: Prisma.$CostItemSupplierPayload<ExtArgs>
        fields: Prisma.CostItemSupplierFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CostItemSupplierFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostItemSupplierPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CostItemSupplierFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostItemSupplierPayload>
          }
          findFirst: {
            args: Prisma.CostItemSupplierFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostItemSupplierPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CostItemSupplierFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostItemSupplierPayload>
          }
          findMany: {
            args: Prisma.CostItemSupplierFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostItemSupplierPayload>[]
          }
          create: {
            args: Prisma.CostItemSupplierCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostItemSupplierPayload>
          }
          createMany: {
            args: Prisma.CostItemSupplierCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CostItemSupplierCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostItemSupplierPayload>[]
          }
          delete: {
            args: Prisma.CostItemSupplierDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostItemSupplierPayload>
          }
          update: {
            args: Prisma.CostItemSupplierUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostItemSupplierPayload>
          }
          deleteMany: {
            args: Prisma.CostItemSupplierDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CostItemSupplierUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CostItemSupplierUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostItemSupplierPayload>[]
          }
          upsert: {
            args: Prisma.CostItemSupplierUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostItemSupplierPayload>
          }
          aggregate: {
            args: Prisma.CostItemSupplierAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCostItemSupplier>
          }
          groupBy: {
            args: Prisma.CostItemSupplierGroupByArgs<ExtArgs>
            result: $Utils.Optional<CostItemSupplierGroupByOutputType>[]
          }
          count: {
            args: Prisma.CostItemSupplierCountArgs<ExtArgs>
            result: $Utils.Optional<CostItemSupplierCountAggregateOutputType> | number
          }
        }
      }
      SupplierPaymentSettlement: {
        payload: Prisma.$SupplierPaymentSettlementPayload<ExtArgs>
        fields: Prisma.SupplierPaymentSettlementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SupplierPaymentSettlementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPaymentSettlementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SupplierPaymentSettlementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPaymentSettlementPayload>
          }
          findFirst: {
            args: Prisma.SupplierPaymentSettlementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPaymentSettlementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SupplierPaymentSettlementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPaymentSettlementPayload>
          }
          findMany: {
            args: Prisma.SupplierPaymentSettlementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPaymentSettlementPayload>[]
          }
          create: {
            args: Prisma.SupplierPaymentSettlementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPaymentSettlementPayload>
          }
          createMany: {
            args: Prisma.SupplierPaymentSettlementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SupplierPaymentSettlementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPaymentSettlementPayload>[]
          }
          delete: {
            args: Prisma.SupplierPaymentSettlementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPaymentSettlementPayload>
          }
          update: {
            args: Prisma.SupplierPaymentSettlementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPaymentSettlementPayload>
          }
          deleteMany: {
            args: Prisma.SupplierPaymentSettlementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SupplierPaymentSettlementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SupplierPaymentSettlementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPaymentSettlementPayload>[]
          }
          upsert: {
            args: Prisma.SupplierPaymentSettlementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPaymentSettlementPayload>
          }
          aggregate: {
            args: Prisma.SupplierPaymentSettlementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSupplierPaymentSettlement>
          }
          groupBy: {
            args: Prisma.SupplierPaymentSettlementGroupByArgs<ExtArgs>
            result: $Utils.Optional<SupplierPaymentSettlementGroupByOutputType>[]
          }
          count: {
            args: Prisma.SupplierPaymentSettlementCountArgs<ExtArgs>
            result: $Utils.Optional<SupplierPaymentSettlementCountAggregateOutputType> | number
          }
        }
      }
      Cancellation: {
        payload: Prisma.$CancellationPayload<ExtArgs>
        fields: Prisma.CancellationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CancellationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CancellationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CancellationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CancellationPayload>
          }
          findFirst: {
            args: Prisma.CancellationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CancellationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CancellationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CancellationPayload>
          }
          findMany: {
            args: Prisma.CancellationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CancellationPayload>[]
          }
          create: {
            args: Prisma.CancellationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CancellationPayload>
          }
          createMany: {
            args: Prisma.CancellationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CancellationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CancellationPayload>[]
          }
          delete: {
            args: Prisma.CancellationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CancellationPayload>
          }
          update: {
            args: Prisma.CancellationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CancellationPayload>
          }
          deleteMany: {
            args: Prisma.CancellationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CancellationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CancellationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CancellationPayload>[]
          }
          upsert: {
            args: Prisma.CancellationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CancellationPayload>
          }
          aggregate: {
            args: Prisma.CancellationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCancellation>
          }
          groupBy: {
            args: Prisma.CancellationGroupByArgs<ExtArgs>
            result: $Utils.Optional<CancellationGroupByOutputType>[]
          }
          count: {
            args: Prisma.CancellationCountArgs<ExtArgs>
            result: $Utils.Optional<CancellationCountAggregateOutputType> | number
          }
        }
      }
      SupplierCreditNote: {
        payload: Prisma.$SupplierCreditNotePayload<ExtArgs>
        fields: Prisma.SupplierCreditNoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SupplierCreditNoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierCreditNotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SupplierCreditNoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierCreditNotePayload>
          }
          findFirst: {
            args: Prisma.SupplierCreditNoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierCreditNotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SupplierCreditNoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierCreditNotePayload>
          }
          findMany: {
            args: Prisma.SupplierCreditNoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierCreditNotePayload>[]
          }
          create: {
            args: Prisma.SupplierCreditNoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierCreditNotePayload>
          }
          createMany: {
            args: Prisma.SupplierCreditNoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SupplierCreditNoteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierCreditNotePayload>[]
          }
          delete: {
            args: Prisma.SupplierCreditNoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierCreditNotePayload>
          }
          update: {
            args: Prisma.SupplierCreditNoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierCreditNotePayload>
          }
          deleteMany: {
            args: Prisma.SupplierCreditNoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SupplierCreditNoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SupplierCreditNoteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierCreditNotePayload>[]
          }
          upsert: {
            args: Prisma.SupplierCreditNoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierCreditNotePayload>
          }
          aggregate: {
            args: Prisma.SupplierCreditNoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSupplierCreditNote>
          }
          groupBy: {
            args: Prisma.SupplierCreditNoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<SupplierCreditNoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.SupplierCreditNoteCountArgs<ExtArgs>
            result: $Utils.Optional<SupplierCreditNoteCountAggregateOutputType> | number
          }
        }
      }
      CreditNoteUsage: {
        payload: Prisma.$CreditNoteUsagePayload<ExtArgs>
        fields: Prisma.CreditNoteUsageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CreditNoteUsageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditNoteUsagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CreditNoteUsageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditNoteUsagePayload>
          }
          findFirst: {
            args: Prisma.CreditNoteUsageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditNoteUsagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CreditNoteUsageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditNoteUsagePayload>
          }
          findMany: {
            args: Prisma.CreditNoteUsageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditNoteUsagePayload>[]
          }
          create: {
            args: Prisma.CreditNoteUsageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditNoteUsagePayload>
          }
          createMany: {
            args: Prisma.CreditNoteUsageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CreditNoteUsageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditNoteUsagePayload>[]
          }
          delete: {
            args: Prisma.CreditNoteUsageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditNoteUsagePayload>
          }
          update: {
            args: Prisma.CreditNoteUsageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditNoteUsagePayload>
          }
          deleteMany: {
            args: Prisma.CreditNoteUsageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CreditNoteUsageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CreditNoteUsageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditNoteUsagePayload>[]
          }
          upsert: {
            args: Prisma.CreditNoteUsageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CreditNoteUsagePayload>
          }
          aggregate: {
            args: Prisma.CreditNoteUsageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCreditNoteUsage>
          }
          groupBy: {
            args: Prisma.CreditNoteUsageGroupByArgs<ExtArgs>
            result: $Utils.Optional<CreditNoteUsageGroupByOutputType>[]
          }
          count: {
            args: Prisma.CreditNoteUsageCountArgs<ExtArgs>
            result: $Utils.Optional<CreditNoteUsageCountAggregateOutputType> | number
          }
        }
      }
      SupplierPayable: {
        payload: Prisma.$SupplierPayablePayload<ExtArgs>
        fields: Prisma.SupplierPayableFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SupplierPayableFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayablePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SupplierPayableFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayablePayload>
          }
          findFirst: {
            args: Prisma.SupplierPayableFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayablePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SupplierPayableFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayablePayload>
          }
          findMany: {
            args: Prisma.SupplierPayableFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayablePayload>[]
          }
          create: {
            args: Prisma.SupplierPayableCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayablePayload>
          }
          createMany: {
            args: Prisma.SupplierPayableCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SupplierPayableCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayablePayload>[]
          }
          delete: {
            args: Prisma.SupplierPayableDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayablePayload>
          }
          update: {
            args: Prisma.SupplierPayableUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayablePayload>
          }
          deleteMany: {
            args: Prisma.SupplierPayableDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SupplierPayableUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SupplierPayableUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayablePayload>[]
          }
          upsert: {
            args: Prisma.SupplierPayableUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayablePayload>
          }
          aggregate: {
            args: Prisma.SupplierPayableAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSupplierPayable>
          }
          groupBy: {
            args: Prisma.SupplierPayableGroupByArgs<ExtArgs>
            result: $Utils.Optional<SupplierPayableGroupByOutputType>[]
          }
          count: {
            args: Prisma.SupplierPayableCountArgs<ExtArgs>
            result: $Utils.Optional<SupplierPayableCountAggregateOutputType> | number
          }
        }
      }
      SupplierPayableSettlement: {
        payload: Prisma.$SupplierPayableSettlementPayload<ExtArgs>
        fields: Prisma.SupplierPayableSettlementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SupplierPayableSettlementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayableSettlementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SupplierPayableSettlementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayableSettlementPayload>
          }
          findFirst: {
            args: Prisma.SupplierPayableSettlementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayableSettlementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SupplierPayableSettlementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayableSettlementPayload>
          }
          findMany: {
            args: Prisma.SupplierPayableSettlementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayableSettlementPayload>[]
          }
          create: {
            args: Prisma.SupplierPayableSettlementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayableSettlementPayload>
          }
          createMany: {
            args: Prisma.SupplierPayableSettlementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SupplierPayableSettlementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayableSettlementPayload>[]
          }
          delete: {
            args: Prisma.SupplierPayableSettlementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayableSettlementPayload>
          }
          update: {
            args: Prisma.SupplierPayableSettlementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayableSettlementPayload>
          }
          deleteMany: {
            args: Prisma.SupplierPayableSettlementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SupplierPayableSettlementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SupplierPayableSettlementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayableSettlementPayload>[]
          }
          upsert: {
            args: Prisma.SupplierPayableSettlementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayableSettlementPayload>
          }
          aggregate: {
            args: Prisma.SupplierPayableSettlementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSupplierPayableSettlement>
          }
          groupBy: {
            args: Prisma.SupplierPayableSettlementGroupByArgs<ExtArgs>
            result: $Utils.Optional<SupplierPayableSettlementGroupByOutputType>[]
          }
          count: {
            args: Prisma.SupplierPayableSettlementCountArgs<ExtArgs>
            result: $Utils.Optional<SupplierPayableSettlementCountAggregateOutputType> | number
          }
        }
      }
      CustomerPayable: {
        payload: Prisma.$CustomerPayablePayload<ExtArgs>
        fields: Prisma.CustomerPayableFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerPayableFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayablePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerPayableFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayablePayload>
          }
          findFirst: {
            args: Prisma.CustomerPayableFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayablePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerPayableFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayablePayload>
          }
          findMany: {
            args: Prisma.CustomerPayableFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayablePayload>[]
          }
          create: {
            args: Prisma.CustomerPayableCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayablePayload>
          }
          createMany: {
            args: Prisma.CustomerPayableCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerPayableCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayablePayload>[]
          }
          delete: {
            args: Prisma.CustomerPayableDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayablePayload>
          }
          update: {
            args: Prisma.CustomerPayableUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayablePayload>
          }
          deleteMany: {
            args: Prisma.CustomerPayableDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerPayableUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomerPayableUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayablePayload>[]
          }
          upsert: {
            args: Prisma.CustomerPayableUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayablePayload>
          }
          aggregate: {
            args: Prisma.CustomerPayableAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomerPayable>
          }
          groupBy: {
            args: Prisma.CustomerPayableGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerPayableGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerPayableCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerPayableCountAggregateOutputType> | number
          }
        }
      }
      CustomerPayableSettlement: {
        payload: Prisma.$CustomerPayableSettlementPayload<ExtArgs>
        fields: Prisma.CustomerPayableSettlementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerPayableSettlementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayableSettlementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerPayableSettlementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayableSettlementPayload>
          }
          findFirst: {
            args: Prisma.CustomerPayableSettlementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayableSettlementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerPayableSettlementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayableSettlementPayload>
          }
          findMany: {
            args: Prisma.CustomerPayableSettlementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayableSettlementPayload>[]
          }
          create: {
            args: Prisma.CustomerPayableSettlementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayableSettlementPayload>
          }
          createMany: {
            args: Prisma.CustomerPayableSettlementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerPayableSettlementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayableSettlementPayload>[]
          }
          delete: {
            args: Prisma.CustomerPayableSettlementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayableSettlementPayload>
          }
          update: {
            args: Prisma.CustomerPayableSettlementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayableSettlementPayload>
          }
          deleteMany: {
            args: Prisma.CustomerPayableSettlementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerPayableSettlementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomerPayableSettlementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayableSettlementPayload>[]
          }
          upsert: {
            args: Prisma.CustomerPayableSettlementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayableSettlementPayload>
          }
          aggregate: {
            args: Prisma.CustomerPayableSettlementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomerPayableSettlement>
          }
          groupBy: {
            args: Prisma.CustomerPayableSettlementGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerPayableSettlementGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerPayableSettlementCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerPayableSettlementCountAggregateOutputType> | number
          }
        }
      }
      PassengerRefundPayment: {
        payload: Prisma.$PassengerRefundPaymentPayload<ExtArgs>
        fields: Prisma.PassengerRefundPaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PassengerRefundPaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PassengerRefundPaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PassengerRefundPaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PassengerRefundPaymentPayload>
          }
          findFirst: {
            args: Prisma.PassengerRefundPaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PassengerRefundPaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PassengerRefundPaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PassengerRefundPaymentPayload>
          }
          findMany: {
            args: Prisma.PassengerRefundPaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PassengerRefundPaymentPayload>[]
          }
          create: {
            args: Prisma.PassengerRefundPaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PassengerRefundPaymentPayload>
          }
          createMany: {
            args: Prisma.PassengerRefundPaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PassengerRefundPaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PassengerRefundPaymentPayload>[]
          }
          delete: {
            args: Prisma.PassengerRefundPaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PassengerRefundPaymentPayload>
          }
          update: {
            args: Prisma.PassengerRefundPaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PassengerRefundPaymentPayload>
          }
          deleteMany: {
            args: Prisma.PassengerRefundPaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PassengerRefundPaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PassengerRefundPaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PassengerRefundPaymentPayload>[]
          }
          upsert: {
            args: Prisma.PassengerRefundPaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PassengerRefundPaymentPayload>
          }
          aggregate: {
            args: Prisma.PassengerRefundPaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePassengerRefundPayment>
          }
          groupBy: {
            args: Prisma.PassengerRefundPaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PassengerRefundPaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PassengerRefundPaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PassengerRefundPaymentCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    booking?: BookingOmit
    pendingBooking?: PendingBookingOmit
    instalment?: InstalmentOmit
    pendingInstalment?: PendingInstalmentOmit
    instalmentPayment?: InstalmentPaymentOmit
    user?: UserOmit
    costItem?: CostItemOmit
    pendingCostItem?: PendingCostItemOmit
    passenger?: PassengerOmit
    pendingPassenger?: PendingPassengerOmit
    costItemSupplier?: CostItemSupplierOmit
    supplierPaymentSettlement?: SupplierPaymentSettlementOmit
    cancellation?: CancellationOmit
    supplierCreditNote?: SupplierCreditNoteOmit
    creditNoteUsage?: CreditNoteUsageOmit
    supplierPayable?: SupplierPayableOmit
    supplierPayableSettlement?: SupplierPayableSettlementOmit
    customerPayable?: CustomerPayableOmit
    customerPayableSettlement?: CustomerPayableSettlementOmit
    passengerRefundPayment?: PassengerRefundPaymentOmit
    auditLog?: AuditLogOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type BookingCountOutputType
   */

  export type BookingCountOutputType = {
    costItems: number
    instalments: number
    passengers: number
    followUpBookings: number
    customerPayables: number
  }

  export type BookingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    costItems?: boolean | BookingCountOutputTypeCountCostItemsArgs
    instalments?: boolean | BookingCountOutputTypeCountInstalmentsArgs
    passengers?: boolean | BookingCountOutputTypeCountPassengersArgs
    followUpBookings?: boolean | BookingCountOutputTypeCountFollowUpBookingsArgs
    customerPayables?: boolean | BookingCountOutputTypeCountCustomerPayablesArgs
  }

  // Custom InputTypes
  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingCountOutputType
     */
    select?: BookingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeCountCostItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CostItemWhereInput
  }

  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeCountInstalmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstalmentWhereInput
  }

  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeCountPassengersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PassengerWhereInput
  }

  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeCountFollowUpBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }

  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeCountCustomerPayablesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerPayableWhereInput
  }


  /**
   * Count Type PendingBookingCountOutputType
   */

  export type PendingBookingCountOutputType = {
    costItems: number
    instalments: number
    passengers: number
  }

  export type PendingBookingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    costItems?: boolean | PendingBookingCountOutputTypeCountCostItemsArgs
    instalments?: boolean | PendingBookingCountOutputTypeCountInstalmentsArgs
    passengers?: boolean | PendingBookingCountOutputTypeCountPassengersArgs
  }

  // Custom InputTypes
  /**
   * PendingBookingCountOutputType without action
   */
  export type PendingBookingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingBookingCountOutputType
     */
    select?: PendingBookingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PendingBookingCountOutputType without action
   */
  export type PendingBookingCountOutputTypeCountCostItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PendingCostItemWhereInput
  }

  /**
   * PendingBookingCountOutputType without action
   */
  export type PendingBookingCountOutputTypeCountInstalmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PendingInstalmentWhereInput
  }

  /**
   * PendingBookingCountOutputType without action
   */
  export type PendingBookingCountOutputTypeCountPassengersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PendingPassengerWhereInput
  }


  /**
   * Count Type InstalmentCountOutputType
   */

  export type InstalmentCountOutputType = {
    payments: number
  }

  export type InstalmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | InstalmentCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * InstalmentCountOutputType without action
   */
  export type InstalmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstalmentCountOutputType
     */
    select?: InstalmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InstalmentCountOutputType without action
   */
  export type InstalmentCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstalmentPaymentWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    createdPendingBookings: number
    voidedBookings: number
    auditLogs: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdPendingBookings?: boolean | UserCountOutputTypeCountCreatedPendingBookingsArgs
    voidedBookings?: boolean | UserCountOutputTypeCountVoidedBookingsArgs
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedPendingBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PendingBookingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountVoidedBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }


  /**
   * Count Type CostItemCountOutputType
   */

  export type CostItemCountOutputType = {
    suppliers: number
  }

  export type CostItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    suppliers?: boolean | CostItemCountOutputTypeCountSuppliersArgs
  }

  // Custom InputTypes
  /**
   * CostItemCountOutputType without action
   */
  export type CostItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostItemCountOutputType
     */
    select?: CostItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CostItemCountOutputType without action
   */
  export type CostItemCountOutputTypeCountSuppliersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CostItemSupplierWhereInput
  }


  /**
   * Count Type PendingCostItemCountOutputType
   */

  export type PendingCostItemCountOutputType = {
    suppliers: number
  }

  export type PendingCostItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    suppliers?: boolean | PendingCostItemCountOutputTypeCountSuppliersArgs
  }

  // Custom InputTypes
  /**
   * PendingCostItemCountOutputType without action
   */
  export type PendingCostItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingCostItemCountOutputType
     */
    select?: PendingCostItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PendingCostItemCountOutputType without action
   */
  export type PendingCostItemCountOutputTypeCountSuppliersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CostItemSupplierWhereInput
  }


  /**
   * Count Type CostItemSupplierCountOutputType
   */

  export type CostItemSupplierCountOutputType = {
    settlements: number
    paidByCreditNoteUsage: number
  }

  export type CostItemSupplierCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    settlements?: boolean | CostItemSupplierCountOutputTypeCountSettlementsArgs
    paidByCreditNoteUsage?: boolean | CostItemSupplierCountOutputTypeCountPaidByCreditNoteUsageArgs
  }

  // Custom InputTypes
  /**
   * CostItemSupplierCountOutputType without action
   */
  export type CostItemSupplierCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostItemSupplierCountOutputType
     */
    select?: CostItemSupplierCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CostItemSupplierCountOutputType without action
   */
  export type CostItemSupplierCountOutputTypeCountSettlementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplierPaymentSettlementWhereInput
  }

  /**
   * CostItemSupplierCountOutputType without action
   */
  export type CostItemSupplierCountOutputTypeCountPaidByCreditNoteUsageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreditNoteUsageWhereInput
  }


  /**
   * Count Type SupplierCreditNoteCountOutputType
   */

  export type SupplierCreditNoteCountOutputType = {
    usageHistory: number
  }

  export type SupplierCreditNoteCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usageHistory?: boolean | SupplierCreditNoteCountOutputTypeCountUsageHistoryArgs
  }

  // Custom InputTypes
  /**
   * SupplierCreditNoteCountOutputType without action
   */
  export type SupplierCreditNoteCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierCreditNoteCountOutputType
     */
    select?: SupplierCreditNoteCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SupplierCreditNoteCountOutputType without action
   */
  export type SupplierCreditNoteCountOutputTypeCountUsageHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreditNoteUsageWhereInput
  }


  /**
   * Count Type SupplierPayableCountOutputType
   */

  export type SupplierPayableCountOutputType = {
    settlements: number
  }

  export type SupplierPayableCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    settlements?: boolean | SupplierPayableCountOutputTypeCountSettlementsArgs
  }

  // Custom InputTypes
  /**
   * SupplierPayableCountOutputType without action
   */
  export type SupplierPayableCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierPayableCountOutputType
     */
    select?: SupplierPayableCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SupplierPayableCountOutputType without action
   */
  export type SupplierPayableCountOutputTypeCountSettlementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplierPayableSettlementWhereInput
  }


  /**
   * Count Type CustomerPayableCountOutputType
   */

  export type CustomerPayableCountOutputType = {
    settlements: number
  }

  export type CustomerPayableCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    settlements?: boolean | CustomerPayableCountOutputTypeCountSettlementsArgs
  }

  // Custom InputTypes
  /**
   * CustomerPayableCountOutputType without action
   */
  export type CustomerPayableCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPayableCountOutputType
     */
    select?: CustomerPayableCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomerPayableCountOutputType without action
   */
  export type CustomerPayableCountOutputTypeCountSettlementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerPayableSettlementWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Booking
   */

  export type AggregateBooking = {
    _count: BookingCountAggregateOutputType | null
    _avg: BookingAvgAggregateOutputType | null
    _sum: BookingSumAggregateOutputType | null
    _min: BookingMinAggregateOutputType | null
    _max: BookingMaxAggregateOutputType | null
  }

  export type BookingAvgAggregateOutputType = {
    id: number | null
    revenue: number | null
    prodCost: number | null
    transFee: number | null
    surcharge: number | null
    received: number | null
    balance: number | null
    profit: number | null
    numPax: number | null
    initialDeposit: number | null
    originalBookingId: number | null
    voidedById: number | null
  }

  export type BookingSumAggregateOutputType = {
    id: number | null
    revenue: number | null
    prodCost: number | null
    transFee: number | null
    surcharge: number | null
    received: number | null
    balance: number | null
    profit: number | null
    numPax: number | null
    initialDeposit: number | null
    originalBookingId: number | null
    voidedById: number | null
  }

  export type BookingMinAggregateOutputType = {
    id: number | null
    folderNo: string | null
    refNo: string | null
    paxName: string | null
    agentName: string | null
    teamName: $Enums.Teams | null
    pnr: string | null
    airline: string | null
    fromTo: string | null
    bookingType: $Enums.BookingType | null
    bookingStatus: $Enums.BookingStatus | null
    pcDate: Date | null
    issuedDate: Date | null
    paymentMethod: $Enums.PaymentMethod | null
    lastPaymentDate: Date | null
    travelDate: Date | null
    revenue: number | null
    prodCost: number | null
    transFee: number | null
    surcharge: number | null
    received: number | null
    transactionMethod: string | null
    receivedDate: Date | null
    balance: number | null
    profit: number | null
    invoiced: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    numPax: number | null
    initialDeposit: number | null
    originalBookingId: number | null
    statusBeforeVoid: $Enums.BookingStatus | null
    voidReason: string | null
    voidedAt: Date | null
    voidedById: number | null
  }

  export type BookingMaxAggregateOutputType = {
    id: number | null
    folderNo: string | null
    refNo: string | null
    paxName: string | null
    agentName: string | null
    teamName: $Enums.Teams | null
    pnr: string | null
    airline: string | null
    fromTo: string | null
    bookingType: $Enums.BookingType | null
    bookingStatus: $Enums.BookingStatus | null
    pcDate: Date | null
    issuedDate: Date | null
    paymentMethod: $Enums.PaymentMethod | null
    lastPaymentDate: Date | null
    travelDate: Date | null
    revenue: number | null
    prodCost: number | null
    transFee: number | null
    surcharge: number | null
    received: number | null
    transactionMethod: string | null
    receivedDate: Date | null
    balance: number | null
    profit: number | null
    invoiced: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    numPax: number | null
    initialDeposit: number | null
    originalBookingId: number | null
    statusBeforeVoid: $Enums.BookingStatus | null
    voidReason: string | null
    voidedAt: Date | null
    voidedById: number | null
  }

  export type BookingCountAggregateOutputType = {
    id: number
    folderNo: number
    refNo: number
    paxName: number
    agentName: number
    teamName: number
    pnr: number
    airline: number
    fromTo: number
    bookingType: number
    bookingStatus: number
    pcDate: number
    issuedDate: number
    paymentMethod: number
    lastPaymentDate: number
    travelDate: number
    revenue: number
    prodCost: number
    transFee: number
    surcharge: number
    received: number
    transactionMethod: number
    receivedDate: number
    balance: number
    profit: number
    invoiced: number
    description: number
    createdAt: number
    updatedAt: number
    numPax: number
    initialDeposit: number
    originalBookingId: number
    statusBeforeVoid: number
    voidReason: number
    voidedAt: number
    voidedById: number
    _all: number
  }


  export type BookingAvgAggregateInputType = {
    id?: true
    revenue?: true
    prodCost?: true
    transFee?: true
    surcharge?: true
    received?: true
    balance?: true
    profit?: true
    numPax?: true
    initialDeposit?: true
    originalBookingId?: true
    voidedById?: true
  }

  export type BookingSumAggregateInputType = {
    id?: true
    revenue?: true
    prodCost?: true
    transFee?: true
    surcharge?: true
    received?: true
    balance?: true
    profit?: true
    numPax?: true
    initialDeposit?: true
    originalBookingId?: true
    voidedById?: true
  }

  export type BookingMinAggregateInputType = {
    id?: true
    folderNo?: true
    refNo?: true
    paxName?: true
    agentName?: true
    teamName?: true
    pnr?: true
    airline?: true
    fromTo?: true
    bookingType?: true
    bookingStatus?: true
    pcDate?: true
    issuedDate?: true
    paymentMethod?: true
    lastPaymentDate?: true
    travelDate?: true
    revenue?: true
    prodCost?: true
    transFee?: true
    surcharge?: true
    received?: true
    transactionMethod?: true
    receivedDate?: true
    balance?: true
    profit?: true
    invoiced?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    numPax?: true
    initialDeposit?: true
    originalBookingId?: true
    statusBeforeVoid?: true
    voidReason?: true
    voidedAt?: true
    voidedById?: true
  }

  export type BookingMaxAggregateInputType = {
    id?: true
    folderNo?: true
    refNo?: true
    paxName?: true
    agentName?: true
    teamName?: true
    pnr?: true
    airline?: true
    fromTo?: true
    bookingType?: true
    bookingStatus?: true
    pcDate?: true
    issuedDate?: true
    paymentMethod?: true
    lastPaymentDate?: true
    travelDate?: true
    revenue?: true
    prodCost?: true
    transFee?: true
    surcharge?: true
    received?: true
    transactionMethod?: true
    receivedDate?: true
    balance?: true
    profit?: true
    invoiced?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    numPax?: true
    initialDeposit?: true
    originalBookingId?: true
    statusBeforeVoid?: true
    voidReason?: true
    voidedAt?: true
    voidedById?: true
  }

  export type BookingCountAggregateInputType = {
    id?: true
    folderNo?: true
    refNo?: true
    paxName?: true
    agentName?: true
    teamName?: true
    pnr?: true
    airline?: true
    fromTo?: true
    bookingType?: true
    bookingStatus?: true
    pcDate?: true
    issuedDate?: true
    paymentMethod?: true
    lastPaymentDate?: true
    travelDate?: true
    revenue?: true
    prodCost?: true
    transFee?: true
    surcharge?: true
    received?: true
    transactionMethod?: true
    receivedDate?: true
    balance?: true
    profit?: true
    invoiced?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    numPax?: true
    initialDeposit?: true
    originalBookingId?: true
    statusBeforeVoid?: true
    voidReason?: true
    voidedAt?: true
    voidedById?: true
    _all?: true
  }

  export type BookingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Booking to aggregate.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bookings
    **/
    _count?: true | BookingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BookingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BookingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookingMaxAggregateInputType
  }

  export type GetBookingAggregateType<T extends BookingAggregateArgs> = {
        [P in keyof T & keyof AggregateBooking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBooking[P]>
      : GetScalarType<T[P], AggregateBooking[P]>
  }




  export type BookingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithAggregationInput | BookingOrderByWithAggregationInput[]
    by: BookingScalarFieldEnum[] | BookingScalarFieldEnum
    having?: BookingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookingCountAggregateInputType | true
    _avg?: BookingAvgAggregateInputType
    _sum?: BookingSumAggregateInputType
    _min?: BookingMinAggregateInputType
    _max?: BookingMaxAggregateInputType
  }

  export type BookingGroupByOutputType = {
    id: number
    folderNo: string
    refNo: string
    paxName: string
    agentName: string
    teamName: $Enums.Teams | null
    pnr: string
    airline: string
    fromTo: string
    bookingType: $Enums.BookingType
    bookingStatus: $Enums.BookingStatus | null
    pcDate: Date
    issuedDate: Date | null
    paymentMethod: $Enums.PaymentMethod
    lastPaymentDate: Date | null
    travelDate: Date | null
    revenue: number | null
    prodCost: number | null
    transFee: number | null
    surcharge: number | null
    received: number | null
    transactionMethod: string | null
    receivedDate: Date | null
    balance: number | null
    profit: number | null
    invoiced: string | null
    description: string | null
    createdAt: Date
    updatedAt: Date
    numPax: number
    initialDeposit: number | null
    originalBookingId: number | null
    statusBeforeVoid: $Enums.BookingStatus | null
    voidReason: string | null
    voidedAt: Date | null
    voidedById: number | null
    _count: BookingCountAggregateOutputType | null
    _avg: BookingAvgAggregateOutputType | null
    _sum: BookingSumAggregateOutputType | null
    _min: BookingMinAggregateOutputType | null
    _max: BookingMaxAggregateOutputType | null
  }

  type GetBookingGroupByPayload<T extends BookingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookingGroupByOutputType[P]>
            : GetScalarType<T[P], BookingGroupByOutputType[P]>
        }
      >
    >


  export type BookingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    folderNo?: boolean
    refNo?: boolean
    paxName?: boolean
    agentName?: boolean
    teamName?: boolean
    pnr?: boolean
    airline?: boolean
    fromTo?: boolean
    bookingType?: boolean
    bookingStatus?: boolean
    pcDate?: boolean
    issuedDate?: boolean
    paymentMethod?: boolean
    lastPaymentDate?: boolean
    travelDate?: boolean
    revenue?: boolean
    prodCost?: boolean
    transFee?: boolean
    surcharge?: boolean
    received?: boolean
    transactionMethod?: boolean
    receivedDate?: boolean
    balance?: boolean
    profit?: boolean
    invoiced?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    numPax?: boolean
    initialDeposit?: boolean
    originalBookingId?: boolean
    statusBeforeVoid?: boolean
    voidReason?: boolean
    voidedAt?: boolean
    voidedById?: boolean
    costItems?: boolean | Booking$costItemsArgs<ExtArgs>
    instalments?: boolean | Booking$instalmentsArgs<ExtArgs>
    passengers?: boolean | Booking$passengersArgs<ExtArgs>
    originalBooking?: boolean | Booking$originalBookingArgs<ExtArgs>
    followUpBookings?: boolean | Booking$followUpBookingsArgs<ExtArgs>
    voidedBy?: boolean | Booking$voidedByArgs<ExtArgs>
    customerPayables?: boolean | Booking$customerPayablesArgs<ExtArgs>
    cancellation?: boolean | Booking$cancellationArgs<ExtArgs>
    _count?: boolean | BookingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>

  export type BookingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    folderNo?: boolean
    refNo?: boolean
    paxName?: boolean
    agentName?: boolean
    teamName?: boolean
    pnr?: boolean
    airline?: boolean
    fromTo?: boolean
    bookingType?: boolean
    bookingStatus?: boolean
    pcDate?: boolean
    issuedDate?: boolean
    paymentMethod?: boolean
    lastPaymentDate?: boolean
    travelDate?: boolean
    revenue?: boolean
    prodCost?: boolean
    transFee?: boolean
    surcharge?: boolean
    received?: boolean
    transactionMethod?: boolean
    receivedDate?: boolean
    balance?: boolean
    profit?: boolean
    invoiced?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    numPax?: boolean
    initialDeposit?: boolean
    originalBookingId?: boolean
    statusBeforeVoid?: boolean
    voidReason?: boolean
    voidedAt?: boolean
    voidedById?: boolean
    originalBooking?: boolean | Booking$originalBookingArgs<ExtArgs>
    voidedBy?: boolean | Booking$voidedByArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>

  export type BookingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    folderNo?: boolean
    refNo?: boolean
    paxName?: boolean
    agentName?: boolean
    teamName?: boolean
    pnr?: boolean
    airline?: boolean
    fromTo?: boolean
    bookingType?: boolean
    bookingStatus?: boolean
    pcDate?: boolean
    issuedDate?: boolean
    paymentMethod?: boolean
    lastPaymentDate?: boolean
    travelDate?: boolean
    revenue?: boolean
    prodCost?: boolean
    transFee?: boolean
    surcharge?: boolean
    received?: boolean
    transactionMethod?: boolean
    receivedDate?: boolean
    balance?: boolean
    profit?: boolean
    invoiced?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    numPax?: boolean
    initialDeposit?: boolean
    originalBookingId?: boolean
    statusBeforeVoid?: boolean
    voidReason?: boolean
    voidedAt?: boolean
    voidedById?: boolean
    originalBooking?: boolean | Booking$originalBookingArgs<ExtArgs>
    voidedBy?: boolean | Booking$voidedByArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>

  export type BookingSelectScalar = {
    id?: boolean
    folderNo?: boolean
    refNo?: boolean
    paxName?: boolean
    agentName?: boolean
    teamName?: boolean
    pnr?: boolean
    airline?: boolean
    fromTo?: boolean
    bookingType?: boolean
    bookingStatus?: boolean
    pcDate?: boolean
    issuedDate?: boolean
    paymentMethod?: boolean
    lastPaymentDate?: boolean
    travelDate?: boolean
    revenue?: boolean
    prodCost?: boolean
    transFee?: boolean
    surcharge?: boolean
    received?: boolean
    transactionMethod?: boolean
    receivedDate?: boolean
    balance?: boolean
    profit?: boolean
    invoiced?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    numPax?: boolean
    initialDeposit?: boolean
    originalBookingId?: boolean
    statusBeforeVoid?: boolean
    voidReason?: boolean
    voidedAt?: boolean
    voidedById?: boolean
  }

  export type BookingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "folderNo" | "refNo" | "paxName" | "agentName" | "teamName" | "pnr" | "airline" | "fromTo" | "bookingType" | "bookingStatus" | "pcDate" | "issuedDate" | "paymentMethod" | "lastPaymentDate" | "travelDate" | "revenue" | "prodCost" | "transFee" | "surcharge" | "received" | "transactionMethod" | "receivedDate" | "balance" | "profit" | "invoiced" | "description" | "createdAt" | "updatedAt" | "numPax" | "initialDeposit" | "originalBookingId" | "statusBeforeVoid" | "voidReason" | "voidedAt" | "voidedById", ExtArgs["result"]["booking"]>
  export type BookingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    costItems?: boolean | Booking$costItemsArgs<ExtArgs>
    instalments?: boolean | Booking$instalmentsArgs<ExtArgs>
    passengers?: boolean | Booking$passengersArgs<ExtArgs>
    originalBooking?: boolean | Booking$originalBookingArgs<ExtArgs>
    followUpBookings?: boolean | Booking$followUpBookingsArgs<ExtArgs>
    voidedBy?: boolean | Booking$voidedByArgs<ExtArgs>
    customerPayables?: boolean | Booking$customerPayablesArgs<ExtArgs>
    cancellation?: boolean | Booking$cancellationArgs<ExtArgs>
    _count?: boolean | BookingCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BookingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    originalBooking?: boolean | Booking$originalBookingArgs<ExtArgs>
    voidedBy?: boolean | Booking$voidedByArgs<ExtArgs>
  }
  export type BookingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    originalBooking?: boolean | Booking$originalBookingArgs<ExtArgs>
    voidedBy?: boolean | Booking$voidedByArgs<ExtArgs>
  }

  export type $BookingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Booking"
    objects: {
      costItems: Prisma.$CostItemPayload<ExtArgs>[]
      instalments: Prisma.$InstalmentPayload<ExtArgs>[]
      passengers: Prisma.$PassengerPayload<ExtArgs>[]
      originalBooking: Prisma.$BookingPayload<ExtArgs> | null
      followUpBookings: Prisma.$BookingPayload<ExtArgs>[]
      voidedBy: Prisma.$UserPayload<ExtArgs> | null
      customerPayables: Prisma.$CustomerPayablePayload<ExtArgs>[]
      cancellation: Prisma.$CancellationPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      folderNo: string
      refNo: string
      paxName: string
      agentName: string
      teamName: $Enums.Teams | null
      pnr: string
      airline: string
      fromTo: string
      bookingType: $Enums.BookingType
      bookingStatus: $Enums.BookingStatus | null
      pcDate: Date
      issuedDate: Date | null
      paymentMethod: $Enums.PaymentMethod
      lastPaymentDate: Date | null
      travelDate: Date | null
      revenue: number | null
      prodCost: number | null
      transFee: number | null
      surcharge: number | null
      received: number | null
      transactionMethod: string | null
      receivedDate: Date | null
      balance: number | null
      profit: number | null
      invoiced: string | null
      description: string | null
      createdAt: Date
      updatedAt: Date
      numPax: number
      initialDeposit: number | null
      originalBookingId: number | null
      statusBeforeVoid: $Enums.BookingStatus | null
      voidReason: string | null
      voidedAt: Date | null
      voidedById: number | null
    }, ExtArgs["result"]["booking"]>
    composites: {}
  }

  type BookingGetPayload<S extends boolean | null | undefined | BookingDefaultArgs> = $Result.GetResult<Prisma.$BookingPayload, S>

  type BookingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BookingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BookingCountAggregateInputType | true
    }

  export interface BookingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Booking'], meta: { name: 'Booking' } }
    /**
     * Find zero or one Booking that matches the filter.
     * @param {BookingFindUniqueArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookingFindUniqueArgs>(args: SelectSubset<T, BookingFindUniqueArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Booking that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BookingFindUniqueOrThrowArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookingFindUniqueOrThrowArgs>(args: SelectSubset<T, BookingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Booking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindFirstArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookingFindFirstArgs>(args?: SelectSubset<T, BookingFindFirstArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Booking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindFirstOrThrowArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookingFindFirstOrThrowArgs>(args?: SelectSubset<T, BookingFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Bookings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bookings
     * const bookings = await prisma.booking.findMany()
     * 
     * // Get first 10 Bookings
     * const bookings = await prisma.booking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookingWithIdOnly = await prisma.booking.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BookingFindManyArgs>(args?: SelectSubset<T, BookingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Booking.
     * @param {BookingCreateArgs} args - Arguments to create a Booking.
     * @example
     * // Create one Booking
     * const Booking = await prisma.booking.create({
     *   data: {
     *     // ... data to create a Booking
     *   }
     * })
     * 
     */
    create<T extends BookingCreateArgs>(args: SelectSubset<T, BookingCreateArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Bookings.
     * @param {BookingCreateManyArgs} args - Arguments to create many Bookings.
     * @example
     * // Create many Bookings
     * const booking = await prisma.booking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookingCreateManyArgs>(args?: SelectSubset<T, BookingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bookings and returns the data saved in the database.
     * @param {BookingCreateManyAndReturnArgs} args - Arguments to create many Bookings.
     * @example
     * // Create many Bookings
     * const booking = await prisma.booking.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bookings and only return the `id`
     * const bookingWithIdOnly = await prisma.booking.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BookingCreateManyAndReturnArgs>(args?: SelectSubset<T, BookingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Booking.
     * @param {BookingDeleteArgs} args - Arguments to delete one Booking.
     * @example
     * // Delete one Booking
     * const Booking = await prisma.booking.delete({
     *   where: {
     *     // ... filter to delete one Booking
     *   }
     * })
     * 
     */
    delete<T extends BookingDeleteArgs>(args: SelectSubset<T, BookingDeleteArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Booking.
     * @param {BookingUpdateArgs} args - Arguments to update one Booking.
     * @example
     * // Update one Booking
     * const booking = await prisma.booking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookingUpdateArgs>(args: SelectSubset<T, BookingUpdateArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Bookings.
     * @param {BookingDeleteManyArgs} args - Arguments to filter Bookings to delete.
     * @example
     * // Delete a few Bookings
     * const { count } = await prisma.booking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookingDeleteManyArgs>(args?: SelectSubset<T, BookingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bookings
     * const booking = await prisma.booking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookingUpdateManyArgs>(args: SelectSubset<T, BookingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bookings and returns the data updated in the database.
     * @param {BookingUpdateManyAndReturnArgs} args - Arguments to update many Bookings.
     * @example
     * // Update many Bookings
     * const booking = await prisma.booking.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Bookings and only return the `id`
     * const bookingWithIdOnly = await prisma.booking.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BookingUpdateManyAndReturnArgs>(args: SelectSubset<T, BookingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Booking.
     * @param {BookingUpsertArgs} args - Arguments to update or create a Booking.
     * @example
     * // Update or create a Booking
     * const booking = await prisma.booking.upsert({
     *   create: {
     *     // ... data to create a Booking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Booking we want to update
     *   }
     * })
     */
    upsert<T extends BookingUpsertArgs>(args: SelectSubset<T, BookingUpsertArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingCountArgs} args - Arguments to filter Bookings to count.
     * @example
     * // Count the number of Bookings
     * const count = await prisma.booking.count({
     *   where: {
     *     // ... the filter for the Bookings we want to count
     *   }
     * })
    **/
    count<T extends BookingCountArgs>(
      args?: Subset<T, BookingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Booking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookingAggregateArgs>(args: Subset<T, BookingAggregateArgs>): Prisma.PrismaPromise<GetBookingAggregateType<T>>

    /**
     * Group by Booking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookingGroupByArgs['orderBy'] }
        : { orderBy?: BookingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Booking model
   */
  readonly fields: BookingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Booking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    costItems<T extends Booking$costItemsArgs<ExtArgs> = {}>(args?: Subset<T, Booking$costItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CostItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    instalments<T extends Booking$instalmentsArgs<ExtArgs> = {}>(args?: Subset<T, Booking$instalmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstalmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    passengers<T extends Booking$passengersArgs<ExtArgs> = {}>(args?: Subset<T, Booking$passengersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PassengerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    originalBooking<T extends Booking$originalBookingArgs<ExtArgs> = {}>(args?: Subset<T, Booking$originalBookingArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    followUpBookings<T extends Booking$followUpBookingsArgs<ExtArgs> = {}>(args?: Subset<T, Booking$followUpBookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    voidedBy<T extends Booking$voidedByArgs<ExtArgs> = {}>(args?: Subset<T, Booking$voidedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    customerPayables<T extends Booking$customerPayablesArgs<ExtArgs> = {}>(args?: Subset<T, Booking$customerPayablesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cancellation<T extends Booking$cancellationArgs<ExtArgs> = {}>(args?: Subset<T, Booking$cancellationArgs<ExtArgs>>): Prisma__CancellationClient<$Result.GetResult<Prisma.$CancellationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Booking model
   */
  interface BookingFieldRefs {
    readonly id: FieldRef<"Booking", 'Int'>
    readonly folderNo: FieldRef<"Booking", 'String'>
    readonly refNo: FieldRef<"Booking", 'String'>
    readonly paxName: FieldRef<"Booking", 'String'>
    readonly agentName: FieldRef<"Booking", 'String'>
    readonly teamName: FieldRef<"Booking", 'Teams'>
    readonly pnr: FieldRef<"Booking", 'String'>
    readonly airline: FieldRef<"Booking", 'String'>
    readonly fromTo: FieldRef<"Booking", 'String'>
    readonly bookingType: FieldRef<"Booking", 'BookingType'>
    readonly bookingStatus: FieldRef<"Booking", 'BookingStatus'>
    readonly pcDate: FieldRef<"Booking", 'DateTime'>
    readonly issuedDate: FieldRef<"Booking", 'DateTime'>
    readonly paymentMethod: FieldRef<"Booking", 'PaymentMethod'>
    readonly lastPaymentDate: FieldRef<"Booking", 'DateTime'>
    readonly travelDate: FieldRef<"Booking", 'DateTime'>
    readonly revenue: FieldRef<"Booking", 'Float'>
    readonly prodCost: FieldRef<"Booking", 'Float'>
    readonly transFee: FieldRef<"Booking", 'Float'>
    readonly surcharge: FieldRef<"Booking", 'Float'>
    readonly received: FieldRef<"Booking", 'Float'>
    readonly transactionMethod: FieldRef<"Booking", 'String'>
    readonly receivedDate: FieldRef<"Booking", 'DateTime'>
    readonly balance: FieldRef<"Booking", 'Float'>
    readonly profit: FieldRef<"Booking", 'Float'>
    readonly invoiced: FieldRef<"Booking", 'String'>
    readonly description: FieldRef<"Booking", 'String'>
    readonly createdAt: FieldRef<"Booking", 'DateTime'>
    readonly updatedAt: FieldRef<"Booking", 'DateTime'>
    readonly numPax: FieldRef<"Booking", 'Int'>
    readonly initialDeposit: FieldRef<"Booking", 'Float'>
    readonly originalBookingId: FieldRef<"Booking", 'Int'>
    readonly statusBeforeVoid: FieldRef<"Booking", 'BookingStatus'>
    readonly voidReason: FieldRef<"Booking", 'String'>
    readonly voidedAt: FieldRef<"Booking", 'DateTime'>
    readonly voidedById: FieldRef<"Booking", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Booking findUnique
   */
  export type BookingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking findUniqueOrThrow
   */
  export type BookingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking findFirst
   */
  export type BookingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookings.
     */
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking findFirstOrThrow
   */
  export type BookingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookings.
     */
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking findMany
   */
  export type BookingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Bookings to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking create
   */
  export type BookingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The data needed to create a Booking.
     */
    data: XOR<BookingCreateInput, BookingUncheckedCreateInput>
  }

  /**
   * Booking createMany
   */
  export type BookingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bookings.
     */
    data: BookingCreateManyInput | BookingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Booking createManyAndReturn
   */
  export type BookingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * The data used to create many Bookings.
     */
    data: BookingCreateManyInput | BookingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Booking update
   */
  export type BookingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The data needed to update a Booking.
     */
    data: XOR<BookingUpdateInput, BookingUncheckedUpdateInput>
    /**
     * Choose, which Booking to update.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking updateMany
   */
  export type BookingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bookings.
     */
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyInput>
    /**
     * Filter which Bookings to update
     */
    where?: BookingWhereInput
    /**
     * Limit how many Bookings to update.
     */
    limit?: number
  }

  /**
   * Booking updateManyAndReturn
   */
  export type BookingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * The data used to update Bookings.
     */
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyInput>
    /**
     * Filter which Bookings to update
     */
    where?: BookingWhereInput
    /**
     * Limit how many Bookings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Booking upsert
   */
  export type BookingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The filter to search for the Booking to update in case it exists.
     */
    where: BookingWhereUniqueInput
    /**
     * In case the Booking found by the `where` argument doesn't exist, create a new Booking with this data.
     */
    create: XOR<BookingCreateInput, BookingUncheckedCreateInput>
    /**
     * In case the Booking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookingUpdateInput, BookingUncheckedUpdateInput>
  }

  /**
   * Booking delete
   */
  export type BookingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter which Booking to delete.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking deleteMany
   */
  export type BookingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bookings to delete
     */
    where?: BookingWhereInput
    /**
     * Limit how many Bookings to delete.
     */
    limit?: number
  }

  /**
   * Booking.costItems
   */
  export type Booking$costItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostItem
     */
    select?: CostItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostItem
     */
    omit?: CostItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostItemInclude<ExtArgs> | null
    where?: CostItemWhereInput
    orderBy?: CostItemOrderByWithRelationInput | CostItemOrderByWithRelationInput[]
    cursor?: CostItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CostItemScalarFieldEnum | CostItemScalarFieldEnum[]
  }

  /**
   * Booking.instalments
   */
  export type Booking$instalmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instalment
     */
    select?: InstalmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instalment
     */
    omit?: InstalmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstalmentInclude<ExtArgs> | null
    where?: InstalmentWhereInput
    orderBy?: InstalmentOrderByWithRelationInput | InstalmentOrderByWithRelationInput[]
    cursor?: InstalmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InstalmentScalarFieldEnum | InstalmentScalarFieldEnum[]
  }

  /**
   * Booking.passengers
   */
  export type Booking$passengersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passenger
     */
    select?: PassengerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Passenger
     */
    omit?: PassengerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PassengerInclude<ExtArgs> | null
    where?: PassengerWhereInput
    orderBy?: PassengerOrderByWithRelationInput | PassengerOrderByWithRelationInput[]
    cursor?: PassengerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PassengerScalarFieldEnum | PassengerScalarFieldEnum[]
  }

  /**
   * Booking.originalBooking
   */
  export type Booking$originalBookingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
  }

  /**
   * Booking.followUpBookings
   */
  export type Booking$followUpBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking.voidedBy
   */
  export type Booking$voidedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Booking.customerPayables
   */
  export type Booking$customerPayablesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPayable
     */
    select?: CustomerPayableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPayable
     */
    omit?: CustomerPayableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPayableInclude<ExtArgs> | null
    where?: CustomerPayableWhereInput
    orderBy?: CustomerPayableOrderByWithRelationInput | CustomerPayableOrderByWithRelationInput[]
    cursor?: CustomerPayableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerPayableScalarFieldEnum | CustomerPayableScalarFieldEnum[]
  }

  /**
   * Booking.cancellation
   */
  export type Booking$cancellationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cancellation
     */
    select?: CancellationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cancellation
     */
    omit?: CancellationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CancellationInclude<ExtArgs> | null
    where?: CancellationWhereInput
  }

  /**
   * Booking without action
   */
  export type BookingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
  }


  /**
   * Model PendingBooking
   */

  export type AggregatePendingBooking = {
    _count: PendingBookingCountAggregateOutputType | null
    _avg: PendingBookingAvgAggregateOutputType | null
    _sum: PendingBookingSumAggregateOutputType | null
    _min: PendingBookingMinAggregateOutputType | null
    _max: PendingBookingMaxAggregateOutputType | null
  }

  export type PendingBookingAvgAggregateOutputType = {
    id: number | null
    revenue: number | null
    prodCost: number | null
    transFee: number | null
    surcharge: number | null
    received: number | null
    balance: number | null
    profit: number | null
    numPax: number | null
    createdById: number | null
  }

  export type PendingBookingSumAggregateOutputType = {
    id: number | null
    revenue: number | null
    prodCost: number | null
    transFee: number | null
    surcharge: number | null
    received: number | null
    balance: number | null
    profit: number | null
    numPax: number | null
    createdById: number | null
  }

  export type PendingBookingMinAggregateOutputType = {
    id: number | null
    refNo: string | null
    paxName: string | null
    agentName: string | null
    teamName: $Enums.Teams | null
    pnr: string | null
    airline: string | null
    fromTo: string | null
    bookingType: $Enums.BookingType | null
    bookingStatus: $Enums.BookingStatus | null
    pcDate: Date | null
    issuedDate: Date | null
    paymentMethod: $Enums.PaymentMethod | null
    lastPaymentDate: Date | null
    travelDate: Date | null
    revenue: number | null
    prodCost: number | null
    transFee: number | null
    surcharge: number | null
    received: number | null
    transactionMethod: string | null
    receivedDate: Date | null
    balance: number | null
    profit: number | null
    invoiced: string | null
    description: string | null
    status: $Enums.PendingStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    numPax: number | null
    createdById: number | null
  }

  export type PendingBookingMaxAggregateOutputType = {
    id: number | null
    refNo: string | null
    paxName: string | null
    agentName: string | null
    teamName: $Enums.Teams | null
    pnr: string | null
    airline: string | null
    fromTo: string | null
    bookingType: $Enums.BookingType | null
    bookingStatus: $Enums.BookingStatus | null
    pcDate: Date | null
    issuedDate: Date | null
    paymentMethod: $Enums.PaymentMethod | null
    lastPaymentDate: Date | null
    travelDate: Date | null
    revenue: number | null
    prodCost: number | null
    transFee: number | null
    surcharge: number | null
    received: number | null
    transactionMethod: string | null
    receivedDate: Date | null
    balance: number | null
    profit: number | null
    invoiced: string | null
    description: string | null
    status: $Enums.PendingStatus | null
    createdAt: Date | null
    updatedAt: Date | null
    numPax: number | null
    createdById: number | null
  }

  export type PendingBookingCountAggregateOutputType = {
    id: number
    refNo: number
    paxName: number
    agentName: number
    teamName: number
    pnr: number
    airline: number
    fromTo: number
    bookingType: number
    bookingStatus: number
    pcDate: number
    issuedDate: number
    paymentMethod: number
    lastPaymentDate: number
    travelDate: number
    revenue: number
    prodCost: number
    transFee: number
    surcharge: number
    received: number
    transactionMethod: number
    receivedDate: number
    balance: number
    profit: number
    invoiced: number
    description: number
    status: number
    createdAt: number
    updatedAt: number
    numPax: number
    createdById: number
    _all: number
  }


  export type PendingBookingAvgAggregateInputType = {
    id?: true
    revenue?: true
    prodCost?: true
    transFee?: true
    surcharge?: true
    received?: true
    balance?: true
    profit?: true
    numPax?: true
    createdById?: true
  }

  export type PendingBookingSumAggregateInputType = {
    id?: true
    revenue?: true
    prodCost?: true
    transFee?: true
    surcharge?: true
    received?: true
    balance?: true
    profit?: true
    numPax?: true
    createdById?: true
  }

  export type PendingBookingMinAggregateInputType = {
    id?: true
    refNo?: true
    paxName?: true
    agentName?: true
    teamName?: true
    pnr?: true
    airline?: true
    fromTo?: true
    bookingType?: true
    bookingStatus?: true
    pcDate?: true
    issuedDate?: true
    paymentMethod?: true
    lastPaymentDate?: true
    travelDate?: true
    revenue?: true
    prodCost?: true
    transFee?: true
    surcharge?: true
    received?: true
    transactionMethod?: true
    receivedDate?: true
    balance?: true
    profit?: true
    invoiced?: true
    description?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    numPax?: true
    createdById?: true
  }

  export type PendingBookingMaxAggregateInputType = {
    id?: true
    refNo?: true
    paxName?: true
    agentName?: true
    teamName?: true
    pnr?: true
    airline?: true
    fromTo?: true
    bookingType?: true
    bookingStatus?: true
    pcDate?: true
    issuedDate?: true
    paymentMethod?: true
    lastPaymentDate?: true
    travelDate?: true
    revenue?: true
    prodCost?: true
    transFee?: true
    surcharge?: true
    received?: true
    transactionMethod?: true
    receivedDate?: true
    balance?: true
    profit?: true
    invoiced?: true
    description?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    numPax?: true
    createdById?: true
  }

  export type PendingBookingCountAggregateInputType = {
    id?: true
    refNo?: true
    paxName?: true
    agentName?: true
    teamName?: true
    pnr?: true
    airline?: true
    fromTo?: true
    bookingType?: true
    bookingStatus?: true
    pcDate?: true
    issuedDate?: true
    paymentMethod?: true
    lastPaymentDate?: true
    travelDate?: true
    revenue?: true
    prodCost?: true
    transFee?: true
    surcharge?: true
    received?: true
    transactionMethod?: true
    receivedDate?: true
    balance?: true
    profit?: true
    invoiced?: true
    description?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    numPax?: true
    createdById?: true
    _all?: true
  }

  export type PendingBookingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PendingBooking to aggregate.
     */
    where?: PendingBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PendingBookings to fetch.
     */
    orderBy?: PendingBookingOrderByWithRelationInput | PendingBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PendingBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PendingBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PendingBookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PendingBookings
    **/
    _count?: true | PendingBookingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PendingBookingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PendingBookingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PendingBookingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PendingBookingMaxAggregateInputType
  }

  export type GetPendingBookingAggregateType<T extends PendingBookingAggregateArgs> = {
        [P in keyof T & keyof AggregatePendingBooking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePendingBooking[P]>
      : GetScalarType<T[P], AggregatePendingBooking[P]>
  }




  export type PendingBookingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PendingBookingWhereInput
    orderBy?: PendingBookingOrderByWithAggregationInput | PendingBookingOrderByWithAggregationInput[]
    by: PendingBookingScalarFieldEnum[] | PendingBookingScalarFieldEnum
    having?: PendingBookingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PendingBookingCountAggregateInputType | true
    _avg?: PendingBookingAvgAggregateInputType
    _sum?: PendingBookingSumAggregateInputType
    _min?: PendingBookingMinAggregateInputType
    _max?: PendingBookingMaxAggregateInputType
  }

  export type PendingBookingGroupByOutputType = {
    id: number
    refNo: string
    paxName: string
    agentName: string
    teamName: $Enums.Teams | null
    pnr: string
    airline: string
    fromTo: string
    bookingType: $Enums.BookingType
    bookingStatus: $Enums.BookingStatus | null
    pcDate: Date
    issuedDate: Date | null
    paymentMethod: $Enums.PaymentMethod
    lastPaymentDate: Date | null
    travelDate: Date | null
    revenue: number | null
    prodCost: number | null
    transFee: number | null
    surcharge: number | null
    received: number | null
    transactionMethod: string | null
    receivedDate: Date | null
    balance: number | null
    profit: number | null
    invoiced: string | null
    description: string | null
    status: $Enums.PendingStatus
    createdAt: Date
    updatedAt: Date
    numPax: number
    createdById: number
    _count: PendingBookingCountAggregateOutputType | null
    _avg: PendingBookingAvgAggregateOutputType | null
    _sum: PendingBookingSumAggregateOutputType | null
    _min: PendingBookingMinAggregateOutputType | null
    _max: PendingBookingMaxAggregateOutputType | null
  }

  type GetPendingBookingGroupByPayload<T extends PendingBookingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PendingBookingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PendingBookingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PendingBookingGroupByOutputType[P]>
            : GetScalarType<T[P], PendingBookingGroupByOutputType[P]>
        }
      >
    >


  export type PendingBookingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    refNo?: boolean
    paxName?: boolean
    agentName?: boolean
    teamName?: boolean
    pnr?: boolean
    airline?: boolean
    fromTo?: boolean
    bookingType?: boolean
    bookingStatus?: boolean
    pcDate?: boolean
    issuedDate?: boolean
    paymentMethod?: boolean
    lastPaymentDate?: boolean
    travelDate?: boolean
    revenue?: boolean
    prodCost?: boolean
    transFee?: boolean
    surcharge?: boolean
    received?: boolean
    transactionMethod?: boolean
    receivedDate?: boolean
    balance?: boolean
    profit?: boolean
    invoiced?: boolean
    description?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    numPax?: boolean
    createdById?: boolean
    costItems?: boolean | PendingBooking$costItemsArgs<ExtArgs>
    instalments?: boolean | PendingBooking$instalmentsArgs<ExtArgs>
    passengers?: boolean | PendingBooking$passengersArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | PendingBookingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pendingBooking"]>

  export type PendingBookingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    refNo?: boolean
    paxName?: boolean
    agentName?: boolean
    teamName?: boolean
    pnr?: boolean
    airline?: boolean
    fromTo?: boolean
    bookingType?: boolean
    bookingStatus?: boolean
    pcDate?: boolean
    issuedDate?: boolean
    paymentMethod?: boolean
    lastPaymentDate?: boolean
    travelDate?: boolean
    revenue?: boolean
    prodCost?: boolean
    transFee?: boolean
    surcharge?: boolean
    received?: boolean
    transactionMethod?: boolean
    receivedDate?: boolean
    balance?: boolean
    profit?: boolean
    invoiced?: boolean
    description?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    numPax?: boolean
    createdById?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pendingBooking"]>

  export type PendingBookingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    refNo?: boolean
    paxName?: boolean
    agentName?: boolean
    teamName?: boolean
    pnr?: boolean
    airline?: boolean
    fromTo?: boolean
    bookingType?: boolean
    bookingStatus?: boolean
    pcDate?: boolean
    issuedDate?: boolean
    paymentMethod?: boolean
    lastPaymentDate?: boolean
    travelDate?: boolean
    revenue?: boolean
    prodCost?: boolean
    transFee?: boolean
    surcharge?: boolean
    received?: boolean
    transactionMethod?: boolean
    receivedDate?: boolean
    balance?: boolean
    profit?: boolean
    invoiced?: boolean
    description?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    numPax?: boolean
    createdById?: boolean
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pendingBooking"]>

  export type PendingBookingSelectScalar = {
    id?: boolean
    refNo?: boolean
    paxName?: boolean
    agentName?: boolean
    teamName?: boolean
    pnr?: boolean
    airline?: boolean
    fromTo?: boolean
    bookingType?: boolean
    bookingStatus?: boolean
    pcDate?: boolean
    issuedDate?: boolean
    paymentMethod?: boolean
    lastPaymentDate?: boolean
    travelDate?: boolean
    revenue?: boolean
    prodCost?: boolean
    transFee?: boolean
    surcharge?: boolean
    received?: boolean
    transactionMethod?: boolean
    receivedDate?: boolean
    balance?: boolean
    profit?: boolean
    invoiced?: boolean
    description?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    numPax?: boolean
    createdById?: boolean
  }

  export type PendingBookingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "refNo" | "paxName" | "agentName" | "teamName" | "pnr" | "airline" | "fromTo" | "bookingType" | "bookingStatus" | "pcDate" | "issuedDate" | "paymentMethod" | "lastPaymentDate" | "travelDate" | "revenue" | "prodCost" | "transFee" | "surcharge" | "received" | "transactionMethod" | "receivedDate" | "balance" | "profit" | "invoiced" | "description" | "status" | "createdAt" | "updatedAt" | "numPax" | "createdById", ExtArgs["result"]["pendingBooking"]>
  export type PendingBookingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    costItems?: boolean | PendingBooking$costItemsArgs<ExtArgs>
    instalments?: boolean | PendingBooking$instalmentsArgs<ExtArgs>
    passengers?: boolean | PendingBooking$passengersArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    _count?: boolean | PendingBookingCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PendingBookingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PendingBookingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PendingBookingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PendingBooking"
    objects: {
      costItems: Prisma.$PendingCostItemPayload<ExtArgs>[]
      instalments: Prisma.$PendingInstalmentPayload<ExtArgs>[]
      passengers: Prisma.$PendingPassengerPayload<ExtArgs>[]
      createdBy: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      refNo: string
      paxName: string
      agentName: string
      teamName: $Enums.Teams | null
      pnr: string
      airline: string
      fromTo: string
      bookingType: $Enums.BookingType
      bookingStatus: $Enums.BookingStatus | null
      pcDate: Date
      issuedDate: Date | null
      paymentMethod: $Enums.PaymentMethod
      lastPaymentDate: Date | null
      travelDate: Date | null
      revenue: number | null
      prodCost: number | null
      transFee: number | null
      surcharge: number | null
      received: number | null
      transactionMethod: string | null
      receivedDate: Date | null
      balance: number | null
      profit: number | null
      invoiced: string | null
      description: string | null
      status: $Enums.PendingStatus
      createdAt: Date
      updatedAt: Date
      numPax: number
      createdById: number
    }, ExtArgs["result"]["pendingBooking"]>
    composites: {}
  }

  type PendingBookingGetPayload<S extends boolean | null | undefined | PendingBookingDefaultArgs> = $Result.GetResult<Prisma.$PendingBookingPayload, S>

  type PendingBookingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PendingBookingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PendingBookingCountAggregateInputType | true
    }

  export interface PendingBookingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PendingBooking'], meta: { name: 'PendingBooking' } }
    /**
     * Find zero or one PendingBooking that matches the filter.
     * @param {PendingBookingFindUniqueArgs} args - Arguments to find a PendingBooking
     * @example
     * // Get one PendingBooking
     * const pendingBooking = await prisma.pendingBooking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PendingBookingFindUniqueArgs>(args: SelectSubset<T, PendingBookingFindUniqueArgs<ExtArgs>>): Prisma__PendingBookingClient<$Result.GetResult<Prisma.$PendingBookingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PendingBooking that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PendingBookingFindUniqueOrThrowArgs} args - Arguments to find a PendingBooking
     * @example
     * // Get one PendingBooking
     * const pendingBooking = await prisma.pendingBooking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PendingBookingFindUniqueOrThrowArgs>(args: SelectSubset<T, PendingBookingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PendingBookingClient<$Result.GetResult<Prisma.$PendingBookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PendingBooking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingBookingFindFirstArgs} args - Arguments to find a PendingBooking
     * @example
     * // Get one PendingBooking
     * const pendingBooking = await prisma.pendingBooking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PendingBookingFindFirstArgs>(args?: SelectSubset<T, PendingBookingFindFirstArgs<ExtArgs>>): Prisma__PendingBookingClient<$Result.GetResult<Prisma.$PendingBookingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PendingBooking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingBookingFindFirstOrThrowArgs} args - Arguments to find a PendingBooking
     * @example
     * // Get one PendingBooking
     * const pendingBooking = await prisma.pendingBooking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PendingBookingFindFirstOrThrowArgs>(args?: SelectSubset<T, PendingBookingFindFirstOrThrowArgs<ExtArgs>>): Prisma__PendingBookingClient<$Result.GetResult<Prisma.$PendingBookingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PendingBookings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingBookingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PendingBookings
     * const pendingBookings = await prisma.pendingBooking.findMany()
     * 
     * // Get first 10 PendingBookings
     * const pendingBookings = await prisma.pendingBooking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pendingBookingWithIdOnly = await prisma.pendingBooking.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PendingBookingFindManyArgs>(args?: SelectSubset<T, PendingBookingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PendingBookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PendingBooking.
     * @param {PendingBookingCreateArgs} args - Arguments to create a PendingBooking.
     * @example
     * // Create one PendingBooking
     * const PendingBooking = await prisma.pendingBooking.create({
     *   data: {
     *     // ... data to create a PendingBooking
     *   }
     * })
     * 
     */
    create<T extends PendingBookingCreateArgs>(args: SelectSubset<T, PendingBookingCreateArgs<ExtArgs>>): Prisma__PendingBookingClient<$Result.GetResult<Prisma.$PendingBookingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PendingBookings.
     * @param {PendingBookingCreateManyArgs} args - Arguments to create many PendingBookings.
     * @example
     * // Create many PendingBookings
     * const pendingBooking = await prisma.pendingBooking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PendingBookingCreateManyArgs>(args?: SelectSubset<T, PendingBookingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PendingBookings and returns the data saved in the database.
     * @param {PendingBookingCreateManyAndReturnArgs} args - Arguments to create many PendingBookings.
     * @example
     * // Create many PendingBookings
     * const pendingBooking = await prisma.pendingBooking.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PendingBookings and only return the `id`
     * const pendingBookingWithIdOnly = await prisma.pendingBooking.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PendingBookingCreateManyAndReturnArgs>(args?: SelectSubset<T, PendingBookingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PendingBookingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PendingBooking.
     * @param {PendingBookingDeleteArgs} args - Arguments to delete one PendingBooking.
     * @example
     * // Delete one PendingBooking
     * const PendingBooking = await prisma.pendingBooking.delete({
     *   where: {
     *     // ... filter to delete one PendingBooking
     *   }
     * })
     * 
     */
    delete<T extends PendingBookingDeleteArgs>(args: SelectSubset<T, PendingBookingDeleteArgs<ExtArgs>>): Prisma__PendingBookingClient<$Result.GetResult<Prisma.$PendingBookingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PendingBooking.
     * @param {PendingBookingUpdateArgs} args - Arguments to update one PendingBooking.
     * @example
     * // Update one PendingBooking
     * const pendingBooking = await prisma.pendingBooking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PendingBookingUpdateArgs>(args: SelectSubset<T, PendingBookingUpdateArgs<ExtArgs>>): Prisma__PendingBookingClient<$Result.GetResult<Prisma.$PendingBookingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PendingBookings.
     * @param {PendingBookingDeleteManyArgs} args - Arguments to filter PendingBookings to delete.
     * @example
     * // Delete a few PendingBookings
     * const { count } = await prisma.pendingBooking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PendingBookingDeleteManyArgs>(args?: SelectSubset<T, PendingBookingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PendingBookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingBookingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PendingBookings
     * const pendingBooking = await prisma.pendingBooking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PendingBookingUpdateManyArgs>(args: SelectSubset<T, PendingBookingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PendingBookings and returns the data updated in the database.
     * @param {PendingBookingUpdateManyAndReturnArgs} args - Arguments to update many PendingBookings.
     * @example
     * // Update many PendingBookings
     * const pendingBooking = await prisma.pendingBooking.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PendingBookings and only return the `id`
     * const pendingBookingWithIdOnly = await prisma.pendingBooking.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PendingBookingUpdateManyAndReturnArgs>(args: SelectSubset<T, PendingBookingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PendingBookingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PendingBooking.
     * @param {PendingBookingUpsertArgs} args - Arguments to update or create a PendingBooking.
     * @example
     * // Update or create a PendingBooking
     * const pendingBooking = await prisma.pendingBooking.upsert({
     *   create: {
     *     // ... data to create a PendingBooking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PendingBooking we want to update
     *   }
     * })
     */
    upsert<T extends PendingBookingUpsertArgs>(args: SelectSubset<T, PendingBookingUpsertArgs<ExtArgs>>): Prisma__PendingBookingClient<$Result.GetResult<Prisma.$PendingBookingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PendingBookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingBookingCountArgs} args - Arguments to filter PendingBookings to count.
     * @example
     * // Count the number of PendingBookings
     * const count = await prisma.pendingBooking.count({
     *   where: {
     *     // ... the filter for the PendingBookings we want to count
     *   }
     * })
    **/
    count<T extends PendingBookingCountArgs>(
      args?: Subset<T, PendingBookingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PendingBookingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PendingBooking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingBookingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PendingBookingAggregateArgs>(args: Subset<T, PendingBookingAggregateArgs>): Prisma.PrismaPromise<GetPendingBookingAggregateType<T>>

    /**
     * Group by PendingBooking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingBookingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PendingBookingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PendingBookingGroupByArgs['orderBy'] }
        : { orderBy?: PendingBookingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PendingBookingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPendingBookingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PendingBooking model
   */
  readonly fields: PendingBookingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PendingBooking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PendingBookingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    costItems<T extends PendingBooking$costItemsArgs<ExtArgs> = {}>(args?: Subset<T, PendingBooking$costItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PendingCostItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    instalments<T extends PendingBooking$instalmentsArgs<ExtArgs> = {}>(args?: Subset<T, PendingBooking$instalmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PendingInstalmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    passengers<T extends PendingBooking$passengersArgs<ExtArgs> = {}>(args?: Subset<T, PendingBooking$passengersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PendingPassengerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PendingBooking model
   */
  interface PendingBookingFieldRefs {
    readonly id: FieldRef<"PendingBooking", 'Int'>
    readonly refNo: FieldRef<"PendingBooking", 'String'>
    readonly paxName: FieldRef<"PendingBooking", 'String'>
    readonly agentName: FieldRef<"PendingBooking", 'String'>
    readonly teamName: FieldRef<"PendingBooking", 'Teams'>
    readonly pnr: FieldRef<"PendingBooking", 'String'>
    readonly airline: FieldRef<"PendingBooking", 'String'>
    readonly fromTo: FieldRef<"PendingBooking", 'String'>
    readonly bookingType: FieldRef<"PendingBooking", 'BookingType'>
    readonly bookingStatus: FieldRef<"PendingBooking", 'BookingStatus'>
    readonly pcDate: FieldRef<"PendingBooking", 'DateTime'>
    readonly issuedDate: FieldRef<"PendingBooking", 'DateTime'>
    readonly paymentMethod: FieldRef<"PendingBooking", 'PaymentMethod'>
    readonly lastPaymentDate: FieldRef<"PendingBooking", 'DateTime'>
    readonly travelDate: FieldRef<"PendingBooking", 'DateTime'>
    readonly revenue: FieldRef<"PendingBooking", 'Float'>
    readonly prodCost: FieldRef<"PendingBooking", 'Float'>
    readonly transFee: FieldRef<"PendingBooking", 'Float'>
    readonly surcharge: FieldRef<"PendingBooking", 'Float'>
    readonly received: FieldRef<"PendingBooking", 'Float'>
    readonly transactionMethod: FieldRef<"PendingBooking", 'String'>
    readonly receivedDate: FieldRef<"PendingBooking", 'DateTime'>
    readonly balance: FieldRef<"PendingBooking", 'Float'>
    readonly profit: FieldRef<"PendingBooking", 'Float'>
    readonly invoiced: FieldRef<"PendingBooking", 'String'>
    readonly description: FieldRef<"PendingBooking", 'String'>
    readonly status: FieldRef<"PendingBooking", 'PendingStatus'>
    readonly createdAt: FieldRef<"PendingBooking", 'DateTime'>
    readonly updatedAt: FieldRef<"PendingBooking", 'DateTime'>
    readonly numPax: FieldRef<"PendingBooking", 'Int'>
    readonly createdById: FieldRef<"PendingBooking", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PendingBooking findUnique
   */
  export type PendingBookingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingBooking
     */
    select?: PendingBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingBooking
     */
    omit?: PendingBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingBookingInclude<ExtArgs> | null
    /**
     * Filter, which PendingBooking to fetch.
     */
    where: PendingBookingWhereUniqueInput
  }

  /**
   * PendingBooking findUniqueOrThrow
   */
  export type PendingBookingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingBooking
     */
    select?: PendingBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingBooking
     */
    omit?: PendingBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingBookingInclude<ExtArgs> | null
    /**
     * Filter, which PendingBooking to fetch.
     */
    where: PendingBookingWhereUniqueInput
  }

  /**
   * PendingBooking findFirst
   */
  export type PendingBookingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingBooking
     */
    select?: PendingBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingBooking
     */
    omit?: PendingBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingBookingInclude<ExtArgs> | null
    /**
     * Filter, which PendingBooking to fetch.
     */
    where?: PendingBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PendingBookings to fetch.
     */
    orderBy?: PendingBookingOrderByWithRelationInput | PendingBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PendingBookings.
     */
    cursor?: PendingBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PendingBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PendingBookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PendingBookings.
     */
    distinct?: PendingBookingScalarFieldEnum | PendingBookingScalarFieldEnum[]
  }

  /**
   * PendingBooking findFirstOrThrow
   */
  export type PendingBookingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingBooking
     */
    select?: PendingBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingBooking
     */
    omit?: PendingBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingBookingInclude<ExtArgs> | null
    /**
     * Filter, which PendingBooking to fetch.
     */
    where?: PendingBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PendingBookings to fetch.
     */
    orderBy?: PendingBookingOrderByWithRelationInput | PendingBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PendingBookings.
     */
    cursor?: PendingBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PendingBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PendingBookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PendingBookings.
     */
    distinct?: PendingBookingScalarFieldEnum | PendingBookingScalarFieldEnum[]
  }

  /**
   * PendingBooking findMany
   */
  export type PendingBookingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingBooking
     */
    select?: PendingBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingBooking
     */
    omit?: PendingBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingBookingInclude<ExtArgs> | null
    /**
     * Filter, which PendingBookings to fetch.
     */
    where?: PendingBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PendingBookings to fetch.
     */
    orderBy?: PendingBookingOrderByWithRelationInput | PendingBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PendingBookings.
     */
    cursor?: PendingBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PendingBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PendingBookings.
     */
    skip?: number
    distinct?: PendingBookingScalarFieldEnum | PendingBookingScalarFieldEnum[]
  }

  /**
   * PendingBooking create
   */
  export type PendingBookingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingBooking
     */
    select?: PendingBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingBooking
     */
    omit?: PendingBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingBookingInclude<ExtArgs> | null
    /**
     * The data needed to create a PendingBooking.
     */
    data: XOR<PendingBookingCreateInput, PendingBookingUncheckedCreateInput>
  }

  /**
   * PendingBooking createMany
   */
  export type PendingBookingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PendingBookings.
     */
    data: PendingBookingCreateManyInput | PendingBookingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PendingBooking createManyAndReturn
   */
  export type PendingBookingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingBooking
     */
    select?: PendingBookingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PendingBooking
     */
    omit?: PendingBookingOmit<ExtArgs> | null
    /**
     * The data used to create many PendingBookings.
     */
    data: PendingBookingCreateManyInput | PendingBookingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingBookingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PendingBooking update
   */
  export type PendingBookingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingBooking
     */
    select?: PendingBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingBooking
     */
    omit?: PendingBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingBookingInclude<ExtArgs> | null
    /**
     * The data needed to update a PendingBooking.
     */
    data: XOR<PendingBookingUpdateInput, PendingBookingUncheckedUpdateInput>
    /**
     * Choose, which PendingBooking to update.
     */
    where: PendingBookingWhereUniqueInput
  }

  /**
   * PendingBooking updateMany
   */
  export type PendingBookingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PendingBookings.
     */
    data: XOR<PendingBookingUpdateManyMutationInput, PendingBookingUncheckedUpdateManyInput>
    /**
     * Filter which PendingBookings to update
     */
    where?: PendingBookingWhereInput
    /**
     * Limit how many PendingBookings to update.
     */
    limit?: number
  }

  /**
   * PendingBooking updateManyAndReturn
   */
  export type PendingBookingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingBooking
     */
    select?: PendingBookingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PendingBooking
     */
    omit?: PendingBookingOmit<ExtArgs> | null
    /**
     * The data used to update PendingBookings.
     */
    data: XOR<PendingBookingUpdateManyMutationInput, PendingBookingUncheckedUpdateManyInput>
    /**
     * Filter which PendingBookings to update
     */
    where?: PendingBookingWhereInput
    /**
     * Limit how many PendingBookings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingBookingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PendingBooking upsert
   */
  export type PendingBookingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingBooking
     */
    select?: PendingBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingBooking
     */
    omit?: PendingBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingBookingInclude<ExtArgs> | null
    /**
     * The filter to search for the PendingBooking to update in case it exists.
     */
    where: PendingBookingWhereUniqueInput
    /**
     * In case the PendingBooking found by the `where` argument doesn't exist, create a new PendingBooking with this data.
     */
    create: XOR<PendingBookingCreateInput, PendingBookingUncheckedCreateInput>
    /**
     * In case the PendingBooking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PendingBookingUpdateInput, PendingBookingUncheckedUpdateInput>
  }

  /**
   * PendingBooking delete
   */
  export type PendingBookingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingBooking
     */
    select?: PendingBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingBooking
     */
    omit?: PendingBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingBookingInclude<ExtArgs> | null
    /**
     * Filter which PendingBooking to delete.
     */
    where: PendingBookingWhereUniqueInput
  }

  /**
   * PendingBooking deleteMany
   */
  export type PendingBookingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PendingBookings to delete
     */
    where?: PendingBookingWhereInput
    /**
     * Limit how many PendingBookings to delete.
     */
    limit?: number
  }

  /**
   * PendingBooking.costItems
   */
  export type PendingBooking$costItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingCostItem
     */
    select?: PendingCostItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingCostItem
     */
    omit?: PendingCostItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingCostItemInclude<ExtArgs> | null
    where?: PendingCostItemWhereInput
    orderBy?: PendingCostItemOrderByWithRelationInput | PendingCostItemOrderByWithRelationInput[]
    cursor?: PendingCostItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PendingCostItemScalarFieldEnum | PendingCostItemScalarFieldEnum[]
  }

  /**
   * PendingBooking.instalments
   */
  export type PendingBooking$instalmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingInstalment
     */
    select?: PendingInstalmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingInstalment
     */
    omit?: PendingInstalmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingInstalmentInclude<ExtArgs> | null
    where?: PendingInstalmentWhereInput
    orderBy?: PendingInstalmentOrderByWithRelationInput | PendingInstalmentOrderByWithRelationInput[]
    cursor?: PendingInstalmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PendingInstalmentScalarFieldEnum | PendingInstalmentScalarFieldEnum[]
  }

  /**
   * PendingBooking.passengers
   */
  export type PendingBooking$passengersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingPassenger
     */
    select?: PendingPassengerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingPassenger
     */
    omit?: PendingPassengerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingPassengerInclude<ExtArgs> | null
    where?: PendingPassengerWhereInput
    orderBy?: PendingPassengerOrderByWithRelationInput | PendingPassengerOrderByWithRelationInput[]
    cursor?: PendingPassengerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PendingPassengerScalarFieldEnum | PendingPassengerScalarFieldEnum[]
  }

  /**
   * PendingBooking without action
   */
  export type PendingBookingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingBooking
     */
    select?: PendingBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingBooking
     */
    omit?: PendingBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingBookingInclude<ExtArgs> | null
  }


  /**
   * Model Instalment
   */

  export type AggregateInstalment = {
    _count: InstalmentCountAggregateOutputType | null
    _avg: InstalmentAvgAggregateOutputType | null
    _sum: InstalmentSumAggregateOutputType | null
    _min: InstalmentMinAggregateOutputType | null
    _max: InstalmentMaxAggregateOutputType | null
  }

  export type InstalmentAvgAggregateOutputType = {
    id: number | null
    bookingId: number | null
    amount: number | null
  }

  export type InstalmentSumAggregateOutputType = {
    id: number | null
    bookingId: number | null
    amount: number | null
  }

  export type InstalmentMinAggregateOutputType = {
    id: number | null
    bookingId: number | null
    dueDate: Date | null
    amount: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InstalmentMaxAggregateOutputType = {
    id: number | null
    bookingId: number | null
    dueDate: Date | null
    amount: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InstalmentCountAggregateOutputType = {
    id: number
    bookingId: number
    dueDate: number
    amount: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InstalmentAvgAggregateInputType = {
    id?: true
    bookingId?: true
    amount?: true
  }

  export type InstalmentSumAggregateInputType = {
    id?: true
    bookingId?: true
    amount?: true
  }

  export type InstalmentMinAggregateInputType = {
    id?: true
    bookingId?: true
    dueDate?: true
    amount?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InstalmentMaxAggregateInputType = {
    id?: true
    bookingId?: true
    dueDate?: true
    amount?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InstalmentCountAggregateInputType = {
    id?: true
    bookingId?: true
    dueDate?: true
    amount?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InstalmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Instalment to aggregate.
     */
    where?: InstalmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Instalments to fetch.
     */
    orderBy?: InstalmentOrderByWithRelationInput | InstalmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InstalmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Instalments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Instalments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Instalments
    **/
    _count?: true | InstalmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InstalmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InstalmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InstalmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InstalmentMaxAggregateInputType
  }

  export type GetInstalmentAggregateType<T extends InstalmentAggregateArgs> = {
        [P in keyof T & keyof AggregateInstalment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInstalment[P]>
      : GetScalarType<T[P], AggregateInstalment[P]>
  }




  export type InstalmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstalmentWhereInput
    orderBy?: InstalmentOrderByWithAggregationInput | InstalmentOrderByWithAggregationInput[]
    by: InstalmentScalarFieldEnum[] | InstalmentScalarFieldEnum
    having?: InstalmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InstalmentCountAggregateInputType | true
    _avg?: InstalmentAvgAggregateInputType
    _sum?: InstalmentSumAggregateInputType
    _min?: InstalmentMinAggregateInputType
    _max?: InstalmentMaxAggregateInputType
  }

  export type InstalmentGroupByOutputType = {
    id: number
    bookingId: number
    dueDate: Date
    amount: number
    status: string
    createdAt: Date
    updatedAt: Date
    _count: InstalmentCountAggregateOutputType | null
    _avg: InstalmentAvgAggregateOutputType | null
    _sum: InstalmentSumAggregateOutputType | null
    _min: InstalmentMinAggregateOutputType | null
    _max: InstalmentMaxAggregateOutputType | null
  }

  type GetInstalmentGroupByPayload<T extends InstalmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InstalmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InstalmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InstalmentGroupByOutputType[P]>
            : GetScalarType<T[P], InstalmentGroupByOutputType[P]>
        }
      >
    >


  export type InstalmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    dueDate?: boolean
    amount?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    payments?: boolean | Instalment$paymentsArgs<ExtArgs>
    _count?: boolean | InstalmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["instalment"]>

  export type InstalmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    dueDate?: boolean
    amount?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["instalment"]>

  export type InstalmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    dueDate?: boolean
    amount?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["instalment"]>

  export type InstalmentSelectScalar = {
    id?: boolean
    bookingId?: boolean
    dueDate?: boolean
    amount?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InstalmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bookingId" | "dueDate" | "amount" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["instalment"]>
  export type InstalmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    payments?: boolean | Instalment$paymentsArgs<ExtArgs>
    _count?: boolean | InstalmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InstalmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }
  export type InstalmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }

  export type $InstalmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Instalment"
    objects: {
      booking: Prisma.$BookingPayload<ExtArgs>
      payments: Prisma.$InstalmentPaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      bookingId: number
      dueDate: Date
      amount: number
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["instalment"]>
    composites: {}
  }

  type InstalmentGetPayload<S extends boolean | null | undefined | InstalmentDefaultArgs> = $Result.GetResult<Prisma.$InstalmentPayload, S>

  type InstalmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InstalmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InstalmentCountAggregateInputType | true
    }

  export interface InstalmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Instalment'], meta: { name: 'Instalment' } }
    /**
     * Find zero or one Instalment that matches the filter.
     * @param {InstalmentFindUniqueArgs} args - Arguments to find a Instalment
     * @example
     * // Get one Instalment
     * const instalment = await prisma.instalment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InstalmentFindUniqueArgs>(args: SelectSubset<T, InstalmentFindUniqueArgs<ExtArgs>>): Prisma__InstalmentClient<$Result.GetResult<Prisma.$InstalmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Instalment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InstalmentFindUniqueOrThrowArgs} args - Arguments to find a Instalment
     * @example
     * // Get one Instalment
     * const instalment = await prisma.instalment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InstalmentFindUniqueOrThrowArgs>(args: SelectSubset<T, InstalmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InstalmentClient<$Result.GetResult<Prisma.$InstalmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Instalment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstalmentFindFirstArgs} args - Arguments to find a Instalment
     * @example
     * // Get one Instalment
     * const instalment = await prisma.instalment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InstalmentFindFirstArgs>(args?: SelectSubset<T, InstalmentFindFirstArgs<ExtArgs>>): Prisma__InstalmentClient<$Result.GetResult<Prisma.$InstalmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Instalment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstalmentFindFirstOrThrowArgs} args - Arguments to find a Instalment
     * @example
     * // Get one Instalment
     * const instalment = await prisma.instalment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InstalmentFindFirstOrThrowArgs>(args?: SelectSubset<T, InstalmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__InstalmentClient<$Result.GetResult<Prisma.$InstalmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Instalments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstalmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Instalments
     * const instalments = await prisma.instalment.findMany()
     * 
     * // Get first 10 Instalments
     * const instalments = await prisma.instalment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const instalmentWithIdOnly = await prisma.instalment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InstalmentFindManyArgs>(args?: SelectSubset<T, InstalmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstalmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Instalment.
     * @param {InstalmentCreateArgs} args - Arguments to create a Instalment.
     * @example
     * // Create one Instalment
     * const Instalment = await prisma.instalment.create({
     *   data: {
     *     // ... data to create a Instalment
     *   }
     * })
     * 
     */
    create<T extends InstalmentCreateArgs>(args: SelectSubset<T, InstalmentCreateArgs<ExtArgs>>): Prisma__InstalmentClient<$Result.GetResult<Prisma.$InstalmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Instalments.
     * @param {InstalmentCreateManyArgs} args - Arguments to create many Instalments.
     * @example
     * // Create many Instalments
     * const instalment = await prisma.instalment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InstalmentCreateManyArgs>(args?: SelectSubset<T, InstalmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Instalments and returns the data saved in the database.
     * @param {InstalmentCreateManyAndReturnArgs} args - Arguments to create many Instalments.
     * @example
     * // Create many Instalments
     * const instalment = await prisma.instalment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Instalments and only return the `id`
     * const instalmentWithIdOnly = await prisma.instalment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InstalmentCreateManyAndReturnArgs>(args?: SelectSubset<T, InstalmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstalmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Instalment.
     * @param {InstalmentDeleteArgs} args - Arguments to delete one Instalment.
     * @example
     * // Delete one Instalment
     * const Instalment = await prisma.instalment.delete({
     *   where: {
     *     // ... filter to delete one Instalment
     *   }
     * })
     * 
     */
    delete<T extends InstalmentDeleteArgs>(args: SelectSubset<T, InstalmentDeleteArgs<ExtArgs>>): Prisma__InstalmentClient<$Result.GetResult<Prisma.$InstalmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Instalment.
     * @param {InstalmentUpdateArgs} args - Arguments to update one Instalment.
     * @example
     * // Update one Instalment
     * const instalment = await prisma.instalment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InstalmentUpdateArgs>(args: SelectSubset<T, InstalmentUpdateArgs<ExtArgs>>): Prisma__InstalmentClient<$Result.GetResult<Prisma.$InstalmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Instalments.
     * @param {InstalmentDeleteManyArgs} args - Arguments to filter Instalments to delete.
     * @example
     * // Delete a few Instalments
     * const { count } = await prisma.instalment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InstalmentDeleteManyArgs>(args?: SelectSubset<T, InstalmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Instalments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstalmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Instalments
     * const instalment = await prisma.instalment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InstalmentUpdateManyArgs>(args: SelectSubset<T, InstalmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Instalments and returns the data updated in the database.
     * @param {InstalmentUpdateManyAndReturnArgs} args - Arguments to update many Instalments.
     * @example
     * // Update many Instalments
     * const instalment = await prisma.instalment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Instalments and only return the `id`
     * const instalmentWithIdOnly = await prisma.instalment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InstalmentUpdateManyAndReturnArgs>(args: SelectSubset<T, InstalmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstalmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Instalment.
     * @param {InstalmentUpsertArgs} args - Arguments to update or create a Instalment.
     * @example
     * // Update or create a Instalment
     * const instalment = await prisma.instalment.upsert({
     *   create: {
     *     // ... data to create a Instalment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Instalment we want to update
     *   }
     * })
     */
    upsert<T extends InstalmentUpsertArgs>(args: SelectSubset<T, InstalmentUpsertArgs<ExtArgs>>): Prisma__InstalmentClient<$Result.GetResult<Prisma.$InstalmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Instalments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstalmentCountArgs} args - Arguments to filter Instalments to count.
     * @example
     * // Count the number of Instalments
     * const count = await prisma.instalment.count({
     *   where: {
     *     // ... the filter for the Instalments we want to count
     *   }
     * })
    **/
    count<T extends InstalmentCountArgs>(
      args?: Subset<T, InstalmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InstalmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Instalment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstalmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InstalmentAggregateArgs>(args: Subset<T, InstalmentAggregateArgs>): Prisma.PrismaPromise<GetInstalmentAggregateType<T>>

    /**
     * Group by Instalment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstalmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InstalmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InstalmentGroupByArgs['orderBy'] }
        : { orderBy?: InstalmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InstalmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInstalmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Instalment model
   */
  readonly fields: InstalmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Instalment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InstalmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    booking<T extends BookingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BookingDefaultArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    payments<T extends Instalment$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Instalment$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstalmentPaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Instalment model
   */
  interface InstalmentFieldRefs {
    readonly id: FieldRef<"Instalment", 'Int'>
    readonly bookingId: FieldRef<"Instalment", 'Int'>
    readonly dueDate: FieldRef<"Instalment", 'DateTime'>
    readonly amount: FieldRef<"Instalment", 'Float'>
    readonly status: FieldRef<"Instalment", 'String'>
    readonly createdAt: FieldRef<"Instalment", 'DateTime'>
    readonly updatedAt: FieldRef<"Instalment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Instalment findUnique
   */
  export type InstalmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instalment
     */
    select?: InstalmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instalment
     */
    omit?: InstalmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstalmentInclude<ExtArgs> | null
    /**
     * Filter, which Instalment to fetch.
     */
    where: InstalmentWhereUniqueInput
  }

  /**
   * Instalment findUniqueOrThrow
   */
  export type InstalmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instalment
     */
    select?: InstalmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instalment
     */
    omit?: InstalmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstalmentInclude<ExtArgs> | null
    /**
     * Filter, which Instalment to fetch.
     */
    where: InstalmentWhereUniqueInput
  }

  /**
   * Instalment findFirst
   */
  export type InstalmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instalment
     */
    select?: InstalmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instalment
     */
    omit?: InstalmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstalmentInclude<ExtArgs> | null
    /**
     * Filter, which Instalment to fetch.
     */
    where?: InstalmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Instalments to fetch.
     */
    orderBy?: InstalmentOrderByWithRelationInput | InstalmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Instalments.
     */
    cursor?: InstalmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Instalments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Instalments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Instalments.
     */
    distinct?: InstalmentScalarFieldEnum | InstalmentScalarFieldEnum[]
  }

  /**
   * Instalment findFirstOrThrow
   */
  export type InstalmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instalment
     */
    select?: InstalmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instalment
     */
    omit?: InstalmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstalmentInclude<ExtArgs> | null
    /**
     * Filter, which Instalment to fetch.
     */
    where?: InstalmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Instalments to fetch.
     */
    orderBy?: InstalmentOrderByWithRelationInput | InstalmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Instalments.
     */
    cursor?: InstalmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Instalments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Instalments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Instalments.
     */
    distinct?: InstalmentScalarFieldEnum | InstalmentScalarFieldEnum[]
  }

  /**
   * Instalment findMany
   */
  export type InstalmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instalment
     */
    select?: InstalmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instalment
     */
    omit?: InstalmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstalmentInclude<ExtArgs> | null
    /**
     * Filter, which Instalments to fetch.
     */
    where?: InstalmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Instalments to fetch.
     */
    orderBy?: InstalmentOrderByWithRelationInput | InstalmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Instalments.
     */
    cursor?: InstalmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Instalments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Instalments.
     */
    skip?: number
    distinct?: InstalmentScalarFieldEnum | InstalmentScalarFieldEnum[]
  }

  /**
   * Instalment create
   */
  export type InstalmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instalment
     */
    select?: InstalmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instalment
     */
    omit?: InstalmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstalmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Instalment.
     */
    data: XOR<InstalmentCreateInput, InstalmentUncheckedCreateInput>
  }

  /**
   * Instalment createMany
   */
  export type InstalmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Instalments.
     */
    data: InstalmentCreateManyInput | InstalmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Instalment createManyAndReturn
   */
  export type InstalmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instalment
     */
    select?: InstalmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Instalment
     */
    omit?: InstalmentOmit<ExtArgs> | null
    /**
     * The data used to create many Instalments.
     */
    data: InstalmentCreateManyInput | InstalmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstalmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Instalment update
   */
  export type InstalmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instalment
     */
    select?: InstalmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instalment
     */
    omit?: InstalmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstalmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Instalment.
     */
    data: XOR<InstalmentUpdateInput, InstalmentUncheckedUpdateInput>
    /**
     * Choose, which Instalment to update.
     */
    where: InstalmentWhereUniqueInput
  }

  /**
   * Instalment updateMany
   */
  export type InstalmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Instalments.
     */
    data: XOR<InstalmentUpdateManyMutationInput, InstalmentUncheckedUpdateManyInput>
    /**
     * Filter which Instalments to update
     */
    where?: InstalmentWhereInput
    /**
     * Limit how many Instalments to update.
     */
    limit?: number
  }

  /**
   * Instalment updateManyAndReturn
   */
  export type InstalmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instalment
     */
    select?: InstalmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Instalment
     */
    omit?: InstalmentOmit<ExtArgs> | null
    /**
     * The data used to update Instalments.
     */
    data: XOR<InstalmentUpdateManyMutationInput, InstalmentUncheckedUpdateManyInput>
    /**
     * Filter which Instalments to update
     */
    where?: InstalmentWhereInput
    /**
     * Limit how many Instalments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstalmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Instalment upsert
   */
  export type InstalmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instalment
     */
    select?: InstalmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instalment
     */
    omit?: InstalmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstalmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Instalment to update in case it exists.
     */
    where: InstalmentWhereUniqueInput
    /**
     * In case the Instalment found by the `where` argument doesn't exist, create a new Instalment with this data.
     */
    create: XOR<InstalmentCreateInput, InstalmentUncheckedCreateInput>
    /**
     * In case the Instalment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InstalmentUpdateInput, InstalmentUncheckedUpdateInput>
  }

  /**
   * Instalment delete
   */
  export type InstalmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instalment
     */
    select?: InstalmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instalment
     */
    omit?: InstalmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstalmentInclude<ExtArgs> | null
    /**
     * Filter which Instalment to delete.
     */
    where: InstalmentWhereUniqueInput
  }

  /**
   * Instalment deleteMany
   */
  export type InstalmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Instalments to delete
     */
    where?: InstalmentWhereInput
    /**
     * Limit how many Instalments to delete.
     */
    limit?: number
  }

  /**
   * Instalment.payments
   */
  export type Instalment$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstalmentPayment
     */
    select?: InstalmentPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstalmentPayment
     */
    omit?: InstalmentPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstalmentPaymentInclude<ExtArgs> | null
    where?: InstalmentPaymentWhereInput
    orderBy?: InstalmentPaymentOrderByWithRelationInput | InstalmentPaymentOrderByWithRelationInput[]
    cursor?: InstalmentPaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InstalmentPaymentScalarFieldEnum | InstalmentPaymentScalarFieldEnum[]
  }

  /**
   * Instalment without action
   */
  export type InstalmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Instalment
     */
    select?: InstalmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Instalment
     */
    omit?: InstalmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstalmentInclude<ExtArgs> | null
  }


  /**
   * Model PendingInstalment
   */

  export type AggregatePendingInstalment = {
    _count: PendingInstalmentCountAggregateOutputType | null
    _avg: PendingInstalmentAvgAggregateOutputType | null
    _sum: PendingInstalmentSumAggregateOutputType | null
    _min: PendingInstalmentMinAggregateOutputType | null
    _max: PendingInstalmentMaxAggregateOutputType | null
  }

  export type PendingInstalmentAvgAggregateOutputType = {
    id: number | null
    pendingBookingId: number | null
    amount: number | null
  }

  export type PendingInstalmentSumAggregateOutputType = {
    id: number | null
    pendingBookingId: number | null
    amount: number | null
  }

  export type PendingInstalmentMinAggregateOutputType = {
    id: number | null
    pendingBookingId: number | null
    dueDate: Date | null
    amount: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PendingInstalmentMaxAggregateOutputType = {
    id: number | null
    pendingBookingId: number | null
    dueDate: Date | null
    amount: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PendingInstalmentCountAggregateOutputType = {
    id: number
    pendingBookingId: number
    dueDate: number
    amount: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PendingInstalmentAvgAggregateInputType = {
    id?: true
    pendingBookingId?: true
    amount?: true
  }

  export type PendingInstalmentSumAggregateInputType = {
    id?: true
    pendingBookingId?: true
    amount?: true
  }

  export type PendingInstalmentMinAggregateInputType = {
    id?: true
    pendingBookingId?: true
    dueDate?: true
    amount?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PendingInstalmentMaxAggregateInputType = {
    id?: true
    pendingBookingId?: true
    dueDate?: true
    amount?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PendingInstalmentCountAggregateInputType = {
    id?: true
    pendingBookingId?: true
    dueDate?: true
    amount?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PendingInstalmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PendingInstalment to aggregate.
     */
    where?: PendingInstalmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PendingInstalments to fetch.
     */
    orderBy?: PendingInstalmentOrderByWithRelationInput | PendingInstalmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PendingInstalmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PendingInstalments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PendingInstalments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PendingInstalments
    **/
    _count?: true | PendingInstalmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PendingInstalmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PendingInstalmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PendingInstalmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PendingInstalmentMaxAggregateInputType
  }

  export type GetPendingInstalmentAggregateType<T extends PendingInstalmentAggregateArgs> = {
        [P in keyof T & keyof AggregatePendingInstalment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePendingInstalment[P]>
      : GetScalarType<T[P], AggregatePendingInstalment[P]>
  }




  export type PendingInstalmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PendingInstalmentWhereInput
    orderBy?: PendingInstalmentOrderByWithAggregationInput | PendingInstalmentOrderByWithAggregationInput[]
    by: PendingInstalmentScalarFieldEnum[] | PendingInstalmentScalarFieldEnum
    having?: PendingInstalmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PendingInstalmentCountAggregateInputType | true
    _avg?: PendingInstalmentAvgAggregateInputType
    _sum?: PendingInstalmentSumAggregateInputType
    _min?: PendingInstalmentMinAggregateInputType
    _max?: PendingInstalmentMaxAggregateInputType
  }

  export type PendingInstalmentGroupByOutputType = {
    id: number
    pendingBookingId: number
    dueDate: Date
    amount: number
    status: string
    createdAt: Date
    updatedAt: Date
    _count: PendingInstalmentCountAggregateOutputType | null
    _avg: PendingInstalmentAvgAggregateOutputType | null
    _sum: PendingInstalmentSumAggregateOutputType | null
    _min: PendingInstalmentMinAggregateOutputType | null
    _max: PendingInstalmentMaxAggregateOutputType | null
  }

  type GetPendingInstalmentGroupByPayload<T extends PendingInstalmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PendingInstalmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PendingInstalmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PendingInstalmentGroupByOutputType[P]>
            : GetScalarType<T[P], PendingInstalmentGroupByOutputType[P]>
        }
      >
    >


  export type PendingInstalmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pendingBookingId?: boolean
    dueDate?: boolean
    amount?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pendingBooking?: boolean | PendingBookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pendingInstalment"]>

  export type PendingInstalmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pendingBookingId?: boolean
    dueDate?: boolean
    amount?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pendingBooking?: boolean | PendingBookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pendingInstalment"]>

  export type PendingInstalmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pendingBookingId?: boolean
    dueDate?: boolean
    amount?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pendingBooking?: boolean | PendingBookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pendingInstalment"]>

  export type PendingInstalmentSelectScalar = {
    id?: boolean
    pendingBookingId?: boolean
    dueDate?: boolean
    amount?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PendingInstalmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "pendingBookingId" | "dueDate" | "amount" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["pendingInstalment"]>
  export type PendingInstalmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pendingBooking?: boolean | PendingBookingDefaultArgs<ExtArgs>
  }
  export type PendingInstalmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pendingBooking?: boolean | PendingBookingDefaultArgs<ExtArgs>
  }
  export type PendingInstalmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pendingBooking?: boolean | PendingBookingDefaultArgs<ExtArgs>
  }

  export type $PendingInstalmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PendingInstalment"
    objects: {
      pendingBooking: Prisma.$PendingBookingPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      pendingBookingId: number
      dueDate: Date
      amount: number
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["pendingInstalment"]>
    composites: {}
  }

  type PendingInstalmentGetPayload<S extends boolean | null | undefined | PendingInstalmentDefaultArgs> = $Result.GetResult<Prisma.$PendingInstalmentPayload, S>

  type PendingInstalmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PendingInstalmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PendingInstalmentCountAggregateInputType | true
    }

  export interface PendingInstalmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PendingInstalment'], meta: { name: 'PendingInstalment' } }
    /**
     * Find zero or one PendingInstalment that matches the filter.
     * @param {PendingInstalmentFindUniqueArgs} args - Arguments to find a PendingInstalment
     * @example
     * // Get one PendingInstalment
     * const pendingInstalment = await prisma.pendingInstalment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PendingInstalmentFindUniqueArgs>(args: SelectSubset<T, PendingInstalmentFindUniqueArgs<ExtArgs>>): Prisma__PendingInstalmentClient<$Result.GetResult<Prisma.$PendingInstalmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PendingInstalment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PendingInstalmentFindUniqueOrThrowArgs} args - Arguments to find a PendingInstalment
     * @example
     * // Get one PendingInstalment
     * const pendingInstalment = await prisma.pendingInstalment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PendingInstalmentFindUniqueOrThrowArgs>(args: SelectSubset<T, PendingInstalmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PendingInstalmentClient<$Result.GetResult<Prisma.$PendingInstalmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PendingInstalment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingInstalmentFindFirstArgs} args - Arguments to find a PendingInstalment
     * @example
     * // Get one PendingInstalment
     * const pendingInstalment = await prisma.pendingInstalment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PendingInstalmentFindFirstArgs>(args?: SelectSubset<T, PendingInstalmentFindFirstArgs<ExtArgs>>): Prisma__PendingInstalmentClient<$Result.GetResult<Prisma.$PendingInstalmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PendingInstalment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingInstalmentFindFirstOrThrowArgs} args - Arguments to find a PendingInstalment
     * @example
     * // Get one PendingInstalment
     * const pendingInstalment = await prisma.pendingInstalment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PendingInstalmentFindFirstOrThrowArgs>(args?: SelectSubset<T, PendingInstalmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PendingInstalmentClient<$Result.GetResult<Prisma.$PendingInstalmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PendingInstalments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingInstalmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PendingInstalments
     * const pendingInstalments = await prisma.pendingInstalment.findMany()
     * 
     * // Get first 10 PendingInstalments
     * const pendingInstalments = await prisma.pendingInstalment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pendingInstalmentWithIdOnly = await prisma.pendingInstalment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PendingInstalmentFindManyArgs>(args?: SelectSubset<T, PendingInstalmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PendingInstalmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PendingInstalment.
     * @param {PendingInstalmentCreateArgs} args - Arguments to create a PendingInstalment.
     * @example
     * // Create one PendingInstalment
     * const PendingInstalment = await prisma.pendingInstalment.create({
     *   data: {
     *     // ... data to create a PendingInstalment
     *   }
     * })
     * 
     */
    create<T extends PendingInstalmentCreateArgs>(args: SelectSubset<T, PendingInstalmentCreateArgs<ExtArgs>>): Prisma__PendingInstalmentClient<$Result.GetResult<Prisma.$PendingInstalmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PendingInstalments.
     * @param {PendingInstalmentCreateManyArgs} args - Arguments to create many PendingInstalments.
     * @example
     * // Create many PendingInstalments
     * const pendingInstalment = await prisma.pendingInstalment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PendingInstalmentCreateManyArgs>(args?: SelectSubset<T, PendingInstalmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PendingInstalments and returns the data saved in the database.
     * @param {PendingInstalmentCreateManyAndReturnArgs} args - Arguments to create many PendingInstalments.
     * @example
     * // Create many PendingInstalments
     * const pendingInstalment = await prisma.pendingInstalment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PendingInstalments and only return the `id`
     * const pendingInstalmentWithIdOnly = await prisma.pendingInstalment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PendingInstalmentCreateManyAndReturnArgs>(args?: SelectSubset<T, PendingInstalmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PendingInstalmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PendingInstalment.
     * @param {PendingInstalmentDeleteArgs} args - Arguments to delete one PendingInstalment.
     * @example
     * // Delete one PendingInstalment
     * const PendingInstalment = await prisma.pendingInstalment.delete({
     *   where: {
     *     // ... filter to delete one PendingInstalment
     *   }
     * })
     * 
     */
    delete<T extends PendingInstalmentDeleteArgs>(args: SelectSubset<T, PendingInstalmentDeleteArgs<ExtArgs>>): Prisma__PendingInstalmentClient<$Result.GetResult<Prisma.$PendingInstalmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PendingInstalment.
     * @param {PendingInstalmentUpdateArgs} args - Arguments to update one PendingInstalment.
     * @example
     * // Update one PendingInstalment
     * const pendingInstalment = await prisma.pendingInstalment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PendingInstalmentUpdateArgs>(args: SelectSubset<T, PendingInstalmentUpdateArgs<ExtArgs>>): Prisma__PendingInstalmentClient<$Result.GetResult<Prisma.$PendingInstalmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PendingInstalments.
     * @param {PendingInstalmentDeleteManyArgs} args - Arguments to filter PendingInstalments to delete.
     * @example
     * // Delete a few PendingInstalments
     * const { count } = await prisma.pendingInstalment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PendingInstalmentDeleteManyArgs>(args?: SelectSubset<T, PendingInstalmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PendingInstalments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingInstalmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PendingInstalments
     * const pendingInstalment = await prisma.pendingInstalment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PendingInstalmentUpdateManyArgs>(args: SelectSubset<T, PendingInstalmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PendingInstalments and returns the data updated in the database.
     * @param {PendingInstalmentUpdateManyAndReturnArgs} args - Arguments to update many PendingInstalments.
     * @example
     * // Update many PendingInstalments
     * const pendingInstalment = await prisma.pendingInstalment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PendingInstalments and only return the `id`
     * const pendingInstalmentWithIdOnly = await prisma.pendingInstalment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PendingInstalmentUpdateManyAndReturnArgs>(args: SelectSubset<T, PendingInstalmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PendingInstalmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PendingInstalment.
     * @param {PendingInstalmentUpsertArgs} args - Arguments to update or create a PendingInstalment.
     * @example
     * // Update or create a PendingInstalment
     * const pendingInstalment = await prisma.pendingInstalment.upsert({
     *   create: {
     *     // ... data to create a PendingInstalment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PendingInstalment we want to update
     *   }
     * })
     */
    upsert<T extends PendingInstalmentUpsertArgs>(args: SelectSubset<T, PendingInstalmentUpsertArgs<ExtArgs>>): Prisma__PendingInstalmentClient<$Result.GetResult<Prisma.$PendingInstalmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PendingInstalments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingInstalmentCountArgs} args - Arguments to filter PendingInstalments to count.
     * @example
     * // Count the number of PendingInstalments
     * const count = await prisma.pendingInstalment.count({
     *   where: {
     *     // ... the filter for the PendingInstalments we want to count
     *   }
     * })
    **/
    count<T extends PendingInstalmentCountArgs>(
      args?: Subset<T, PendingInstalmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PendingInstalmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PendingInstalment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingInstalmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PendingInstalmentAggregateArgs>(args: Subset<T, PendingInstalmentAggregateArgs>): Prisma.PrismaPromise<GetPendingInstalmentAggregateType<T>>

    /**
     * Group by PendingInstalment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingInstalmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PendingInstalmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PendingInstalmentGroupByArgs['orderBy'] }
        : { orderBy?: PendingInstalmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PendingInstalmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPendingInstalmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PendingInstalment model
   */
  readonly fields: PendingInstalmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PendingInstalment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PendingInstalmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pendingBooking<T extends PendingBookingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PendingBookingDefaultArgs<ExtArgs>>): Prisma__PendingBookingClient<$Result.GetResult<Prisma.$PendingBookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PendingInstalment model
   */
  interface PendingInstalmentFieldRefs {
    readonly id: FieldRef<"PendingInstalment", 'Int'>
    readonly pendingBookingId: FieldRef<"PendingInstalment", 'Int'>
    readonly dueDate: FieldRef<"PendingInstalment", 'DateTime'>
    readonly amount: FieldRef<"PendingInstalment", 'Float'>
    readonly status: FieldRef<"PendingInstalment", 'String'>
    readonly createdAt: FieldRef<"PendingInstalment", 'DateTime'>
    readonly updatedAt: FieldRef<"PendingInstalment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PendingInstalment findUnique
   */
  export type PendingInstalmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingInstalment
     */
    select?: PendingInstalmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingInstalment
     */
    omit?: PendingInstalmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingInstalmentInclude<ExtArgs> | null
    /**
     * Filter, which PendingInstalment to fetch.
     */
    where: PendingInstalmentWhereUniqueInput
  }

  /**
   * PendingInstalment findUniqueOrThrow
   */
  export type PendingInstalmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingInstalment
     */
    select?: PendingInstalmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingInstalment
     */
    omit?: PendingInstalmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingInstalmentInclude<ExtArgs> | null
    /**
     * Filter, which PendingInstalment to fetch.
     */
    where: PendingInstalmentWhereUniqueInput
  }

  /**
   * PendingInstalment findFirst
   */
  export type PendingInstalmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingInstalment
     */
    select?: PendingInstalmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingInstalment
     */
    omit?: PendingInstalmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingInstalmentInclude<ExtArgs> | null
    /**
     * Filter, which PendingInstalment to fetch.
     */
    where?: PendingInstalmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PendingInstalments to fetch.
     */
    orderBy?: PendingInstalmentOrderByWithRelationInput | PendingInstalmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PendingInstalments.
     */
    cursor?: PendingInstalmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PendingInstalments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PendingInstalments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PendingInstalments.
     */
    distinct?: PendingInstalmentScalarFieldEnum | PendingInstalmentScalarFieldEnum[]
  }

  /**
   * PendingInstalment findFirstOrThrow
   */
  export type PendingInstalmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingInstalment
     */
    select?: PendingInstalmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingInstalment
     */
    omit?: PendingInstalmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingInstalmentInclude<ExtArgs> | null
    /**
     * Filter, which PendingInstalment to fetch.
     */
    where?: PendingInstalmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PendingInstalments to fetch.
     */
    orderBy?: PendingInstalmentOrderByWithRelationInput | PendingInstalmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PendingInstalments.
     */
    cursor?: PendingInstalmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PendingInstalments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PendingInstalments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PendingInstalments.
     */
    distinct?: PendingInstalmentScalarFieldEnum | PendingInstalmentScalarFieldEnum[]
  }

  /**
   * PendingInstalment findMany
   */
  export type PendingInstalmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingInstalment
     */
    select?: PendingInstalmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingInstalment
     */
    omit?: PendingInstalmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingInstalmentInclude<ExtArgs> | null
    /**
     * Filter, which PendingInstalments to fetch.
     */
    where?: PendingInstalmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PendingInstalments to fetch.
     */
    orderBy?: PendingInstalmentOrderByWithRelationInput | PendingInstalmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PendingInstalments.
     */
    cursor?: PendingInstalmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PendingInstalments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PendingInstalments.
     */
    skip?: number
    distinct?: PendingInstalmentScalarFieldEnum | PendingInstalmentScalarFieldEnum[]
  }

  /**
   * PendingInstalment create
   */
  export type PendingInstalmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingInstalment
     */
    select?: PendingInstalmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingInstalment
     */
    omit?: PendingInstalmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingInstalmentInclude<ExtArgs> | null
    /**
     * The data needed to create a PendingInstalment.
     */
    data: XOR<PendingInstalmentCreateInput, PendingInstalmentUncheckedCreateInput>
  }

  /**
   * PendingInstalment createMany
   */
  export type PendingInstalmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PendingInstalments.
     */
    data: PendingInstalmentCreateManyInput | PendingInstalmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PendingInstalment createManyAndReturn
   */
  export type PendingInstalmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingInstalment
     */
    select?: PendingInstalmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PendingInstalment
     */
    omit?: PendingInstalmentOmit<ExtArgs> | null
    /**
     * The data used to create many PendingInstalments.
     */
    data: PendingInstalmentCreateManyInput | PendingInstalmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingInstalmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PendingInstalment update
   */
  export type PendingInstalmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingInstalment
     */
    select?: PendingInstalmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingInstalment
     */
    omit?: PendingInstalmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingInstalmentInclude<ExtArgs> | null
    /**
     * The data needed to update a PendingInstalment.
     */
    data: XOR<PendingInstalmentUpdateInput, PendingInstalmentUncheckedUpdateInput>
    /**
     * Choose, which PendingInstalment to update.
     */
    where: PendingInstalmentWhereUniqueInput
  }

  /**
   * PendingInstalment updateMany
   */
  export type PendingInstalmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PendingInstalments.
     */
    data: XOR<PendingInstalmentUpdateManyMutationInput, PendingInstalmentUncheckedUpdateManyInput>
    /**
     * Filter which PendingInstalments to update
     */
    where?: PendingInstalmentWhereInput
    /**
     * Limit how many PendingInstalments to update.
     */
    limit?: number
  }

  /**
   * PendingInstalment updateManyAndReturn
   */
  export type PendingInstalmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingInstalment
     */
    select?: PendingInstalmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PendingInstalment
     */
    omit?: PendingInstalmentOmit<ExtArgs> | null
    /**
     * The data used to update PendingInstalments.
     */
    data: XOR<PendingInstalmentUpdateManyMutationInput, PendingInstalmentUncheckedUpdateManyInput>
    /**
     * Filter which PendingInstalments to update
     */
    where?: PendingInstalmentWhereInput
    /**
     * Limit how many PendingInstalments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingInstalmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PendingInstalment upsert
   */
  export type PendingInstalmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingInstalment
     */
    select?: PendingInstalmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingInstalment
     */
    omit?: PendingInstalmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingInstalmentInclude<ExtArgs> | null
    /**
     * The filter to search for the PendingInstalment to update in case it exists.
     */
    where: PendingInstalmentWhereUniqueInput
    /**
     * In case the PendingInstalment found by the `where` argument doesn't exist, create a new PendingInstalment with this data.
     */
    create: XOR<PendingInstalmentCreateInput, PendingInstalmentUncheckedCreateInput>
    /**
     * In case the PendingInstalment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PendingInstalmentUpdateInput, PendingInstalmentUncheckedUpdateInput>
  }

  /**
   * PendingInstalment delete
   */
  export type PendingInstalmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingInstalment
     */
    select?: PendingInstalmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingInstalment
     */
    omit?: PendingInstalmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingInstalmentInclude<ExtArgs> | null
    /**
     * Filter which PendingInstalment to delete.
     */
    where: PendingInstalmentWhereUniqueInput
  }

  /**
   * PendingInstalment deleteMany
   */
  export type PendingInstalmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PendingInstalments to delete
     */
    where?: PendingInstalmentWhereInput
    /**
     * Limit how many PendingInstalments to delete.
     */
    limit?: number
  }

  /**
   * PendingInstalment without action
   */
  export type PendingInstalmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingInstalment
     */
    select?: PendingInstalmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingInstalment
     */
    omit?: PendingInstalmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingInstalmentInclude<ExtArgs> | null
  }


  /**
   * Model InstalmentPayment
   */

  export type AggregateInstalmentPayment = {
    _count: InstalmentPaymentCountAggregateOutputType | null
    _avg: InstalmentPaymentAvgAggregateOutputType | null
    _sum: InstalmentPaymentSumAggregateOutputType | null
    _min: InstalmentPaymentMinAggregateOutputType | null
    _max: InstalmentPaymentMaxAggregateOutputType | null
  }

  export type InstalmentPaymentAvgAggregateOutputType = {
    id: number | null
    instalmentId: number | null
    amount: number | null
  }

  export type InstalmentPaymentSumAggregateOutputType = {
    id: number | null
    instalmentId: number | null
    amount: number | null
  }

  export type InstalmentPaymentMinAggregateOutputType = {
    id: number | null
    instalmentId: number | null
    amount: number | null
    transactionMethod: string | null
    paymentDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InstalmentPaymentMaxAggregateOutputType = {
    id: number | null
    instalmentId: number | null
    amount: number | null
    transactionMethod: string | null
    paymentDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InstalmentPaymentCountAggregateOutputType = {
    id: number
    instalmentId: number
    amount: number
    transactionMethod: number
    paymentDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InstalmentPaymentAvgAggregateInputType = {
    id?: true
    instalmentId?: true
    amount?: true
  }

  export type InstalmentPaymentSumAggregateInputType = {
    id?: true
    instalmentId?: true
    amount?: true
  }

  export type InstalmentPaymentMinAggregateInputType = {
    id?: true
    instalmentId?: true
    amount?: true
    transactionMethod?: true
    paymentDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InstalmentPaymentMaxAggregateInputType = {
    id?: true
    instalmentId?: true
    amount?: true
    transactionMethod?: true
    paymentDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InstalmentPaymentCountAggregateInputType = {
    id?: true
    instalmentId?: true
    amount?: true
    transactionMethod?: true
    paymentDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InstalmentPaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InstalmentPayment to aggregate.
     */
    where?: InstalmentPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstalmentPayments to fetch.
     */
    orderBy?: InstalmentPaymentOrderByWithRelationInput | InstalmentPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InstalmentPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstalmentPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstalmentPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InstalmentPayments
    **/
    _count?: true | InstalmentPaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InstalmentPaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InstalmentPaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InstalmentPaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InstalmentPaymentMaxAggregateInputType
  }

  export type GetInstalmentPaymentAggregateType<T extends InstalmentPaymentAggregateArgs> = {
        [P in keyof T & keyof AggregateInstalmentPayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInstalmentPayment[P]>
      : GetScalarType<T[P], AggregateInstalmentPayment[P]>
  }




  export type InstalmentPaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InstalmentPaymentWhereInput
    orderBy?: InstalmentPaymentOrderByWithAggregationInput | InstalmentPaymentOrderByWithAggregationInput[]
    by: InstalmentPaymentScalarFieldEnum[] | InstalmentPaymentScalarFieldEnum
    having?: InstalmentPaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InstalmentPaymentCountAggregateInputType | true
    _avg?: InstalmentPaymentAvgAggregateInputType
    _sum?: InstalmentPaymentSumAggregateInputType
    _min?: InstalmentPaymentMinAggregateInputType
    _max?: InstalmentPaymentMaxAggregateInputType
  }

  export type InstalmentPaymentGroupByOutputType = {
    id: number
    instalmentId: number
    amount: number
    transactionMethod: string
    paymentDate: Date
    createdAt: Date
    updatedAt: Date
    _count: InstalmentPaymentCountAggregateOutputType | null
    _avg: InstalmentPaymentAvgAggregateOutputType | null
    _sum: InstalmentPaymentSumAggregateOutputType | null
    _min: InstalmentPaymentMinAggregateOutputType | null
    _max: InstalmentPaymentMaxAggregateOutputType | null
  }

  type GetInstalmentPaymentGroupByPayload<T extends InstalmentPaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InstalmentPaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InstalmentPaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InstalmentPaymentGroupByOutputType[P]>
            : GetScalarType<T[P], InstalmentPaymentGroupByOutputType[P]>
        }
      >
    >


  export type InstalmentPaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    instalmentId?: boolean
    amount?: boolean
    transactionMethod?: boolean
    paymentDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    instalment?: boolean | InstalmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["instalmentPayment"]>

  export type InstalmentPaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    instalmentId?: boolean
    amount?: boolean
    transactionMethod?: boolean
    paymentDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    instalment?: boolean | InstalmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["instalmentPayment"]>

  export type InstalmentPaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    instalmentId?: boolean
    amount?: boolean
    transactionMethod?: boolean
    paymentDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    instalment?: boolean | InstalmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["instalmentPayment"]>

  export type InstalmentPaymentSelectScalar = {
    id?: boolean
    instalmentId?: boolean
    amount?: boolean
    transactionMethod?: boolean
    paymentDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InstalmentPaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "instalmentId" | "amount" | "transactionMethod" | "paymentDate" | "createdAt" | "updatedAt", ExtArgs["result"]["instalmentPayment"]>
  export type InstalmentPaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    instalment?: boolean | InstalmentDefaultArgs<ExtArgs>
  }
  export type InstalmentPaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    instalment?: boolean | InstalmentDefaultArgs<ExtArgs>
  }
  export type InstalmentPaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    instalment?: boolean | InstalmentDefaultArgs<ExtArgs>
  }

  export type $InstalmentPaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InstalmentPayment"
    objects: {
      instalment: Prisma.$InstalmentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      instalmentId: number
      amount: number
      transactionMethod: string
      paymentDate: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["instalmentPayment"]>
    composites: {}
  }

  type InstalmentPaymentGetPayload<S extends boolean | null | undefined | InstalmentPaymentDefaultArgs> = $Result.GetResult<Prisma.$InstalmentPaymentPayload, S>

  type InstalmentPaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InstalmentPaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InstalmentPaymentCountAggregateInputType | true
    }

  export interface InstalmentPaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InstalmentPayment'], meta: { name: 'InstalmentPayment' } }
    /**
     * Find zero or one InstalmentPayment that matches the filter.
     * @param {InstalmentPaymentFindUniqueArgs} args - Arguments to find a InstalmentPayment
     * @example
     * // Get one InstalmentPayment
     * const instalmentPayment = await prisma.instalmentPayment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InstalmentPaymentFindUniqueArgs>(args: SelectSubset<T, InstalmentPaymentFindUniqueArgs<ExtArgs>>): Prisma__InstalmentPaymentClient<$Result.GetResult<Prisma.$InstalmentPaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InstalmentPayment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InstalmentPaymentFindUniqueOrThrowArgs} args - Arguments to find a InstalmentPayment
     * @example
     * // Get one InstalmentPayment
     * const instalmentPayment = await prisma.instalmentPayment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InstalmentPaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, InstalmentPaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InstalmentPaymentClient<$Result.GetResult<Prisma.$InstalmentPaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InstalmentPayment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstalmentPaymentFindFirstArgs} args - Arguments to find a InstalmentPayment
     * @example
     * // Get one InstalmentPayment
     * const instalmentPayment = await prisma.instalmentPayment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InstalmentPaymentFindFirstArgs>(args?: SelectSubset<T, InstalmentPaymentFindFirstArgs<ExtArgs>>): Prisma__InstalmentPaymentClient<$Result.GetResult<Prisma.$InstalmentPaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InstalmentPayment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstalmentPaymentFindFirstOrThrowArgs} args - Arguments to find a InstalmentPayment
     * @example
     * // Get one InstalmentPayment
     * const instalmentPayment = await prisma.instalmentPayment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InstalmentPaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, InstalmentPaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__InstalmentPaymentClient<$Result.GetResult<Prisma.$InstalmentPaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InstalmentPayments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstalmentPaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InstalmentPayments
     * const instalmentPayments = await prisma.instalmentPayment.findMany()
     * 
     * // Get first 10 InstalmentPayments
     * const instalmentPayments = await prisma.instalmentPayment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const instalmentPaymentWithIdOnly = await prisma.instalmentPayment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InstalmentPaymentFindManyArgs>(args?: SelectSubset<T, InstalmentPaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstalmentPaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InstalmentPayment.
     * @param {InstalmentPaymentCreateArgs} args - Arguments to create a InstalmentPayment.
     * @example
     * // Create one InstalmentPayment
     * const InstalmentPayment = await prisma.instalmentPayment.create({
     *   data: {
     *     // ... data to create a InstalmentPayment
     *   }
     * })
     * 
     */
    create<T extends InstalmentPaymentCreateArgs>(args: SelectSubset<T, InstalmentPaymentCreateArgs<ExtArgs>>): Prisma__InstalmentPaymentClient<$Result.GetResult<Prisma.$InstalmentPaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InstalmentPayments.
     * @param {InstalmentPaymentCreateManyArgs} args - Arguments to create many InstalmentPayments.
     * @example
     * // Create many InstalmentPayments
     * const instalmentPayment = await prisma.instalmentPayment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InstalmentPaymentCreateManyArgs>(args?: SelectSubset<T, InstalmentPaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InstalmentPayments and returns the data saved in the database.
     * @param {InstalmentPaymentCreateManyAndReturnArgs} args - Arguments to create many InstalmentPayments.
     * @example
     * // Create many InstalmentPayments
     * const instalmentPayment = await prisma.instalmentPayment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InstalmentPayments and only return the `id`
     * const instalmentPaymentWithIdOnly = await prisma.instalmentPayment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InstalmentPaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, InstalmentPaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstalmentPaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InstalmentPayment.
     * @param {InstalmentPaymentDeleteArgs} args - Arguments to delete one InstalmentPayment.
     * @example
     * // Delete one InstalmentPayment
     * const InstalmentPayment = await prisma.instalmentPayment.delete({
     *   where: {
     *     // ... filter to delete one InstalmentPayment
     *   }
     * })
     * 
     */
    delete<T extends InstalmentPaymentDeleteArgs>(args: SelectSubset<T, InstalmentPaymentDeleteArgs<ExtArgs>>): Prisma__InstalmentPaymentClient<$Result.GetResult<Prisma.$InstalmentPaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InstalmentPayment.
     * @param {InstalmentPaymentUpdateArgs} args - Arguments to update one InstalmentPayment.
     * @example
     * // Update one InstalmentPayment
     * const instalmentPayment = await prisma.instalmentPayment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InstalmentPaymentUpdateArgs>(args: SelectSubset<T, InstalmentPaymentUpdateArgs<ExtArgs>>): Prisma__InstalmentPaymentClient<$Result.GetResult<Prisma.$InstalmentPaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InstalmentPayments.
     * @param {InstalmentPaymentDeleteManyArgs} args - Arguments to filter InstalmentPayments to delete.
     * @example
     * // Delete a few InstalmentPayments
     * const { count } = await prisma.instalmentPayment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InstalmentPaymentDeleteManyArgs>(args?: SelectSubset<T, InstalmentPaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InstalmentPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstalmentPaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InstalmentPayments
     * const instalmentPayment = await prisma.instalmentPayment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InstalmentPaymentUpdateManyArgs>(args: SelectSubset<T, InstalmentPaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InstalmentPayments and returns the data updated in the database.
     * @param {InstalmentPaymentUpdateManyAndReturnArgs} args - Arguments to update many InstalmentPayments.
     * @example
     * // Update many InstalmentPayments
     * const instalmentPayment = await prisma.instalmentPayment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InstalmentPayments and only return the `id`
     * const instalmentPaymentWithIdOnly = await prisma.instalmentPayment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InstalmentPaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, InstalmentPaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InstalmentPaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InstalmentPayment.
     * @param {InstalmentPaymentUpsertArgs} args - Arguments to update or create a InstalmentPayment.
     * @example
     * // Update or create a InstalmentPayment
     * const instalmentPayment = await prisma.instalmentPayment.upsert({
     *   create: {
     *     // ... data to create a InstalmentPayment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InstalmentPayment we want to update
     *   }
     * })
     */
    upsert<T extends InstalmentPaymentUpsertArgs>(args: SelectSubset<T, InstalmentPaymentUpsertArgs<ExtArgs>>): Prisma__InstalmentPaymentClient<$Result.GetResult<Prisma.$InstalmentPaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InstalmentPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstalmentPaymentCountArgs} args - Arguments to filter InstalmentPayments to count.
     * @example
     * // Count the number of InstalmentPayments
     * const count = await prisma.instalmentPayment.count({
     *   where: {
     *     // ... the filter for the InstalmentPayments we want to count
     *   }
     * })
    **/
    count<T extends InstalmentPaymentCountArgs>(
      args?: Subset<T, InstalmentPaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InstalmentPaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InstalmentPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstalmentPaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InstalmentPaymentAggregateArgs>(args: Subset<T, InstalmentPaymentAggregateArgs>): Prisma.PrismaPromise<GetInstalmentPaymentAggregateType<T>>

    /**
     * Group by InstalmentPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InstalmentPaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InstalmentPaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InstalmentPaymentGroupByArgs['orderBy'] }
        : { orderBy?: InstalmentPaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InstalmentPaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInstalmentPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InstalmentPayment model
   */
  readonly fields: InstalmentPaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InstalmentPayment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InstalmentPaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    instalment<T extends InstalmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InstalmentDefaultArgs<ExtArgs>>): Prisma__InstalmentClient<$Result.GetResult<Prisma.$InstalmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InstalmentPayment model
   */
  interface InstalmentPaymentFieldRefs {
    readonly id: FieldRef<"InstalmentPayment", 'Int'>
    readonly instalmentId: FieldRef<"InstalmentPayment", 'Int'>
    readonly amount: FieldRef<"InstalmentPayment", 'Float'>
    readonly transactionMethod: FieldRef<"InstalmentPayment", 'String'>
    readonly paymentDate: FieldRef<"InstalmentPayment", 'DateTime'>
    readonly createdAt: FieldRef<"InstalmentPayment", 'DateTime'>
    readonly updatedAt: FieldRef<"InstalmentPayment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InstalmentPayment findUnique
   */
  export type InstalmentPaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstalmentPayment
     */
    select?: InstalmentPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstalmentPayment
     */
    omit?: InstalmentPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstalmentPaymentInclude<ExtArgs> | null
    /**
     * Filter, which InstalmentPayment to fetch.
     */
    where: InstalmentPaymentWhereUniqueInput
  }

  /**
   * InstalmentPayment findUniqueOrThrow
   */
  export type InstalmentPaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstalmentPayment
     */
    select?: InstalmentPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstalmentPayment
     */
    omit?: InstalmentPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstalmentPaymentInclude<ExtArgs> | null
    /**
     * Filter, which InstalmentPayment to fetch.
     */
    where: InstalmentPaymentWhereUniqueInput
  }

  /**
   * InstalmentPayment findFirst
   */
  export type InstalmentPaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstalmentPayment
     */
    select?: InstalmentPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstalmentPayment
     */
    omit?: InstalmentPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstalmentPaymentInclude<ExtArgs> | null
    /**
     * Filter, which InstalmentPayment to fetch.
     */
    where?: InstalmentPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstalmentPayments to fetch.
     */
    orderBy?: InstalmentPaymentOrderByWithRelationInput | InstalmentPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InstalmentPayments.
     */
    cursor?: InstalmentPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstalmentPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstalmentPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InstalmentPayments.
     */
    distinct?: InstalmentPaymentScalarFieldEnum | InstalmentPaymentScalarFieldEnum[]
  }

  /**
   * InstalmentPayment findFirstOrThrow
   */
  export type InstalmentPaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstalmentPayment
     */
    select?: InstalmentPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstalmentPayment
     */
    omit?: InstalmentPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstalmentPaymentInclude<ExtArgs> | null
    /**
     * Filter, which InstalmentPayment to fetch.
     */
    where?: InstalmentPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstalmentPayments to fetch.
     */
    orderBy?: InstalmentPaymentOrderByWithRelationInput | InstalmentPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InstalmentPayments.
     */
    cursor?: InstalmentPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstalmentPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstalmentPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InstalmentPayments.
     */
    distinct?: InstalmentPaymentScalarFieldEnum | InstalmentPaymentScalarFieldEnum[]
  }

  /**
   * InstalmentPayment findMany
   */
  export type InstalmentPaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstalmentPayment
     */
    select?: InstalmentPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstalmentPayment
     */
    omit?: InstalmentPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstalmentPaymentInclude<ExtArgs> | null
    /**
     * Filter, which InstalmentPayments to fetch.
     */
    where?: InstalmentPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InstalmentPayments to fetch.
     */
    orderBy?: InstalmentPaymentOrderByWithRelationInput | InstalmentPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InstalmentPayments.
     */
    cursor?: InstalmentPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InstalmentPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InstalmentPayments.
     */
    skip?: number
    distinct?: InstalmentPaymentScalarFieldEnum | InstalmentPaymentScalarFieldEnum[]
  }

  /**
   * InstalmentPayment create
   */
  export type InstalmentPaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstalmentPayment
     */
    select?: InstalmentPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstalmentPayment
     */
    omit?: InstalmentPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstalmentPaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a InstalmentPayment.
     */
    data: XOR<InstalmentPaymentCreateInput, InstalmentPaymentUncheckedCreateInput>
  }

  /**
   * InstalmentPayment createMany
   */
  export type InstalmentPaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InstalmentPayments.
     */
    data: InstalmentPaymentCreateManyInput | InstalmentPaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InstalmentPayment createManyAndReturn
   */
  export type InstalmentPaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstalmentPayment
     */
    select?: InstalmentPaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InstalmentPayment
     */
    omit?: InstalmentPaymentOmit<ExtArgs> | null
    /**
     * The data used to create many InstalmentPayments.
     */
    data: InstalmentPaymentCreateManyInput | InstalmentPaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstalmentPaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InstalmentPayment update
   */
  export type InstalmentPaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstalmentPayment
     */
    select?: InstalmentPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstalmentPayment
     */
    omit?: InstalmentPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstalmentPaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a InstalmentPayment.
     */
    data: XOR<InstalmentPaymentUpdateInput, InstalmentPaymentUncheckedUpdateInput>
    /**
     * Choose, which InstalmentPayment to update.
     */
    where: InstalmentPaymentWhereUniqueInput
  }

  /**
   * InstalmentPayment updateMany
   */
  export type InstalmentPaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InstalmentPayments.
     */
    data: XOR<InstalmentPaymentUpdateManyMutationInput, InstalmentPaymentUncheckedUpdateManyInput>
    /**
     * Filter which InstalmentPayments to update
     */
    where?: InstalmentPaymentWhereInput
    /**
     * Limit how many InstalmentPayments to update.
     */
    limit?: number
  }

  /**
   * InstalmentPayment updateManyAndReturn
   */
  export type InstalmentPaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstalmentPayment
     */
    select?: InstalmentPaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InstalmentPayment
     */
    omit?: InstalmentPaymentOmit<ExtArgs> | null
    /**
     * The data used to update InstalmentPayments.
     */
    data: XOR<InstalmentPaymentUpdateManyMutationInput, InstalmentPaymentUncheckedUpdateManyInput>
    /**
     * Filter which InstalmentPayments to update
     */
    where?: InstalmentPaymentWhereInput
    /**
     * Limit how many InstalmentPayments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstalmentPaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InstalmentPayment upsert
   */
  export type InstalmentPaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstalmentPayment
     */
    select?: InstalmentPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstalmentPayment
     */
    omit?: InstalmentPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstalmentPaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the InstalmentPayment to update in case it exists.
     */
    where: InstalmentPaymentWhereUniqueInput
    /**
     * In case the InstalmentPayment found by the `where` argument doesn't exist, create a new InstalmentPayment with this data.
     */
    create: XOR<InstalmentPaymentCreateInput, InstalmentPaymentUncheckedCreateInput>
    /**
     * In case the InstalmentPayment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InstalmentPaymentUpdateInput, InstalmentPaymentUncheckedUpdateInput>
  }

  /**
   * InstalmentPayment delete
   */
  export type InstalmentPaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstalmentPayment
     */
    select?: InstalmentPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstalmentPayment
     */
    omit?: InstalmentPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstalmentPaymentInclude<ExtArgs> | null
    /**
     * Filter which InstalmentPayment to delete.
     */
    where: InstalmentPaymentWhereUniqueInput
  }

  /**
   * InstalmentPayment deleteMany
   */
  export type InstalmentPaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InstalmentPayments to delete
     */
    where?: InstalmentPaymentWhereInput
    /**
     * Limit how many InstalmentPayments to delete.
     */
    limit?: number
  }

  /**
   * InstalmentPayment without action
   */
  export type InstalmentPaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InstalmentPayment
     */
    select?: InstalmentPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InstalmentPayment
     */
    omit?: InstalmentPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InstalmentPaymentInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    title: $Enums.Title | null
    firstName: string | null
    lastName: string | null
    contactNo: string | null
    role: $Enums.Role | null
    team: $Enums.Teams | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    title: $Enums.Title | null
    firstName: string | null
    lastName: string | null
    contactNo: string | null
    role: $Enums.Role | null
    team: $Enums.Teams | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    title: number
    firstName: number
    lastName: number
    contactNo: number
    role: number
    team: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    title?: true
    firstName?: true
    lastName?: true
    contactNo?: true
    role?: true
    team?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    title?: true
    firstName?: true
    lastName?: true
    contactNo?: true
    role?: true
    team?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    title?: true
    firstName?: true
    lastName?: true
    contactNo?: true
    role?: true
    team?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    email: string
    password: string
    title: $Enums.Title | null
    firstName: string
    lastName: string
    contactNo: string | null
    role: $Enums.Role
    team: $Enums.Teams | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    title?: boolean
    firstName?: boolean
    lastName?: boolean
    contactNo?: boolean
    role?: boolean
    team?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdPendingBookings?: boolean | User$createdPendingBookingsArgs<ExtArgs>
    voidedBookings?: boolean | User$voidedBookingsArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    title?: boolean
    firstName?: boolean
    lastName?: boolean
    contactNo?: boolean
    role?: boolean
    team?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    title?: boolean
    firstName?: boolean
    lastName?: boolean
    contactNo?: boolean
    role?: boolean
    team?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    title?: boolean
    firstName?: boolean
    lastName?: boolean
    contactNo?: boolean
    role?: boolean
    team?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "password" | "title" | "firstName" | "lastName" | "contactNo" | "role" | "team" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdPendingBookings?: boolean | User$createdPendingBookingsArgs<ExtArgs>
    voidedBookings?: boolean | User$voidedBookingsArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      createdPendingBookings: Prisma.$PendingBookingPayload<ExtArgs>[]
      voidedBookings: Prisma.$BookingPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      password: string
      title: $Enums.Title | null
      firstName: string
      lastName: string
      contactNo: string | null
      role: $Enums.Role
      team: $Enums.Teams | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdPendingBookings<T extends User$createdPendingBookingsArgs<ExtArgs> = {}>(args?: Subset<T, User$createdPendingBookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PendingBookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    voidedBookings<T extends User$voidedBookingsArgs<ExtArgs> = {}>(args?: Subset<T, User$voidedBookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly title: FieldRef<"User", 'Title'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly contactNo: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
    readonly team: FieldRef<"User", 'Teams'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.createdPendingBookings
   */
  export type User$createdPendingBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingBooking
     */
    select?: PendingBookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingBooking
     */
    omit?: PendingBookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingBookingInclude<ExtArgs> | null
    where?: PendingBookingWhereInput
    orderBy?: PendingBookingOrderByWithRelationInput | PendingBookingOrderByWithRelationInput[]
    cursor?: PendingBookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PendingBookingScalarFieldEnum | PendingBookingScalarFieldEnum[]
  }

  /**
   * User.voidedBookings
   */
  export type User$voidedBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model CostItem
   */

  export type AggregateCostItem = {
    _count: CostItemCountAggregateOutputType | null
    _avg: CostItemAvgAggregateOutputType | null
    _sum: CostItemSumAggregateOutputType | null
    _min: CostItemMinAggregateOutputType | null
    _max: CostItemMaxAggregateOutputType | null
  }

  export type CostItemAvgAggregateOutputType = {
    id: number | null
    bookingId: number | null
    amount: number | null
  }

  export type CostItemSumAggregateOutputType = {
    id: number | null
    bookingId: number | null
    amount: number | null
  }

  export type CostItemMinAggregateOutputType = {
    id: number | null
    bookingId: number | null
    category: string | null
    amount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CostItemMaxAggregateOutputType = {
    id: number | null
    bookingId: number | null
    category: string | null
    amount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CostItemCountAggregateOutputType = {
    id: number
    bookingId: number
    category: number
    amount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CostItemAvgAggregateInputType = {
    id?: true
    bookingId?: true
    amount?: true
  }

  export type CostItemSumAggregateInputType = {
    id?: true
    bookingId?: true
    amount?: true
  }

  export type CostItemMinAggregateInputType = {
    id?: true
    bookingId?: true
    category?: true
    amount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CostItemMaxAggregateInputType = {
    id?: true
    bookingId?: true
    category?: true
    amount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CostItemCountAggregateInputType = {
    id?: true
    bookingId?: true
    category?: true
    amount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CostItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CostItem to aggregate.
     */
    where?: CostItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CostItems to fetch.
     */
    orderBy?: CostItemOrderByWithRelationInput | CostItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CostItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CostItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CostItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CostItems
    **/
    _count?: true | CostItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CostItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CostItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CostItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CostItemMaxAggregateInputType
  }

  export type GetCostItemAggregateType<T extends CostItemAggregateArgs> = {
        [P in keyof T & keyof AggregateCostItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCostItem[P]>
      : GetScalarType<T[P], AggregateCostItem[P]>
  }




  export type CostItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CostItemWhereInput
    orderBy?: CostItemOrderByWithAggregationInput | CostItemOrderByWithAggregationInput[]
    by: CostItemScalarFieldEnum[] | CostItemScalarFieldEnum
    having?: CostItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CostItemCountAggregateInputType | true
    _avg?: CostItemAvgAggregateInputType
    _sum?: CostItemSumAggregateInputType
    _min?: CostItemMinAggregateInputType
    _max?: CostItemMaxAggregateInputType
  }

  export type CostItemGroupByOutputType = {
    id: number
    bookingId: number
    category: string
    amount: number
    createdAt: Date
    updatedAt: Date
    _count: CostItemCountAggregateOutputType | null
    _avg: CostItemAvgAggregateOutputType | null
    _sum: CostItemSumAggregateOutputType | null
    _min: CostItemMinAggregateOutputType | null
    _max: CostItemMaxAggregateOutputType | null
  }

  type GetCostItemGroupByPayload<T extends CostItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CostItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CostItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CostItemGroupByOutputType[P]>
            : GetScalarType<T[P], CostItemGroupByOutputType[P]>
        }
      >
    >


  export type CostItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    category?: boolean
    amount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    suppliers?: boolean | CostItem$suppliersArgs<ExtArgs>
    _count?: boolean | CostItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["costItem"]>

  export type CostItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    category?: boolean
    amount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["costItem"]>

  export type CostItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    category?: boolean
    amount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["costItem"]>

  export type CostItemSelectScalar = {
    id?: boolean
    bookingId?: boolean
    category?: boolean
    amount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CostItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bookingId" | "category" | "amount" | "createdAt" | "updatedAt", ExtArgs["result"]["costItem"]>
  export type CostItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    suppliers?: boolean | CostItem$suppliersArgs<ExtArgs>
    _count?: boolean | CostItemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CostItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }
  export type CostItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }

  export type $CostItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CostItem"
    objects: {
      booking: Prisma.$BookingPayload<ExtArgs>
      suppliers: Prisma.$CostItemSupplierPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      bookingId: number
      category: string
      amount: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["costItem"]>
    composites: {}
  }

  type CostItemGetPayload<S extends boolean | null | undefined | CostItemDefaultArgs> = $Result.GetResult<Prisma.$CostItemPayload, S>

  type CostItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CostItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CostItemCountAggregateInputType | true
    }

  export interface CostItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CostItem'], meta: { name: 'CostItem' } }
    /**
     * Find zero or one CostItem that matches the filter.
     * @param {CostItemFindUniqueArgs} args - Arguments to find a CostItem
     * @example
     * // Get one CostItem
     * const costItem = await prisma.costItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CostItemFindUniqueArgs>(args: SelectSubset<T, CostItemFindUniqueArgs<ExtArgs>>): Prisma__CostItemClient<$Result.GetResult<Prisma.$CostItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CostItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CostItemFindUniqueOrThrowArgs} args - Arguments to find a CostItem
     * @example
     * // Get one CostItem
     * const costItem = await prisma.costItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CostItemFindUniqueOrThrowArgs>(args: SelectSubset<T, CostItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CostItemClient<$Result.GetResult<Prisma.$CostItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CostItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostItemFindFirstArgs} args - Arguments to find a CostItem
     * @example
     * // Get one CostItem
     * const costItem = await prisma.costItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CostItemFindFirstArgs>(args?: SelectSubset<T, CostItemFindFirstArgs<ExtArgs>>): Prisma__CostItemClient<$Result.GetResult<Prisma.$CostItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CostItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostItemFindFirstOrThrowArgs} args - Arguments to find a CostItem
     * @example
     * // Get one CostItem
     * const costItem = await prisma.costItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CostItemFindFirstOrThrowArgs>(args?: SelectSubset<T, CostItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__CostItemClient<$Result.GetResult<Prisma.$CostItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CostItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CostItems
     * const costItems = await prisma.costItem.findMany()
     * 
     * // Get first 10 CostItems
     * const costItems = await prisma.costItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const costItemWithIdOnly = await prisma.costItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CostItemFindManyArgs>(args?: SelectSubset<T, CostItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CostItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CostItem.
     * @param {CostItemCreateArgs} args - Arguments to create a CostItem.
     * @example
     * // Create one CostItem
     * const CostItem = await prisma.costItem.create({
     *   data: {
     *     // ... data to create a CostItem
     *   }
     * })
     * 
     */
    create<T extends CostItemCreateArgs>(args: SelectSubset<T, CostItemCreateArgs<ExtArgs>>): Prisma__CostItemClient<$Result.GetResult<Prisma.$CostItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CostItems.
     * @param {CostItemCreateManyArgs} args - Arguments to create many CostItems.
     * @example
     * // Create many CostItems
     * const costItem = await prisma.costItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CostItemCreateManyArgs>(args?: SelectSubset<T, CostItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CostItems and returns the data saved in the database.
     * @param {CostItemCreateManyAndReturnArgs} args - Arguments to create many CostItems.
     * @example
     * // Create many CostItems
     * const costItem = await prisma.costItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CostItems and only return the `id`
     * const costItemWithIdOnly = await prisma.costItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CostItemCreateManyAndReturnArgs>(args?: SelectSubset<T, CostItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CostItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CostItem.
     * @param {CostItemDeleteArgs} args - Arguments to delete one CostItem.
     * @example
     * // Delete one CostItem
     * const CostItem = await prisma.costItem.delete({
     *   where: {
     *     // ... filter to delete one CostItem
     *   }
     * })
     * 
     */
    delete<T extends CostItemDeleteArgs>(args: SelectSubset<T, CostItemDeleteArgs<ExtArgs>>): Prisma__CostItemClient<$Result.GetResult<Prisma.$CostItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CostItem.
     * @param {CostItemUpdateArgs} args - Arguments to update one CostItem.
     * @example
     * // Update one CostItem
     * const costItem = await prisma.costItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CostItemUpdateArgs>(args: SelectSubset<T, CostItemUpdateArgs<ExtArgs>>): Prisma__CostItemClient<$Result.GetResult<Prisma.$CostItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CostItems.
     * @param {CostItemDeleteManyArgs} args - Arguments to filter CostItems to delete.
     * @example
     * // Delete a few CostItems
     * const { count } = await prisma.costItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CostItemDeleteManyArgs>(args?: SelectSubset<T, CostItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CostItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CostItems
     * const costItem = await prisma.costItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CostItemUpdateManyArgs>(args: SelectSubset<T, CostItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CostItems and returns the data updated in the database.
     * @param {CostItemUpdateManyAndReturnArgs} args - Arguments to update many CostItems.
     * @example
     * // Update many CostItems
     * const costItem = await prisma.costItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CostItems and only return the `id`
     * const costItemWithIdOnly = await prisma.costItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CostItemUpdateManyAndReturnArgs>(args: SelectSubset<T, CostItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CostItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CostItem.
     * @param {CostItemUpsertArgs} args - Arguments to update or create a CostItem.
     * @example
     * // Update or create a CostItem
     * const costItem = await prisma.costItem.upsert({
     *   create: {
     *     // ... data to create a CostItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CostItem we want to update
     *   }
     * })
     */
    upsert<T extends CostItemUpsertArgs>(args: SelectSubset<T, CostItemUpsertArgs<ExtArgs>>): Prisma__CostItemClient<$Result.GetResult<Prisma.$CostItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CostItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostItemCountArgs} args - Arguments to filter CostItems to count.
     * @example
     * // Count the number of CostItems
     * const count = await prisma.costItem.count({
     *   where: {
     *     // ... the filter for the CostItems we want to count
     *   }
     * })
    **/
    count<T extends CostItemCountArgs>(
      args?: Subset<T, CostItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CostItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CostItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CostItemAggregateArgs>(args: Subset<T, CostItemAggregateArgs>): Prisma.PrismaPromise<GetCostItemAggregateType<T>>

    /**
     * Group by CostItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CostItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CostItemGroupByArgs['orderBy'] }
        : { orderBy?: CostItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CostItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCostItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CostItem model
   */
  readonly fields: CostItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CostItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CostItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    booking<T extends BookingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BookingDefaultArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    suppliers<T extends CostItem$suppliersArgs<ExtArgs> = {}>(args?: Subset<T, CostItem$suppliersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CostItemSupplierPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CostItem model
   */
  interface CostItemFieldRefs {
    readonly id: FieldRef<"CostItem", 'Int'>
    readonly bookingId: FieldRef<"CostItem", 'Int'>
    readonly category: FieldRef<"CostItem", 'String'>
    readonly amount: FieldRef<"CostItem", 'Float'>
    readonly createdAt: FieldRef<"CostItem", 'DateTime'>
    readonly updatedAt: FieldRef<"CostItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CostItem findUnique
   */
  export type CostItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostItem
     */
    select?: CostItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostItem
     */
    omit?: CostItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostItemInclude<ExtArgs> | null
    /**
     * Filter, which CostItem to fetch.
     */
    where: CostItemWhereUniqueInput
  }

  /**
   * CostItem findUniqueOrThrow
   */
  export type CostItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostItem
     */
    select?: CostItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostItem
     */
    omit?: CostItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostItemInclude<ExtArgs> | null
    /**
     * Filter, which CostItem to fetch.
     */
    where: CostItemWhereUniqueInput
  }

  /**
   * CostItem findFirst
   */
  export type CostItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostItem
     */
    select?: CostItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostItem
     */
    omit?: CostItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostItemInclude<ExtArgs> | null
    /**
     * Filter, which CostItem to fetch.
     */
    where?: CostItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CostItems to fetch.
     */
    orderBy?: CostItemOrderByWithRelationInput | CostItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CostItems.
     */
    cursor?: CostItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CostItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CostItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CostItems.
     */
    distinct?: CostItemScalarFieldEnum | CostItemScalarFieldEnum[]
  }

  /**
   * CostItem findFirstOrThrow
   */
  export type CostItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostItem
     */
    select?: CostItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostItem
     */
    omit?: CostItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostItemInclude<ExtArgs> | null
    /**
     * Filter, which CostItem to fetch.
     */
    where?: CostItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CostItems to fetch.
     */
    orderBy?: CostItemOrderByWithRelationInput | CostItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CostItems.
     */
    cursor?: CostItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CostItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CostItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CostItems.
     */
    distinct?: CostItemScalarFieldEnum | CostItemScalarFieldEnum[]
  }

  /**
   * CostItem findMany
   */
  export type CostItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostItem
     */
    select?: CostItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostItem
     */
    omit?: CostItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostItemInclude<ExtArgs> | null
    /**
     * Filter, which CostItems to fetch.
     */
    where?: CostItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CostItems to fetch.
     */
    orderBy?: CostItemOrderByWithRelationInput | CostItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CostItems.
     */
    cursor?: CostItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CostItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CostItems.
     */
    skip?: number
    distinct?: CostItemScalarFieldEnum | CostItemScalarFieldEnum[]
  }

  /**
   * CostItem create
   */
  export type CostItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostItem
     */
    select?: CostItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostItem
     */
    omit?: CostItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostItemInclude<ExtArgs> | null
    /**
     * The data needed to create a CostItem.
     */
    data: XOR<CostItemCreateInput, CostItemUncheckedCreateInput>
  }

  /**
   * CostItem createMany
   */
  export type CostItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CostItems.
     */
    data: CostItemCreateManyInput | CostItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CostItem createManyAndReturn
   */
  export type CostItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostItem
     */
    select?: CostItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CostItem
     */
    omit?: CostItemOmit<ExtArgs> | null
    /**
     * The data used to create many CostItems.
     */
    data: CostItemCreateManyInput | CostItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CostItem update
   */
  export type CostItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostItem
     */
    select?: CostItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostItem
     */
    omit?: CostItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostItemInclude<ExtArgs> | null
    /**
     * The data needed to update a CostItem.
     */
    data: XOR<CostItemUpdateInput, CostItemUncheckedUpdateInput>
    /**
     * Choose, which CostItem to update.
     */
    where: CostItemWhereUniqueInput
  }

  /**
   * CostItem updateMany
   */
  export type CostItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CostItems.
     */
    data: XOR<CostItemUpdateManyMutationInput, CostItemUncheckedUpdateManyInput>
    /**
     * Filter which CostItems to update
     */
    where?: CostItemWhereInput
    /**
     * Limit how many CostItems to update.
     */
    limit?: number
  }

  /**
   * CostItem updateManyAndReturn
   */
  export type CostItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostItem
     */
    select?: CostItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CostItem
     */
    omit?: CostItemOmit<ExtArgs> | null
    /**
     * The data used to update CostItems.
     */
    data: XOR<CostItemUpdateManyMutationInput, CostItemUncheckedUpdateManyInput>
    /**
     * Filter which CostItems to update
     */
    where?: CostItemWhereInput
    /**
     * Limit how many CostItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CostItem upsert
   */
  export type CostItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostItem
     */
    select?: CostItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostItem
     */
    omit?: CostItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostItemInclude<ExtArgs> | null
    /**
     * The filter to search for the CostItem to update in case it exists.
     */
    where: CostItemWhereUniqueInput
    /**
     * In case the CostItem found by the `where` argument doesn't exist, create a new CostItem with this data.
     */
    create: XOR<CostItemCreateInput, CostItemUncheckedCreateInput>
    /**
     * In case the CostItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CostItemUpdateInput, CostItemUncheckedUpdateInput>
  }

  /**
   * CostItem delete
   */
  export type CostItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostItem
     */
    select?: CostItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostItem
     */
    omit?: CostItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostItemInclude<ExtArgs> | null
    /**
     * Filter which CostItem to delete.
     */
    where: CostItemWhereUniqueInput
  }

  /**
   * CostItem deleteMany
   */
  export type CostItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CostItems to delete
     */
    where?: CostItemWhereInput
    /**
     * Limit how many CostItems to delete.
     */
    limit?: number
  }

  /**
   * CostItem.suppliers
   */
  export type CostItem$suppliersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostItemSupplier
     */
    select?: CostItemSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostItemSupplier
     */
    omit?: CostItemSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostItemSupplierInclude<ExtArgs> | null
    where?: CostItemSupplierWhereInput
    orderBy?: CostItemSupplierOrderByWithRelationInput | CostItemSupplierOrderByWithRelationInput[]
    cursor?: CostItemSupplierWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CostItemSupplierScalarFieldEnum | CostItemSupplierScalarFieldEnum[]
  }

  /**
   * CostItem without action
   */
  export type CostItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostItem
     */
    select?: CostItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostItem
     */
    omit?: CostItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostItemInclude<ExtArgs> | null
  }


  /**
   * Model PendingCostItem
   */

  export type AggregatePendingCostItem = {
    _count: PendingCostItemCountAggregateOutputType | null
    _avg: PendingCostItemAvgAggregateOutputType | null
    _sum: PendingCostItemSumAggregateOutputType | null
    _min: PendingCostItemMinAggregateOutputType | null
    _max: PendingCostItemMaxAggregateOutputType | null
  }

  export type PendingCostItemAvgAggregateOutputType = {
    id: number | null
    pendingBookingId: number | null
    amount: number | null
  }

  export type PendingCostItemSumAggregateOutputType = {
    id: number | null
    pendingBookingId: number | null
    amount: number | null
  }

  export type PendingCostItemMinAggregateOutputType = {
    id: number | null
    pendingBookingId: number | null
    category: string | null
    amount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PendingCostItemMaxAggregateOutputType = {
    id: number | null
    pendingBookingId: number | null
    category: string | null
    amount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PendingCostItemCountAggregateOutputType = {
    id: number
    pendingBookingId: number
    category: number
    amount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PendingCostItemAvgAggregateInputType = {
    id?: true
    pendingBookingId?: true
    amount?: true
  }

  export type PendingCostItemSumAggregateInputType = {
    id?: true
    pendingBookingId?: true
    amount?: true
  }

  export type PendingCostItemMinAggregateInputType = {
    id?: true
    pendingBookingId?: true
    category?: true
    amount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PendingCostItemMaxAggregateInputType = {
    id?: true
    pendingBookingId?: true
    category?: true
    amount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PendingCostItemCountAggregateInputType = {
    id?: true
    pendingBookingId?: true
    category?: true
    amount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PendingCostItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PendingCostItem to aggregate.
     */
    where?: PendingCostItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PendingCostItems to fetch.
     */
    orderBy?: PendingCostItemOrderByWithRelationInput | PendingCostItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PendingCostItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PendingCostItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PendingCostItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PendingCostItems
    **/
    _count?: true | PendingCostItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PendingCostItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PendingCostItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PendingCostItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PendingCostItemMaxAggregateInputType
  }

  export type GetPendingCostItemAggregateType<T extends PendingCostItemAggregateArgs> = {
        [P in keyof T & keyof AggregatePendingCostItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePendingCostItem[P]>
      : GetScalarType<T[P], AggregatePendingCostItem[P]>
  }




  export type PendingCostItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PendingCostItemWhereInput
    orderBy?: PendingCostItemOrderByWithAggregationInput | PendingCostItemOrderByWithAggregationInput[]
    by: PendingCostItemScalarFieldEnum[] | PendingCostItemScalarFieldEnum
    having?: PendingCostItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PendingCostItemCountAggregateInputType | true
    _avg?: PendingCostItemAvgAggregateInputType
    _sum?: PendingCostItemSumAggregateInputType
    _min?: PendingCostItemMinAggregateInputType
    _max?: PendingCostItemMaxAggregateInputType
  }

  export type PendingCostItemGroupByOutputType = {
    id: number
    pendingBookingId: number
    category: string
    amount: number
    createdAt: Date
    updatedAt: Date
    _count: PendingCostItemCountAggregateOutputType | null
    _avg: PendingCostItemAvgAggregateOutputType | null
    _sum: PendingCostItemSumAggregateOutputType | null
    _min: PendingCostItemMinAggregateOutputType | null
    _max: PendingCostItemMaxAggregateOutputType | null
  }

  type GetPendingCostItemGroupByPayload<T extends PendingCostItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PendingCostItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PendingCostItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PendingCostItemGroupByOutputType[P]>
            : GetScalarType<T[P], PendingCostItemGroupByOutputType[P]>
        }
      >
    >


  export type PendingCostItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pendingBookingId?: boolean
    category?: boolean
    amount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pendingBooking?: boolean | PendingBookingDefaultArgs<ExtArgs>
    suppliers?: boolean | PendingCostItem$suppliersArgs<ExtArgs>
    _count?: boolean | PendingCostItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pendingCostItem"]>

  export type PendingCostItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pendingBookingId?: boolean
    category?: boolean
    amount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pendingBooking?: boolean | PendingBookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pendingCostItem"]>

  export type PendingCostItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pendingBookingId?: boolean
    category?: boolean
    amount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pendingBooking?: boolean | PendingBookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pendingCostItem"]>

  export type PendingCostItemSelectScalar = {
    id?: boolean
    pendingBookingId?: boolean
    category?: boolean
    amount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PendingCostItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "pendingBookingId" | "category" | "amount" | "createdAt" | "updatedAt", ExtArgs["result"]["pendingCostItem"]>
  export type PendingCostItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pendingBooking?: boolean | PendingBookingDefaultArgs<ExtArgs>
    suppliers?: boolean | PendingCostItem$suppliersArgs<ExtArgs>
    _count?: boolean | PendingCostItemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PendingCostItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pendingBooking?: boolean | PendingBookingDefaultArgs<ExtArgs>
  }
  export type PendingCostItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pendingBooking?: boolean | PendingBookingDefaultArgs<ExtArgs>
  }

  export type $PendingCostItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PendingCostItem"
    objects: {
      pendingBooking: Prisma.$PendingBookingPayload<ExtArgs>
      suppliers: Prisma.$CostItemSupplierPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      pendingBookingId: number
      category: string
      amount: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["pendingCostItem"]>
    composites: {}
  }

  type PendingCostItemGetPayload<S extends boolean | null | undefined | PendingCostItemDefaultArgs> = $Result.GetResult<Prisma.$PendingCostItemPayload, S>

  type PendingCostItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PendingCostItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PendingCostItemCountAggregateInputType | true
    }

  export interface PendingCostItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PendingCostItem'], meta: { name: 'PendingCostItem' } }
    /**
     * Find zero or one PendingCostItem that matches the filter.
     * @param {PendingCostItemFindUniqueArgs} args - Arguments to find a PendingCostItem
     * @example
     * // Get one PendingCostItem
     * const pendingCostItem = await prisma.pendingCostItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PendingCostItemFindUniqueArgs>(args: SelectSubset<T, PendingCostItemFindUniqueArgs<ExtArgs>>): Prisma__PendingCostItemClient<$Result.GetResult<Prisma.$PendingCostItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PendingCostItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PendingCostItemFindUniqueOrThrowArgs} args - Arguments to find a PendingCostItem
     * @example
     * // Get one PendingCostItem
     * const pendingCostItem = await prisma.pendingCostItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PendingCostItemFindUniqueOrThrowArgs>(args: SelectSubset<T, PendingCostItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PendingCostItemClient<$Result.GetResult<Prisma.$PendingCostItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PendingCostItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingCostItemFindFirstArgs} args - Arguments to find a PendingCostItem
     * @example
     * // Get one PendingCostItem
     * const pendingCostItem = await prisma.pendingCostItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PendingCostItemFindFirstArgs>(args?: SelectSubset<T, PendingCostItemFindFirstArgs<ExtArgs>>): Prisma__PendingCostItemClient<$Result.GetResult<Prisma.$PendingCostItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PendingCostItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingCostItemFindFirstOrThrowArgs} args - Arguments to find a PendingCostItem
     * @example
     * // Get one PendingCostItem
     * const pendingCostItem = await prisma.pendingCostItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PendingCostItemFindFirstOrThrowArgs>(args?: SelectSubset<T, PendingCostItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__PendingCostItemClient<$Result.GetResult<Prisma.$PendingCostItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PendingCostItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingCostItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PendingCostItems
     * const pendingCostItems = await prisma.pendingCostItem.findMany()
     * 
     * // Get first 10 PendingCostItems
     * const pendingCostItems = await prisma.pendingCostItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pendingCostItemWithIdOnly = await prisma.pendingCostItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PendingCostItemFindManyArgs>(args?: SelectSubset<T, PendingCostItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PendingCostItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PendingCostItem.
     * @param {PendingCostItemCreateArgs} args - Arguments to create a PendingCostItem.
     * @example
     * // Create one PendingCostItem
     * const PendingCostItem = await prisma.pendingCostItem.create({
     *   data: {
     *     // ... data to create a PendingCostItem
     *   }
     * })
     * 
     */
    create<T extends PendingCostItemCreateArgs>(args: SelectSubset<T, PendingCostItemCreateArgs<ExtArgs>>): Prisma__PendingCostItemClient<$Result.GetResult<Prisma.$PendingCostItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PendingCostItems.
     * @param {PendingCostItemCreateManyArgs} args - Arguments to create many PendingCostItems.
     * @example
     * // Create many PendingCostItems
     * const pendingCostItem = await prisma.pendingCostItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PendingCostItemCreateManyArgs>(args?: SelectSubset<T, PendingCostItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PendingCostItems and returns the data saved in the database.
     * @param {PendingCostItemCreateManyAndReturnArgs} args - Arguments to create many PendingCostItems.
     * @example
     * // Create many PendingCostItems
     * const pendingCostItem = await prisma.pendingCostItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PendingCostItems and only return the `id`
     * const pendingCostItemWithIdOnly = await prisma.pendingCostItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PendingCostItemCreateManyAndReturnArgs>(args?: SelectSubset<T, PendingCostItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PendingCostItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PendingCostItem.
     * @param {PendingCostItemDeleteArgs} args - Arguments to delete one PendingCostItem.
     * @example
     * // Delete one PendingCostItem
     * const PendingCostItem = await prisma.pendingCostItem.delete({
     *   where: {
     *     // ... filter to delete one PendingCostItem
     *   }
     * })
     * 
     */
    delete<T extends PendingCostItemDeleteArgs>(args: SelectSubset<T, PendingCostItemDeleteArgs<ExtArgs>>): Prisma__PendingCostItemClient<$Result.GetResult<Prisma.$PendingCostItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PendingCostItem.
     * @param {PendingCostItemUpdateArgs} args - Arguments to update one PendingCostItem.
     * @example
     * // Update one PendingCostItem
     * const pendingCostItem = await prisma.pendingCostItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PendingCostItemUpdateArgs>(args: SelectSubset<T, PendingCostItemUpdateArgs<ExtArgs>>): Prisma__PendingCostItemClient<$Result.GetResult<Prisma.$PendingCostItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PendingCostItems.
     * @param {PendingCostItemDeleteManyArgs} args - Arguments to filter PendingCostItems to delete.
     * @example
     * // Delete a few PendingCostItems
     * const { count } = await prisma.pendingCostItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PendingCostItemDeleteManyArgs>(args?: SelectSubset<T, PendingCostItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PendingCostItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingCostItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PendingCostItems
     * const pendingCostItem = await prisma.pendingCostItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PendingCostItemUpdateManyArgs>(args: SelectSubset<T, PendingCostItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PendingCostItems and returns the data updated in the database.
     * @param {PendingCostItemUpdateManyAndReturnArgs} args - Arguments to update many PendingCostItems.
     * @example
     * // Update many PendingCostItems
     * const pendingCostItem = await prisma.pendingCostItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PendingCostItems and only return the `id`
     * const pendingCostItemWithIdOnly = await prisma.pendingCostItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PendingCostItemUpdateManyAndReturnArgs>(args: SelectSubset<T, PendingCostItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PendingCostItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PendingCostItem.
     * @param {PendingCostItemUpsertArgs} args - Arguments to update or create a PendingCostItem.
     * @example
     * // Update or create a PendingCostItem
     * const pendingCostItem = await prisma.pendingCostItem.upsert({
     *   create: {
     *     // ... data to create a PendingCostItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PendingCostItem we want to update
     *   }
     * })
     */
    upsert<T extends PendingCostItemUpsertArgs>(args: SelectSubset<T, PendingCostItemUpsertArgs<ExtArgs>>): Prisma__PendingCostItemClient<$Result.GetResult<Prisma.$PendingCostItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PendingCostItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingCostItemCountArgs} args - Arguments to filter PendingCostItems to count.
     * @example
     * // Count the number of PendingCostItems
     * const count = await prisma.pendingCostItem.count({
     *   where: {
     *     // ... the filter for the PendingCostItems we want to count
     *   }
     * })
    **/
    count<T extends PendingCostItemCountArgs>(
      args?: Subset<T, PendingCostItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PendingCostItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PendingCostItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingCostItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PendingCostItemAggregateArgs>(args: Subset<T, PendingCostItemAggregateArgs>): Prisma.PrismaPromise<GetPendingCostItemAggregateType<T>>

    /**
     * Group by PendingCostItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingCostItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PendingCostItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PendingCostItemGroupByArgs['orderBy'] }
        : { orderBy?: PendingCostItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PendingCostItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPendingCostItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PendingCostItem model
   */
  readonly fields: PendingCostItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PendingCostItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PendingCostItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pendingBooking<T extends PendingBookingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PendingBookingDefaultArgs<ExtArgs>>): Prisma__PendingBookingClient<$Result.GetResult<Prisma.$PendingBookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    suppliers<T extends PendingCostItem$suppliersArgs<ExtArgs> = {}>(args?: Subset<T, PendingCostItem$suppliersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CostItemSupplierPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PendingCostItem model
   */
  interface PendingCostItemFieldRefs {
    readonly id: FieldRef<"PendingCostItem", 'Int'>
    readonly pendingBookingId: FieldRef<"PendingCostItem", 'Int'>
    readonly category: FieldRef<"PendingCostItem", 'String'>
    readonly amount: FieldRef<"PendingCostItem", 'Float'>
    readonly createdAt: FieldRef<"PendingCostItem", 'DateTime'>
    readonly updatedAt: FieldRef<"PendingCostItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PendingCostItem findUnique
   */
  export type PendingCostItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingCostItem
     */
    select?: PendingCostItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingCostItem
     */
    omit?: PendingCostItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingCostItemInclude<ExtArgs> | null
    /**
     * Filter, which PendingCostItem to fetch.
     */
    where: PendingCostItemWhereUniqueInput
  }

  /**
   * PendingCostItem findUniqueOrThrow
   */
  export type PendingCostItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingCostItem
     */
    select?: PendingCostItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingCostItem
     */
    omit?: PendingCostItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingCostItemInclude<ExtArgs> | null
    /**
     * Filter, which PendingCostItem to fetch.
     */
    where: PendingCostItemWhereUniqueInput
  }

  /**
   * PendingCostItem findFirst
   */
  export type PendingCostItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingCostItem
     */
    select?: PendingCostItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingCostItem
     */
    omit?: PendingCostItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingCostItemInclude<ExtArgs> | null
    /**
     * Filter, which PendingCostItem to fetch.
     */
    where?: PendingCostItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PendingCostItems to fetch.
     */
    orderBy?: PendingCostItemOrderByWithRelationInput | PendingCostItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PendingCostItems.
     */
    cursor?: PendingCostItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PendingCostItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PendingCostItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PendingCostItems.
     */
    distinct?: PendingCostItemScalarFieldEnum | PendingCostItemScalarFieldEnum[]
  }

  /**
   * PendingCostItem findFirstOrThrow
   */
  export type PendingCostItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingCostItem
     */
    select?: PendingCostItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingCostItem
     */
    omit?: PendingCostItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingCostItemInclude<ExtArgs> | null
    /**
     * Filter, which PendingCostItem to fetch.
     */
    where?: PendingCostItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PendingCostItems to fetch.
     */
    orderBy?: PendingCostItemOrderByWithRelationInput | PendingCostItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PendingCostItems.
     */
    cursor?: PendingCostItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PendingCostItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PendingCostItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PendingCostItems.
     */
    distinct?: PendingCostItemScalarFieldEnum | PendingCostItemScalarFieldEnum[]
  }

  /**
   * PendingCostItem findMany
   */
  export type PendingCostItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingCostItem
     */
    select?: PendingCostItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingCostItem
     */
    omit?: PendingCostItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingCostItemInclude<ExtArgs> | null
    /**
     * Filter, which PendingCostItems to fetch.
     */
    where?: PendingCostItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PendingCostItems to fetch.
     */
    orderBy?: PendingCostItemOrderByWithRelationInput | PendingCostItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PendingCostItems.
     */
    cursor?: PendingCostItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PendingCostItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PendingCostItems.
     */
    skip?: number
    distinct?: PendingCostItemScalarFieldEnum | PendingCostItemScalarFieldEnum[]
  }

  /**
   * PendingCostItem create
   */
  export type PendingCostItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingCostItem
     */
    select?: PendingCostItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingCostItem
     */
    omit?: PendingCostItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingCostItemInclude<ExtArgs> | null
    /**
     * The data needed to create a PendingCostItem.
     */
    data: XOR<PendingCostItemCreateInput, PendingCostItemUncheckedCreateInput>
  }

  /**
   * PendingCostItem createMany
   */
  export type PendingCostItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PendingCostItems.
     */
    data: PendingCostItemCreateManyInput | PendingCostItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PendingCostItem createManyAndReturn
   */
  export type PendingCostItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingCostItem
     */
    select?: PendingCostItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PendingCostItem
     */
    omit?: PendingCostItemOmit<ExtArgs> | null
    /**
     * The data used to create many PendingCostItems.
     */
    data: PendingCostItemCreateManyInput | PendingCostItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingCostItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PendingCostItem update
   */
  export type PendingCostItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingCostItem
     */
    select?: PendingCostItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingCostItem
     */
    omit?: PendingCostItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingCostItemInclude<ExtArgs> | null
    /**
     * The data needed to update a PendingCostItem.
     */
    data: XOR<PendingCostItemUpdateInput, PendingCostItemUncheckedUpdateInput>
    /**
     * Choose, which PendingCostItem to update.
     */
    where: PendingCostItemWhereUniqueInput
  }

  /**
   * PendingCostItem updateMany
   */
  export type PendingCostItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PendingCostItems.
     */
    data: XOR<PendingCostItemUpdateManyMutationInput, PendingCostItemUncheckedUpdateManyInput>
    /**
     * Filter which PendingCostItems to update
     */
    where?: PendingCostItemWhereInput
    /**
     * Limit how many PendingCostItems to update.
     */
    limit?: number
  }

  /**
   * PendingCostItem updateManyAndReturn
   */
  export type PendingCostItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingCostItem
     */
    select?: PendingCostItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PendingCostItem
     */
    omit?: PendingCostItemOmit<ExtArgs> | null
    /**
     * The data used to update PendingCostItems.
     */
    data: XOR<PendingCostItemUpdateManyMutationInput, PendingCostItemUncheckedUpdateManyInput>
    /**
     * Filter which PendingCostItems to update
     */
    where?: PendingCostItemWhereInput
    /**
     * Limit how many PendingCostItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingCostItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PendingCostItem upsert
   */
  export type PendingCostItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingCostItem
     */
    select?: PendingCostItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingCostItem
     */
    omit?: PendingCostItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingCostItemInclude<ExtArgs> | null
    /**
     * The filter to search for the PendingCostItem to update in case it exists.
     */
    where: PendingCostItemWhereUniqueInput
    /**
     * In case the PendingCostItem found by the `where` argument doesn't exist, create a new PendingCostItem with this data.
     */
    create: XOR<PendingCostItemCreateInput, PendingCostItemUncheckedCreateInput>
    /**
     * In case the PendingCostItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PendingCostItemUpdateInput, PendingCostItemUncheckedUpdateInput>
  }

  /**
   * PendingCostItem delete
   */
  export type PendingCostItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingCostItem
     */
    select?: PendingCostItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingCostItem
     */
    omit?: PendingCostItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingCostItemInclude<ExtArgs> | null
    /**
     * Filter which PendingCostItem to delete.
     */
    where: PendingCostItemWhereUniqueInput
  }

  /**
   * PendingCostItem deleteMany
   */
  export type PendingCostItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PendingCostItems to delete
     */
    where?: PendingCostItemWhereInput
    /**
     * Limit how many PendingCostItems to delete.
     */
    limit?: number
  }

  /**
   * PendingCostItem.suppliers
   */
  export type PendingCostItem$suppliersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostItemSupplier
     */
    select?: CostItemSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostItemSupplier
     */
    omit?: CostItemSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostItemSupplierInclude<ExtArgs> | null
    where?: CostItemSupplierWhereInput
    orderBy?: CostItemSupplierOrderByWithRelationInput | CostItemSupplierOrderByWithRelationInput[]
    cursor?: CostItemSupplierWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CostItemSupplierScalarFieldEnum | CostItemSupplierScalarFieldEnum[]
  }

  /**
   * PendingCostItem without action
   */
  export type PendingCostItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingCostItem
     */
    select?: PendingCostItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingCostItem
     */
    omit?: PendingCostItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingCostItemInclude<ExtArgs> | null
  }


  /**
   * Model Passenger
   */

  export type AggregatePassenger = {
    _count: PassengerCountAggregateOutputType | null
    _avg: PassengerAvgAggregateOutputType | null
    _sum: PassengerSumAggregateOutputType | null
    _min: PassengerMinAggregateOutputType | null
    _max: PassengerMaxAggregateOutputType | null
  }

  export type PassengerAvgAggregateOutputType = {
    id: number | null
    bookingId: number | null
  }

  export type PassengerSumAggregateOutputType = {
    id: number | null
    bookingId: number | null
  }

  export type PassengerMinAggregateOutputType = {
    id: number | null
    bookingId: number | null
    title: $Enums.Title | null
    firstName: string | null
    middleName: string | null
    lastName: string | null
    gender: $Enums.Gender | null
    email: string | null
    contactNo: string | null
    nationality: string | null
    birthday: Date | null
    category: $Enums.PassengerCategory | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PassengerMaxAggregateOutputType = {
    id: number | null
    bookingId: number | null
    title: $Enums.Title | null
    firstName: string | null
    middleName: string | null
    lastName: string | null
    gender: $Enums.Gender | null
    email: string | null
    contactNo: string | null
    nationality: string | null
    birthday: Date | null
    category: $Enums.PassengerCategory | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PassengerCountAggregateOutputType = {
    id: number
    bookingId: number
    title: number
    firstName: number
    middleName: number
    lastName: number
    gender: number
    email: number
    contactNo: number
    nationality: number
    birthday: number
    category: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PassengerAvgAggregateInputType = {
    id?: true
    bookingId?: true
  }

  export type PassengerSumAggregateInputType = {
    id?: true
    bookingId?: true
  }

  export type PassengerMinAggregateInputType = {
    id?: true
    bookingId?: true
    title?: true
    firstName?: true
    middleName?: true
    lastName?: true
    gender?: true
    email?: true
    contactNo?: true
    nationality?: true
    birthday?: true
    category?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PassengerMaxAggregateInputType = {
    id?: true
    bookingId?: true
    title?: true
    firstName?: true
    middleName?: true
    lastName?: true
    gender?: true
    email?: true
    contactNo?: true
    nationality?: true
    birthday?: true
    category?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PassengerCountAggregateInputType = {
    id?: true
    bookingId?: true
    title?: true
    firstName?: true
    middleName?: true
    lastName?: true
    gender?: true
    email?: true
    contactNo?: true
    nationality?: true
    birthday?: true
    category?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PassengerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Passenger to aggregate.
     */
    where?: PassengerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Passengers to fetch.
     */
    orderBy?: PassengerOrderByWithRelationInput | PassengerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PassengerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Passengers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Passengers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Passengers
    **/
    _count?: true | PassengerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PassengerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PassengerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PassengerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PassengerMaxAggregateInputType
  }

  export type GetPassengerAggregateType<T extends PassengerAggregateArgs> = {
        [P in keyof T & keyof AggregatePassenger]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePassenger[P]>
      : GetScalarType<T[P], AggregatePassenger[P]>
  }




  export type PassengerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PassengerWhereInput
    orderBy?: PassengerOrderByWithAggregationInput | PassengerOrderByWithAggregationInput[]
    by: PassengerScalarFieldEnum[] | PassengerScalarFieldEnum
    having?: PassengerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PassengerCountAggregateInputType | true
    _avg?: PassengerAvgAggregateInputType
    _sum?: PassengerSumAggregateInputType
    _min?: PassengerMinAggregateInputType
    _max?: PassengerMaxAggregateInputType
  }

  export type PassengerGroupByOutputType = {
    id: number
    bookingId: number
    title: $Enums.Title
    firstName: string
    middleName: string | null
    lastName: string
    gender: $Enums.Gender
    email: string | null
    contactNo: string | null
    nationality: string | null
    birthday: Date | null
    category: $Enums.PassengerCategory
    createdAt: Date
    updatedAt: Date
    _count: PassengerCountAggregateOutputType | null
    _avg: PassengerAvgAggregateOutputType | null
    _sum: PassengerSumAggregateOutputType | null
    _min: PassengerMinAggregateOutputType | null
    _max: PassengerMaxAggregateOutputType | null
  }

  type GetPassengerGroupByPayload<T extends PassengerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PassengerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PassengerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PassengerGroupByOutputType[P]>
            : GetScalarType<T[P], PassengerGroupByOutputType[P]>
        }
      >
    >


  export type PassengerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    title?: boolean
    firstName?: boolean
    middleName?: boolean
    lastName?: boolean
    gender?: boolean
    email?: boolean
    contactNo?: boolean
    nationality?: boolean
    birthday?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passenger"]>

  export type PassengerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    title?: boolean
    firstName?: boolean
    middleName?: boolean
    lastName?: boolean
    gender?: boolean
    email?: boolean
    contactNo?: boolean
    nationality?: boolean
    birthday?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passenger"]>

  export type PassengerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    title?: boolean
    firstName?: boolean
    middleName?: boolean
    lastName?: boolean
    gender?: boolean
    email?: boolean
    contactNo?: boolean
    nationality?: boolean
    birthday?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passenger"]>

  export type PassengerSelectScalar = {
    id?: boolean
    bookingId?: boolean
    title?: boolean
    firstName?: boolean
    middleName?: boolean
    lastName?: boolean
    gender?: boolean
    email?: boolean
    contactNo?: boolean
    nationality?: boolean
    birthday?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PassengerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bookingId" | "title" | "firstName" | "middleName" | "lastName" | "gender" | "email" | "contactNo" | "nationality" | "birthday" | "category" | "createdAt" | "updatedAt", ExtArgs["result"]["passenger"]>
  export type PassengerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }
  export type PassengerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }
  export type PassengerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }

  export type $PassengerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Passenger"
    objects: {
      booking: Prisma.$BookingPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      bookingId: number
      title: $Enums.Title
      firstName: string
      middleName: string | null
      lastName: string
      gender: $Enums.Gender
      email: string | null
      contactNo: string | null
      nationality: string | null
      birthday: Date | null
      category: $Enums.PassengerCategory
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["passenger"]>
    composites: {}
  }

  type PassengerGetPayload<S extends boolean | null | undefined | PassengerDefaultArgs> = $Result.GetResult<Prisma.$PassengerPayload, S>

  type PassengerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PassengerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PassengerCountAggregateInputType | true
    }

  export interface PassengerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Passenger'], meta: { name: 'Passenger' } }
    /**
     * Find zero or one Passenger that matches the filter.
     * @param {PassengerFindUniqueArgs} args - Arguments to find a Passenger
     * @example
     * // Get one Passenger
     * const passenger = await prisma.passenger.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PassengerFindUniqueArgs>(args: SelectSubset<T, PassengerFindUniqueArgs<ExtArgs>>): Prisma__PassengerClient<$Result.GetResult<Prisma.$PassengerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Passenger that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PassengerFindUniqueOrThrowArgs} args - Arguments to find a Passenger
     * @example
     * // Get one Passenger
     * const passenger = await prisma.passenger.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PassengerFindUniqueOrThrowArgs>(args: SelectSubset<T, PassengerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PassengerClient<$Result.GetResult<Prisma.$PassengerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Passenger that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PassengerFindFirstArgs} args - Arguments to find a Passenger
     * @example
     * // Get one Passenger
     * const passenger = await prisma.passenger.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PassengerFindFirstArgs>(args?: SelectSubset<T, PassengerFindFirstArgs<ExtArgs>>): Prisma__PassengerClient<$Result.GetResult<Prisma.$PassengerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Passenger that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PassengerFindFirstOrThrowArgs} args - Arguments to find a Passenger
     * @example
     * // Get one Passenger
     * const passenger = await prisma.passenger.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PassengerFindFirstOrThrowArgs>(args?: SelectSubset<T, PassengerFindFirstOrThrowArgs<ExtArgs>>): Prisma__PassengerClient<$Result.GetResult<Prisma.$PassengerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Passengers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PassengerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Passengers
     * const passengers = await prisma.passenger.findMany()
     * 
     * // Get first 10 Passengers
     * const passengers = await prisma.passenger.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const passengerWithIdOnly = await prisma.passenger.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PassengerFindManyArgs>(args?: SelectSubset<T, PassengerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PassengerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Passenger.
     * @param {PassengerCreateArgs} args - Arguments to create a Passenger.
     * @example
     * // Create one Passenger
     * const Passenger = await prisma.passenger.create({
     *   data: {
     *     // ... data to create a Passenger
     *   }
     * })
     * 
     */
    create<T extends PassengerCreateArgs>(args: SelectSubset<T, PassengerCreateArgs<ExtArgs>>): Prisma__PassengerClient<$Result.GetResult<Prisma.$PassengerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Passengers.
     * @param {PassengerCreateManyArgs} args - Arguments to create many Passengers.
     * @example
     * // Create many Passengers
     * const passenger = await prisma.passenger.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PassengerCreateManyArgs>(args?: SelectSubset<T, PassengerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Passengers and returns the data saved in the database.
     * @param {PassengerCreateManyAndReturnArgs} args - Arguments to create many Passengers.
     * @example
     * // Create many Passengers
     * const passenger = await prisma.passenger.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Passengers and only return the `id`
     * const passengerWithIdOnly = await prisma.passenger.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PassengerCreateManyAndReturnArgs>(args?: SelectSubset<T, PassengerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PassengerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Passenger.
     * @param {PassengerDeleteArgs} args - Arguments to delete one Passenger.
     * @example
     * // Delete one Passenger
     * const Passenger = await prisma.passenger.delete({
     *   where: {
     *     // ... filter to delete one Passenger
     *   }
     * })
     * 
     */
    delete<T extends PassengerDeleteArgs>(args: SelectSubset<T, PassengerDeleteArgs<ExtArgs>>): Prisma__PassengerClient<$Result.GetResult<Prisma.$PassengerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Passenger.
     * @param {PassengerUpdateArgs} args - Arguments to update one Passenger.
     * @example
     * // Update one Passenger
     * const passenger = await prisma.passenger.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PassengerUpdateArgs>(args: SelectSubset<T, PassengerUpdateArgs<ExtArgs>>): Prisma__PassengerClient<$Result.GetResult<Prisma.$PassengerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Passengers.
     * @param {PassengerDeleteManyArgs} args - Arguments to filter Passengers to delete.
     * @example
     * // Delete a few Passengers
     * const { count } = await prisma.passenger.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PassengerDeleteManyArgs>(args?: SelectSubset<T, PassengerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Passengers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PassengerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Passengers
     * const passenger = await prisma.passenger.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PassengerUpdateManyArgs>(args: SelectSubset<T, PassengerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Passengers and returns the data updated in the database.
     * @param {PassengerUpdateManyAndReturnArgs} args - Arguments to update many Passengers.
     * @example
     * // Update many Passengers
     * const passenger = await prisma.passenger.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Passengers and only return the `id`
     * const passengerWithIdOnly = await prisma.passenger.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PassengerUpdateManyAndReturnArgs>(args: SelectSubset<T, PassengerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PassengerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Passenger.
     * @param {PassengerUpsertArgs} args - Arguments to update or create a Passenger.
     * @example
     * // Update or create a Passenger
     * const passenger = await prisma.passenger.upsert({
     *   create: {
     *     // ... data to create a Passenger
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Passenger we want to update
     *   }
     * })
     */
    upsert<T extends PassengerUpsertArgs>(args: SelectSubset<T, PassengerUpsertArgs<ExtArgs>>): Prisma__PassengerClient<$Result.GetResult<Prisma.$PassengerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Passengers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PassengerCountArgs} args - Arguments to filter Passengers to count.
     * @example
     * // Count the number of Passengers
     * const count = await prisma.passenger.count({
     *   where: {
     *     // ... the filter for the Passengers we want to count
     *   }
     * })
    **/
    count<T extends PassengerCountArgs>(
      args?: Subset<T, PassengerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PassengerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Passenger.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PassengerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PassengerAggregateArgs>(args: Subset<T, PassengerAggregateArgs>): Prisma.PrismaPromise<GetPassengerAggregateType<T>>

    /**
     * Group by Passenger.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PassengerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PassengerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PassengerGroupByArgs['orderBy'] }
        : { orderBy?: PassengerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PassengerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPassengerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Passenger model
   */
  readonly fields: PassengerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Passenger.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PassengerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    booking<T extends BookingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BookingDefaultArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Passenger model
   */
  interface PassengerFieldRefs {
    readonly id: FieldRef<"Passenger", 'Int'>
    readonly bookingId: FieldRef<"Passenger", 'Int'>
    readonly title: FieldRef<"Passenger", 'Title'>
    readonly firstName: FieldRef<"Passenger", 'String'>
    readonly middleName: FieldRef<"Passenger", 'String'>
    readonly lastName: FieldRef<"Passenger", 'String'>
    readonly gender: FieldRef<"Passenger", 'Gender'>
    readonly email: FieldRef<"Passenger", 'String'>
    readonly contactNo: FieldRef<"Passenger", 'String'>
    readonly nationality: FieldRef<"Passenger", 'String'>
    readonly birthday: FieldRef<"Passenger", 'DateTime'>
    readonly category: FieldRef<"Passenger", 'PassengerCategory'>
    readonly createdAt: FieldRef<"Passenger", 'DateTime'>
    readonly updatedAt: FieldRef<"Passenger", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Passenger findUnique
   */
  export type PassengerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passenger
     */
    select?: PassengerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Passenger
     */
    omit?: PassengerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PassengerInclude<ExtArgs> | null
    /**
     * Filter, which Passenger to fetch.
     */
    where: PassengerWhereUniqueInput
  }

  /**
   * Passenger findUniqueOrThrow
   */
  export type PassengerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passenger
     */
    select?: PassengerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Passenger
     */
    omit?: PassengerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PassengerInclude<ExtArgs> | null
    /**
     * Filter, which Passenger to fetch.
     */
    where: PassengerWhereUniqueInput
  }

  /**
   * Passenger findFirst
   */
  export type PassengerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passenger
     */
    select?: PassengerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Passenger
     */
    omit?: PassengerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PassengerInclude<ExtArgs> | null
    /**
     * Filter, which Passenger to fetch.
     */
    where?: PassengerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Passengers to fetch.
     */
    orderBy?: PassengerOrderByWithRelationInput | PassengerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Passengers.
     */
    cursor?: PassengerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Passengers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Passengers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Passengers.
     */
    distinct?: PassengerScalarFieldEnum | PassengerScalarFieldEnum[]
  }

  /**
   * Passenger findFirstOrThrow
   */
  export type PassengerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passenger
     */
    select?: PassengerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Passenger
     */
    omit?: PassengerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PassengerInclude<ExtArgs> | null
    /**
     * Filter, which Passenger to fetch.
     */
    where?: PassengerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Passengers to fetch.
     */
    orderBy?: PassengerOrderByWithRelationInput | PassengerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Passengers.
     */
    cursor?: PassengerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Passengers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Passengers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Passengers.
     */
    distinct?: PassengerScalarFieldEnum | PassengerScalarFieldEnum[]
  }

  /**
   * Passenger findMany
   */
  export type PassengerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passenger
     */
    select?: PassengerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Passenger
     */
    omit?: PassengerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PassengerInclude<ExtArgs> | null
    /**
     * Filter, which Passengers to fetch.
     */
    where?: PassengerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Passengers to fetch.
     */
    orderBy?: PassengerOrderByWithRelationInput | PassengerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Passengers.
     */
    cursor?: PassengerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Passengers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Passengers.
     */
    skip?: number
    distinct?: PassengerScalarFieldEnum | PassengerScalarFieldEnum[]
  }

  /**
   * Passenger create
   */
  export type PassengerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passenger
     */
    select?: PassengerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Passenger
     */
    omit?: PassengerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PassengerInclude<ExtArgs> | null
    /**
     * The data needed to create a Passenger.
     */
    data: XOR<PassengerCreateInput, PassengerUncheckedCreateInput>
  }

  /**
   * Passenger createMany
   */
  export type PassengerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Passengers.
     */
    data: PassengerCreateManyInput | PassengerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Passenger createManyAndReturn
   */
  export type PassengerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passenger
     */
    select?: PassengerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Passenger
     */
    omit?: PassengerOmit<ExtArgs> | null
    /**
     * The data used to create many Passengers.
     */
    data: PassengerCreateManyInput | PassengerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PassengerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Passenger update
   */
  export type PassengerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passenger
     */
    select?: PassengerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Passenger
     */
    omit?: PassengerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PassengerInclude<ExtArgs> | null
    /**
     * The data needed to update a Passenger.
     */
    data: XOR<PassengerUpdateInput, PassengerUncheckedUpdateInput>
    /**
     * Choose, which Passenger to update.
     */
    where: PassengerWhereUniqueInput
  }

  /**
   * Passenger updateMany
   */
  export type PassengerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Passengers.
     */
    data: XOR<PassengerUpdateManyMutationInput, PassengerUncheckedUpdateManyInput>
    /**
     * Filter which Passengers to update
     */
    where?: PassengerWhereInput
    /**
     * Limit how many Passengers to update.
     */
    limit?: number
  }

  /**
   * Passenger updateManyAndReturn
   */
  export type PassengerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passenger
     */
    select?: PassengerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Passenger
     */
    omit?: PassengerOmit<ExtArgs> | null
    /**
     * The data used to update Passengers.
     */
    data: XOR<PassengerUpdateManyMutationInput, PassengerUncheckedUpdateManyInput>
    /**
     * Filter which Passengers to update
     */
    where?: PassengerWhereInput
    /**
     * Limit how many Passengers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PassengerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Passenger upsert
   */
  export type PassengerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passenger
     */
    select?: PassengerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Passenger
     */
    omit?: PassengerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PassengerInclude<ExtArgs> | null
    /**
     * The filter to search for the Passenger to update in case it exists.
     */
    where: PassengerWhereUniqueInput
    /**
     * In case the Passenger found by the `where` argument doesn't exist, create a new Passenger with this data.
     */
    create: XOR<PassengerCreateInput, PassengerUncheckedCreateInput>
    /**
     * In case the Passenger was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PassengerUpdateInput, PassengerUncheckedUpdateInput>
  }

  /**
   * Passenger delete
   */
  export type PassengerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passenger
     */
    select?: PassengerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Passenger
     */
    omit?: PassengerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PassengerInclude<ExtArgs> | null
    /**
     * Filter which Passenger to delete.
     */
    where: PassengerWhereUniqueInput
  }

  /**
   * Passenger deleteMany
   */
  export type PassengerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Passengers to delete
     */
    where?: PassengerWhereInput
    /**
     * Limit how many Passengers to delete.
     */
    limit?: number
  }

  /**
   * Passenger without action
   */
  export type PassengerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Passenger
     */
    select?: PassengerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Passenger
     */
    omit?: PassengerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PassengerInclude<ExtArgs> | null
  }


  /**
   * Model PendingPassenger
   */

  export type AggregatePendingPassenger = {
    _count: PendingPassengerCountAggregateOutputType | null
    _avg: PendingPassengerAvgAggregateOutputType | null
    _sum: PendingPassengerSumAggregateOutputType | null
    _min: PendingPassengerMinAggregateOutputType | null
    _max: PendingPassengerMaxAggregateOutputType | null
  }

  export type PendingPassengerAvgAggregateOutputType = {
    id: number | null
    pendingBookingId: number | null
  }

  export type PendingPassengerSumAggregateOutputType = {
    id: number | null
    pendingBookingId: number | null
  }

  export type PendingPassengerMinAggregateOutputType = {
    id: number | null
    pendingBookingId: number | null
    title: $Enums.Title | null
    firstName: string | null
    middleName: string | null
    lastName: string | null
    gender: $Enums.Gender | null
    email: string | null
    contactNo: string | null
    nationality: string | null
    birthday: Date | null
    category: $Enums.PassengerCategory | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PendingPassengerMaxAggregateOutputType = {
    id: number | null
    pendingBookingId: number | null
    title: $Enums.Title | null
    firstName: string | null
    middleName: string | null
    lastName: string | null
    gender: $Enums.Gender | null
    email: string | null
    contactNo: string | null
    nationality: string | null
    birthday: Date | null
    category: $Enums.PassengerCategory | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PendingPassengerCountAggregateOutputType = {
    id: number
    pendingBookingId: number
    title: number
    firstName: number
    middleName: number
    lastName: number
    gender: number
    email: number
    contactNo: number
    nationality: number
    birthday: number
    category: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PendingPassengerAvgAggregateInputType = {
    id?: true
    pendingBookingId?: true
  }

  export type PendingPassengerSumAggregateInputType = {
    id?: true
    pendingBookingId?: true
  }

  export type PendingPassengerMinAggregateInputType = {
    id?: true
    pendingBookingId?: true
    title?: true
    firstName?: true
    middleName?: true
    lastName?: true
    gender?: true
    email?: true
    contactNo?: true
    nationality?: true
    birthday?: true
    category?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PendingPassengerMaxAggregateInputType = {
    id?: true
    pendingBookingId?: true
    title?: true
    firstName?: true
    middleName?: true
    lastName?: true
    gender?: true
    email?: true
    contactNo?: true
    nationality?: true
    birthday?: true
    category?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PendingPassengerCountAggregateInputType = {
    id?: true
    pendingBookingId?: true
    title?: true
    firstName?: true
    middleName?: true
    lastName?: true
    gender?: true
    email?: true
    contactNo?: true
    nationality?: true
    birthday?: true
    category?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PendingPassengerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PendingPassenger to aggregate.
     */
    where?: PendingPassengerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PendingPassengers to fetch.
     */
    orderBy?: PendingPassengerOrderByWithRelationInput | PendingPassengerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PendingPassengerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PendingPassengers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PendingPassengers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PendingPassengers
    **/
    _count?: true | PendingPassengerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PendingPassengerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PendingPassengerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PendingPassengerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PendingPassengerMaxAggregateInputType
  }

  export type GetPendingPassengerAggregateType<T extends PendingPassengerAggregateArgs> = {
        [P in keyof T & keyof AggregatePendingPassenger]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePendingPassenger[P]>
      : GetScalarType<T[P], AggregatePendingPassenger[P]>
  }




  export type PendingPassengerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PendingPassengerWhereInput
    orderBy?: PendingPassengerOrderByWithAggregationInput | PendingPassengerOrderByWithAggregationInput[]
    by: PendingPassengerScalarFieldEnum[] | PendingPassengerScalarFieldEnum
    having?: PendingPassengerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PendingPassengerCountAggregateInputType | true
    _avg?: PendingPassengerAvgAggregateInputType
    _sum?: PendingPassengerSumAggregateInputType
    _min?: PendingPassengerMinAggregateInputType
    _max?: PendingPassengerMaxAggregateInputType
  }

  export type PendingPassengerGroupByOutputType = {
    id: number
    pendingBookingId: number
    title: $Enums.Title
    firstName: string
    middleName: string | null
    lastName: string
    gender: $Enums.Gender
    email: string | null
    contactNo: string | null
    nationality: string | null
    birthday: Date | null
    category: $Enums.PassengerCategory
    createdAt: Date
    updatedAt: Date
    _count: PendingPassengerCountAggregateOutputType | null
    _avg: PendingPassengerAvgAggregateOutputType | null
    _sum: PendingPassengerSumAggregateOutputType | null
    _min: PendingPassengerMinAggregateOutputType | null
    _max: PendingPassengerMaxAggregateOutputType | null
  }

  type GetPendingPassengerGroupByPayload<T extends PendingPassengerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PendingPassengerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PendingPassengerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PendingPassengerGroupByOutputType[P]>
            : GetScalarType<T[P], PendingPassengerGroupByOutputType[P]>
        }
      >
    >


  export type PendingPassengerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pendingBookingId?: boolean
    title?: boolean
    firstName?: boolean
    middleName?: boolean
    lastName?: boolean
    gender?: boolean
    email?: boolean
    contactNo?: boolean
    nationality?: boolean
    birthday?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pendingBooking?: boolean | PendingBookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pendingPassenger"]>

  export type PendingPassengerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pendingBookingId?: boolean
    title?: boolean
    firstName?: boolean
    middleName?: boolean
    lastName?: boolean
    gender?: boolean
    email?: boolean
    contactNo?: boolean
    nationality?: boolean
    birthday?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pendingBooking?: boolean | PendingBookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pendingPassenger"]>

  export type PendingPassengerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pendingBookingId?: boolean
    title?: boolean
    firstName?: boolean
    middleName?: boolean
    lastName?: boolean
    gender?: boolean
    email?: boolean
    contactNo?: boolean
    nationality?: boolean
    birthday?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pendingBooking?: boolean | PendingBookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pendingPassenger"]>

  export type PendingPassengerSelectScalar = {
    id?: boolean
    pendingBookingId?: boolean
    title?: boolean
    firstName?: boolean
    middleName?: boolean
    lastName?: boolean
    gender?: boolean
    email?: boolean
    contactNo?: boolean
    nationality?: boolean
    birthday?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PendingPassengerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "pendingBookingId" | "title" | "firstName" | "middleName" | "lastName" | "gender" | "email" | "contactNo" | "nationality" | "birthday" | "category" | "createdAt" | "updatedAt", ExtArgs["result"]["pendingPassenger"]>
  export type PendingPassengerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pendingBooking?: boolean | PendingBookingDefaultArgs<ExtArgs>
  }
  export type PendingPassengerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pendingBooking?: boolean | PendingBookingDefaultArgs<ExtArgs>
  }
  export type PendingPassengerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pendingBooking?: boolean | PendingBookingDefaultArgs<ExtArgs>
  }

  export type $PendingPassengerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PendingPassenger"
    objects: {
      pendingBooking: Prisma.$PendingBookingPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      pendingBookingId: number
      title: $Enums.Title
      firstName: string
      middleName: string | null
      lastName: string
      gender: $Enums.Gender
      email: string | null
      contactNo: string | null
      nationality: string | null
      birthday: Date | null
      category: $Enums.PassengerCategory
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["pendingPassenger"]>
    composites: {}
  }

  type PendingPassengerGetPayload<S extends boolean | null | undefined | PendingPassengerDefaultArgs> = $Result.GetResult<Prisma.$PendingPassengerPayload, S>

  type PendingPassengerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PendingPassengerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PendingPassengerCountAggregateInputType | true
    }

  export interface PendingPassengerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PendingPassenger'], meta: { name: 'PendingPassenger' } }
    /**
     * Find zero or one PendingPassenger that matches the filter.
     * @param {PendingPassengerFindUniqueArgs} args - Arguments to find a PendingPassenger
     * @example
     * // Get one PendingPassenger
     * const pendingPassenger = await prisma.pendingPassenger.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PendingPassengerFindUniqueArgs>(args: SelectSubset<T, PendingPassengerFindUniqueArgs<ExtArgs>>): Prisma__PendingPassengerClient<$Result.GetResult<Prisma.$PendingPassengerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PendingPassenger that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PendingPassengerFindUniqueOrThrowArgs} args - Arguments to find a PendingPassenger
     * @example
     * // Get one PendingPassenger
     * const pendingPassenger = await prisma.pendingPassenger.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PendingPassengerFindUniqueOrThrowArgs>(args: SelectSubset<T, PendingPassengerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PendingPassengerClient<$Result.GetResult<Prisma.$PendingPassengerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PendingPassenger that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingPassengerFindFirstArgs} args - Arguments to find a PendingPassenger
     * @example
     * // Get one PendingPassenger
     * const pendingPassenger = await prisma.pendingPassenger.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PendingPassengerFindFirstArgs>(args?: SelectSubset<T, PendingPassengerFindFirstArgs<ExtArgs>>): Prisma__PendingPassengerClient<$Result.GetResult<Prisma.$PendingPassengerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PendingPassenger that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingPassengerFindFirstOrThrowArgs} args - Arguments to find a PendingPassenger
     * @example
     * // Get one PendingPassenger
     * const pendingPassenger = await prisma.pendingPassenger.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PendingPassengerFindFirstOrThrowArgs>(args?: SelectSubset<T, PendingPassengerFindFirstOrThrowArgs<ExtArgs>>): Prisma__PendingPassengerClient<$Result.GetResult<Prisma.$PendingPassengerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PendingPassengers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingPassengerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PendingPassengers
     * const pendingPassengers = await prisma.pendingPassenger.findMany()
     * 
     * // Get first 10 PendingPassengers
     * const pendingPassengers = await prisma.pendingPassenger.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pendingPassengerWithIdOnly = await prisma.pendingPassenger.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PendingPassengerFindManyArgs>(args?: SelectSubset<T, PendingPassengerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PendingPassengerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PendingPassenger.
     * @param {PendingPassengerCreateArgs} args - Arguments to create a PendingPassenger.
     * @example
     * // Create one PendingPassenger
     * const PendingPassenger = await prisma.pendingPassenger.create({
     *   data: {
     *     // ... data to create a PendingPassenger
     *   }
     * })
     * 
     */
    create<T extends PendingPassengerCreateArgs>(args: SelectSubset<T, PendingPassengerCreateArgs<ExtArgs>>): Prisma__PendingPassengerClient<$Result.GetResult<Prisma.$PendingPassengerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PendingPassengers.
     * @param {PendingPassengerCreateManyArgs} args - Arguments to create many PendingPassengers.
     * @example
     * // Create many PendingPassengers
     * const pendingPassenger = await prisma.pendingPassenger.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PendingPassengerCreateManyArgs>(args?: SelectSubset<T, PendingPassengerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PendingPassengers and returns the data saved in the database.
     * @param {PendingPassengerCreateManyAndReturnArgs} args - Arguments to create many PendingPassengers.
     * @example
     * // Create many PendingPassengers
     * const pendingPassenger = await prisma.pendingPassenger.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PendingPassengers and only return the `id`
     * const pendingPassengerWithIdOnly = await prisma.pendingPassenger.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PendingPassengerCreateManyAndReturnArgs>(args?: SelectSubset<T, PendingPassengerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PendingPassengerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PendingPassenger.
     * @param {PendingPassengerDeleteArgs} args - Arguments to delete one PendingPassenger.
     * @example
     * // Delete one PendingPassenger
     * const PendingPassenger = await prisma.pendingPassenger.delete({
     *   where: {
     *     // ... filter to delete one PendingPassenger
     *   }
     * })
     * 
     */
    delete<T extends PendingPassengerDeleteArgs>(args: SelectSubset<T, PendingPassengerDeleteArgs<ExtArgs>>): Prisma__PendingPassengerClient<$Result.GetResult<Prisma.$PendingPassengerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PendingPassenger.
     * @param {PendingPassengerUpdateArgs} args - Arguments to update one PendingPassenger.
     * @example
     * // Update one PendingPassenger
     * const pendingPassenger = await prisma.pendingPassenger.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PendingPassengerUpdateArgs>(args: SelectSubset<T, PendingPassengerUpdateArgs<ExtArgs>>): Prisma__PendingPassengerClient<$Result.GetResult<Prisma.$PendingPassengerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PendingPassengers.
     * @param {PendingPassengerDeleteManyArgs} args - Arguments to filter PendingPassengers to delete.
     * @example
     * // Delete a few PendingPassengers
     * const { count } = await prisma.pendingPassenger.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PendingPassengerDeleteManyArgs>(args?: SelectSubset<T, PendingPassengerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PendingPassengers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingPassengerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PendingPassengers
     * const pendingPassenger = await prisma.pendingPassenger.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PendingPassengerUpdateManyArgs>(args: SelectSubset<T, PendingPassengerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PendingPassengers and returns the data updated in the database.
     * @param {PendingPassengerUpdateManyAndReturnArgs} args - Arguments to update many PendingPassengers.
     * @example
     * // Update many PendingPassengers
     * const pendingPassenger = await prisma.pendingPassenger.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PendingPassengers and only return the `id`
     * const pendingPassengerWithIdOnly = await prisma.pendingPassenger.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PendingPassengerUpdateManyAndReturnArgs>(args: SelectSubset<T, PendingPassengerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PendingPassengerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PendingPassenger.
     * @param {PendingPassengerUpsertArgs} args - Arguments to update or create a PendingPassenger.
     * @example
     * // Update or create a PendingPassenger
     * const pendingPassenger = await prisma.pendingPassenger.upsert({
     *   create: {
     *     // ... data to create a PendingPassenger
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PendingPassenger we want to update
     *   }
     * })
     */
    upsert<T extends PendingPassengerUpsertArgs>(args: SelectSubset<T, PendingPassengerUpsertArgs<ExtArgs>>): Prisma__PendingPassengerClient<$Result.GetResult<Prisma.$PendingPassengerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PendingPassengers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingPassengerCountArgs} args - Arguments to filter PendingPassengers to count.
     * @example
     * // Count the number of PendingPassengers
     * const count = await prisma.pendingPassenger.count({
     *   where: {
     *     // ... the filter for the PendingPassengers we want to count
     *   }
     * })
    **/
    count<T extends PendingPassengerCountArgs>(
      args?: Subset<T, PendingPassengerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PendingPassengerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PendingPassenger.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingPassengerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PendingPassengerAggregateArgs>(args: Subset<T, PendingPassengerAggregateArgs>): Prisma.PrismaPromise<GetPendingPassengerAggregateType<T>>

    /**
     * Group by PendingPassenger.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingPassengerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PendingPassengerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PendingPassengerGroupByArgs['orderBy'] }
        : { orderBy?: PendingPassengerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PendingPassengerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPendingPassengerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PendingPassenger model
   */
  readonly fields: PendingPassengerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PendingPassenger.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PendingPassengerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pendingBooking<T extends PendingBookingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PendingBookingDefaultArgs<ExtArgs>>): Prisma__PendingBookingClient<$Result.GetResult<Prisma.$PendingBookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PendingPassenger model
   */
  interface PendingPassengerFieldRefs {
    readonly id: FieldRef<"PendingPassenger", 'Int'>
    readonly pendingBookingId: FieldRef<"PendingPassenger", 'Int'>
    readonly title: FieldRef<"PendingPassenger", 'Title'>
    readonly firstName: FieldRef<"PendingPassenger", 'String'>
    readonly middleName: FieldRef<"PendingPassenger", 'String'>
    readonly lastName: FieldRef<"PendingPassenger", 'String'>
    readonly gender: FieldRef<"PendingPassenger", 'Gender'>
    readonly email: FieldRef<"PendingPassenger", 'String'>
    readonly contactNo: FieldRef<"PendingPassenger", 'String'>
    readonly nationality: FieldRef<"PendingPassenger", 'String'>
    readonly birthday: FieldRef<"PendingPassenger", 'DateTime'>
    readonly category: FieldRef<"PendingPassenger", 'PassengerCategory'>
    readonly createdAt: FieldRef<"PendingPassenger", 'DateTime'>
    readonly updatedAt: FieldRef<"PendingPassenger", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PendingPassenger findUnique
   */
  export type PendingPassengerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingPassenger
     */
    select?: PendingPassengerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingPassenger
     */
    omit?: PendingPassengerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingPassengerInclude<ExtArgs> | null
    /**
     * Filter, which PendingPassenger to fetch.
     */
    where: PendingPassengerWhereUniqueInput
  }

  /**
   * PendingPassenger findUniqueOrThrow
   */
  export type PendingPassengerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingPassenger
     */
    select?: PendingPassengerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingPassenger
     */
    omit?: PendingPassengerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingPassengerInclude<ExtArgs> | null
    /**
     * Filter, which PendingPassenger to fetch.
     */
    where: PendingPassengerWhereUniqueInput
  }

  /**
   * PendingPassenger findFirst
   */
  export type PendingPassengerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingPassenger
     */
    select?: PendingPassengerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingPassenger
     */
    omit?: PendingPassengerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingPassengerInclude<ExtArgs> | null
    /**
     * Filter, which PendingPassenger to fetch.
     */
    where?: PendingPassengerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PendingPassengers to fetch.
     */
    orderBy?: PendingPassengerOrderByWithRelationInput | PendingPassengerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PendingPassengers.
     */
    cursor?: PendingPassengerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PendingPassengers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PendingPassengers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PendingPassengers.
     */
    distinct?: PendingPassengerScalarFieldEnum | PendingPassengerScalarFieldEnum[]
  }

  /**
   * PendingPassenger findFirstOrThrow
   */
  export type PendingPassengerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingPassenger
     */
    select?: PendingPassengerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingPassenger
     */
    omit?: PendingPassengerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingPassengerInclude<ExtArgs> | null
    /**
     * Filter, which PendingPassenger to fetch.
     */
    where?: PendingPassengerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PendingPassengers to fetch.
     */
    orderBy?: PendingPassengerOrderByWithRelationInput | PendingPassengerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PendingPassengers.
     */
    cursor?: PendingPassengerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PendingPassengers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PendingPassengers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PendingPassengers.
     */
    distinct?: PendingPassengerScalarFieldEnum | PendingPassengerScalarFieldEnum[]
  }

  /**
   * PendingPassenger findMany
   */
  export type PendingPassengerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingPassenger
     */
    select?: PendingPassengerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingPassenger
     */
    omit?: PendingPassengerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingPassengerInclude<ExtArgs> | null
    /**
     * Filter, which PendingPassengers to fetch.
     */
    where?: PendingPassengerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PendingPassengers to fetch.
     */
    orderBy?: PendingPassengerOrderByWithRelationInput | PendingPassengerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PendingPassengers.
     */
    cursor?: PendingPassengerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PendingPassengers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PendingPassengers.
     */
    skip?: number
    distinct?: PendingPassengerScalarFieldEnum | PendingPassengerScalarFieldEnum[]
  }

  /**
   * PendingPassenger create
   */
  export type PendingPassengerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingPassenger
     */
    select?: PendingPassengerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingPassenger
     */
    omit?: PendingPassengerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingPassengerInclude<ExtArgs> | null
    /**
     * The data needed to create a PendingPassenger.
     */
    data: XOR<PendingPassengerCreateInput, PendingPassengerUncheckedCreateInput>
  }

  /**
   * PendingPassenger createMany
   */
  export type PendingPassengerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PendingPassengers.
     */
    data: PendingPassengerCreateManyInput | PendingPassengerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PendingPassenger createManyAndReturn
   */
  export type PendingPassengerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingPassenger
     */
    select?: PendingPassengerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PendingPassenger
     */
    omit?: PendingPassengerOmit<ExtArgs> | null
    /**
     * The data used to create many PendingPassengers.
     */
    data: PendingPassengerCreateManyInput | PendingPassengerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingPassengerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PendingPassenger update
   */
  export type PendingPassengerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingPassenger
     */
    select?: PendingPassengerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingPassenger
     */
    omit?: PendingPassengerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingPassengerInclude<ExtArgs> | null
    /**
     * The data needed to update a PendingPassenger.
     */
    data: XOR<PendingPassengerUpdateInput, PendingPassengerUncheckedUpdateInput>
    /**
     * Choose, which PendingPassenger to update.
     */
    where: PendingPassengerWhereUniqueInput
  }

  /**
   * PendingPassenger updateMany
   */
  export type PendingPassengerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PendingPassengers.
     */
    data: XOR<PendingPassengerUpdateManyMutationInput, PendingPassengerUncheckedUpdateManyInput>
    /**
     * Filter which PendingPassengers to update
     */
    where?: PendingPassengerWhereInput
    /**
     * Limit how many PendingPassengers to update.
     */
    limit?: number
  }

  /**
   * PendingPassenger updateManyAndReturn
   */
  export type PendingPassengerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingPassenger
     */
    select?: PendingPassengerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PendingPassenger
     */
    omit?: PendingPassengerOmit<ExtArgs> | null
    /**
     * The data used to update PendingPassengers.
     */
    data: XOR<PendingPassengerUpdateManyMutationInput, PendingPassengerUncheckedUpdateManyInput>
    /**
     * Filter which PendingPassengers to update
     */
    where?: PendingPassengerWhereInput
    /**
     * Limit how many PendingPassengers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingPassengerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PendingPassenger upsert
   */
  export type PendingPassengerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingPassenger
     */
    select?: PendingPassengerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingPassenger
     */
    omit?: PendingPassengerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingPassengerInclude<ExtArgs> | null
    /**
     * The filter to search for the PendingPassenger to update in case it exists.
     */
    where: PendingPassengerWhereUniqueInput
    /**
     * In case the PendingPassenger found by the `where` argument doesn't exist, create a new PendingPassenger with this data.
     */
    create: XOR<PendingPassengerCreateInput, PendingPassengerUncheckedCreateInput>
    /**
     * In case the PendingPassenger was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PendingPassengerUpdateInput, PendingPassengerUncheckedUpdateInput>
  }

  /**
   * PendingPassenger delete
   */
  export type PendingPassengerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingPassenger
     */
    select?: PendingPassengerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingPassenger
     */
    omit?: PendingPassengerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingPassengerInclude<ExtArgs> | null
    /**
     * Filter which PendingPassenger to delete.
     */
    where: PendingPassengerWhereUniqueInput
  }

  /**
   * PendingPassenger deleteMany
   */
  export type PendingPassengerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PendingPassengers to delete
     */
    where?: PendingPassengerWhereInput
    /**
     * Limit how many PendingPassengers to delete.
     */
    limit?: number
  }

  /**
   * PendingPassenger without action
   */
  export type PendingPassengerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingPassenger
     */
    select?: PendingPassengerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingPassenger
     */
    omit?: PendingPassengerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingPassengerInclude<ExtArgs> | null
  }


  /**
   * Model CostItemSupplier
   */

  export type AggregateCostItemSupplier = {
    _count: CostItemSupplierCountAggregateOutputType | null
    _avg: CostItemSupplierAvgAggregateOutputType | null
    _sum: CostItemSupplierSumAggregateOutputType | null
    _min: CostItemSupplierMinAggregateOutputType | null
    _max: CostItemSupplierMaxAggregateOutputType | null
  }

  export type CostItemSupplierAvgAggregateOutputType = {
    id: number | null
    costItemId: number | null
    pendingCostItemId: number | null
    amount: number | null
    paidAmount: number | null
    pendingAmount: number | null
    firstMethodAmount: number | null
    secondMethodAmount: number | null
  }

  export type CostItemSupplierSumAggregateOutputType = {
    id: number | null
    costItemId: number | null
    pendingCostItemId: number | null
    amount: number | null
    paidAmount: number | null
    pendingAmount: number | null
    firstMethodAmount: number | null
    secondMethodAmount: number | null
  }

  export type CostItemSupplierMinAggregateOutputType = {
    id: number | null
    costItemId: number | null
    pendingCostItemId: number | null
    supplier: $Enums.Suppliers | null
    amount: number | null
    paymentMethod: string | null
    paidAmount: number | null
    pendingAmount: number | null
    transactionMethod: string | null
    firstMethodAmount: number | null
    secondMethodAmount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CostItemSupplierMaxAggregateOutputType = {
    id: number | null
    costItemId: number | null
    pendingCostItemId: number | null
    supplier: $Enums.Suppliers | null
    amount: number | null
    paymentMethod: string | null
    paidAmount: number | null
    pendingAmount: number | null
    transactionMethod: string | null
    firstMethodAmount: number | null
    secondMethodAmount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CostItemSupplierCountAggregateOutputType = {
    id: number
    costItemId: number
    pendingCostItemId: number
    supplier: number
    amount: number
    paymentMethod: number
    paidAmount: number
    pendingAmount: number
    transactionMethod: number
    firstMethodAmount: number
    secondMethodAmount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CostItemSupplierAvgAggregateInputType = {
    id?: true
    costItemId?: true
    pendingCostItemId?: true
    amount?: true
    paidAmount?: true
    pendingAmount?: true
    firstMethodAmount?: true
    secondMethodAmount?: true
  }

  export type CostItemSupplierSumAggregateInputType = {
    id?: true
    costItemId?: true
    pendingCostItemId?: true
    amount?: true
    paidAmount?: true
    pendingAmount?: true
    firstMethodAmount?: true
    secondMethodAmount?: true
  }

  export type CostItemSupplierMinAggregateInputType = {
    id?: true
    costItemId?: true
    pendingCostItemId?: true
    supplier?: true
    amount?: true
    paymentMethod?: true
    paidAmount?: true
    pendingAmount?: true
    transactionMethod?: true
    firstMethodAmount?: true
    secondMethodAmount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CostItemSupplierMaxAggregateInputType = {
    id?: true
    costItemId?: true
    pendingCostItemId?: true
    supplier?: true
    amount?: true
    paymentMethod?: true
    paidAmount?: true
    pendingAmount?: true
    transactionMethod?: true
    firstMethodAmount?: true
    secondMethodAmount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CostItemSupplierCountAggregateInputType = {
    id?: true
    costItemId?: true
    pendingCostItemId?: true
    supplier?: true
    amount?: true
    paymentMethod?: true
    paidAmount?: true
    pendingAmount?: true
    transactionMethod?: true
    firstMethodAmount?: true
    secondMethodAmount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CostItemSupplierAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CostItemSupplier to aggregate.
     */
    where?: CostItemSupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CostItemSuppliers to fetch.
     */
    orderBy?: CostItemSupplierOrderByWithRelationInput | CostItemSupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CostItemSupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CostItemSuppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CostItemSuppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CostItemSuppliers
    **/
    _count?: true | CostItemSupplierCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CostItemSupplierAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CostItemSupplierSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CostItemSupplierMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CostItemSupplierMaxAggregateInputType
  }

  export type GetCostItemSupplierAggregateType<T extends CostItemSupplierAggregateArgs> = {
        [P in keyof T & keyof AggregateCostItemSupplier]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCostItemSupplier[P]>
      : GetScalarType<T[P], AggregateCostItemSupplier[P]>
  }




  export type CostItemSupplierGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CostItemSupplierWhereInput
    orderBy?: CostItemSupplierOrderByWithAggregationInput | CostItemSupplierOrderByWithAggregationInput[]
    by: CostItemSupplierScalarFieldEnum[] | CostItemSupplierScalarFieldEnum
    having?: CostItemSupplierScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CostItemSupplierCountAggregateInputType | true
    _avg?: CostItemSupplierAvgAggregateInputType
    _sum?: CostItemSupplierSumAggregateInputType
    _min?: CostItemSupplierMinAggregateInputType
    _max?: CostItemSupplierMaxAggregateInputType
  }

  export type CostItemSupplierGroupByOutputType = {
    id: number
    costItemId: number | null
    pendingCostItemId: number | null
    supplier: $Enums.Suppliers
    amount: number
    paymentMethod: string
    paidAmount: number
    pendingAmount: number
    transactionMethod: string | null
    firstMethodAmount: number | null
    secondMethodAmount: number | null
    createdAt: Date
    updatedAt: Date
    _count: CostItemSupplierCountAggregateOutputType | null
    _avg: CostItemSupplierAvgAggregateOutputType | null
    _sum: CostItemSupplierSumAggregateOutputType | null
    _min: CostItemSupplierMinAggregateOutputType | null
    _max: CostItemSupplierMaxAggregateOutputType | null
  }

  type GetCostItemSupplierGroupByPayload<T extends CostItemSupplierGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CostItemSupplierGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CostItemSupplierGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CostItemSupplierGroupByOutputType[P]>
            : GetScalarType<T[P], CostItemSupplierGroupByOutputType[P]>
        }
      >
    >


  export type CostItemSupplierSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    costItemId?: boolean
    pendingCostItemId?: boolean
    supplier?: boolean
    amount?: boolean
    paymentMethod?: boolean
    paidAmount?: boolean
    pendingAmount?: boolean
    transactionMethod?: boolean
    firstMethodAmount?: boolean
    secondMethodAmount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    costItem?: boolean | CostItemSupplier$costItemArgs<ExtArgs>
    pendingCostItem?: boolean | CostItemSupplier$pendingCostItemArgs<ExtArgs>
    settlements?: boolean | CostItemSupplier$settlementsArgs<ExtArgs>
    paidByCreditNoteUsage?: boolean | CostItemSupplier$paidByCreditNoteUsageArgs<ExtArgs>
    _count?: boolean | CostItemSupplierCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["costItemSupplier"]>

  export type CostItemSupplierSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    costItemId?: boolean
    pendingCostItemId?: boolean
    supplier?: boolean
    amount?: boolean
    paymentMethod?: boolean
    paidAmount?: boolean
    pendingAmount?: boolean
    transactionMethod?: boolean
    firstMethodAmount?: boolean
    secondMethodAmount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    costItem?: boolean | CostItemSupplier$costItemArgs<ExtArgs>
    pendingCostItem?: boolean | CostItemSupplier$pendingCostItemArgs<ExtArgs>
  }, ExtArgs["result"]["costItemSupplier"]>

  export type CostItemSupplierSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    costItemId?: boolean
    pendingCostItemId?: boolean
    supplier?: boolean
    amount?: boolean
    paymentMethod?: boolean
    paidAmount?: boolean
    pendingAmount?: boolean
    transactionMethod?: boolean
    firstMethodAmount?: boolean
    secondMethodAmount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    costItem?: boolean | CostItemSupplier$costItemArgs<ExtArgs>
    pendingCostItem?: boolean | CostItemSupplier$pendingCostItemArgs<ExtArgs>
  }, ExtArgs["result"]["costItemSupplier"]>

  export type CostItemSupplierSelectScalar = {
    id?: boolean
    costItemId?: boolean
    pendingCostItemId?: boolean
    supplier?: boolean
    amount?: boolean
    paymentMethod?: boolean
    paidAmount?: boolean
    pendingAmount?: boolean
    transactionMethod?: boolean
    firstMethodAmount?: boolean
    secondMethodAmount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CostItemSupplierOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "costItemId" | "pendingCostItemId" | "supplier" | "amount" | "paymentMethod" | "paidAmount" | "pendingAmount" | "transactionMethod" | "firstMethodAmount" | "secondMethodAmount" | "createdAt" | "updatedAt", ExtArgs["result"]["costItemSupplier"]>
  export type CostItemSupplierInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    costItem?: boolean | CostItemSupplier$costItemArgs<ExtArgs>
    pendingCostItem?: boolean | CostItemSupplier$pendingCostItemArgs<ExtArgs>
    settlements?: boolean | CostItemSupplier$settlementsArgs<ExtArgs>
    paidByCreditNoteUsage?: boolean | CostItemSupplier$paidByCreditNoteUsageArgs<ExtArgs>
    _count?: boolean | CostItemSupplierCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CostItemSupplierIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    costItem?: boolean | CostItemSupplier$costItemArgs<ExtArgs>
    pendingCostItem?: boolean | CostItemSupplier$pendingCostItemArgs<ExtArgs>
  }
  export type CostItemSupplierIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    costItem?: boolean | CostItemSupplier$costItemArgs<ExtArgs>
    pendingCostItem?: boolean | CostItemSupplier$pendingCostItemArgs<ExtArgs>
  }

  export type $CostItemSupplierPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CostItemSupplier"
    objects: {
      costItem: Prisma.$CostItemPayload<ExtArgs> | null
      pendingCostItem: Prisma.$PendingCostItemPayload<ExtArgs> | null
      settlements: Prisma.$SupplierPaymentSettlementPayload<ExtArgs>[]
      paidByCreditNoteUsage: Prisma.$CreditNoteUsagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      costItemId: number | null
      pendingCostItemId: number | null
      supplier: $Enums.Suppliers
      amount: number
      paymentMethod: string
      paidAmount: number
      pendingAmount: number
      transactionMethod: string | null
      firstMethodAmount: number | null
      secondMethodAmount: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["costItemSupplier"]>
    composites: {}
  }

  type CostItemSupplierGetPayload<S extends boolean | null | undefined | CostItemSupplierDefaultArgs> = $Result.GetResult<Prisma.$CostItemSupplierPayload, S>

  type CostItemSupplierCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CostItemSupplierFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CostItemSupplierCountAggregateInputType | true
    }

  export interface CostItemSupplierDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CostItemSupplier'], meta: { name: 'CostItemSupplier' } }
    /**
     * Find zero or one CostItemSupplier that matches the filter.
     * @param {CostItemSupplierFindUniqueArgs} args - Arguments to find a CostItemSupplier
     * @example
     * // Get one CostItemSupplier
     * const costItemSupplier = await prisma.costItemSupplier.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CostItemSupplierFindUniqueArgs>(args: SelectSubset<T, CostItemSupplierFindUniqueArgs<ExtArgs>>): Prisma__CostItemSupplierClient<$Result.GetResult<Prisma.$CostItemSupplierPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CostItemSupplier that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CostItemSupplierFindUniqueOrThrowArgs} args - Arguments to find a CostItemSupplier
     * @example
     * // Get one CostItemSupplier
     * const costItemSupplier = await prisma.costItemSupplier.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CostItemSupplierFindUniqueOrThrowArgs>(args: SelectSubset<T, CostItemSupplierFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CostItemSupplierClient<$Result.GetResult<Prisma.$CostItemSupplierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CostItemSupplier that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostItemSupplierFindFirstArgs} args - Arguments to find a CostItemSupplier
     * @example
     * // Get one CostItemSupplier
     * const costItemSupplier = await prisma.costItemSupplier.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CostItemSupplierFindFirstArgs>(args?: SelectSubset<T, CostItemSupplierFindFirstArgs<ExtArgs>>): Prisma__CostItemSupplierClient<$Result.GetResult<Prisma.$CostItemSupplierPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CostItemSupplier that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostItemSupplierFindFirstOrThrowArgs} args - Arguments to find a CostItemSupplier
     * @example
     * // Get one CostItemSupplier
     * const costItemSupplier = await prisma.costItemSupplier.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CostItemSupplierFindFirstOrThrowArgs>(args?: SelectSubset<T, CostItemSupplierFindFirstOrThrowArgs<ExtArgs>>): Prisma__CostItemSupplierClient<$Result.GetResult<Prisma.$CostItemSupplierPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CostItemSuppliers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostItemSupplierFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CostItemSuppliers
     * const costItemSuppliers = await prisma.costItemSupplier.findMany()
     * 
     * // Get first 10 CostItemSuppliers
     * const costItemSuppliers = await prisma.costItemSupplier.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const costItemSupplierWithIdOnly = await prisma.costItemSupplier.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CostItemSupplierFindManyArgs>(args?: SelectSubset<T, CostItemSupplierFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CostItemSupplierPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CostItemSupplier.
     * @param {CostItemSupplierCreateArgs} args - Arguments to create a CostItemSupplier.
     * @example
     * // Create one CostItemSupplier
     * const CostItemSupplier = await prisma.costItemSupplier.create({
     *   data: {
     *     // ... data to create a CostItemSupplier
     *   }
     * })
     * 
     */
    create<T extends CostItemSupplierCreateArgs>(args: SelectSubset<T, CostItemSupplierCreateArgs<ExtArgs>>): Prisma__CostItemSupplierClient<$Result.GetResult<Prisma.$CostItemSupplierPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CostItemSuppliers.
     * @param {CostItemSupplierCreateManyArgs} args - Arguments to create many CostItemSuppliers.
     * @example
     * // Create many CostItemSuppliers
     * const costItemSupplier = await prisma.costItemSupplier.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CostItemSupplierCreateManyArgs>(args?: SelectSubset<T, CostItemSupplierCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CostItemSuppliers and returns the data saved in the database.
     * @param {CostItemSupplierCreateManyAndReturnArgs} args - Arguments to create many CostItemSuppliers.
     * @example
     * // Create many CostItemSuppliers
     * const costItemSupplier = await prisma.costItemSupplier.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CostItemSuppliers and only return the `id`
     * const costItemSupplierWithIdOnly = await prisma.costItemSupplier.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CostItemSupplierCreateManyAndReturnArgs>(args?: SelectSubset<T, CostItemSupplierCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CostItemSupplierPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CostItemSupplier.
     * @param {CostItemSupplierDeleteArgs} args - Arguments to delete one CostItemSupplier.
     * @example
     * // Delete one CostItemSupplier
     * const CostItemSupplier = await prisma.costItemSupplier.delete({
     *   where: {
     *     // ... filter to delete one CostItemSupplier
     *   }
     * })
     * 
     */
    delete<T extends CostItemSupplierDeleteArgs>(args: SelectSubset<T, CostItemSupplierDeleteArgs<ExtArgs>>): Prisma__CostItemSupplierClient<$Result.GetResult<Prisma.$CostItemSupplierPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CostItemSupplier.
     * @param {CostItemSupplierUpdateArgs} args - Arguments to update one CostItemSupplier.
     * @example
     * // Update one CostItemSupplier
     * const costItemSupplier = await prisma.costItemSupplier.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CostItemSupplierUpdateArgs>(args: SelectSubset<T, CostItemSupplierUpdateArgs<ExtArgs>>): Prisma__CostItemSupplierClient<$Result.GetResult<Prisma.$CostItemSupplierPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CostItemSuppliers.
     * @param {CostItemSupplierDeleteManyArgs} args - Arguments to filter CostItemSuppliers to delete.
     * @example
     * // Delete a few CostItemSuppliers
     * const { count } = await prisma.costItemSupplier.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CostItemSupplierDeleteManyArgs>(args?: SelectSubset<T, CostItemSupplierDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CostItemSuppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostItemSupplierUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CostItemSuppliers
     * const costItemSupplier = await prisma.costItemSupplier.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CostItemSupplierUpdateManyArgs>(args: SelectSubset<T, CostItemSupplierUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CostItemSuppliers and returns the data updated in the database.
     * @param {CostItemSupplierUpdateManyAndReturnArgs} args - Arguments to update many CostItemSuppliers.
     * @example
     * // Update many CostItemSuppliers
     * const costItemSupplier = await prisma.costItemSupplier.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CostItemSuppliers and only return the `id`
     * const costItemSupplierWithIdOnly = await prisma.costItemSupplier.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CostItemSupplierUpdateManyAndReturnArgs>(args: SelectSubset<T, CostItemSupplierUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CostItemSupplierPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CostItemSupplier.
     * @param {CostItemSupplierUpsertArgs} args - Arguments to update or create a CostItemSupplier.
     * @example
     * // Update or create a CostItemSupplier
     * const costItemSupplier = await prisma.costItemSupplier.upsert({
     *   create: {
     *     // ... data to create a CostItemSupplier
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CostItemSupplier we want to update
     *   }
     * })
     */
    upsert<T extends CostItemSupplierUpsertArgs>(args: SelectSubset<T, CostItemSupplierUpsertArgs<ExtArgs>>): Prisma__CostItemSupplierClient<$Result.GetResult<Prisma.$CostItemSupplierPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CostItemSuppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostItemSupplierCountArgs} args - Arguments to filter CostItemSuppliers to count.
     * @example
     * // Count the number of CostItemSuppliers
     * const count = await prisma.costItemSupplier.count({
     *   where: {
     *     // ... the filter for the CostItemSuppliers we want to count
     *   }
     * })
    **/
    count<T extends CostItemSupplierCountArgs>(
      args?: Subset<T, CostItemSupplierCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CostItemSupplierCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CostItemSupplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostItemSupplierAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CostItemSupplierAggregateArgs>(args: Subset<T, CostItemSupplierAggregateArgs>): Prisma.PrismaPromise<GetCostItemSupplierAggregateType<T>>

    /**
     * Group by CostItemSupplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostItemSupplierGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CostItemSupplierGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CostItemSupplierGroupByArgs['orderBy'] }
        : { orderBy?: CostItemSupplierGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CostItemSupplierGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCostItemSupplierGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CostItemSupplier model
   */
  readonly fields: CostItemSupplierFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CostItemSupplier.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CostItemSupplierClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    costItem<T extends CostItemSupplier$costItemArgs<ExtArgs> = {}>(args?: Subset<T, CostItemSupplier$costItemArgs<ExtArgs>>): Prisma__CostItemClient<$Result.GetResult<Prisma.$CostItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    pendingCostItem<T extends CostItemSupplier$pendingCostItemArgs<ExtArgs> = {}>(args?: Subset<T, CostItemSupplier$pendingCostItemArgs<ExtArgs>>): Prisma__PendingCostItemClient<$Result.GetResult<Prisma.$PendingCostItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    settlements<T extends CostItemSupplier$settlementsArgs<ExtArgs> = {}>(args?: Subset<T, CostItemSupplier$settlementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPaymentSettlementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    paidByCreditNoteUsage<T extends CostItemSupplier$paidByCreditNoteUsageArgs<ExtArgs> = {}>(args?: Subset<T, CostItemSupplier$paidByCreditNoteUsageArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditNoteUsagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CostItemSupplier model
   */
  interface CostItemSupplierFieldRefs {
    readonly id: FieldRef<"CostItemSupplier", 'Int'>
    readonly costItemId: FieldRef<"CostItemSupplier", 'Int'>
    readonly pendingCostItemId: FieldRef<"CostItemSupplier", 'Int'>
    readonly supplier: FieldRef<"CostItemSupplier", 'Suppliers'>
    readonly amount: FieldRef<"CostItemSupplier", 'Float'>
    readonly paymentMethod: FieldRef<"CostItemSupplier", 'String'>
    readonly paidAmount: FieldRef<"CostItemSupplier", 'Float'>
    readonly pendingAmount: FieldRef<"CostItemSupplier", 'Float'>
    readonly transactionMethod: FieldRef<"CostItemSupplier", 'String'>
    readonly firstMethodAmount: FieldRef<"CostItemSupplier", 'Float'>
    readonly secondMethodAmount: FieldRef<"CostItemSupplier", 'Float'>
    readonly createdAt: FieldRef<"CostItemSupplier", 'DateTime'>
    readonly updatedAt: FieldRef<"CostItemSupplier", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CostItemSupplier findUnique
   */
  export type CostItemSupplierFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostItemSupplier
     */
    select?: CostItemSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostItemSupplier
     */
    omit?: CostItemSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostItemSupplierInclude<ExtArgs> | null
    /**
     * Filter, which CostItemSupplier to fetch.
     */
    where: CostItemSupplierWhereUniqueInput
  }

  /**
   * CostItemSupplier findUniqueOrThrow
   */
  export type CostItemSupplierFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostItemSupplier
     */
    select?: CostItemSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostItemSupplier
     */
    omit?: CostItemSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostItemSupplierInclude<ExtArgs> | null
    /**
     * Filter, which CostItemSupplier to fetch.
     */
    where: CostItemSupplierWhereUniqueInput
  }

  /**
   * CostItemSupplier findFirst
   */
  export type CostItemSupplierFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostItemSupplier
     */
    select?: CostItemSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostItemSupplier
     */
    omit?: CostItemSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostItemSupplierInclude<ExtArgs> | null
    /**
     * Filter, which CostItemSupplier to fetch.
     */
    where?: CostItemSupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CostItemSuppliers to fetch.
     */
    orderBy?: CostItemSupplierOrderByWithRelationInput | CostItemSupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CostItemSuppliers.
     */
    cursor?: CostItemSupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CostItemSuppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CostItemSuppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CostItemSuppliers.
     */
    distinct?: CostItemSupplierScalarFieldEnum | CostItemSupplierScalarFieldEnum[]
  }

  /**
   * CostItemSupplier findFirstOrThrow
   */
  export type CostItemSupplierFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostItemSupplier
     */
    select?: CostItemSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostItemSupplier
     */
    omit?: CostItemSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostItemSupplierInclude<ExtArgs> | null
    /**
     * Filter, which CostItemSupplier to fetch.
     */
    where?: CostItemSupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CostItemSuppliers to fetch.
     */
    orderBy?: CostItemSupplierOrderByWithRelationInput | CostItemSupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CostItemSuppliers.
     */
    cursor?: CostItemSupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CostItemSuppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CostItemSuppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CostItemSuppliers.
     */
    distinct?: CostItemSupplierScalarFieldEnum | CostItemSupplierScalarFieldEnum[]
  }

  /**
   * CostItemSupplier findMany
   */
  export type CostItemSupplierFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostItemSupplier
     */
    select?: CostItemSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostItemSupplier
     */
    omit?: CostItemSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostItemSupplierInclude<ExtArgs> | null
    /**
     * Filter, which CostItemSuppliers to fetch.
     */
    where?: CostItemSupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CostItemSuppliers to fetch.
     */
    orderBy?: CostItemSupplierOrderByWithRelationInput | CostItemSupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CostItemSuppliers.
     */
    cursor?: CostItemSupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CostItemSuppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CostItemSuppliers.
     */
    skip?: number
    distinct?: CostItemSupplierScalarFieldEnum | CostItemSupplierScalarFieldEnum[]
  }

  /**
   * CostItemSupplier create
   */
  export type CostItemSupplierCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostItemSupplier
     */
    select?: CostItemSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostItemSupplier
     */
    omit?: CostItemSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostItemSupplierInclude<ExtArgs> | null
    /**
     * The data needed to create a CostItemSupplier.
     */
    data: XOR<CostItemSupplierCreateInput, CostItemSupplierUncheckedCreateInput>
  }

  /**
   * CostItemSupplier createMany
   */
  export type CostItemSupplierCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CostItemSuppliers.
     */
    data: CostItemSupplierCreateManyInput | CostItemSupplierCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CostItemSupplier createManyAndReturn
   */
  export type CostItemSupplierCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostItemSupplier
     */
    select?: CostItemSupplierSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CostItemSupplier
     */
    omit?: CostItemSupplierOmit<ExtArgs> | null
    /**
     * The data used to create many CostItemSuppliers.
     */
    data: CostItemSupplierCreateManyInput | CostItemSupplierCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostItemSupplierIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CostItemSupplier update
   */
  export type CostItemSupplierUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostItemSupplier
     */
    select?: CostItemSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostItemSupplier
     */
    omit?: CostItemSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostItemSupplierInclude<ExtArgs> | null
    /**
     * The data needed to update a CostItemSupplier.
     */
    data: XOR<CostItemSupplierUpdateInput, CostItemSupplierUncheckedUpdateInput>
    /**
     * Choose, which CostItemSupplier to update.
     */
    where: CostItemSupplierWhereUniqueInput
  }

  /**
   * CostItemSupplier updateMany
   */
  export type CostItemSupplierUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CostItemSuppliers.
     */
    data: XOR<CostItemSupplierUpdateManyMutationInput, CostItemSupplierUncheckedUpdateManyInput>
    /**
     * Filter which CostItemSuppliers to update
     */
    where?: CostItemSupplierWhereInput
    /**
     * Limit how many CostItemSuppliers to update.
     */
    limit?: number
  }

  /**
   * CostItemSupplier updateManyAndReturn
   */
  export type CostItemSupplierUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostItemSupplier
     */
    select?: CostItemSupplierSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CostItemSupplier
     */
    omit?: CostItemSupplierOmit<ExtArgs> | null
    /**
     * The data used to update CostItemSuppliers.
     */
    data: XOR<CostItemSupplierUpdateManyMutationInput, CostItemSupplierUncheckedUpdateManyInput>
    /**
     * Filter which CostItemSuppliers to update
     */
    where?: CostItemSupplierWhereInput
    /**
     * Limit how many CostItemSuppliers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostItemSupplierIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CostItemSupplier upsert
   */
  export type CostItemSupplierUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostItemSupplier
     */
    select?: CostItemSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostItemSupplier
     */
    omit?: CostItemSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostItemSupplierInclude<ExtArgs> | null
    /**
     * The filter to search for the CostItemSupplier to update in case it exists.
     */
    where: CostItemSupplierWhereUniqueInput
    /**
     * In case the CostItemSupplier found by the `where` argument doesn't exist, create a new CostItemSupplier with this data.
     */
    create: XOR<CostItemSupplierCreateInput, CostItemSupplierUncheckedCreateInput>
    /**
     * In case the CostItemSupplier was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CostItemSupplierUpdateInput, CostItemSupplierUncheckedUpdateInput>
  }

  /**
   * CostItemSupplier delete
   */
  export type CostItemSupplierDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostItemSupplier
     */
    select?: CostItemSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostItemSupplier
     */
    omit?: CostItemSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostItemSupplierInclude<ExtArgs> | null
    /**
     * Filter which CostItemSupplier to delete.
     */
    where: CostItemSupplierWhereUniqueInput
  }

  /**
   * CostItemSupplier deleteMany
   */
  export type CostItemSupplierDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CostItemSuppliers to delete
     */
    where?: CostItemSupplierWhereInput
    /**
     * Limit how many CostItemSuppliers to delete.
     */
    limit?: number
  }

  /**
   * CostItemSupplier.costItem
   */
  export type CostItemSupplier$costItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostItem
     */
    select?: CostItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostItem
     */
    omit?: CostItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostItemInclude<ExtArgs> | null
    where?: CostItemWhereInput
  }

  /**
   * CostItemSupplier.pendingCostItem
   */
  export type CostItemSupplier$pendingCostItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingCostItem
     */
    select?: PendingCostItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingCostItem
     */
    omit?: PendingCostItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PendingCostItemInclude<ExtArgs> | null
    where?: PendingCostItemWhereInput
  }

  /**
   * CostItemSupplier.settlements
   */
  export type CostItemSupplier$settlementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierPaymentSettlement
     */
    select?: SupplierPaymentSettlementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierPaymentSettlement
     */
    omit?: SupplierPaymentSettlementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierPaymentSettlementInclude<ExtArgs> | null
    where?: SupplierPaymentSettlementWhereInput
    orderBy?: SupplierPaymentSettlementOrderByWithRelationInput | SupplierPaymentSettlementOrderByWithRelationInput[]
    cursor?: SupplierPaymentSettlementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SupplierPaymentSettlementScalarFieldEnum | SupplierPaymentSettlementScalarFieldEnum[]
  }

  /**
   * CostItemSupplier.paidByCreditNoteUsage
   */
  export type CostItemSupplier$paidByCreditNoteUsageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditNoteUsage
     */
    select?: CreditNoteUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditNoteUsage
     */
    omit?: CreditNoteUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditNoteUsageInclude<ExtArgs> | null
    where?: CreditNoteUsageWhereInput
    orderBy?: CreditNoteUsageOrderByWithRelationInput | CreditNoteUsageOrderByWithRelationInput[]
    cursor?: CreditNoteUsageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CreditNoteUsageScalarFieldEnum | CreditNoteUsageScalarFieldEnum[]
  }

  /**
   * CostItemSupplier without action
   */
  export type CostItemSupplierDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostItemSupplier
     */
    select?: CostItemSupplierSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostItemSupplier
     */
    omit?: CostItemSupplierOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CostItemSupplierInclude<ExtArgs> | null
  }


  /**
   * Model SupplierPaymentSettlement
   */

  export type AggregateSupplierPaymentSettlement = {
    _count: SupplierPaymentSettlementCountAggregateOutputType | null
    _avg: SupplierPaymentSettlementAvgAggregateOutputType | null
    _sum: SupplierPaymentSettlementSumAggregateOutputType | null
    _min: SupplierPaymentSettlementMinAggregateOutputType | null
    _max: SupplierPaymentSettlementMaxAggregateOutputType | null
  }

  export type SupplierPaymentSettlementAvgAggregateOutputType = {
    id: number | null
    costItemSupplierId: number | null
    amount: number | null
  }

  export type SupplierPaymentSettlementSumAggregateOutputType = {
    id: number | null
    costItemSupplierId: number | null
    amount: number | null
  }

  export type SupplierPaymentSettlementMinAggregateOutputType = {
    id: number | null
    costItemSupplierId: number | null
    amount: number | null
    transactionMethod: string | null
    settlementDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SupplierPaymentSettlementMaxAggregateOutputType = {
    id: number | null
    costItemSupplierId: number | null
    amount: number | null
    transactionMethod: string | null
    settlementDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SupplierPaymentSettlementCountAggregateOutputType = {
    id: number
    costItemSupplierId: number
    amount: number
    transactionMethod: number
    settlementDate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SupplierPaymentSettlementAvgAggregateInputType = {
    id?: true
    costItemSupplierId?: true
    amount?: true
  }

  export type SupplierPaymentSettlementSumAggregateInputType = {
    id?: true
    costItemSupplierId?: true
    amount?: true
  }

  export type SupplierPaymentSettlementMinAggregateInputType = {
    id?: true
    costItemSupplierId?: true
    amount?: true
    transactionMethod?: true
    settlementDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SupplierPaymentSettlementMaxAggregateInputType = {
    id?: true
    costItemSupplierId?: true
    amount?: true
    transactionMethod?: true
    settlementDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SupplierPaymentSettlementCountAggregateInputType = {
    id?: true
    costItemSupplierId?: true
    amount?: true
    transactionMethod?: true
    settlementDate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SupplierPaymentSettlementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SupplierPaymentSettlement to aggregate.
     */
    where?: SupplierPaymentSettlementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupplierPaymentSettlements to fetch.
     */
    orderBy?: SupplierPaymentSettlementOrderByWithRelationInput | SupplierPaymentSettlementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SupplierPaymentSettlementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupplierPaymentSettlements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupplierPaymentSettlements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SupplierPaymentSettlements
    **/
    _count?: true | SupplierPaymentSettlementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SupplierPaymentSettlementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SupplierPaymentSettlementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SupplierPaymentSettlementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SupplierPaymentSettlementMaxAggregateInputType
  }

  export type GetSupplierPaymentSettlementAggregateType<T extends SupplierPaymentSettlementAggregateArgs> = {
        [P in keyof T & keyof AggregateSupplierPaymentSettlement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupplierPaymentSettlement[P]>
      : GetScalarType<T[P], AggregateSupplierPaymentSettlement[P]>
  }




  export type SupplierPaymentSettlementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplierPaymentSettlementWhereInput
    orderBy?: SupplierPaymentSettlementOrderByWithAggregationInput | SupplierPaymentSettlementOrderByWithAggregationInput[]
    by: SupplierPaymentSettlementScalarFieldEnum[] | SupplierPaymentSettlementScalarFieldEnum
    having?: SupplierPaymentSettlementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SupplierPaymentSettlementCountAggregateInputType | true
    _avg?: SupplierPaymentSettlementAvgAggregateInputType
    _sum?: SupplierPaymentSettlementSumAggregateInputType
    _min?: SupplierPaymentSettlementMinAggregateInputType
    _max?: SupplierPaymentSettlementMaxAggregateInputType
  }

  export type SupplierPaymentSettlementGroupByOutputType = {
    id: number
    costItemSupplierId: number
    amount: number
    transactionMethod: string
    settlementDate: Date
    createdAt: Date
    updatedAt: Date
    _count: SupplierPaymentSettlementCountAggregateOutputType | null
    _avg: SupplierPaymentSettlementAvgAggregateOutputType | null
    _sum: SupplierPaymentSettlementSumAggregateOutputType | null
    _min: SupplierPaymentSettlementMinAggregateOutputType | null
    _max: SupplierPaymentSettlementMaxAggregateOutputType | null
  }

  type GetSupplierPaymentSettlementGroupByPayload<T extends SupplierPaymentSettlementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SupplierPaymentSettlementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SupplierPaymentSettlementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SupplierPaymentSettlementGroupByOutputType[P]>
            : GetScalarType<T[P], SupplierPaymentSettlementGroupByOutputType[P]>
        }
      >
    >


  export type SupplierPaymentSettlementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    costItemSupplierId?: boolean
    amount?: boolean
    transactionMethod?: boolean
    settlementDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    costItemSupplier?: boolean | CostItemSupplierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplierPaymentSettlement"]>

  export type SupplierPaymentSettlementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    costItemSupplierId?: boolean
    amount?: boolean
    transactionMethod?: boolean
    settlementDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    costItemSupplier?: boolean | CostItemSupplierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplierPaymentSettlement"]>

  export type SupplierPaymentSettlementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    costItemSupplierId?: boolean
    amount?: boolean
    transactionMethod?: boolean
    settlementDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    costItemSupplier?: boolean | CostItemSupplierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplierPaymentSettlement"]>

  export type SupplierPaymentSettlementSelectScalar = {
    id?: boolean
    costItemSupplierId?: boolean
    amount?: boolean
    transactionMethod?: boolean
    settlementDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SupplierPaymentSettlementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "costItemSupplierId" | "amount" | "transactionMethod" | "settlementDate" | "createdAt" | "updatedAt", ExtArgs["result"]["supplierPaymentSettlement"]>
  export type SupplierPaymentSettlementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    costItemSupplier?: boolean | CostItemSupplierDefaultArgs<ExtArgs>
  }
  export type SupplierPaymentSettlementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    costItemSupplier?: boolean | CostItemSupplierDefaultArgs<ExtArgs>
  }
  export type SupplierPaymentSettlementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    costItemSupplier?: boolean | CostItemSupplierDefaultArgs<ExtArgs>
  }

  export type $SupplierPaymentSettlementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SupplierPaymentSettlement"
    objects: {
      costItemSupplier: Prisma.$CostItemSupplierPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      costItemSupplierId: number
      amount: number
      transactionMethod: string
      settlementDate: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["supplierPaymentSettlement"]>
    composites: {}
  }

  type SupplierPaymentSettlementGetPayload<S extends boolean | null | undefined | SupplierPaymentSettlementDefaultArgs> = $Result.GetResult<Prisma.$SupplierPaymentSettlementPayload, S>

  type SupplierPaymentSettlementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SupplierPaymentSettlementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SupplierPaymentSettlementCountAggregateInputType | true
    }

  export interface SupplierPaymentSettlementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SupplierPaymentSettlement'], meta: { name: 'SupplierPaymentSettlement' } }
    /**
     * Find zero or one SupplierPaymentSettlement that matches the filter.
     * @param {SupplierPaymentSettlementFindUniqueArgs} args - Arguments to find a SupplierPaymentSettlement
     * @example
     * // Get one SupplierPaymentSettlement
     * const supplierPaymentSettlement = await prisma.supplierPaymentSettlement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SupplierPaymentSettlementFindUniqueArgs>(args: SelectSubset<T, SupplierPaymentSettlementFindUniqueArgs<ExtArgs>>): Prisma__SupplierPaymentSettlementClient<$Result.GetResult<Prisma.$SupplierPaymentSettlementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SupplierPaymentSettlement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SupplierPaymentSettlementFindUniqueOrThrowArgs} args - Arguments to find a SupplierPaymentSettlement
     * @example
     * // Get one SupplierPaymentSettlement
     * const supplierPaymentSettlement = await prisma.supplierPaymentSettlement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SupplierPaymentSettlementFindUniqueOrThrowArgs>(args: SelectSubset<T, SupplierPaymentSettlementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SupplierPaymentSettlementClient<$Result.GetResult<Prisma.$SupplierPaymentSettlementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SupplierPaymentSettlement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierPaymentSettlementFindFirstArgs} args - Arguments to find a SupplierPaymentSettlement
     * @example
     * // Get one SupplierPaymentSettlement
     * const supplierPaymentSettlement = await prisma.supplierPaymentSettlement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SupplierPaymentSettlementFindFirstArgs>(args?: SelectSubset<T, SupplierPaymentSettlementFindFirstArgs<ExtArgs>>): Prisma__SupplierPaymentSettlementClient<$Result.GetResult<Prisma.$SupplierPaymentSettlementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SupplierPaymentSettlement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierPaymentSettlementFindFirstOrThrowArgs} args - Arguments to find a SupplierPaymentSettlement
     * @example
     * // Get one SupplierPaymentSettlement
     * const supplierPaymentSettlement = await prisma.supplierPaymentSettlement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SupplierPaymentSettlementFindFirstOrThrowArgs>(args?: SelectSubset<T, SupplierPaymentSettlementFindFirstOrThrowArgs<ExtArgs>>): Prisma__SupplierPaymentSettlementClient<$Result.GetResult<Prisma.$SupplierPaymentSettlementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SupplierPaymentSettlements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierPaymentSettlementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SupplierPaymentSettlements
     * const supplierPaymentSettlements = await prisma.supplierPaymentSettlement.findMany()
     * 
     * // Get first 10 SupplierPaymentSettlements
     * const supplierPaymentSettlements = await prisma.supplierPaymentSettlement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const supplierPaymentSettlementWithIdOnly = await prisma.supplierPaymentSettlement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SupplierPaymentSettlementFindManyArgs>(args?: SelectSubset<T, SupplierPaymentSettlementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPaymentSettlementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SupplierPaymentSettlement.
     * @param {SupplierPaymentSettlementCreateArgs} args - Arguments to create a SupplierPaymentSettlement.
     * @example
     * // Create one SupplierPaymentSettlement
     * const SupplierPaymentSettlement = await prisma.supplierPaymentSettlement.create({
     *   data: {
     *     // ... data to create a SupplierPaymentSettlement
     *   }
     * })
     * 
     */
    create<T extends SupplierPaymentSettlementCreateArgs>(args: SelectSubset<T, SupplierPaymentSettlementCreateArgs<ExtArgs>>): Prisma__SupplierPaymentSettlementClient<$Result.GetResult<Prisma.$SupplierPaymentSettlementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SupplierPaymentSettlements.
     * @param {SupplierPaymentSettlementCreateManyArgs} args - Arguments to create many SupplierPaymentSettlements.
     * @example
     * // Create many SupplierPaymentSettlements
     * const supplierPaymentSettlement = await prisma.supplierPaymentSettlement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SupplierPaymentSettlementCreateManyArgs>(args?: SelectSubset<T, SupplierPaymentSettlementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SupplierPaymentSettlements and returns the data saved in the database.
     * @param {SupplierPaymentSettlementCreateManyAndReturnArgs} args - Arguments to create many SupplierPaymentSettlements.
     * @example
     * // Create many SupplierPaymentSettlements
     * const supplierPaymentSettlement = await prisma.supplierPaymentSettlement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SupplierPaymentSettlements and only return the `id`
     * const supplierPaymentSettlementWithIdOnly = await prisma.supplierPaymentSettlement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SupplierPaymentSettlementCreateManyAndReturnArgs>(args?: SelectSubset<T, SupplierPaymentSettlementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPaymentSettlementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SupplierPaymentSettlement.
     * @param {SupplierPaymentSettlementDeleteArgs} args - Arguments to delete one SupplierPaymentSettlement.
     * @example
     * // Delete one SupplierPaymentSettlement
     * const SupplierPaymentSettlement = await prisma.supplierPaymentSettlement.delete({
     *   where: {
     *     // ... filter to delete one SupplierPaymentSettlement
     *   }
     * })
     * 
     */
    delete<T extends SupplierPaymentSettlementDeleteArgs>(args: SelectSubset<T, SupplierPaymentSettlementDeleteArgs<ExtArgs>>): Prisma__SupplierPaymentSettlementClient<$Result.GetResult<Prisma.$SupplierPaymentSettlementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SupplierPaymentSettlement.
     * @param {SupplierPaymentSettlementUpdateArgs} args - Arguments to update one SupplierPaymentSettlement.
     * @example
     * // Update one SupplierPaymentSettlement
     * const supplierPaymentSettlement = await prisma.supplierPaymentSettlement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SupplierPaymentSettlementUpdateArgs>(args: SelectSubset<T, SupplierPaymentSettlementUpdateArgs<ExtArgs>>): Prisma__SupplierPaymentSettlementClient<$Result.GetResult<Prisma.$SupplierPaymentSettlementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SupplierPaymentSettlements.
     * @param {SupplierPaymentSettlementDeleteManyArgs} args - Arguments to filter SupplierPaymentSettlements to delete.
     * @example
     * // Delete a few SupplierPaymentSettlements
     * const { count } = await prisma.supplierPaymentSettlement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SupplierPaymentSettlementDeleteManyArgs>(args?: SelectSubset<T, SupplierPaymentSettlementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SupplierPaymentSettlements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierPaymentSettlementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SupplierPaymentSettlements
     * const supplierPaymentSettlement = await prisma.supplierPaymentSettlement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SupplierPaymentSettlementUpdateManyArgs>(args: SelectSubset<T, SupplierPaymentSettlementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SupplierPaymentSettlements and returns the data updated in the database.
     * @param {SupplierPaymentSettlementUpdateManyAndReturnArgs} args - Arguments to update many SupplierPaymentSettlements.
     * @example
     * // Update many SupplierPaymentSettlements
     * const supplierPaymentSettlement = await prisma.supplierPaymentSettlement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SupplierPaymentSettlements and only return the `id`
     * const supplierPaymentSettlementWithIdOnly = await prisma.supplierPaymentSettlement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SupplierPaymentSettlementUpdateManyAndReturnArgs>(args: SelectSubset<T, SupplierPaymentSettlementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPaymentSettlementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SupplierPaymentSettlement.
     * @param {SupplierPaymentSettlementUpsertArgs} args - Arguments to update or create a SupplierPaymentSettlement.
     * @example
     * // Update or create a SupplierPaymentSettlement
     * const supplierPaymentSettlement = await prisma.supplierPaymentSettlement.upsert({
     *   create: {
     *     // ... data to create a SupplierPaymentSettlement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SupplierPaymentSettlement we want to update
     *   }
     * })
     */
    upsert<T extends SupplierPaymentSettlementUpsertArgs>(args: SelectSubset<T, SupplierPaymentSettlementUpsertArgs<ExtArgs>>): Prisma__SupplierPaymentSettlementClient<$Result.GetResult<Prisma.$SupplierPaymentSettlementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SupplierPaymentSettlements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierPaymentSettlementCountArgs} args - Arguments to filter SupplierPaymentSettlements to count.
     * @example
     * // Count the number of SupplierPaymentSettlements
     * const count = await prisma.supplierPaymentSettlement.count({
     *   where: {
     *     // ... the filter for the SupplierPaymentSettlements we want to count
     *   }
     * })
    **/
    count<T extends SupplierPaymentSettlementCountArgs>(
      args?: Subset<T, SupplierPaymentSettlementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupplierPaymentSettlementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SupplierPaymentSettlement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierPaymentSettlementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SupplierPaymentSettlementAggregateArgs>(args: Subset<T, SupplierPaymentSettlementAggregateArgs>): Prisma.PrismaPromise<GetSupplierPaymentSettlementAggregateType<T>>

    /**
     * Group by SupplierPaymentSettlement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierPaymentSettlementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SupplierPaymentSettlementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SupplierPaymentSettlementGroupByArgs['orderBy'] }
        : { orderBy?: SupplierPaymentSettlementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SupplierPaymentSettlementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupplierPaymentSettlementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SupplierPaymentSettlement model
   */
  readonly fields: SupplierPaymentSettlementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SupplierPaymentSettlement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SupplierPaymentSettlementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    costItemSupplier<T extends CostItemSupplierDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CostItemSupplierDefaultArgs<ExtArgs>>): Prisma__CostItemSupplierClient<$Result.GetResult<Prisma.$CostItemSupplierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SupplierPaymentSettlement model
   */
  interface SupplierPaymentSettlementFieldRefs {
    readonly id: FieldRef<"SupplierPaymentSettlement", 'Int'>
    readonly costItemSupplierId: FieldRef<"SupplierPaymentSettlement", 'Int'>
    readonly amount: FieldRef<"SupplierPaymentSettlement", 'Float'>
    readonly transactionMethod: FieldRef<"SupplierPaymentSettlement", 'String'>
    readonly settlementDate: FieldRef<"SupplierPaymentSettlement", 'DateTime'>
    readonly createdAt: FieldRef<"SupplierPaymentSettlement", 'DateTime'>
    readonly updatedAt: FieldRef<"SupplierPaymentSettlement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SupplierPaymentSettlement findUnique
   */
  export type SupplierPaymentSettlementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierPaymentSettlement
     */
    select?: SupplierPaymentSettlementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierPaymentSettlement
     */
    omit?: SupplierPaymentSettlementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierPaymentSettlementInclude<ExtArgs> | null
    /**
     * Filter, which SupplierPaymentSettlement to fetch.
     */
    where: SupplierPaymentSettlementWhereUniqueInput
  }

  /**
   * SupplierPaymentSettlement findUniqueOrThrow
   */
  export type SupplierPaymentSettlementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierPaymentSettlement
     */
    select?: SupplierPaymentSettlementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierPaymentSettlement
     */
    omit?: SupplierPaymentSettlementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierPaymentSettlementInclude<ExtArgs> | null
    /**
     * Filter, which SupplierPaymentSettlement to fetch.
     */
    where: SupplierPaymentSettlementWhereUniqueInput
  }

  /**
   * SupplierPaymentSettlement findFirst
   */
  export type SupplierPaymentSettlementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierPaymentSettlement
     */
    select?: SupplierPaymentSettlementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierPaymentSettlement
     */
    omit?: SupplierPaymentSettlementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierPaymentSettlementInclude<ExtArgs> | null
    /**
     * Filter, which SupplierPaymentSettlement to fetch.
     */
    where?: SupplierPaymentSettlementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupplierPaymentSettlements to fetch.
     */
    orderBy?: SupplierPaymentSettlementOrderByWithRelationInput | SupplierPaymentSettlementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SupplierPaymentSettlements.
     */
    cursor?: SupplierPaymentSettlementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupplierPaymentSettlements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupplierPaymentSettlements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SupplierPaymentSettlements.
     */
    distinct?: SupplierPaymentSettlementScalarFieldEnum | SupplierPaymentSettlementScalarFieldEnum[]
  }

  /**
   * SupplierPaymentSettlement findFirstOrThrow
   */
  export type SupplierPaymentSettlementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierPaymentSettlement
     */
    select?: SupplierPaymentSettlementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierPaymentSettlement
     */
    omit?: SupplierPaymentSettlementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierPaymentSettlementInclude<ExtArgs> | null
    /**
     * Filter, which SupplierPaymentSettlement to fetch.
     */
    where?: SupplierPaymentSettlementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupplierPaymentSettlements to fetch.
     */
    orderBy?: SupplierPaymentSettlementOrderByWithRelationInput | SupplierPaymentSettlementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SupplierPaymentSettlements.
     */
    cursor?: SupplierPaymentSettlementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupplierPaymentSettlements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupplierPaymentSettlements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SupplierPaymentSettlements.
     */
    distinct?: SupplierPaymentSettlementScalarFieldEnum | SupplierPaymentSettlementScalarFieldEnum[]
  }

  /**
   * SupplierPaymentSettlement findMany
   */
  export type SupplierPaymentSettlementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierPaymentSettlement
     */
    select?: SupplierPaymentSettlementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierPaymentSettlement
     */
    omit?: SupplierPaymentSettlementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierPaymentSettlementInclude<ExtArgs> | null
    /**
     * Filter, which SupplierPaymentSettlements to fetch.
     */
    where?: SupplierPaymentSettlementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupplierPaymentSettlements to fetch.
     */
    orderBy?: SupplierPaymentSettlementOrderByWithRelationInput | SupplierPaymentSettlementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SupplierPaymentSettlements.
     */
    cursor?: SupplierPaymentSettlementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupplierPaymentSettlements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupplierPaymentSettlements.
     */
    skip?: number
    distinct?: SupplierPaymentSettlementScalarFieldEnum | SupplierPaymentSettlementScalarFieldEnum[]
  }

  /**
   * SupplierPaymentSettlement create
   */
  export type SupplierPaymentSettlementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierPaymentSettlement
     */
    select?: SupplierPaymentSettlementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierPaymentSettlement
     */
    omit?: SupplierPaymentSettlementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierPaymentSettlementInclude<ExtArgs> | null
    /**
     * The data needed to create a SupplierPaymentSettlement.
     */
    data: XOR<SupplierPaymentSettlementCreateInput, SupplierPaymentSettlementUncheckedCreateInput>
  }

  /**
   * SupplierPaymentSettlement createMany
   */
  export type SupplierPaymentSettlementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SupplierPaymentSettlements.
     */
    data: SupplierPaymentSettlementCreateManyInput | SupplierPaymentSettlementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SupplierPaymentSettlement createManyAndReturn
   */
  export type SupplierPaymentSettlementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierPaymentSettlement
     */
    select?: SupplierPaymentSettlementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierPaymentSettlement
     */
    omit?: SupplierPaymentSettlementOmit<ExtArgs> | null
    /**
     * The data used to create many SupplierPaymentSettlements.
     */
    data: SupplierPaymentSettlementCreateManyInput | SupplierPaymentSettlementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierPaymentSettlementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SupplierPaymentSettlement update
   */
  export type SupplierPaymentSettlementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierPaymentSettlement
     */
    select?: SupplierPaymentSettlementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierPaymentSettlement
     */
    omit?: SupplierPaymentSettlementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierPaymentSettlementInclude<ExtArgs> | null
    /**
     * The data needed to update a SupplierPaymentSettlement.
     */
    data: XOR<SupplierPaymentSettlementUpdateInput, SupplierPaymentSettlementUncheckedUpdateInput>
    /**
     * Choose, which SupplierPaymentSettlement to update.
     */
    where: SupplierPaymentSettlementWhereUniqueInput
  }

  /**
   * SupplierPaymentSettlement updateMany
   */
  export type SupplierPaymentSettlementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SupplierPaymentSettlements.
     */
    data: XOR<SupplierPaymentSettlementUpdateManyMutationInput, SupplierPaymentSettlementUncheckedUpdateManyInput>
    /**
     * Filter which SupplierPaymentSettlements to update
     */
    where?: SupplierPaymentSettlementWhereInput
    /**
     * Limit how many SupplierPaymentSettlements to update.
     */
    limit?: number
  }

  /**
   * SupplierPaymentSettlement updateManyAndReturn
   */
  export type SupplierPaymentSettlementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierPaymentSettlement
     */
    select?: SupplierPaymentSettlementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierPaymentSettlement
     */
    omit?: SupplierPaymentSettlementOmit<ExtArgs> | null
    /**
     * The data used to update SupplierPaymentSettlements.
     */
    data: XOR<SupplierPaymentSettlementUpdateManyMutationInput, SupplierPaymentSettlementUncheckedUpdateManyInput>
    /**
     * Filter which SupplierPaymentSettlements to update
     */
    where?: SupplierPaymentSettlementWhereInput
    /**
     * Limit how many SupplierPaymentSettlements to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierPaymentSettlementIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SupplierPaymentSettlement upsert
   */
  export type SupplierPaymentSettlementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierPaymentSettlement
     */
    select?: SupplierPaymentSettlementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierPaymentSettlement
     */
    omit?: SupplierPaymentSettlementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierPaymentSettlementInclude<ExtArgs> | null
    /**
     * The filter to search for the SupplierPaymentSettlement to update in case it exists.
     */
    where: SupplierPaymentSettlementWhereUniqueInput
    /**
     * In case the SupplierPaymentSettlement found by the `where` argument doesn't exist, create a new SupplierPaymentSettlement with this data.
     */
    create: XOR<SupplierPaymentSettlementCreateInput, SupplierPaymentSettlementUncheckedCreateInput>
    /**
     * In case the SupplierPaymentSettlement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SupplierPaymentSettlementUpdateInput, SupplierPaymentSettlementUncheckedUpdateInput>
  }

  /**
   * SupplierPaymentSettlement delete
   */
  export type SupplierPaymentSettlementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierPaymentSettlement
     */
    select?: SupplierPaymentSettlementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierPaymentSettlement
     */
    omit?: SupplierPaymentSettlementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierPaymentSettlementInclude<ExtArgs> | null
    /**
     * Filter which SupplierPaymentSettlement to delete.
     */
    where: SupplierPaymentSettlementWhereUniqueInput
  }

  /**
   * SupplierPaymentSettlement deleteMany
   */
  export type SupplierPaymentSettlementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SupplierPaymentSettlements to delete
     */
    where?: SupplierPaymentSettlementWhereInput
    /**
     * Limit how many SupplierPaymentSettlements to delete.
     */
    limit?: number
  }

  /**
   * SupplierPaymentSettlement without action
   */
  export type SupplierPaymentSettlementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierPaymentSettlement
     */
    select?: SupplierPaymentSettlementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierPaymentSettlement
     */
    omit?: SupplierPaymentSettlementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierPaymentSettlementInclude<ExtArgs> | null
  }


  /**
   * Model Cancellation
   */

  export type AggregateCancellation = {
    _count: CancellationCountAggregateOutputType | null
    _avg: CancellationAvgAggregateOutputType | null
    _sum: CancellationSumAggregateOutputType | null
    _min: CancellationMinAggregateOutputType | null
    _max: CancellationMaxAggregateOutputType | null
  }

  export type CancellationAvgAggregateOutputType = {
    id: number | null
    originalBookingId: number | null
    originalRevenue: number | null
    originalProdCost: number | null
    supplierCancellationFee: number | null
    refundToPassenger: number | null
    adminFee: number | null
    creditNoteAmount: number | null
    profitOrLoss: number | null
  }

  export type CancellationSumAggregateOutputType = {
    id: number | null
    originalBookingId: number | null
    originalRevenue: number | null
    originalProdCost: number | null
    supplierCancellationFee: number | null
    refundToPassenger: number | null
    adminFee: number | null
    creditNoteAmount: number | null
    profitOrLoss: number | null
  }

  export type CancellationMinAggregateOutputType = {
    id: number | null
    originalBookingId: number | null
    folderNo: string | null
    refundTransactionMethod: string | null
    originalRevenue: number | null
    originalProdCost: number | null
    supplierCancellationFee: number | null
    refundToPassenger: number | null
    adminFee: number | null
    refundStatus: string | null
    creditNoteAmount: number | null
    profitOrLoss: number | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CancellationMaxAggregateOutputType = {
    id: number | null
    originalBookingId: number | null
    folderNo: string | null
    refundTransactionMethod: string | null
    originalRevenue: number | null
    originalProdCost: number | null
    supplierCancellationFee: number | null
    refundToPassenger: number | null
    adminFee: number | null
    refundStatus: string | null
    creditNoteAmount: number | null
    profitOrLoss: number | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CancellationCountAggregateOutputType = {
    id: number
    originalBookingId: number
    folderNo: number
    refundTransactionMethod: number
    originalRevenue: number
    originalProdCost: number
    supplierCancellationFee: number
    refundToPassenger: number
    adminFee: number
    refundStatus: number
    creditNoteAmount: number
    profitOrLoss: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CancellationAvgAggregateInputType = {
    id?: true
    originalBookingId?: true
    originalRevenue?: true
    originalProdCost?: true
    supplierCancellationFee?: true
    refundToPassenger?: true
    adminFee?: true
    creditNoteAmount?: true
    profitOrLoss?: true
  }

  export type CancellationSumAggregateInputType = {
    id?: true
    originalBookingId?: true
    originalRevenue?: true
    originalProdCost?: true
    supplierCancellationFee?: true
    refundToPassenger?: true
    adminFee?: true
    creditNoteAmount?: true
    profitOrLoss?: true
  }

  export type CancellationMinAggregateInputType = {
    id?: true
    originalBookingId?: true
    folderNo?: true
    refundTransactionMethod?: true
    originalRevenue?: true
    originalProdCost?: true
    supplierCancellationFee?: true
    refundToPassenger?: true
    adminFee?: true
    refundStatus?: true
    creditNoteAmount?: true
    profitOrLoss?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CancellationMaxAggregateInputType = {
    id?: true
    originalBookingId?: true
    folderNo?: true
    refundTransactionMethod?: true
    originalRevenue?: true
    originalProdCost?: true
    supplierCancellationFee?: true
    refundToPassenger?: true
    adminFee?: true
    refundStatus?: true
    creditNoteAmount?: true
    profitOrLoss?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CancellationCountAggregateInputType = {
    id?: true
    originalBookingId?: true
    folderNo?: true
    refundTransactionMethod?: true
    originalRevenue?: true
    originalProdCost?: true
    supplierCancellationFee?: true
    refundToPassenger?: true
    adminFee?: true
    refundStatus?: true
    creditNoteAmount?: true
    profitOrLoss?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CancellationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cancellation to aggregate.
     */
    where?: CancellationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cancellations to fetch.
     */
    orderBy?: CancellationOrderByWithRelationInput | CancellationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CancellationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cancellations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cancellations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Cancellations
    **/
    _count?: true | CancellationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CancellationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CancellationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CancellationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CancellationMaxAggregateInputType
  }

  export type GetCancellationAggregateType<T extends CancellationAggregateArgs> = {
        [P in keyof T & keyof AggregateCancellation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCancellation[P]>
      : GetScalarType<T[P], AggregateCancellation[P]>
  }




  export type CancellationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CancellationWhereInput
    orderBy?: CancellationOrderByWithAggregationInput | CancellationOrderByWithAggregationInput[]
    by: CancellationScalarFieldEnum[] | CancellationScalarFieldEnum
    having?: CancellationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CancellationCountAggregateInputType | true
    _avg?: CancellationAvgAggregateInputType
    _sum?: CancellationSumAggregateInputType
    _min?: CancellationMinAggregateInputType
    _max?: CancellationMaxAggregateInputType
  }

  export type CancellationGroupByOutputType = {
    id: number
    originalBookingId: number
    folderNo: string
    refundTransactionMethod: string
    originalRevenue: number
    originalProdCost: number
    supplierCancellationFee: number
    refundToPassenger: number
    adminFee: number
    refundStatus: string
    creditNoteAmount: number | null
    profitOrLoss: number
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: CancellationCountAggregateOutputType | null
    _avg: CancellationAvgAggregateOutputType | null
    _sum: CancellationSumAggregateOutputType | null
    _min: CancellationMinAggregateOutputType | null
    _max: CancellationMaxAggregateOutputType | null
  }

  type GetCancellationGroupByPayload<T extends CancellationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CancellationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CancellationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CancellationGroupByOutputType[P]>
            : GetScalarType<T[P], CancellationGroupByOutputType[P]>
        }
      >
    >


  export type CancellationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    originalBookingId?: boolean
    folderNo?: boolean
    refundTransactionMethod?: boolean
    originalRevenue?: boolean
    originalProdCost?: boolean
    supplierCancellationFee?: boolean
    refundToPassenger?: boolean
    adminFee?: boolean
    refundStatus?: boolean
    creditNoteAmount?: boolean
    profitOrLoss?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    originalBooking?: boolean | BookingDefaultArgs<ExtArgs>
    refundPayment?: boolean | Cancellation$refundPaymentArgs<ExtArgs>
    createdCustomerPayable?: boolean | Cancellation$createdCustomerPayableArgs<ExtArgs>
    createdPayable?: boolean | Cancellation$createdPayableArgs<ExtArgs>
    generatedCreditNote?: boolean | Cancellation$generatedCreditNoteArgs<ExtArgs>
  }, ExtArgs["result"]["cancellation"]>

  export type CancellationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    originalBookingId?: boolean
    folderNo?: boolean
    refundTransactionMethod?: boolean
    originalRevenue?: boolean
    originalProdCost?: boolean
    supplierCancellationFee?: boolean
    refundToPassenger?: boolean
    adminFee?: boolean
    refundStatus?: boolean
    creditNoteAmount?: boolean
    profitOrLoss?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    originalBooking?: boolean | BookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cancellation"]>

  export type CancellationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    originalBookingId?: boolean
    folderNo?: boolean
    refundTransactionMethod?: boolean
    originalRevenue?: boolean
    originalProdCost?: boolean
    supplierCancellationFee?: boolean
    refundToPassenger?: boolean
    adminFee?: boolean
    refundStatus?: boolean
    creditNoteAmount?: boolean
    profitOrLoss?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    originalBooking?: boolean | BookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cancellation"]>

  export type CancellationSelectScalar = {
    id?: boolean
    originalBookingId?: boolean
    folderNo?: boolean
    refundTransactionMethod?: boolean
    originalRevenue?: boolean
    originalProdCost?: boolean
    supplierCancellationFee?: boolean
    refundToPassenger?: boolean
    adminFee?: boolean
    refundStatus?: boolean
    creditNoteAmount?: boolean
    profitOrLoss?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CancellationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "originalBookingId" | "folderNo" | "refundTransactionMethod" | "originalRevenue" | "originalProdCost" | "supplierCancellationFee" | "refundToPassenger" | "adminFee" | "refundStatus" | "creditNoteAmount" | "profitOrLoss" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["cancellation"]>
  export type CancellationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    originalBooking?: boolean | BookingDefaultArgs<ExtArgs>
    refundPayment?: boolean | Cancellation$refundPaymentArgs<ExtArgs>
    createdCustomerPayable?: boolean | Cancellation$createdCustomerPayableArgs<ExtArgs>
    createdPayable?: boolean | Cancellation$createdPayableArgs<ExtArgs>
    generatedCreditNote?: boolean | Cancellation$generatedCreditNoteArgs<ExtArgs>
  }
  export type CancellationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    originalBooking?: boolean | BookingDefaultArgs<ExtArgs>
  }
  export type CancellationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    originalBooking?: boolean | BookingDefaultArgs<ExtArgs>
  }

  export type $CancellationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Cancellation"
    objects: {
      originalBooking: Prisma.$BookingPayload<ExtArgs>
      refundPayment: Prisma.$PassengerRefundPaymentPayload<ExtArgs> | null
      createdCustomerPayable: Prisma.$CustomerPayablePayload<ExtArgs> | null
      createdPayable: Prisma.$SupplierPayablePayload<ExtArgs> | null
      generatedCreditNote: Prisma.$SupplierCreditNotePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      originalBookingId: number
      folderNo: string
      refundTransactionMethod: string
      originalRevenue: number
      originalProdCost: number
      supplierCancellationFee: number
      refundToPassenger: number
      adminFee: number
      refundStatus: string
      creditNoteAmount: number | null
      profitOrLoss: number
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cancellation"]>
    composites: {}
  }

  type CancellationGetPayload<S extends boolean | null | undefined | CancellationDefaultArgs> = $Result.GetResult<Prisma.$CancellationPayload, S>

  type CancellationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CancellationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CancellationCountAggregateInputType | true
    }

  export interface CancellationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Cancellation'], meta: { name: 'Cancellation' } }
    /**
     * Find zero or one Cancellation that matches the filter.
     * @param {CancellationFindUniqueArgs} args - Arguments to find a Cancellation
     * @example
     * // Get one Cancellation
     * const cancellation = await prisma.cancellation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CancellationFindUniqueArgs>(args: SelectSubset<T, CancellationFindUniqueArgs<ExtArgs>>): Prisma__CancellationClient<$Result.GetResult<Prisma.$CancellationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Cancellation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CancellationFindUniqueOrThrowArgs} args - Arguments to find a Cancellation
     * @example
     * // Get one Cancellation
     * const cancellation = await prisma.cancellation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CancellationFindUniqueOrThrowArgs>(args: SelectSubset<T, CancellationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CancellationClient<$Result.GetResult<Prisma.$CancellationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cancellation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CancellationFindFirstArgs} args - Arguments to find a Cancellation
     * @example
     * // Get one Cancellation
     * const cancellation = await prisma.cancellation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CancellationFindFirstArgs>(args?: SelectSubset<T, CancellationFindFirstArgs<ExtArgs>>): Prisma__CancellationClient<$Result.GetResult<Prisma.$CancellationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cancellation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CancellationFindFirstOrThrowArgs} args - Arguments to find a Cancellation
     * @example
     * // Get one Cancellation
     * const cancellation = await prisma.cancellation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CancellationFindFirstOrThrowArgs>(args?: SelectSubset<T, CancellationFindFirstOrThrowArgs<ExtArgs>>): Prisma__CancellationClient<$Result.GetResult<Prisma.$CancellationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Cancellations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CancellationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cancellations
     * const cancellations = await prisma.cancellation.findMany()
     * 
     * // Get first 10 Cancellations
     * const cancellations = await prisma.cancellation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cancellationWithIdOnly = await prisma.cancellation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CancellationFindManyArgs>(args?: SelectSubset<T, CancellationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CancellationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Cancellation.
     * @param {CancellationCreateArgs} args - Arguments to create a Cancellation.
     * @example
     * // Create one Cancellation
     * const Cancellation = await prisma.cancellation.create({
     *   data: {
     *     // ... data to create a Cancellation
     *   }
     * })
     * 
     */
    create<T extends CancellationCreateArgs>(args: SelectSubset<T, CancellationCreateArgs<ExtArgs>>): Prisma__CancellationClient<$Result.GetResult<Prisma.$CancellationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Cancellations.
     * @param {CancellationCreateManyArgs} args - Arguments to create many Cancellations.
     * @example
     * // Create many Cancellations
     * const cancellation = await prisma.cancellation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CancellationCreateManyArgs>(args?: SelectSubset<T, CancellationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Cancellations and returns the data saved in the database.
     * @param {CancellationCreateManyAndReturnArgs} args - Arguments to create many Cancellations.
     * @example
     * // Create many Cancellations
     * const cancellation = await prisma.cancellation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Cancellations and only return the `id`
     * const cancellationWithIdOnly = await prisma.cancellation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CancellationCreateManyAndReturnArgs>(args?: SelectSubset<T, CancellationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CancellationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Cancellation.
     * @param {CancellationDeleteArgs} args - Arguments to delete one Cancellation.
     * @example
     * // Delete one Cancellation
     * const Cancellation = await prisma.cancellation.delete({
     *   where: {
     *     // ... filter to delete one Cancellation
     *   }
     * })
     * 
     */
    delete<T extends CancellationDeleteArgs>(args: SelectSubset<T, CancellationDeleteArgs<ExtArgs>>): Prisma__CancellationClient<$Result.GetResult<Prisma.$CancellationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Cancellation.
     * @param {CancellationUpdateArgs} args - Arguments to update one Cancellation.
     * @example
     * // Update one Cancellation
     * const cancellation = await prisma.cancellation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CancellationUpdateArgs>(args: SelectSubset<T, CancellationUpdateArgs<ExtArgs>>): Prisma__CancellationClient<$Result.GetResult<Prisma.$CancellationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Cancellations.
     * @param {CancellationDeleteManyArgs} args - Arguments to filter Cancellations to delete.
     * @example
     * // Delete a few Cancellations
     * const { count } = await prisma.cancellation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CancellationDeleteManyArgs>(args?: SelectSubset<T, CancellationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cancellations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CancellationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cancellations
     * const cancellation = await prisma.cancellation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CancellationUpdateManyArgs>(args: SelectSubset<T, CancellationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cancellations and returns the data updated in the database.
     * @param {CancellationUpdateManyAndReturnArgs} args - Arguments to update many Cancellations.
     * @example
     * // Update many Cancellations
     * const cancellation = await prisma.cancellation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Cancellations and only return the `id`
     * const cancellationWithIdOnly = await prisma.cancellation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CancellationUpdateManyAndReturnArgs>(args: SelectSubset<T, CancellationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CancellationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Cancellation.
     * @param {CancellationUpsertArgs} args - Arguments to update or create a Cancellation.
     * @example
     * // Update or create a Cancellation
     * const cancellation = await prisma.cancellation.upsert({
     *   create: {
     *     // ... data to create a Cancellation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cancellation we want to update
     *   }
     * })
     */
    upsert<T extends CancellationUpsertArgs>(args: SelectSubset<T, CancellationUpsertArgs<ExtArgs>>): Prisma__CancellationClient<$Result.GetResult<Prisma.$CancellationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Cancellations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CancellationCountArgs} args - Arguments to filter Cancellations to count.
     * @example
     * // Count the number of Cancellations
     * const count = await prisma.cancellation.count({
     *   where: {
     *     // ... the filter for the Cancellations we want to count
     *   }
     * })
    **/
    count<T extends CancellationCountArgs>(
      args?: Subset<T, CancellationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CancellationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cancellation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CancellationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CancellationAggregateArgs>(args: Subset<T, CancellationAggregateArgs>): Prisma.PrismaPromise<GetCancellationAggregateType<T>>

    /**
     * Group by Cancellation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CancellationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CancellationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CancellationGroupByArgs['orderBy'] }
        : { orderBy?: CancellationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CancellationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCancellationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Cancellation model
   */
  readonly fields: CancellationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Cancellation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CancellationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    originalBooking<T extends BookingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BookingDefaultArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    refundPayment<T extends Cancellation$refundPaymentArgs<ExtArgs> = {}>(args?: Subset<T, Cancellation$refundPaymentArgs<ExtArgs>>): Prisma__PassengerRefundPaymentClient<$Result.GetResult<Prisma.$PassengerRefundPaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    createdCustomerPayable<T extends Cancellation$createdCustomerPayableArgs<ExtArgs> = {}>(args?: Subset<T, Cancellation$createdCustomerPayableArgs<ExtArgs>>): Prisma__CustomerPayableClient<$Result.GetResult<Prisma.$CustomerPayablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    createdPayable<T extends Cancellation$createdPayableArgs<ExtArgs> = {}>(args?: Subset<T, Cancellation$createdPayableArgs<ExtArgs>>): Prisma__SupplierPayableClient<$Result.GetResult<Prisma.$SupplierPayablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    generatedCreditNote<T extends Cancellation$generatedCreditNoteArgs<ExtArgs> = {}>(args?: Subset<T, Cancellation$generatedCreditNoteArgs<ExtArgs>>): Prisma__SupplierCreditNoteClient<$Result.GetResult<Prisma.$SupplierCreditNotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Cancellation model
   */
  interface CancellationFieldRefs {
    readonly id: FieldRef<"Cancellation", 'Int'>
    readonly originalBookingId: FieldRef<"Cancellation", 'Int'>
    readonly folderNo: FieldRef<"Cancellation", 'String'>
    readonly refundTransactionMethod: FieldRef<"Cancellation", 'String'>
    readonly originalRevenue: FieldRef<"Cancellation", 'Float'>
    readonly originalProdCost: FieldRef<"Cancellation", 'Float'>
    readonly supplierCancellationFee: FieldRef<"Cancellation", 'Float'>
    readonly refundToPassenger: FieldRef<"Cancellation", 'Float'>
    readonly adminFee: FieldRef<"Cancellation", 'Float'>
    readonly refundStatus: FieldRef<"Cancellation", 'String'>
    readonly creditNoteAmount: FieldRef<"Cancellation", 'Float'>
    readonly profitOrLoss: FieldRef<"Cancellation", 'Float'>
    readonly description: FieldRef<"Cancellation", 'String'>
    readonly createdAt: FieldRef<"Cancellation", 'DateTime'>
    readonly updatedAt: FieldRef<"Cancellation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Cancellation findUnique
   */
  export type CancellationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cancellation
     */
    select?: CancellationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cancellation
     */
    omit?: CancellationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CancellationInclude<ExtArgs> | null
    /**
     * Filter, which Cancellation to fetch.
     */
    where: CancellationWhereUniqueInput
  }

  /**
   * Cancellation findUniqueOrThrow
   */
  export type CancellationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cancellation
     */
    select?: CancellationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cancellation
     */
    omit?: CancellationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CancellationInclude<ExtArgs> | null
    /**
     * Filter, which Cancellation to fetch.
     */
    where: CancellationWhereUniqueInput
  }

  /**
   * Cancellation findFirst
   */
  export type CancellationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cancellation
     */
    select?: CancellationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cancellation
     */
    omit?: CancellationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CancellationInclude<ExtArgs> | null
    /**
     * Filter, which Cancellation to fetch.
     */
    where?: CancellationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cancellations to fetch.
     */
    orderBy?: CancellationOrderByWithRelationInput | CancellationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cancellations.
     */
    cursor?: CancellationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cancellations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cancellations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cancellations.
     */
    distinct?: CancellationScalarFieldEnum | CancellationScalarFieldEnum[]
  }

  /**
   * Cancellation findFirstOrThrow
   */
  export type CancellationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cancellation
     */
    select?: CancellationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cancellation
     */
    omit?: CancellationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CancellationInclude<ExtArgs> | null
    /**
     * Filter, which Cancellation to fetch.
     */
    where?: CancellationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cancellations to fetch.
     */
    orderBy?: CancellationOrderByWithRelationInput | CancellationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cancellations.
     */
    cursor?: CancellationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cancellations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cancellations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cancellations.
     */
    distinct?: CancellationScalarFieldEnum | CancellationScalarFieldEnum[]
  }

  /**
   * Cancellation findMany
   */
  export type CancellationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cancellation
     */
    select?: CancellationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cancellation
     */
    omit?: CancellationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CancellationInclude<ExtArgs> | null
    /**
     * Filter, which Cancellations to fetch.
     */
    where?: CancellationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cancellations to fetch.
     */
    orderBy?: CancellationOrderByWithRelationInput | CancellationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Cancellations.
     */
    cursor?: CancellationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cancellations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cancellations.
     */
    skip?: number
    distinct?: CancellationScalarFieldEnum | CancellationScalarFieldEnum[]
  }

  /**
   * Cancellation create
   */
  export type CancellationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cancellation
     */
    select?: CancellationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cancellation
     */
    omit?: CancellationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CancellationInclude<ExtArgs> | null
    /**
     * The data needed to create a Cancellation.
     */
    data: XOR<CancellationCreateInput, CancellationUncheckedCreateInput>
  }

  /**
   * Cancellation createMany
   */
  export type CancellationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Cancellations.
     */
    data: CancellationCreateManyInput | CancellationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Cancellation createManyAndReturn
   */
  export type CancellationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cancellation
     */
    select?: CancellationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Cancellation
     */
    omit?: CancellationOmit<ExtArgs> | null
    /**
     * The data used to create many Cancellations.
     */
    data: CancellationCreateManyInput | CancellationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CancellationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Cancellation update
   */
  export type CancellationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cancellation
     */
    select?: CancellationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cancellation
     */
    omit?: CancellationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CancellationInclude<ExtArgs> | null
    /**
     * The data needed to update a Cancellation.
     */
    data: XOR<CancellationUpdateInput, CancellationUncheckedUpdateInput>
    /**
     * Choose, which Cancellation to update.
     */
    where: CancellationWhereUniqueInput
  }

  /**
   * Cancellation updateMany
   */
  export type CancellationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Cancellations.
     */
    data: XOR<CancellationUpdateManyMutationInput, CancellationUncheckedUpdateManyInput>
    /**
     * Filter which Cancellations to update
     */
    where?: CancellationWhereInput
    /**
     * Limit how many Cancellations to update.
     */
    limit?: number
  }

  /**
   * Cancellation updateManyAndReturn
   */
  export type CancellationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cancellation
     */
    select?: CancellationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Cancellation
     */
    omit?: CancellationOmit<ExtArgs> | null
    /**
     * The data used to update Cancellations.
     */
    data: XOR<CancellationUpdateManyMutationInput, CancellationUncheckedUpdateManyInput>
    /**
     * Filter which Cancellations to update
     */
    where?: CancellationWhereInput
    /**
     * Limit how many Cancellations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CancellationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Cancellation upsert
   */
  export type CancellationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cancellation
     */
    select?: CancellationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cancellation
     */
    omit?: CancellationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CancellationInclude<ExtArgs> | null
    /**
     * The filter to search for the Cancellation to update in case it exists.
     */
    where: CancellationWhereUniqueInput
    /**
     * In case the Cancellation found by the `where` argument doesn't exist, create a new Cancellation with this data.
     */
    create: XOR<CancellationCreateInput, CancellationUncheckedCreateInput>
    /**
     * In case the Cancellation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CancellationUpdateInput, CancellationUncheckedUpdateInput>
  }

  /**
   * Cancellation delete
   */
  export type CancellationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cancellation
     */
    select?: CancellationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cancellation
     */
    omit?: CancellationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CancellationInclude<ExtArgs> | null
    /**
     * Filter which Cancellation to delete.
     */
    where: CancellationWhereUniqueInput
  }

  /**
   * Cancellation deleteMany
   */
  export type CancellationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Cancellations to delete
     */
    where?: CancellationWhereInput
    /**
     * Limit how many Cancellations to delete.
     */
    limit?: number
  }

  /**
   * Cancellation.refundPayment
   */
  export type Cancellation$refundPaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PassengerRefundPayment
     */
    select?: PassengerRefundPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PassengerRefundPayment
     */
    omit?: PassengerRefundPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PassengerRefundPaymentInclude<ExtArgs> | null
    where?: PassengerRefundPaymentWhereInput
  }

  /**
   * Cancellation.createdCustomerPayable
   */
  export type Cancellation$createdCustomerPayableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPayable
     */
    select?: CustomerPayableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPayable
     */
    omit?: CustomerPayableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPayableInclude<ExtArgs> | null
    where?: CustomerPayableWhereInput
  }

  /**
   * Cancellation.createdPayable
   */
  export type Cancellation$createdPayableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierPayable
     */
    select?: SupplierPayableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierPayable
     */
    omit?: SupplierPayableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierPayableInclude<ExtArgs> | null
    where?: SupplierPayableWhereInput
  }

  /**
   * Cancellation.generatedCreditNote
   */
  export type Cancellation$generatedCreditNoteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierCreditNote
     */
    select?: SupplierCreditNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierCreditNote
     */
    omit?: SupplierCreditNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierCreditNoteInclude<ExtArgs> | null
    where?: SupplierCreditNoteWhereInput
  }

  /**
   * Cancellation without action
   */
  export type CancellationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Cancellation
     */
    select?: CancellationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Cancellation
     */
    omit?: CancellationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CancellationInclude<ExtArgs> | null
  }


  /**
   * Model SupplierCreditNote
   */

  export type AggregateSupplierCreditNote = {
    _count: SupplierCreditNoteCountAggregateOutputType | null
    _avg: SupplierCreditNoteAvgAggregateOutputType | null
    _sum: SupplierCreditNoteSumAggregateOutputType | null
    _min: SupplierCreditNoteMinAggregateOutputType | null
    _max: SupplierCreditNoteMaxAggregateOutputType | null
  }

  export type SupplierCreditNoteAvgAggregateOutputType = {
    id: number | null
    initialAmount: number | null
    remainingAmount: number | null
    generatedFromCancellationId: number | null
  }

  export type SupplierCreditNoteSumAggregateOutputType = {
    id: number | null
    initialAmount: number | null
    remainingAmount: number | null
    generatedFromCancellationId: number | null
  }

  export type SupplierCreditNoteMinAggregateOutputType = {
    id: number | null
    supplier: $Enums.Suppliers | null
    initialAmount: number | null
    remainingAmount: number | null
    status: $Enums.CreditNoteStatus | null
    generatedFromCancellationId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SupplierCreditNoteMaxAggregateOutputType = {
    id: number | null
    supplier: $Enums.Suppliers | null
    initialAmount: number | null
    remainingAmount: number | null
    status: $Enums.CreditNoteStatus | null
    generatedFromCancellationId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SupplierCreditNoteCountAggregateOutputType = {
    id: number
    supplier: number
    initialAmount: number
    remainingAmount: number
    status: number
    generatedFromCancellationId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SupplierCreditNoteAvgAggregateInputType = {
    id?: true
    initialAmount?: true
    remainingAmount?: true
    generatedFromCancellationId?: true
  }

  export type SupplierCreditNoteSumAggregateInputType = {
    id?: true
    initialAmount?: true
    remainingAmount?: true
    generatedFromCancellationId?: true
  }

  export type SupplierCreditNoteMinAggregateInputType = {
    id?: true
    supplier?: true
    initialAmount?: true
    remainingAmount?: true
    status?: true
    generatedFromCancellationId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SupplierCreditNoteMaxAggregateInputType = {
    id?: true
    supplier?: true
    initialAmount?: true
    remainingAmount?: true
    status?: true
    generatedFromCancellationId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SupplierCreditNoteCountAggregateInputType = {
    id?: true
    supplier?: true
    initialAmount?: true
    remainingAmount?: true
    status?: true
    generatedFromCancellationId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SupplierCreditNoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SupplierCreditNote to aggregate.
     */
    where?: SupplierCreditNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupplierCreditNotes to fetch.
     */
    orderBy?: SupplierCreditNoteOrderByWithRelationInput | SupplierCreditNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SupplierCreditNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupplierCreditNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupplierCreditNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SupplierCreditNotes
    **/
    _count?: true | SupplierCreditNoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SupplierCreditNoteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SupplierCreditNoteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SupplierCreditNoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SupplierCreditNoteMaxAggregateInputType
  }

  export type GetSupplierCreditNoteAggregateType<T extends SupplierCreditNoteAggregateArgs> = {
        [P in keyof T & keyof AggregateSupplierCreditNote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupplierCreditNote[P]>
      : GetScalarType<T[P], AggregateSupplierCreditNote[P]>
  }




  export type SupplierCreditNoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplierCreditNoteWhereInput
    orderBy?: SupplierCreditNoteOrderByWithAggregationInput | SupplierCreditNoteOrderByWithAggregationInput[]
    by: SupplierCreditNoteScalarFieldEnum[] | SupplierCreditNoteScalarFieldEnum
    having?: SupplierCreditNoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SupplierCreditNoteCountAggregateInputType | true
    _avg?: SupplierCreditNoteAvgAggregateInputType
    _sum?: SupplierCreditNoteSumAggregateInputType
    _min?: SupplierCreditNoteMinAggregateInputType
    _max?: SupplierCreditNoteMaxAggregateInputType
  }

  export type SupplierCreditNoteGroupByOutputType = {
    id: number
    supplier: $Enums.Suppliers
    initialAmount: number
    remainingAmount: number
    status: $Enums.CreditNoteStatus
    generatedFromCancellationId: number
    createdAt: Date
    updatedAt: Date
    _count: SupplierCreditNoteCountAggregateOutputType | null
    _avg: SupplierCreditNoteAvgAggregateOutputType | null
    _sum: SupplierCreditNoteSumAggregateOutputType | null
    _min: SupplierCreditNoteMinAggregateOutputType | null
    _max: SupplierCreditNoteMaxAggregateOutputType | null
  }

  type GetSupplierCreditNoteGroupByPayload<T extends SupplierCreditNoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SupplierCreditNoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SupplierCreditNoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SupplierCreditNoteGroupByOutputType[P]>
            : GetScalarType<T[P], SupplierCreditNoteGroupByOutputType[P]>
        }
      >
    >


  export type SupplierCreditNoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    supplier?: boolean
    initialAmount?: boolean
    remainingAmount?: boolean
    status?: boolean
    generatedFromCancellationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    generatedFromCancellation?: boolean | CancellationDefaultArgs<ExtArgs>
    usageHistory?: boolean | SupplierCreditNote$usageHistoryArgs<ExtArgs>
    _count?: boolean | SupplierCreditNoteCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplierCreditNote"]>

  export type SupplierCreditNoteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    supplier?: boolean
    initialAmount?: boolean
    remainingAmount?: boolean
    status?: boolean
    generatedFromCancellationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    generatedFromCancellation?: boolean | CancellationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplierCreditNote"]>

  export type SupplierCreditNoteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    supplier?: boolean
    initialAmount?: boolean
    remainingAmount?: boolean
    status?: boolean
    generatedFromCancellationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    generatedFromCancellation?: boolean | CancellationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplierCreditNote"]>

  export type SupplierCreditNoteSelectScalar = {
    id?: boolean
    supplier?: boolean
    initialAmount?: boolean
    remainingAmount?: boolean
    status?: boolean
    generatedFromCancellationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SupplierCreditNoteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "supplier" | "initialAmount" | "remainingAmount" | "status" | "generatedFromCancellationId" | "createdAt" | "updatedAt", ExtArgs["result"]["supplierCreditNote"]>
  export type SupplierCreditNoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    generatedFromCancellation?: boolean | CancellationDefaultArgs<ExtArgs>
    usageHistory?: boolean | SupplierCreditNote$usageHistoryArgs<ExtArgs>
    _count?: boolean | SupplierCreditNoteCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SupplierCreditNoteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    generatedFromCancellation?: boolean | CancellationDefaultArgs<ExtArgs>
  }
  export type SupplierCreditNoteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    generatedFromCancellation?: boolean | CancellationDefaultArgs<ExtArgs>
  }

  export type $SupplierCreditNotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SupplierCreditNote"
    objects: {
      generatedFromCancellation: Prisma.$CancellationPayload<ExtArgs>
      usageHistory: Prisma.$CreditNoteUsagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      supplier: $Enums.Suppliers
      initialAmount: number
      remainingAmount: number
      status: $Enums.CreditNoteStatus
      generatedFromCancellationId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["supplierCreditNote"]>
    composites: {}
  }

  type SupplierCreditNoteGetPayload<S extends boolean | null | undefined | SupplierCreditNoteDefaultArgs> = $Result.GetResult<Prisma.$SupplierCreditNotePayload, S>

  type SupplierCreditNoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SupplierCreditNoteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SupplierCreditNoteCountAggregateInputType | true
    }

  export interface SupplierCreditNoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SupplierCreditNote'], meta: { name: 'SupplierCreditNote' } }
    /**
     * Find zero or one SupplierCreditNote that matches the filter.
     * @param {SupplierCreditNoteFindUniqueArgs} args - Arguments to find a SupplierCreditNote
     * @example
     * // Get one SupplierCreditNote
     * const supplierCreditNote = await prisma.supplierCreditNote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SupplierCreditNoteFindUniqueArgs>(args: SelectSubset<T, SupplierCreditNoteFindUniqueArgs<ExtArgs>>): Prisma__SupplierCreditNoteClient<$Result.GetResult<Prisma.$SupplierCreditNotePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SupplierCreditNote that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SupplierCreditNoteFindUniqueOrThrowArgs} args - Arguments to find a SupplierCreditNote
     * @example
     * // Get one SupplierCreditNote
     * const supplierCreditNote = await prisma.supplierCreditNote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SupplierCreditNoteFindUniqueOrThrowArgs>(args: SelectSubset<T, SupplierCreditNoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SupplierCreditNoteClient<$Result.GetResult<Prisma.$SupplierCreditNotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SupplierCreditNote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierCreditNoteFindFirstArgs} args - Arguments to find a SupplierCreditNote
     * @example
     * // Get one SupplierCreditNote
     * const supplierCreditNote = await prisma.supplierCreditNote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SupplierCreditNoteFindFirstArgs>(args?: SelectSubset<T, SupplierCreditNoteFindFirstArgs<ExtArgs>>): Prisma__SupplierCreditNoteClient<$Result.GetResult<Prisma.$SupplierCreditNotePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SupplierCreditNote that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierCreditNoteFindFirstOrThrowArgs} args - Arguments to find a SupplierCreditNote
     * @example
     * // Get one SupplierCreditNote
     * const supplierCreditNote = await prisma.supplierCreditNote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SupplierCreditNoteFindFirstOrThrowArgs>(args?: SelectSubset<T, SupplierCreditNoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__SupplierCreditNoteClient<$Result.GetResult<Prisma.$SupplierCreditNotePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SupplierCreditNotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierCreditNoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SupplierCreditNotes
     * const supplierCreditNotes = await prisma.supplierCreditNote.findMany()
     * 
     * // Get first 10 SupplierCreditNotes
     * const supplierCreditNotes = await prisma.supplierCreditNote.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const supplierCreditNoteWithIdOnly = await prisma.supplierCreditNote.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SupplierCreditNoteFindManyArgs>(args?: SelectSubset<T, SupplierCreditNoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierCreditNotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SupplierCreditNote.
     * @param {SupplierCreditNoteCreateArgs} args - Arguments to create a SupplierCreditNote.
     * @example
     * // Create one SupplierCreditNote
     * const SupplierCreditNote = await prisma.supplierCreditNote.create({
     *   data: {
     *     // ... data to create a SupplierCreditNote
     *   }
     * })
     * 
     */
    create<T extends SupplierCreditNoteCreateArgs>(args: SelectSubset<T, SupplierCreditNoteCreateArgs<ExtArgs>>): Prisma__SupplierCreditNoteClient<$Result.GetResult<Prisma.$SupplierCreditNotePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SupplierCreditNotes.
     * @param {SupplierCreditNoteCreateManyArgs} args - Arguments to create many SupplierCreditNotes.
     * @example
     * // Create many SupplierCreditNotes
     * const supplierCreditNote = await prisma.supplierCreditNote.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SupplierCreditNoteCreateManyArgs>(args?: SelectSubset<T, SupplierCreditNoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SupplierCreditNotes and returns the data saved in the database.
     * @param {SupplierCreditNoteCreateManyAndReturnArgs} args - Arguments to create many SupplierCreditNotes.
     * @example
     * // Create many SupplierCreditNotes
     * const supplierCreditNote = await prisma.supplierCreditNote.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SupplierCreditNotes and only return the `id`
     * const supplierCreditNoteWithIdOnly = await prisma.supplierCreditNote.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SupplierCreditNoteCreateManyAndReturnArgs>(args?: SelectSubset<T, SupplierCreditNoteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierCreditNotePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SupplierCreditNote.
     * @param {SupplierCreditNoteDeleteArgs} args - Arguments to delete one SupplierCreditNote.
     * @example
     * // Delete one SupplierCreditNote
     * const SupplierCreditNote = await prisma.supplierCreditNote.delete({
     *   where: {
     *     // ... filter to delete one SupplierCreditNote
     *   }
     * })
     * 
     */
    delete<T extends SupplierCreditNoteDeleteArgs>(args: SelectSubset<T, SupplierCreditNoteDeleteArgs<ExtArgs>>): Prisma__SupplierCreditNoteClient<$Result.GetResult<Prisma.$SupplierCreditNotePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SupplierCreditNote.
     * @param {SupplierCreditNoteUpdateArgs} args - Arguments to update one SupplierCreditNote.
     * @example
     * // Update one SupplierCreditNote
     * const supplierCreditNote = await prisma.supplierCreditNote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SupplierCreditNoteUpdateArgs>(args: SelectSubset<T, SupplierCreditNoteUpdateArgs<ExtArgs>>): Prisma__SupplierCreditNoteClient<$Result.GetResult<Prisma.$SupplierCreditNotePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SupplierCreditNotes.
     * @param {SupplierCreditNoteDeleteManyArgs} args - Arguments to filter SupplierCreditNotes to delete.
     * @example
     * // Delete a few SupplierCreditNotes
     * const { count } = await prisma.supplierCreditNote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SupplierCreditNoteDeleteManyArgs>(args?: SelectSubset<T, SupplierCreditNoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SupplierCreditNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierCreditNoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SupplierCreditNotes
     * const supplierCreditNote = await prisma.supplierCreditNote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SupplierCreditNoteUpdateManyArgs>(args: SelectSubset<T, SupplierCreditNoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SupplierCreditNotes and returns the data updated in the database.
     * @param {SupplierCreditNoteUpdateManyAndReturnArgs} args - Arguments to update many SupplierCreditNotes.
     * @example
     * // Update many SupplierCreditNotes
     * const supplierCreditNote = await prisma.supplierCreditNote.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SupplierCreditNotes and only return the `id`
     * const supplierCreditNoteWithIdOnly = await prisma.supplierCreditNote.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SupplierCreditNoteUpdateManyAndReturnArgs>(args: SelectSubset<T, SupplierCreditNoteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierCreditNotePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SupplierCreditNote.
     * @param {SupplierCreditNoteUpsertArgs} args - Arguments to update or create a SupplierCreditNote.
     * @example
     * // Update or create a SupplierCreditNote
     * const supplierCreditNote = await prisma.supplierCreditNote.upsert({
     *   create: {
     *     // ... data to create a SupplierCreditNote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SupplierCreditNote we want to update
     *   }
     * })
     */
    upsert<T extends SupplierCreditNoteUpsertArgs>(args: SelectSubset<T, SupplierCreditNoteUpsertArgs<ExtArgs>>): Prisma__SupplierCreditNoteClient<$Result.GetResult<Prisma.$SupplierCreditNotePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SupplierCreditNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierCreditNoteCountArgs} args - Arguments to filter SupplierCreditNotes to count.
     * @example
     * // Count the number of SupplierCreditNotes
     * const count = await prisma.supplierCreditNote.count({
     *   where: {
     *     // ... the filter for the SupplierCreditNotes we want to count
     *   }
     * })
    **/
    count<T extends SupplierCreditNoteCountArgs>(
      args?: Subset<T, SupplierCreditNoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupplierCreditNoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SupplierCreditNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierCreditNoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SupplierCreditNoteAggregateArgs>(args: Subset<T, SupplierCreditNoteAggregateArgs>): Prisma.PrismaPromise<GetSupplierCreditNoteAggregateType<T>>

    /**
     * Group by SupplierCreditNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierCreditNoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SupplierCreditNoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SupplierCreditNoteGroupByArgs['orderBy'] }
        : { orderBy?: SupplierCreditNoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SupplierCreditNoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupplierCreditNoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SupplierCreditNote model
   */
  readonly fields: SupplierCreditNoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SupplierCreditNote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SupplierCreditNoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    generatedFromCancellation<T extends CancellationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CancellationDefaultArgs<ExtArgs>>): Prisma__CancellationClient<$Result.GetResult<Prisma.$CancellationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    usageHistory<T extends SupplierCreditNote$usageHistoryArgs<ExtArgs> = {}>(args?: Subset<T, SupplierCreditNote$usageHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditNoteUsagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SupplierCreditNote model
   */
  interface SupplierCreditNoteFieldRefs {
    readonly id: FieldRef<"SupplierCreditNote", 'Int'>
    readonly supplier: FieldRef<"SupplierCreditNote", 'Suppliers'>
    readonly initialAmount: FieldRef<"SupplierCreditNote", 'Float'>
    readonly remainingAmount: FieldRef<"SupplierCreditNote", 'Float'>
    readonly status: FieldRef<"SupplierCreditNote", 'CreditNoteStatus'>
    readonly generatedFromCancellationId: FieldRef<"SupplierCreditNote", 'Int'>
    readonly createdAt: FieldRef<"SupplierCreditNote", 'DateTime'>
    readonly updatedAt: FieldRef<"SupplierCreditNote", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SupplierCreditNote findUnique
   */
  export type SupplierCreditNoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierCreditNote
     */
    select?: SupplierCreditNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierCreditNote
     */
    omit?: SupplierCreditNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierCreditNoteInclude<ExtArgs> | null
    /**
     * Filter, which SupplierCreditNote to fetch.
     */
    where: SupplierCreditNoteWhereUniqueInput
  }

  /**
   * SupplierCreditNote findUniqueOrThrow
   */
  export type SupplierCreditNoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierCreditNote
     */
    select?: SupplierCreditNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierCreditNote
     */
    omit?: SupplierCreditNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierCreditNoteInclude<ExtArgs> | null
    /**
     * Filter, which SupplierCreditNote to fetch.
     */
    where: SupplierCreditNoteWhereUniqueInput
  }

  /**
   * SupplierCreditNote findFirst
   */
  export type SupplierCreditNoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierCreditNote
     */
    select?: SupplierCreditNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierCreditNote
     */
    omit?: SupplierCreditNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierCreditNoteInclude<ExtArgs> | null
    /**
     * Filter, which SupplierCreditNote to fetch.
     */
    where?: SupplierCreditNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupplierCreditNotes to fetch.
     */
    orderBy?: SupplierCreditNoteOrderByWithRelationInput | SupplierCreditNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SupplierCreditNotes.
     */
    cursor?: SupplierCreditNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupplierCreditNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupplierCreditNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SupplierCreditNotes.
     */
    distinct?: SupplierCreditNoteScalarFieldEnum | SupplierCreditNoteScalarFieldEnum[]
  }

  /**
   * SupplierCreditNote findFirstOrThrow
   */
  export type SupplierCreditNoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierCreditNote
     */
    select?: SupplierCreditNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierCreditNote
     */
    omit?: SupplierCreditNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierCreditNoteInclude<ExtArgs> | null
    /**
     * Filter, which SupplierCreditNote to fetch.
     */
    where?: SupplierCreditNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupplierCreditNotes to fetch.
     */
    orderBy?: SupplierCreditNoteOrderByWithRelationInput | SupplierCreditNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SupplierCreditNotes.
     */
    cursor?: SupplierCreditNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupplierCreditNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupplierCreditNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SupplierCreditNotes.
     */
    distinct?: SupplierCreditNoteScalarFieldEnum | SupplierCreditNoteScalarFieldEnum[]
  }

  /**
   * SupplierCreditNote findMany
   */
  export type SupplierCreditNoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierCreditNote
     */
    select?: SupplierCreditNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierCreditNote
     */
    omit?: SupplierCreditNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierCreditNoteInclude<ExtArgs> | null
    /**
     * Filter, which SupplierCreditNotes to fetch.
     */
    where?: SupplierCreditNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupplierCreditNotes to fetch.
     */
    orderBy?: SupplierCreditNoteOrderByWithRelationInput | SupplierCreditNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SupplierCreditNotes.
     */
    cursor?: SupplierCreditNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupplierCreditNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupplierCreditNotes.
     */
    skip?: number
    distinct?: SupplierCreditNoteScalarFieldEnum | SupplierCreditNoteScalarFieldEnum[]
  }

  /**
   * SupplierCreditNote create
   */
  export type SupplierCreditNoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierCreditNote
     */
    select?: SupplierCreditNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierCreditNote
     */
    omit?: SupplierCreditNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierCreditNoteInclude<ExtArgs> | null
    /**
     * The data needed to create a SupplierCreditNote.
     */
    data: XOR<SupplierCreditNoteCreateInput, SupplierCreditNoteUncheckedCreateInput>
  }

  /**
   * SupplierCreditNote createMany
   */
  export type SupplierCreditNoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SupplierCreditNotes.
     */
    data: SupplierCreditNoteCreateManyInput | SupplierCreditNoteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SupplierCreditNote createManyAndReturn
   */
  export type SupplierCreditNoteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierCreditNote
     */
    select?: SupplierCreditNoteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierCreditNote
     */
    omit?: SupplierCreditNoteOmit<ExtArgs> | null
    /**
     * The data used to create many SupplierCreditNotes.
     */
    data: SupplierCreditNoteCreateManyInput | SupplierCreditNoteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierCreditNoteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SupplierCreditNote update
   */
  export type SupplierCreditNoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierCreditNote
     */
    select?: SupplierCreditNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierCreditNote
     */
    omit?: SupplierCreditNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierCreditNoteInclude<ExtArgs> | null
    /**
     * The data needed to update a SupplierCreditNote.
     */
    data: XOR<SupplierCreditNoteUpdateInput, SupplierCreditNoteUncheckedUpdateInput>
    /**
     * Choose, which SupplierCreditNote to update.
     */
    where: SupplierCreditNoteWhereUniqueInput
  }

  /**
   * SupplierCreditNote updateMany
   */
  export type SupplierCreditNoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SupplierCreditNotes.
     */
    data: XOR<SupplierCreditNoteUpdateManyMutationInput, SupplierCreditNoteUncheckedUpdateManyInput>
    /**
     * Filter which SupplierCreditNotes to update
     */
    where?: SupplierCreditNoteWhereInput
    /**
     * Limit how many SupplierCreditNotes to update.
     */
    limit?: number
  }

  /**
   * SupplierCreditNote updateManyAndReturn
   */
  export type SupplierCreditNoteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierCreditNote
     */
    select?: SupplierCreditNoteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierCreditNote
     */
    omit?: SupplierCreditNoteOmit<ExtArgs> | null
    /**
     * The data used to update SupplierCreditNotes.
     */
    data: XOR<SupplierCreditNoteUpdateManyMutationInput, SupplierCreditNoteUncheckedUpdateManyInput>
    /**
     * Filter which SupplierCreditNotes to update
     */
    where?: SupplierCreditNoteWhereInput
    /**
     * Limit how many SupplierCreditNotes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierCreditNoteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SupplierCreditNote upsert
   */
  export type SupplierCreditNoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierCreditNote
     */
    select?: SupplierCreditNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierCreditNote
     */
    omit?: SupplierCreditNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierCreditNoteInclude<ExtArgs> | null
    /**
     * The filter to search for the SupplierCreditNote to update in case it exists.
     */
    where: SupplierCreditNoteWhereUniqueInput
    /**
     * In case the SupplierCreditNote found by the `where` argument doesn't exist, create a new SupplierCreditNote with this data.
     */
    create: XOR<SupplierCreditNoteCreateInput, SupplierCreditNoteUncheckedCreateInput>
    /**
     * In case the SupplierCreditNote was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SupplierCreditNoteUpdateInput, SupplierCreditNoteUncheckedUpdateInput>
  }

  /**
   * SupplierCreditNote delete
   */
  export type SupplierCreditNoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierCreditNote
     */
    select?: SupplierCreditNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierCreditNote
     */
    omit?: SupplierCreditNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierCreditNoteInclude<ExtArgs> | null
    /**
     * Filter which SupplierCreditNote to delete.
     */
    where: SupplierCreditNoteWhereUniqueInput
  }

  /**
   * SupplierCreditNote deleteMany
   */
  export type SupplierCreditNoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SupplierCreditNotes to delete
     */
    where?: SupplierCreditNoteWhereInput
    /**
     * Limit how many SupplierCreditNotes to delete.
     */
    limit?: number
  }

  /**
   * SupplierCreditNote.usageHistory
   */
  export type SupplierCreditNote$usageHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditNoteUsage
     */
    select?: CreditNoteUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditNoteUsage
     */
    omit?: CreditNoteUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditNoteUsageInclude<ExtArgs> | null
    where?: CreditNoteUsageWhereInput
    orderBy?: CreditNoteUsageOrderByWithRelationInput | CreditNoteUsageOrderByWithRelationInput[]
    cursor?: CreditNoteUsageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CreditNoteUsageScalarFieldEnum | CreditNoteUsageScalarFieldEnum[]
  }

  /**
   * SupplierCreditNote without action
   */
  export type SupplierCreditNoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierCreditNote
     */
    select?: SupplierCreditNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierCreditNote
     */
    omit?: SupplierCreditNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierCreditNoteInclude<ExtArgs> | null
  }


  /**
   * Model CreditNoteUsage
   */

  export type AggregateCreditNoteUsage = {
    _count: CreditNoteUsageCountAggregateOutputType | null
    _avg: CreditNoteUsageAvgAggregateOutputType | null
    _sum: CreditNoteUsageSumAggregateOutputType | null
    _min: CreditNoteUsageMinAggregateOutputType | null
    _max: CreditNoteUsageMaxAggregateOutputType | null
  }

  export type CreditNoteUsageAvgAggregateOutputType = {
    id: number | null
    amountUsed: number | null
    creditNoteId: number | null
    usedOnCostItemSupplierId: number | null
  }

  export type CreditNoteUsageSumAggregateOutputType = {
    id: number | null
    amountUsed: number | null
    creditNoteId: number | null
    usedOnCostItemSupplierId: number | null
  }

  export type CreditNoteUsageMinAggregateOutputType = {
    id: number | null
    amountUsed: number | null
    usedAt: Date | null
    creditNoteId: number | null
    usedOnCostItemSupplierId: number | null
  }

  export type CreditNoteUsageMaxAggregateOutputType = {
    id: number | null
    amountUsed: number | null
    usedAt: Date | null
    creditNoteId: number | null
    usedOnCostItemSupplierId: number | null
  }

  export type CreditNoteUsageCountAggregateOutputType = {
    id: number
    amountUsed: number
    usedAt: number
    creditNoteId: number
    usedOnCostItemSupplierId: number
    _all: number
  }


  export type CreditNoteUsageAvgAggregateInputType = {
    id?: true
    amountUsed?: true
    creditNoteId?: true
    usedOnCostItemSupplierId?: true
  }

  export type CreditNoteUsageSumAggregateInputType = {
    id?: true
    amountUsed?: true
    creditNoteId?: true
    usedOnCostItemSupplierId?: true
  }

  export type CreditNoteUsageMinAggregateInputType = {
    id?: true
    amountUsed?: true
    usedAt?: true
    creditNoteId?: true
    usedOnCostItemSupplierId?: true
  }

  export type CreditNoteUsageMaxAggregateInputType = {
    id?: true
    amountUsed?: true
    usedAt?: true
    creditNoteId?: true
    usedOnCostItemSupplierId?: true
  }

  export type CreditNoteUsageCountAggregateInputType = {
    id?: true
    amountUsed?: true
    usedAt?: true
    creditNoteId?: true
    usedOnCostItemSupplierId?: true
    _all?: true
  }

  export type CreditNoteUsageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CreditNoteUsage to aggregate.
     */
    where?: CreditNoteUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditNoteUsages to fetch.
     */
    orderBy?: CreditNoteUsageOrderByWithRelationInput | CreditNoteUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CreditNoteUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditNoteUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditNoteUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CreditNoteUsages
    **/
    _count?: true | CreditNoteUsageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CreditNoteUsageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CreditNoteUsageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CreditNoteUsageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CreditNoteUsageMaxAggregateInputType
  }

  export type GetCreditNoteUsageAggregateType<T extends CreditNoteUsageAggregateArgs> = {
        [P in keyof T & keyof AggregateCreditNoteUsage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCreditNoteUsage[P]>
      : GetScalarType<T[P], AggregateCreditNoteUsage[P]>
  }




  export type CreditNoteUsageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CreditNoteUsageWhereInput
    orderBy?: CreditNoteUsageOrderByWithAggregationInput | CreditNoteUsageOrderByWithAggregationInput[]
    by: CreditNoteUsageScalarFieldEnum[] | CreditNoteUsageScalarFieldEnum
    having?: CreditNoteUsageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CreditNoteUsageCountAggregateInputType | true
    _avg?: CreditNoteUsageAvgAggregateInputType
    _sum?: CreditNoteUsageSumAggregateInputType
    _min?: CreditNoteUsageMinAggregateInputType
    _max?: CreditNoteUsageMaxAggregateInputType
  }

  export type CreditNoteUsageGroupByOutputType = {
    id: number
    amountUsed: number
    usedAt: Date
    creditNoteId: number
    usedOnCostItemSupplierId: number
    _count: CreditNoteUsageCountAggregateOutputType | null
    _avg: CreditNoteUsageAvgAggregateOutputType | null
    _sum: CreditNoteUsageSumAggregateOutputType | null
    _min: CreditNoteUsageMinAggregateOutputType | null
    _max: CreditNoteUsageMaxAggregateOutputType | null
  }

  type GetCreditNoteUsageGroupByPayload<T extends CreditNoteUsageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CreditNoteUsageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CreditNoteUsageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CreditNoteUsageGroupByOutputType[P]>
            : GetScalarType<T[P], CreditNoteUsageGroupByOutputType[P]>
        }
      >
    >


  export type CreditNoteUsageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amountUsed?: boolean
    usedAt?: boolean
    creditNoteId?: boolean
    usedOnCostItemSupplierId?: boolean
    creditNote?: boolean | SupplierCreditNoteDefaultArgs<ExtArgs>
    usedOnCostItemSupplier?: boolean | CostItemSupplierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creditNoteUsage"]>

  export type CreditNoteUsageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amountUsed?: boolean
    usedAt?: boolean
    creditNoteId?: boolean
    usedOnCostItemSupplierId?: boolean
    creditNote?: boolean | SupplierCreditNoteDefaultArgs<ExtArgs>
    usedOnCostItemSupplier?: boolean | CostItemSupplierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creditNoteUsage"]>

  export type CreditNoteUsageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amountUsed?: boolean
    usedAt?: boolean
    creditNoteId?: boolean
    usedOnCostItemSupplierId?: boolean
    creditNote?: boolean | SupplierCreditNoteDefaultArgs<ExtArgs>
    usedOnCostItemSupplier?: boolean | CostItemSupplierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["creditNoteUsage"]>

  export type CreditNoteUsageSelectScalar = {
    id?: boolean
    amountUsed?: boolean
    usedAt?: boolean
    creditNoteId?: boolean
    usedOnCostItemSupplierId?: boolean
  }

  export type CreditNoteUsageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "amountUsed" | "usedAt" | "creditNoteId" | "usedOnCostItemSupplierId", ExtArgs["result"]["creditNoteUsage"]>
  export type CreditNoteUsageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creditNote?: boolean | SupplierCreditNoteDefaultArgs<ExtArgs>
    usedOnCostItemSupplier?: boolean | CostItemSupplierDefaultArgs<ExtArgs>
  }
  export type CreditNoteUsageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creditNote?: boolean | SupplierCreditNoteDefaultArgs<ExtArgs>
    usedOnCostItemSupplier?: boolean | CostItemSupplierDefaultArgs<ExtArgs>
  }
  export type CreditNoteUsageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creditNote?: boolean | SupplierCreditNoteDefaultArgs<ExtArgs>
    usedOnCostItemSupplier?: boolean | CostItemSupplierDefaultArgs<ExtArgs>
  }

  export type $CreditNoteUsagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CreditNoteUsage"
    objects: {
      creditNote: Prisma.$SupplierCreditNotePayload<ExtArgs>
      usedOnCostItemSupplier: Prisma.$CostItemSupplierPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      amountUsed: number
      usedAt: Date
      creditNoteId: number
      usedOnCostItemSupplierId: number
    }, ExtArgs["result"]["creditNoteUsage"]>
    composites: {}
  }

  type CreditNoteUsageGetPayload<S extends boolean | null | undefined | CreditNoteUsageDefaultArgs> = $Result.GetResult<Prisma.$CreditNoteUsagePayload, S>

  type CreditNoteUsageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CreditNoteUsageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CreditNoteUsageCountAggregateInputType | true
    }

  export interface CreditNoteUsageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CreditNoteUsage'], meta: { name: 'CreditNoteUsage' } }
    /**
     * Find zero or one CreditNoteUsage that matches the filter.
     * @param {CreditNoteUsageFindUniqueArgs} args - Arguments to find a CreditNoteUsage
     * @example
     * // Get one CreditNoteUsage
     * const creditNoteUsage = await prisma.creditNoteUsage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CreditNoteUsageFindUniqueArgs>(args: SelectSubset<T, CreditNoteUsageFindUniqueArgs<ExtArgs>>): Prisma__CreditNoteUsageClient<$Result.GetResult<Prisma.$CreditNoteUsagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CreditNoteUsage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CreditNoteUsageFindUniqueOrThrowArgs} args - Arguments to find a CreditNoteUsage
     * @example
     * // Get one CreditNoteUsage
     * const creditNoteUsage = await prisma.creditNoteUsage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CreditNoteUsageFindUniqueOrThrowArgs>(args: SelectSubset<T, CreditNoteUsageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CreditNoteUsageClient<$Result.GetResult<Prisma.$CreditNoteUsagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CreditNoteUsage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditNoteUsageFindFirstArgs} args - Arguments to find a CreditNoteUsage
     * @example
     * // Get one CreditNoteUsage
     * const creditNoteUsage = await prisma.creditNoteUsage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CreditNoteUsageFindFirstArgs>(args?: SelectSubset<T, CreditNoteUsageFindFirstArgs<ExtArgs>>): Prisma__CreditNoteUsageClient<$Result.GetResult<Prisma.$CreditNoteUsagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CreditNoteUsage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditNoteUsageFindFirstOrThrowArgs} args - Arguments to find a CreditNoteUsage
     * @example
     * // Get one CreditNoteUsage
     * const creditNoteUsage = await prisma.creditNoteUsage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CreditNoteUsageFindFirstOrThrowArgs>(args?: SelectSubset<T, CreditNoteUsageFindFirstOrThrowArgs<ExtArgs>>): Prisma__CreditNoteUsageClient<$Result.GetResult<Prisma.$CreditNoteUsagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CreditNoteUsages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditNoteUsageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CreditNoteUsages
     * const creditNoteUsages = await prisma.creditNoteUsage.findMany()
     * 
     * // Get first 10 CreditNoteUsages
     * const creditNoteUsages = await prisma.creditNoteUsage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const creditNoteUsageWithIdOnly = await prisma.creditNoteUsage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CreditNoteUsageFindManyArgs>(args?: SelectSubset<T, CreditNoteUsageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditNoteUsagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CreditNoteUsage.
     * @param {CreditNoteUsageCreateArgs} args - Arguments to create a CreditNoteUsage.
     * @example
     * // Create one CreditNoteUsage
     * const CreditNoteUsage = await prisma.creditNoteUsage.create({
     *   data: {
     *     // ... data to create a CreditNoteUsage
     *   }
     * })
     * 
     */
    create<T extends CreditNoteUsageCreateArgs>(args: SelectSubset<T, CreditNoteUsageCreateArgs<ExtArgs>>): Prisma__CreditNoteUsageClient<$Result.GetResult<Prisma.$CreditNoteUsagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CreditNoteUsages.
     * @param {CreditNoteUsageCreateManyArgs} args - Arguments to create many CreditNoteUsages.
     * @example
     * // Create many CreditNoteUsages
     * const creditNoteUsage = await prisma.creditNoteUsage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CreditNoteUsageCreateManyArgs>(args?: SelectSubset<T, CreditNoteUsageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CreditNoteUsages and returns the data saved in the database.
     * @param {CreditNoteUsageCreateManyAndReturnArgs} args - Arguments to create many CreditNoteUsages.
     * @example
     * // Create many CreditNoteUsages
     * const creditNoteUsage = await prisma.creditNoteUsage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CreditNoteUsages and only return the `id`
     * const creditNoteUsageWithIdOnly = await prisma.creditNoteUsage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CreditNoteUsageCreateManyAndReturnArgs>(args?: SelectSubset<T, CreditNoteUsageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditNoteUsagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CreditNoteUsage.
     * @param {CreditNoteUsageDeleteArgs} args - Arguments to delete one CreditNoteUsage.
     * @example
     * // Delete one CreditNoteUsage
     * const CreditNoteUsage = await prisma.creditNoteUsage.delete({
     *   where: {
     *     // ... filter to delete one CreditNoteUsage
     *   }
     * })
     * 
     */
    delete<T extends CreditNoteUsageDeleteArgs>(args: SelectSubset<T, CreditNoteUsageDeleteArgs<ExtArgs>>): Prisma__CreditNoteUsageClient<$Result.GetResult<Prisma.$CreditNoteUsagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CreditNoteUsage.
     * @param {CreditNoteUsageUpdateArgs} args - Arguments to update one CreditNoteUsage.
     * @example
     * // Update one CreditNoteUsage
     * const creditNoteUsage = await prisma.creditNoteUsage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CreditNoteUsageUpdateArgs>(args: SelectSubset<T, CreditNoteUsageUpdateArgs<ExtArgs>>): Prisma__CreditNoteUsageClient<$Result.GetResult<Prisma.$CreditNoteUsagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CreditNoteUsages.
     * @param {CreditNoteUsageDeleteManyArgs} args - Arguments to filter CreditNoteUsages to delete.
     * @example
     * // Delete a few CreditNoteUsages
     * const { count } = await prisma.creditNoteUsage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CreditNoteUsageDeleteManyArgs>(args?: SelectSubset<T, CreditNoteUsageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CreditNoteUsages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditNoteUsageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CreditNoteUsages
     * const creditNoteUsage = await prisma.creditNoteUsage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CreditNoteUsageUpdateManyArgs>(args: SelectSubset<T, CreditNoteUsageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CreditNoteUsages and returns the data updated in the database.
     * @param {CreditNoteUsageUpdateManyAndReturnArgs} args - Arguments to update many CreditNoteUsages.
     * @example
     * // Update many CreditNoteUsages
     * const creditNoteUsage = await prisma.creditNoteUsage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CreditNoteUsages and only return the `id`
     * const creditNoteUsageWithIdOnly = await prisma.creditNoteUsage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CreditNoteUsageUpdateManyAndReturnArgs>(args: SelectSubset<T, CreditNoteUsageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CreditNoteUsagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CreditNoteUsage.
     * @param {CreditNoteUsageUpsertArgs} args - Arguments to update or create a CreditNoteUsage.
     * @example
     * // Update or create a CreditNoteUsage
     * const creditNoteUsage = await prisma.creditNoteUsage.upsert({
     *   create: {
     *     // ... data to create a CreditNoteUsage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CreditNoteUsage we want to update
     *   }
     * })
     */
    upsert<T extends CreditNoteUsageUpsertArgs>(args: SelectSubset<T, CreditNoteUsageUpsertArgs<ExtArgs>>): Prisma__CreditNoteUsageClient<$Result.GetResult<Prisma.$CreditNoteUsagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CreditNoteUsages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditNoteUsageCountArgs} args - Arguments to filter CreditNoteUsages to count.
     * @example
     * // Count the number of CreditNoteUsages
     * const count = await prisma.creditNoteUsage.count({
     *   where: {
     *     // ... the filter for the CreditNoteUsages we want to count
     *   }
     * })
    **/
    count<T extends CreditNoteUsageCountArgs>(
      args?: Subset<T, CreditNoteUsageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CreditNoteUsageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CreditNoteUsage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditNoteUsageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CreditNoteUsageAggregateArgs>(args: Subset<T, CreditNoteUsageAggregateArgs>): Prisma.PrismaPromise<GetCreditNoteUsageAggregateType<T>>

    /**
     * Group by CreditNoteUsage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CreditNoteUsageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CreditNoteUsageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CreditNoteUsageGroupByArgs['orderBy'] }
        : { orderBy?: CreditNoteUsageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CreditNoteUsageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCreditNoteUsageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CreditNoteUsage model
   */
  readonly fields: CreditNoteUsageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CreditNoteUsage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CreditNoteUsageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creditNote<T extends SupplierCreditNoteDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SupplierCreditNoteDefaultArgs<ExtArgs>>): Prisma__SupplierCreditNoteClient<$Result.GetResult<Prisma.$SupplierCreditNotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    usedOnCostItemSupplier<T extends CostItemSupplierDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CostItemSupplierDefaultArgs<ExtArgs>>): Prisma__CostItemSupplierClient<$Result.GetResult<Prisma.$CostItemSupplierPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CreditNoteUsage model
   */
  interface CreditNoteUsageFieldRefs {
    readonly id: FieldRef<"CreditNoteUsage", 'Int'>
    readonly amountUsed: FieldRef<"CreditNoteUsage", 'Float'>
    readonly usedAt: FieldRef<"CreditNoteUsage", 'DateTime'>
    readonly creditNoteId: FieldRef<"CreditNoteUsage", 'Int'>
    readonly usedOnCostItemSupplierId: FieldRef<"CreditNoteUsage", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * CreditNoteUsage findUnique
   */
  export type CreditNoteUsageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditNoteUsage
     */
    select?: CreditNoteUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditNoteUsage
     */
    omit?: CreditNoteUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditNoteUsageInclude<ExtArgs> | null
    /**
     * Filter, which CreditNoteUsage to fetch.
     */
    where: CreditNoteUsageWhereUniqueInput
  }

  /**
   * CreditNoteUsage findUniqueOrThrow
   */
  export type CreditNoteUsageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditNoteUsage
     */
    select?: CreditNoteUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditNoteUsage
     */
    omit?: CreditNoteUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditNoteUsageInclude<ExtArgs> | null
    /**
     * Filter, which CreditNoteUsage to fetch.
     */
    where: CreditNoteUsageWhereUniqueInput
  }

  /**
   * CreditNoteUsage findFirst
   */
  export type CreditNoteUsageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditNoteUsage
     */
    select?: CreditNoteUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditNoteUsage
     */
    omit?: CreditNoteUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditNoteUsageInclude<ExtArgs> | null
    /**
     * Filter, which CreditNoteUsage to fetch.
     */
    where?: CreditNoteUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditNoteUsages to fetch.
     */
    orderBy?: CreditNoteUsageOrderByWithRelationInput | CreditNoteUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CreditNoteUsages.
     */
    cursor?: CreditNoteUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditNoteUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditNoteUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CreditNoteUsages.
     */
    distinct?: CreditNoteUsageScalarFieldEnum | CreditNoteUsageScalarFieldEnum[]
  }

  /**
   * CreditNoteUsage findFirstOrThrow
   */
  export type CreditNoteUsageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditNoteUsage
     */
    select?: CreditNoteUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditNoteUsage
     */
    omit?: CreditNoteUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditNoteUsageInclude<ExtArgs> | null
    /**
     * Filter, which CreditNoteUsage to fetch.
     */
    where?: CreditNoteUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditNoteUsages to fetch.
     */
    orderBy?: CreditNoteUsageOrderByWithRelationInput | CreditNoteUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CreditNoteUsages.
     */
    cursor?: CreditNoteUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditNoteUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditNoteUsages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CreditNoteUsages.
     */
    distinct?: CreditNoteUsageScalarFieldEnum | CreditNoteUsageScalarFieldEnum[]
  }

  /**
   * CreditNoteUsage findMany
   */
  export type CreditNoteUsageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditNoteUsage
     */
    select?: CreditNoteUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditNoteUsage
     */
    omit?: CreditNoteUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditNoteUsageInclude<ExtArgs> | null
    /**
     * Filter, which CreditNoteUsages to fetch.
     */
    where?: CreditNoteUsageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CreditNoteUsages to fetch.
     */
    orderBy?: CreditNoteUsageOrderByWithRelationInput | CreditNoteUsageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CreditNoteUsages.
     */
    cursor?: CreditNoteUsageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CreditNoteUsages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CreditNoteUsages.
     */
    skip?: number
    distinct?: CreditNoteUsageScalarFieldEnum | CreditNoteUsageScalarFieldEnum[]
  }

  /**
   * CreditNoteUsage create
   */
  export type CreditNoteUsageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditNoteUsage
     */
    select?: CreditNoteUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditNoteUsage
     */
    omit?: CreditNoteUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditNoteUsageInclude<ExtArgs> | null
    /**
     * The data needed to create a CreditNoteUsage.
     */
    data: XOR<CreditNoteUsageCreateInput, CreditNoteUsageUncheckedCreateInput>
  }

  /**
   * CreditNoteUsage createMany
   */
  export type CreditNoteUsageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CreditNoteUsages.
     */
    data: CreditNoteUsageCreateManyInput | CreditNoteUsageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CreditNoteUsage createManyAndReturn
   */
  export type CreditNoteUsageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditNoteUsage
     */
    select?: CreditNoteUsageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CreditNoteUsage
     */
    omit?: CreditNoteUsageOmit<ExtArgs> | null
    /**
     * The data used to create many CreditNoteUsages.
     */
    data: CreditNoteUsageCreateManyInput | CreditNoteUsageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditNoteUsageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CreditNoteUsage update
   */
  export type CreditNoteUsageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditNoteUsage
     */
    select?: CreditNoteUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditNoteUsage
     */
    omit?: CreditNoteUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditNoteUsageInclude<ExtArgs> | null
    /**
     * The data needed to update a CreditNoteUsage.
     */
    data: XOR<CreditNoteUsageUpdateInput, CreditNoteUsageUncheckedUpdateInput>
    /**
     * Choose, which CreditNoteUsage to update.
     */
    where: CreditNoteUsageWhereUniqueInput
  }

  /**
   * CreditNoteUsage updateMany
   */
  export type CreditNoteUsageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CreditNoteUsages.
     */
    data: XOR<CreditNoteUsageUpdateManyMutationInput, CreditNoteUsageUncheckedUpdateManyInput>
    /**
     * Filter which CreditNoteUsages to update
     */
    where?: CreditNoteUsageWhereInput
    /**
     * Limit how many CreditNoteUsages to update.
     */
    limit?: number
  }

  /**
   * CreditNoteUsage updateManyAndReturn
   */
  export type CreditNoteUsageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditNoteUsage
     */
    select?: CreditNoteUsageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CreditNoteUsage
     */
    omit?: CreditNoteUsageOmit<ExtArgs> | null
    /**
     * The data used to update CreditNoteUsages.
     */
    data: XOR<CreditNoteUsageUpdateManyMutationInput, CreditNoteUsageUncheckedUpdateManyInput>
    /**
     * Filter which CreditNoteUsages to update
     */
    where?: CreditNoteUsageWhereInput
    /**
     * Limit how many CreditNoteUsages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditNoteUsageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CreditNoteUsage upsert
   */
  export type CreditNoteUsageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditNoteUsage
     */
    select?: CreditNoteUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditNoteUsage
     */
    omit?: CreditNoteUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditNoteUsageInclude<ExtArgs> | null
    /**
     * The filter to search for the CreditNoteUsage to update in case it exists.
     */
    where: CreditNoteUsageWhereUniqueInput
    /**
     * In case the CreditNoteUsage found by the `where` argument doesn't exist, create a new CreditNoteUsage with this data.
     */
    create: XOR<CreditNoteUsageCreateInput, CreditNoteUsageUncheckedCreateInput>
    /**
     * In case the CreditNoteUsage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CreditNoteUsageUpdateInput, CreditNoteUsageUncheckedUpdateInput>
  }

  /**
   * CreditNoteUsage delete
   */
  export type CreditNoteUsageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditNoteUsage
     */
    select?: CreditNoteUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditNoteUsage
     */
    omit?: CreditNoteUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditNoteUsageInclude<ExtArgs> | null
    /**
     * Filter which CreditNoteUsage to delete.
     */
    where: CreditNoteUsageWhereUniqueInput
  }

  /**
   * CreditNoteUsage deleteMany
   */
  export type CreditNoteUsageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CreditNoteUsages to delete
     */
    where?: CreditNoteUsageWhereInput
    /**
     * Limit how many CreditNoteUsages to delete.
     */
    limit?: number
  }

  /**
   * CreditNoteUsage without action
   */
  export type CreditNoteUsageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CreditNoteUsage
     */
    select?: CreditNoteUsageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CreditNoteUsage
     */
    omit?: CreditNoteUsageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CreditNoteUsageInclude<ExtArgs> | null
  }


  /**
   * Model SupplierPayable
   */

  export type AggregateSupplierPayable = {
    _count: SupplierPayableCountAggregateOutputType | null
    _avg: SupplierPayableAvgAggregateOutputType | null
    _sum: SupplierPayableSumAggregateOutputType | null
    _min: SupplierPayableMinAggregateOutputType | null
    _max: SupplierPayableMaxAggregateOutputType | null
  }

  export type SupplierPayableAvgAggregateOutputType = {
    id: number | null
    totalAmount: number | null
    paidAmount: number | null
    pendingAmount: number | null
    createdFromCancellationId: number | null
  }

  export type SupplierPayableSumAggregateOutputType = {
    id: number | null
    totalAmount: number | null
    paidAmount: number | null
    pendingAmount: number | null
    createdFromCancellationId: number | null
  }

  export type SupplierPayableMinAggregateOutputType = {
    id: number | null
    supplier: $Enums.Suppliers | null
    totalAmount: number | null
    paidAmount: number | null
    pendingAmount: number | null
    reason: string | null
    status: string | null
    createdFromCancellationId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SupplierPayableMaxAggregateOutputType = {
    id: number | null
    supplier: $Enums.Suppliers | null
    totalAmount: number | null
    paidAmount: number | null
    pendingAmount: number | null
    reason: string | null
    status: string | null
    createdFromCancellationId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SupplierPayableCountAggregateOutputType = {
    id: number
    supplier: number
    totalAmount: number
    paidAmount: number
    pendingAmount: number
    reason: number
    status: number
    createdFromCancellationId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SupplierPayableAvgAggregateInputType = {
    id?: true
    totalAmount?: true
    paidAmount?: true
    pendingAmount?: true
    createdFromCancellationId?: true
  }

  export type SupplierPayableSumAggregateInputType = {
    id?: true
    totalAmount?: true
    paidAmount?: true
    pendingAmount?: true
    createdFromCancellationId?: true
  }

  export type SupplierPayableMinAggregateInputType = {
    id?: true
    supplier?: true
    totalAmount?: true
    paidAmount?: true
    pendingAmount?: true
    reason?: true
    status?: true
    createdFromCancellationId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SupplierPayableMaxAggregateInputType = {
    id?: true
    supplier?: true
    totalAmount?: true
    paidAmount?: true
    pendingAmount?: true
    reason?: true
    status?: true
    createdFromCancellationId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SupplierPayableCountAggregateInputType = {
    id?: true
    supplier?: true
    totalAmount?: true
    paidAmount?: true
    pendingAmount?: true
    reason?: true
    status?: true
    createdFromCancellationId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SupplierPayableAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SupplierPayable to aggregate.
     */
    where?: SupplierPayableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupplierPayables to fetch.
     */
    orderBy?: SupplierPayableOrderByWithRelationInput | SupplierPayableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SupplierPayableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupplierPayables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupplierPayables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SupplierPayables
    **/
    _count?: true | SupplierPayableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SupplierPayableAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SupplierPayableSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SupplierPayableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SupplierPayableMaxAggregateInputType
  }

  export type GetSupplierPayableAggregateType<T extends SupplierPayableAggregateArgs> = {
        [P in keyof T & keyof AggregateSupplierPayable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupplierPayable[P]>
      : GetScalarType<T[P], AggregateSupplierPayable[P]>
  }




  export type SupplierPayableGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplierPayableWhereInput
    orderBy?: SupplierPayableOrderByWithAggregationInput | SupplierPayableOrderByWithAggregationInput[]
    by: SupplierPayableScalarFieldEnum[] | SupplierPayableScalarFieldEnum
    having?: SupplierPayableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SupplierPayableCountAggregateInputType | true
    _avg?: SupplierPayableAvgAggregateInputType
    _sum?: SupplierPayableSumAggregateInputType
    _min?: SupplierPayableMinAggregateInputType
    _max?: SupplierPayableMaxAggregateInputType
  }

  export type SupplierPayableGroupByOutputType = {
    id: number
    supplier: $Enums.Suppliers
    totalAmount: number
    paidAmount: number
    pendingAmount: number
    reason: string
    status: string
    createdFromCancellationId: number
    createdAt: Date
    updatedAt: Date
    _count: SupplierPayableCountAggregateOutputType | null
    _avg: SupplierPayableAvgAggregateOutputType | null
    _sum: SupplierPayableSumAggregateOutputType | null
    _min: SupplierPayableMinAggregateOutputType | null
    _max: SupplierPayableMaxAggregateOutputType | null
  }

  type GetSupplierPayableGroupByPayload<T extends SupplierPayableGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SupplierPayableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SupplierPayableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SupplierPayableGroupByOutputType[P]>
            : GetScalarType<T[P], SupplierPayableGroupByOutputType[P]>
        }
      >
    >


  export type SupplierPayableSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    supplier?: boolean
    totalAmount?: boolean
    paidAmount?: boolean
    pendingAmount?: boolean
    reason?: boolean
    status?: boolean
    createdFromCancellationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdFromCancellation?: boolean | CancellationDefaultArgs<ExtArgs>
    settlements?: boolean | SupplierPayable$settlementsArgs<ExtArgs>
    _count?: boolean | SupplierPayableCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplierPayable"]>

  export type SupplierPayableSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    supplier?: boolean
    totalAmount?: boolean
    paidAmount?: boolean
    pendingAmount?: boolean
    reason?: boolean
    status?: boolean
    createdFromCancellationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdFromCancellation?: boolean | CancellationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplierPayable"]>

  export type SupplierPayableSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    supplier?: boolean
    totalAmount?: boolean
    paidAmount?: boolean
    pendingAmount?: boolean
    reason?: boolean
    status?: boolean
    createdFromCancellationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdFromCancellation?: boolean | CancellationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplierPayable"]>

  export type SupplierPayableSelectScalar = {
    id?: boolean
    supplier?: boolean
    totalAmount?: boolean
    paidAmount?: boolean
    pendingAmount?: boolean
    reason?: boolean
    status?: boolean
    createdFromCancellationId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SupplierPayableOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "supplier" | "totalAmount" | "paidAmount" | "pendingAmount" | "reason" | "status" | "createdFromCancellationId" | "createdAt" | "updatedAt", ExtArgs["result"]["supplierPayable"]>
  export type SupplierPayableInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdFromCancellation?: boolean | CancellationDefaultArgs<ExtArgs>
    settlements?: boolean | SupplierPayable$settlementsArgs<ExtArgs>
    _count?: boolean | SupplierPayableCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SupplierPayableIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdFromCancellation?: boolean | CancellationDefaultArgs<ExtArgs>
  }
  export type SupplierPayableIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdFromCancellation?: boolean | CancellationDefaultArgs<ExtArgs>
  }

  export type $SupplierPayablePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SupplierPayable"
    objects: {
      createdFromCancellation: Prisma.$CancellationPayload<ExtArgs>
      settlements: Prisma.$SupplierPayableSettlementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      supplier: $Enums.Suppliers
      totalAmount: number
      paidAmount: number
      pendingAmount: number
      reason: string
      status: string
      createdFromCancellationId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["supplierPayable"]>
    composites: {}
  }

  type SupplierPayableGetPayload<S extends boolean | null | undefined | SupplierPayableDefaultArgs> = $Result.GetResult<Prisma.$SupplierPayablePayload, S>

  type SupplierPayableCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SupplierPayableFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SupplierPayableCountAggregateInputType | true
    }

  export interface SupplierPayableDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SupplierPayable'], meta: { name: 'SupplierPayable' } }
    /**
     * Find zero or one SupplierPayable that matches the filter.
     * @param {SupplierPayableFindUniqueArgs} args - Arguments to find a SupplierPayable
     * @example
     * // Get one SupplierPayable
     * const supplierPayable = await prisma.supplierPayable.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SupplierPayableFindUniqueArgs>(args: SelectSubset<T, SupplierPayableFindUniqueArgs<ExtArgs>>): Prisma__SupplierPayableClient<$Result.GetResult<Prisma.$SupplierPayablePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SupplierPayable that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SupplierPayableFindUniqueOrThrowArgs} args - Arguments to find a SupplierPayable
     * @example
     * // Get one SupplierPayable
     * const supplierPayable = await prisma.supplierPayable.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SupplierPayableFindUniqueOrThrowArgs>(args: SelectSubset<T, SupplierPayableFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SupplierPayableClient<$Result.GetResult<Prisma.$SupplierPayablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SupplierPayable that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierPayableFindFirstArgs} args - Arguments to find a SupplierPayable
     * @example
     * // Get one SupplierPayable
     * const supplierPayable = await prisma.supplierPayable.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SupplierPayableFindFirstArgs>(args?: SelectSubset<T, SupplierPayableFindFirstArgs<ExtArgs>>): Prisma__SupplierPayableClient<$Result.GetResult<Prisma.$SupplierPayablePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SupplierPayable that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierPayableFindFirstOrThrowArgs} args - Arguments to find a SupplierPayable
     * @example
     * // Get one SupplierPayable
     * const supplierPayable = await prisma.supplierPayable.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SupplierPayableFindFirstOrThrowArgs>(args?: SelectSubset<T, SupplierPayableFindFirstOrThrowArgs<ExtArgs>>): Prisma__SupplierPayableClient<$Result.GetResult<Prisma.$SupplierPayablePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SupplierPayables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierPayableFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SupplierPayables
     * const supplierPayables = await prisma.supplierPayable.findMany()
     * 
     * // Get first 10 SupplierPayables
     * const supplierPayables = await prisma.supplierPayable.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const supplierPayableWithIdOnly = await prisma.supplierPayable.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SupplierPayableFindManyArgs>(args?: SelectSubset<T, SupplierPayableFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPayablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SupplierPayable.
     * @param {SupplierPayableCreateArgs} args - Arguments to create a SupplierPayable.
     * @example
     * // Create one SupplierPayable
     * const SupplierPayable = await prisma.supplierPayable.create({
     *   data: {
     *     // ... data to create a SupplierPayable
     *   }
     * })
     * 
     */
    create<T extends SupplierPayableCreateArgs>(args: SelectSubset<T, SupplierPayableCreateArgs<ExtArgs>>): Prisma__SupplierPayableClient<$Result.GetResult<Prisma.$SupplierPayablePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SupplierPayables.
     * @param {SupplierPayableCreateManyArgs} args - Arguments to create many SupplierPayables.
     * @example
     * // Create many SupplierPayables
     * const supplierPayable = await prisma.supplierPayable.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SupplierPayableCreateManyArgs>(args?: SelectSubset<T, SupplierPayableCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SupplierPayables and returns the data saved in the database.
     * @param {SupplierPayableCreateManyAndReturnArgs} args - Arguments to create many SupplierPayables.
     * @example
     * // Create many SupplierPayables
     * const supplierPayable = await prisma.supplierPayable.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SupplierPayables and only return the `id`
     * const supplierPayableWithIdOnly = await prisma.supplierPayable.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SupplierPayableCreateManyAndReturnArgs>(args?: SelectSubset<T, SupplierPayableCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPayablePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SupplierPayable.
     * @param {SupplierPayableDeleteArgs} args - Arguments to delete one SupplierPayable.
     * @example
     * // Delete one SupplierPayable
     * const SupplierPayable = await prisma.supplierPayable.delete({
     *   where: {
     *     // ... filter to delete one SupplierPayable
     *   }
     * })
     * 
     */
    delete<T extends SupplierPayableDeleteArgs>(args: SelectSubset<T, SupplierPayableDeleteArgs<ExtArgs>>): Prisma__SupplierPayableClient<$Result.GetResult<Prisma.$SupplierPayablePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SupplierPayable.
     * @param {SupplierPayableUpdateArgs} args - Arguments to update one SupplierPayable.
     * @example
     * // Update one SupplierPayable
     * const supplierPayable = await prisma.supplierPayable.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SupplierPayableUpdateArgs>(args: SelectSubset<T, SupplierPayableUpdateArgs<ExtArgs>>): Prisma__SupplierPayableClient<$Result.GetResult<Prisma.$SupplierPayablePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SupplierPayables.
     * @param {SupplierPayableDeleteManyArgs} args - Arguments to filter SupplierPayables to delete.
     * @example
     * // Delete a few SupplierPayables
     * const { count } = await prisma.supplierPayable.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SupplierPayableDeleteManyArgs>(args?: SelectSubset<T, SupplierPayableDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SupplierPayables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierPayableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SupplierPayables
     * const supplierPayable = await prisma.supplierPayable.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SupplierPayableUpdateManyArgs>(args: SelectSubset<T, SupplierPayableUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SupplierPayables and returns the data updated in the database.
     * @param {SupplierPayableUpdateManyAndReturnArgs} args - Arguments to update many SupplierPayables.
     * @example
     * // Update many SupplierPayables
     * const supplierPayable = await prisma.supplierPayable.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SupplierPayables and only return the `id`
     * const supplierPayableWithIdOnly = await prisma.supplierPayable.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SupplierPayableUpdateManyAndReturnArgs>(args: SelectSubset<T, SupplierPayableUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPayablePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SupplierPayable.
     * @param {SupplierPayableUpsertArgs} args - Arguments to update or create a SupplierPayable.
     * @example
     * // Update or create a SupplierPayable
     * const supplierPayable = await prisma.supplierPayable.upsert({
     *   create: {
     *     // ... data to create a SupplierPayable
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SupplierPayable we want to update
     *   }
     * })
     */
    upsert<T extends SupplierPayableUpsertArgs>(args: SelectSubset<T, SupplierPayableUpsertArgs<ExtArgs>>): Prisma__SupplierPayableClient<$Result.GetResult<Prisma.$SupplierPayablePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SupplierPayables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierPayableCountArgs} args - Arguments to filter SupplierPayables to count.
     * @example
     * // Count the number of SupplierPayables
     * const count = await prisma.supplierPayable.count({
     *   where: {
     *     // ... the filter for the SupplierPayables we want to count
     *   }
     * })
    **/
    count<T extends SupplierPayableCountArgs>(
      args?: Subset<T, SupplierPayableCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupplierPayableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SupplierPayable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierPayableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SupplierPayableAggregateArgs>(args: Subset<T, SupplierPayableAggregateArgs>): Prisma.PrismaPromise<GetSupplierPayableAggregateType<T>>

    /**
     * Group by SupplierPayable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierPayableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SupplierPayableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SupplierPayableGroupByArgs['orderBy'] }
        : { orderBy?: SupplierPayableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SupplierPayableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupplierPayableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SupplierPayable model
   */
  readonly fields: SupplierPayableFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SupplierPayable.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SupplierPayableClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdFromCancellation<T extends CancellationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CancellationDefaultArgs<ExtArgs>>): Prisma__CancellationClient<$Result.GetResult<Prisma.$CancellationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    settlements<T extends SupplierPayable$settlementsArgs<ExtArgs> = {}>(args?: Subset<T, SupplierPayable$settlementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPayableSettlementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SupplierPayable model
   */
  interface SupplierPayableFieldRefs {
    readonly id: FieldRef<"SupplierPayable", 'Int'>
    readonly supplier: FieldRef<"SupplierPayable", 'Suppliers'>
    readonly totalAmount: FieldRef<"SupplierPayable", 'Float'>
    readonly paidAmount: FieldRef<"SupplierPayable", 'Float'>
    readonly pendingAmount: FieldRef<"SupplierPayable", 'Float'>
    readonly reason: FieldRef<"SupplierPayable", 'String'>
    readonly status: FieldRef<"SupplierPayable", 'String'>
    readonly createdFromCancellationId: FieldRef<"SupplierPayable", 'Int'>
    readonly createdAt: FieldRef<"SupplierPayable", 'DateTime'>
    readonly updatedAt: FieldRef<"SupplierPayable", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SupplierPayable findUnique
   */
  export type SupplierPayableFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierPayable
     */
    select?: SupplierPayableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierPayable
     */
    omit?: SupplierPayableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierPayableInclude<ExtArgs> | null
    /**
     * Filter, which SupplierPayable to fetch.
     */
    where: SupplierPayableWhereUniqueInput
  }

  /**
   * SupplierPayable findUniqueOrThrow
   */
  export type SupplierPayableFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierPayable
     */
    select?: SupplierPayableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierPayable
     */
    omit?: SupplierPayableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierPayableInclude<ExtArgs> | null
    /**
     * Filter, which SupplierPayable to fetch.
     */
    where: SupplierPayableWhereUniqueInput
  }

  /**
   * SupplierPayable findFirst
   */
  export type SupplierPayableFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierPayable
     */
    select?: SupplierPayableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierPayable
     */
    omit?: SupplierPayableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierPayableInclude<ExtArgs> | null
    /**
     * Filter, which SupplierPayable to fetch.
     */
    where?: SupplierPayableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupplierPayables to fetch.
     */
    orderBy?: SupplierPayableOrderByWithRelationInput | SupplierPayableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SupplierPayables.
     */
    cursor?: SupplierPayableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupplierPayables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupplierPayables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SupplierPayables.
     */
    distinct?: SupplierPayableScalarFieldEnum | SupplierPayableScalarFieldEnum[]
  }

  /**
   * SupplierPayable findFirstOrThrow
   */
  export type SupplierPayableFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierPayable
     */
    select?: SupplierPayableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierPayable
     */
    omit?: SupplierPayableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierPayableInclude<ExtArgs> | null
    /**
     * Filter, which SupplierPayable to fetch.
     */
    where?: SupplierPayableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupplierPayables to fetch.
     */
    orderBy?: SupplierPayableOrderByWithRelationInput | SupplierPayableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SupplierPayables.
     */
    cursor?: SupplierPayableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupplierPayables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupplierPayables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SupplierPayables.
     */
    distinct?: SupplierPayableScalarFieldEnum | SupplierPayableScalarFieldEnum[]
  }

  /**
   * SupplierPayable findMany
   */
  export type SupplierPayableFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierPayable
     */
    select?: SupplierPayableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierPayable
     */
    omit?: SupplierPayableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierPayableInclude<ExtArgs> | null
    /**
     * Filter, which SupplierPayables to fetch.
     */
    where?: SupplierPayableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupplierPayables to fetch.
     */
    orderBy?: SupplierPayableOrderByWithRelationInput | SupplierPayableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SupplierPayables.
     */
    cursor?: SupplierPayableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupplierPayables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupplierPayables.
     */
    skip?: number
    distinct?: SupplierPayableScalarFieldEnum | SupplierPayableScalarFieldEnum[]
  }

  /**
   * SupplierPayable create
   */
  export type SupplierPayableCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierPayable
     */
    select?: SupplierPayableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierPayable
     */
    omit?: SupplierPayableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierPayableInclude<ExtArgs> | null
    /**
     * The data needed to create a SupplierPayable.
     */
    data: XOR<SupplierPayableCreateInput, SupplierPayableUncheckedCreateInput>
  }

  /**
   * SupplierPayable createMany
   */
  export type SupplierPayableCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SupplierPayables.
     */
    data: SupplierPayableCreateManyInput | SupplierPayableCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SupplierPayable createManyAndReturn
   */
  export type SupplierPayableCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierPayable
     */
    select?: SupplierPayableSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierPayable
     */
    omit?: SupplierPayableOmit<ExtArgs> | null
    /**
     * The data used to create many SupplierPayables.
     */
    data: SupplierPayableCreateManyInput | SupplierPayableCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierPayableIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SupplierPayable update
   */
  export type SupplierPayableUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierPayable
     */
    select?: SupplierPayableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierPayable
     */
    omit?: SupplierPayableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierPayableInclude<ExtArgs> | null
    /**
     * The data needed to update a SupplierPayable.
     */
    data: XOR<SupplierPayableUpdateInput, SupplierPayableUncheckedUpdateInput>
    /**
     * Choose, which SupplierPayable to update.
     */
    where: SupplierPayableWhereUniqueInput
  }

  /**
   * SupplierPayable updateMany
   */
  export type SupplierPayableUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SupplierPayables.
     */
    data: XOR<SupplierPayableUpdateManyMutationInput, SupplierPayableUncheckedUpdateManyInput>
    /**
     * Filter which SupplierPayables to update
     */
    where?: SupplierPayableWhereInput
    /**
     * Limit how many SupplierPayables to update.
     */
    limit?: number
  }

  /**
   * SupplierPayable updateManyAndReturn
   */
  export type SupplierPayableUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierPayable
     */
    select?: SupplierPayableSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierPayable
     */
    omit?: SupplierPayableOmit<ExtArgs> | null
    /**
     * The data used to update SupplierPayables.
     */
    data: XOR<SupplierPayableUpdateManyMutationInput, SupplierPayableUncheckedUpdateManyInput>
    /**
     * Filter which SupplierPayables to update
     */
    where?: SupplierPayableWhereInput
    /**
     * Limit how many SupplierPayables to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierPayableIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SupplierPayable upsert
   */
  export type SupplierPayableUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierPayable
     */
    select?: SupplierPayableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierPayable
     */
    omit?: SupplierPayableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierPayableInclude<ExtArgs> | null
    /**
     * The filter to search for the SupplierPayable to update in case it exists.
     */
    where: SupplierPayableWhereUniqueInput
    /**
     * In case the SupplierPayable found by the `where` argument doesn't exist, create a new SupplierPayable with this data.
     */
    create: XOR<SupplierPayableCreateInput, SupplierPayableUncheckedCreateInput>
    /**
     * In case the SupplierPayable was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SupplierPayableUpdateInput, SupplierPayableUncheckedUpdateInput>
  }

  /**
   * SupplierPayable delete
   */
  export type SupplierPayableDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierPayable
     */
    select?: SupplierPayableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierPayable
     */
    omit?: SupplierPayableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierPayableInclude<ExtArgs> | null
    /**
     * Filter which SupplierPayable to delete.
     */
    where: SupplierPayableWhereUniqueInput
  }

  /**
   * SupplierPayable deleteMany
   */
  export type SupplierPayableDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SupplierPayables to delete
     */
    where?: SupplierPayableWhereInput
    /**
     * Limit how many SupplierPayables to delete.
     */
    limit?: number
  }

  /**
   * SupplierPayable.settlements
   */
  export type SupplierPayable$settlementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierPayableSettlement
     */
    select?: SupplierPayableSettlementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierPayableSettlement
     */
    omit?: SupplierPayableSettlementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierPayableSettlementInclude<ExtArgs> | null
    where?: SupplierPayableSettlementWhereInput
    orderBy?: SupplierPayableSettlementOrderByWithRelationInput | SupplierPayableSettlementOrderByWithRelationInput[]
    cursor?: SupplierPayableSettlementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SupplierPayableSettlementScalarFieldEnum | SupplierPayableSettlementScalarFieldEnum[]
  }

  /**
   * SupplierPayable without action
   */
  export type SupplierPayableDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierPayable
     */
    select?: SupplierPayableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierPayable
     */
    omit?: SupplierPayableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierPayableInclude<ExtArgs> | null
  }


  /**
   * Model SupplierPayableSettlement
   */

  export type AggregateSupplierPayableSettlement = {
    _count: SupplierPayableSettlementCountAggregateOutputType | null
    _avg: SupplierPayableSettlementAvgAggregateOutputType | null
    _sum: SupplierPayableSettlementSumAggregateOutputType | null
    _min: SupplierPayableSettlementMinAggregateOutputType | null
    _max: SupplierPayableSettlementMaxAggregateOutputType | null
  }

  export type SupplierPayableSettlementAvgAggregateOutputType = {
    id: number | null
    supplierPayableId: number | null
    amount: number | null
  }

  export type SupplierPayableSettlementSumAggregateOutputType = {
    id: number | null
    supplierPayableId: number | null
    amount: number | null
  }

  export type SupplierPayableSettlementMinAggregateOutputType = {
    id: number | null
    supplierPayableId: number | null
    amount: number | null
    transactionMethod: string | null
    settlementDate: Date | null
    createdAt: Date | null
  }

  export type SupplierPayableSettlementMaxAggregateOutputType = {
    id: number | null
    supplierPayableId: number | null
    amount: number | null
    transactionMethod: string | null
    settlementDate: Date | null
    createdAt: Date | null
  }

  export type SupplierPayableSettlementCountAggregateOutputType = {
    id: number
    supplierPayableId: number
    amount: number
    transactionMethod: number
    settlementDate: number
    createdAt: number
    _all: number
  }


  export type SupplierPayableSettlementAvgAggregateInputType = {
    id?: true
    supplierPayableId?: true
    amount?: true
  }

  export type SupplierPayableSettlementSumAggregateInputType = {
    id?: true
    supplierPayableId?: true
    amount?: true
  }

  export type SupplierPayableSettlementMinAggregateInputType = {
    id?: true
    supplierPayableId?: true
    amount?: true
    transactionMethod?: true
    settlementDate?: true
    createdAt?: true
  }

  export type SupplierPayableSettlementMaxAggregateInputType = {
    id?: true
    supplierPayableId?: true
    amount?: true
    transactionMethod?: true
    settlementDate?: true
    createdAt?: true
  }

  export type SupplierPayableSettlementCountAggregateInputType = {
    id?: true
    supplierPayableId?: true
    amount?: true
    transactionMethod?: true
    settlementDate?: true
    createdAt?: true
    _all?: true
  }

  export type SupplierPayableSettlementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SupplierPayableSettlement to aggregate.
     */
    where?: SupplierPayableSettlementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupplierPayableSettlements to fetch.
     */
    orderBy?: SupplierPayableSettlementOrderByWithRelationInput | SupplierPayableSettlementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SupplierPayableSettlementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupplierPayableSettlements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupplierPayableSettlements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SupplierPayableSettlements
    **/
    _count?: true | SupplierPayableSettlementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SupplierPayableSettlementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SupplierPayableSettlementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SupplierPayableSettlementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SupplierPayableSettlementMaxAggregateInputType
  }

  export type GetSupplierPayableSettlementAggregateType<T extends SupplierPayableSettlementAggregateArgs> = {
        [P in keyof T & keyof AggregateSupplierPayableSettlement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupplierPayableSettlement[P]>
      : GetScalarType<T[P], AggregateSupplierPayableSettlement[P]>
  }




  export type SupplierPayableSettlementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplierPayableSettlementWhereInput
    orderBy?: SupplierPayableSettlementOrderByWithAggregationInput | SupplierPayableSettlementOrderByWithAggregationInput[]
    by: SupplierPayableSettlementScalarFieldEnum[] | SupplierPayableSettlementScalarFieldEnum
    having?: SupplierPayableSettlementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SupplierPayableSettlementCountAggregateInputType | true
    _avg?: SupplierPayableSettlementAvgAggregateInputType
    _sum?: SupplierPayableSettlementSumAggregateInputType
    _min?: SupplierPayableSettlementMinAggregateInputType
    _max?: SupplierPayableSettlementMaxAggregateInputType
  }

  export type SupplierPayableSettlementGroupByOutputType = {
    id: number
    supplierPayableId: number
    amount: number
    transactionMethod: string
    settlementDate: Date
    createdAt: Date
    _count: SupplierPayableSettlementCountAggregateOutputType | null
    _avg: SupplierPayableSettlementAvgAggregateOutputType | null
    _sum: SupplierPayableSettlementSumAggregateOutputType | null
    _min: SupplierPayableSettlementMinAggregateOutputType | null
    _max: SupplierPayableSettlementMaxAggregateOutputType | null
  }

  type GetSupplierPayableSettlementGroupByPayload<T extends SupplierPayableSettlementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SupplierPayableSettlementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SupplierPayableSettlementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SupplierPayableSettlementGroupByOutputType[P]>
            : GetScalarType<T[P], SupplierPayableSettlementGroupByOutputType[P]>
        }
      >
    >


  export type SupplierPayableSettlementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    supplierPayableId?: boolean
    amount?: boolean
    transactionMethod?: boolean
    settlementDate?: boolean
    createdAt?: boolean
    payable?: boolean | SupplierPayableDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplierPayableSettlement"]>

  export type SupplierPayableSettlementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    supplierPayableId?: boolean
    amount?: boolean
    transactionMethod?: boolean
    settlementDate?: boolean
    createdAt?: boolean
    payable?: boolean | SupplierPayableDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplierPayableSettlement"]>

  export type SupplierPayableSettlementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    supplierPayableId?: boolean
    amount?: boolean
    transactionMethod?: boolean
    settlementDate?: boolean
    createdAt?: boolean
    payable?: boolean | SupplierPayableDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplierPayableSettlement"]>

  export type SupplierPayableSettlementSelectScalar = {
    id?: boolean
    supplierPayableId?: boolean
    amount?: boolean
    transactionMethod?: boolean
    settlementDate?: boolean
    createdAt?: boolean
  }

  export type SupplierPayableSettlementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "supplierPayableId" | "amount" | "transactionMethod" | "settlementDate" | "createdAt", ExtArgs["result"]["supplierPayableSettlement"]>
  export type SupplierPayableSettlementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payable?: boolean | SupplierPayableDefaultArgs<ExtArgs>
  }
  export type SupplierPayableSettlementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payable?: boolean | SupplierPayableDefaultArgs<ExtArgs>
  }
  export type SupplierPayableSettlementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payable?: boolean | SupplierPayableDefaultArgs<ExtArgs>
  }

  export type $SupplierPayableSettlementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SupplierPayableSettlement"
    objects: {
      payable: Prisma.$SupplierPayablePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      supplierPayableId: number
      amount: number
      transactionMethod: string
      settlementDate: Date
      createdAt: Date
    }, ExtArgs["result"]["supplierPayableSettlement"]>
    composites: {}
  }

  type SupplierPayableSettlementGetPayload<S extends boolean | null | undefined | SupplierPayableSettlementDefaultArgs> = $Result.GetResult<Prisma.$SupplierPayableSettlementPayload, S>

  type SupplierPayableSettlementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SupplierPayableSettlementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SupplierPayableSettlementCountAggregateInputType | true
    }

  export interface SupplierPayableSettlementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SupplierPayableSettlement'], meta: { name: 'SupplierPayableSettlement' } }
    /**
     * Find zero or one SupplierPayableSettlement that matches the filter.
     * @param {SupplierPayableSettlementFindUniqueArgs} args - Arguments to find a SupplierPayableSettlement
     * @example
     * // Get one SupplierPayableSettlement
     * const supplierPayableSettlement = await prisma.supplierPayableSettlement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SupplierPayableSettlementFindUniqueArgs>(args: SelectSubset<T, SupplierPayableSettlementFindUniqueArgs<ExtArgs>>): Prisma__SupplierPayableSettlementClient<$Result.GetResult<Prisma.$SupplierPayableSettlementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SupplierPayableSettlement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SupplierPayableSettlementFindUniqueOrThrowArgs} args - Arguments to find a SupplierPayableSettlement
     * @example
     * // Get one SupplierPayableSettlement
     * const supplierPayableSettlement = await prisma.supplierPayableSettlement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SupplierPayableSettlementFindUniqueOrThrowArgs>(args: SelectSubset<T, SupplierPayableSettlementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SupplierPayableSettlementClient<$Result.GetResult<Prisma.$SupplierPayableSettlementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SupplierPayableSettlement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierPayableSettlementFindFirstArgs} args - Arguments to find a SupplierPayableSettlement
     * @example
     * // Get one SupplierPayableSettlement
     * const supplierPayableSettlement = await prisma.supplierPayableSettlement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SupplierPayableSettlementFindFirstArgs>(args?: SelectSubset<T, SupplierPayableSettlementFindFirstArgs<ExtArgs>>): Prisma__SupplierPayableSettlementClient<$Result.GetResult<Prisma.$SupplierPayableSettlementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SupplierPayableSettlement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierPayableSettlementFindFirstOrThrowArgs} args - Arguments to find a SupplierPayableSettlement
     * @example
     * // Get one SupplierPayableSettlement
     * const supplierPayableSettlement = await prisma.supplierPayableSettlement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SupplierPayableSettlementFindFirstOrThrowArgs>(args?: SelectSubset<T, SupplierPayableSettlementFindFirstOrThrowArgs<ExtArgs>>): Prisma__SupplierPayableSettlementClient<$Result.GetResult<Prisma.$SupplierPayableSettlementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SupplierPayableSettlements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierPayableSettlementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SupplierPayableSettlements
     * const supplierPayableSettlements = await prisma.supplierPayableSettlement.findMany()
     * 
     * // Get first 10 SupplierPayableSettlements
     * const supplierPayableSettlements = await prisma.supplierPayableSettlement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const supplierPayableSettlementWithIdOnly = await prisma.supplierPayableSettlement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SupplierPayableSettlementFindManyArgs>(args?: SelectSubset<T, SupplierPayableSettlementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPayableSettlementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SupplierPayableSettlement.
     * @param {SupplierPayableSettlementCreateArgs} args - Arguments to create a SupplierPayableSettlement.
     * @example
     * // Create one SupplierPayableSettlement
     * const SupplierPayableSettlement = await prisma.supplierPayableSettlement.create({
     *   data: {
     *     // ... data to create a SupplierPayableSettlement
     *   }
     * })
     * 
     */
    create<T extends SupplierPayableSettlementCreateArgs>(args: SelectSubset<T, SupplierPayableSettlementCreateArgs<ExtArgs>>): Prisma__SupplierPayableSettlementClient<$Result.GetResult<Prisma.$SupplierPayableSettlementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SupplierPayableSettlements.
     * @param {SupplierPayableSettlementCreateManyArgs} args - Arguments to create many SupplierPayableSettlements.
     * @example
     * // Create many SupplierPayableSettlements
     * const supplierPayableSettlement = await prisma.supplierPayableSettlement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SupplierPayableSettlementCreateManyArgs>(args?: SelectSubset<T, SupplierPayableSettlementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SupplierPayableSettlements and returns the data saved in the database.
     * @param {SupplierPayableSettlementCreateManyAndReturnArgs} args - Arguments to create many SupplierPayableSettlements.
     * @example
     * // Create many SupplierPayableSettlements
     * const supplierPayableSettlement = await prisma.supplierPayableSettlement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SupplierPayableSettlements and only return the `id`
     * const supplierPayableSettlementWithIdOnly = await prisma.supplierPayableSettlement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SupplierPayableSettlementCreateManyAndReturnArgs>(args?: SelectSubset<T, SupplierPayableSettlementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPayableSettlementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SupplierPayableSettlement.
     * @param {SupplierPayableSettlementDeleteArgs} args - Arguments to delete one SupplierPayableSettlement.
     * @example
     * // Delete one SupplierPayableSettlement
     * const SupplierPayableSettlement = await prisma.supplierPayableSettlement.delete({
     *   where: {
     *     // ... filter to delete one SupplierPayableSettlement
     *   }
     * })
     * 
     */
    delete<T extends SupplierPayableSettlementDeleteArgs>(args: SelectSubset<T, SupplierPayableSettlementDeleteArgs<ExtArgs>>): Prisma__SupplierPayableSettlementClient<$Result.GetResult<Prisma.$SupplierPayableSettlementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SupplierPayableSettlement.
     * @param {SupplierPayableSettlementUpdateArgs} args - Arguments to update one SupplierPayableSettlement.
     * @example
     * // Update one SupplierPayableSettlement
     * const supplierPayableSettlement = await prisma.supplierPayableSettlement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SupplierPayableSettlementUpdateArgs>(args: SelectSubset<T, SupplierPayableSettlementUpdateArgs<ExtArgs>>): Prisma__SupplierPayableSettlementClient<$Result.GetResult<Prisma.$SupplierPayableSettlementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SupplierPayableSettlements.
     * @param {SupplierPayableSettlementDeleteManyArgs} args - Arguments to filter SupplierPayableSettlements to delete.
     * @example
     * // Delete a few SupplierPayableSettlements
     * const { count } = await prisma.supplierPayableSettlement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SupplierPayableSettlementDeleteManyArgs>(args?: SelectSubset<T, SupplierPayableSettlementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SupplierPayableSettlements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierPayableSettlementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SupplierPayableSettlements
     * const supplierPayableSettlement = await prisma.supplierPayableSettlement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SupplierPayableSettlementUpdateManyArgs>(args: SelectSubset<T, SupplierPayableSettlementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SupplierPayableSettlements and returns the data updated in the database.
     * @param {SupplierPayableSettlementUpdateManyAndReturnArgs} args - Arguments to update many SupplierPayableSettlements.
     * @example
     * // Update many SupplierPayableSettlements
     * const supplierPayableSettlement = await prisma.supplierPayableSettlement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SupplierPayableSettlements and only return the `id`
     * const supplierPayableSettlementWithIdOnly = await prisma.supplierPayableSettlement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SupplierPayableSettlementUpdateManyAndReturnArgs>(args: SelectSubset<T, SupplierPayableSettlementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPayableSettlementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SupplierPayableSettlement.
     * @param {SupplierPayableSettlementUpsertArgs} args - Arguments to update or create a SupplierPayableSettlement.
     * @example
     * // Update or create a SupplierPayableSettlement
     * const supplierPayableSettlement = await prisma.supplierPayableSettlement.upsert({
     *   create: {
     *     // ... data to create a SupplierPayableSettlement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SupplierPayableSettlement we want to update
     *   }
     * })
     */
    upsert<T extends SupplierPayableSettlementUpsertArgs>(args: SelectSubset<T, SupplierPayableSettlementUpsertArgs<ExtArgs>>): Prisma__SupplierPayableSettlementClient<$Result.GetResult<Prisma.$SupplierPayableSettlementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SupplierPayableSettlements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierPayableSettlementCountArgs} args - Arguments to filter SupplierPayableSettlements to count.
     * @example
     * // Count the number of SupplierPayableSettlements
     * const count = await prisma.supplierPayableSettlement.count({
     *   where: {
     *     // ... the filter for the SupplierPayableSettlements we want to count
     *   }
     * })
    **/
    count<T extends SupplierPayableSettlementCountArgs>(
      args?: Subset<T, SupplierPayableSettlementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupplierPayableSettlementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SupplierPayableSettlement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierPayableSettlementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SupplierPayableSettlementAggregateArgs>(args: Subset<T, SupplierPayableSettlementAggregateArgs>): Prisma.PrismaPromise<GetSupplierPayableSettlementAggregateType<T>>

    /**
     * Group by SupplierPayableSettlement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierPayableSettlementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SupplierPayableSettlementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SupplierPayableSettlementGroupByArgs['orderBy'] }
        : { orderBy?: SupplierPayableSettlementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SupplierPayableSettlementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupplierPayableSettlementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SupplierPayableSettlement model
   */
  readonly fields: SupplierPayableSettlementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SupplierPayableSettlement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SupplierPayableSettlementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    payable<T extends SupplierPayableDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SupplierPayableDefaultArgs<ExtArgs>>): Prisma__SupplierPayableClient<$Result.GetResult<Prisma.$SupplierPayablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SupplierPayableSettlement model
   */
  interface SupplierPayableSettlementFieldRefs {
    readonly id: FieldRef<"SupplierPayableSettlement", 'Int'>
    readonly supplierPayableId: FieldRef<"SupplierPayableSettlement", 'Int'>
    readonly amount: FieldRef<"SupplierPayableSettlement", 'Float'>
    readonly transactionMethod: FieldRef<"SupplierPayableSettlement", 'String'>
    readonly settlementDate: FieldRef<"SupplierPayableSettlement", 'DateTime'>
    readonly createdAt: FieldRef<"SupplierPayableSettlement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SupplierPayableSettlement findUnique
   */
  export type SupplierPayableSettlementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierPayableSettlement
     */
    select?: SupplierPayableSettlementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierPayableSettlement
     */
    omit?: SupplierPayableSettlementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierPayableSettlementInclude<ExtArgs> | null
    /**
     * Filter, which SupplierPayableSettlement to fetch.
     */
    where: SupplierPayableSettlementWhereUniqueInput
  }

  /**
   * SupplierPayableSettlement findUniqueOrThrow
   */
  export type SupplierPayableSettlementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierPayableSettlement
     */
    select?: SupplierPayableSettlementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierPayableSettlement
     */
    omit?: SupplierPayableSettlementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierPayableSettlementInclude<ExtArgs> | null
    /**
     * Filter, which SupplierPayableSettlement to fetch.
     */
    where: SupplierPayableSettlementWhereUniqueInput
  }

  /**
   * SupplierPayableSettlement findFirst
   */
  export type SupplierPayableSettlementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierPayableSettlement
     */
    select?: SupplierPayableSettlementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierPayableSettlement
     */
    omit?: SupplierPayableSettlementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierPayableSettlementInclude<ExtArgs> | null
    /**
     * Filter, which SupplierPayableSettlement to fetch.
     */
    where?: SupplierPayableSettlementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupplierPayableSettlements to fetch.
     */
    orderBy?: SupplierPayableSettlementOrderByWithRelationInput | SupplierPayableSettlementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SupplierPayableSettlements.
     */
    cursor?: SupplierPayableSettlementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupplierPayableSettlements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupplierPayableSettlements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SupplierPayableSettlements.
     */
    distinct?: SupplierPayableSettlementScalarFieldEnum | SupplierPayableSettlementScalarFieldEnum[]
  }

  /**
   * SupplierPayableSettlement findFirstOrThrow
   */
  export type SupplierPayableSettlementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierPayableSettlement
     */
    select?: SupplierPayableSettlementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierPayableSettlement
     */
    omit?: SupplierPayableSettlementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierPayableSettlementInclude<ExtArgs> | null
    /**
     * Filter, which SupplierPayableSettlement to fetch.
     */
    where?: SupplierPayableSettlementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupplierPayableSettlements to fetch.
     */
    orderBy?: SupplierPayableSettlementOrderByWithRelationInput | SupplierPayableSettlementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SupplierPayableSettlements.
     */
    cursor?: SupplierPayableSettlementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupplierPayableSettlements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupplierPayableSettlements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SupplierPayableSettlements.
     */
    distinct?: SupplierPayableSettlementScalarFieldEnum | SupplierPayableSettlementScalarFieldEnum[]
  }

  /**
   * SupplierPayableSettlement findMany
   */
  export type SupplierPayableSettlementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierPayableSettlement
     */
    select?: SupplierPayableSettlementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierPayableSettlement
     */
    omit?: SupplierPayableSettlementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierPayableSettlementInclude<ExtArgs> | null
    /**
     * Filter, which SupplierPayableSettlements to fetch.
     */
    where?: SupplierPayableSettlementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupplierPayableSettlements to fetch.
     */
    orderBy?: SupplierPayableSettlementOrderByWithRelationInput | SupplierPayableSettlementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SupplierPayableSettlements.
     */
    cursor?: SupplierPayableSettlementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupplierPayableSettlements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupplierPayableSettlements.
     */
    skip?: number
    distinct?: SupplierPayableSettlementScalarFieldEnum | SupplierPayableSettlementScalarFieldEnum[]
  }

  /**
   * SupplierPayableSettlement create
   */
  export type SupplierPayableSettlementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierPayableSettlement
     */
    select?: SupplierPayableSettlementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierPayableSettlement
     */
    omit?: SupplierPayableSettlementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierPayableSettlementInclude<ExtArgs> | null
    /**
     * The data needed to create a SupplierPayableSettlement.
     */
    data: XOR<SupplierPayableSettlementCreateInput, SupplierPayableSettlementUncheckedCreateInput>
  }

  /**
   * SupplierPayableSettlement createMany
   */
  export type SupplierPayableSettlementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SupplierPayableSettlements.
     */
    data: SupplierPayableSettlementCreateManyInput | SupplierPayableSettlementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SupplierPayableSettlement createManyAndReturn
   */
  export type SupplierPayableSettlementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierPayableSettlement
     */
    select?: SupplierPayableSettlementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierPayableSettlement
     */
    omit?: SupplierPayableSettlementOmit<ExtArgs> | null
    /**
     * The data used to create many SupplierPayableSettlements.
     */
    data: SupplierPayableSettlementCreateManyInput | SupplierPayableSettlementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierPayableSettlementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SupplierPayableSettlement update
   */
  export type SupplierPayableSettlementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierPayableSettlement
     */
    select?: SupplierPayableSettlementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierPayableSettlement
     */
    omit?: SupplierPayableSettlementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierPayableSettlementInclude<ExtArgs> | null
    /**
     * The data needed to update a SupplierPayableSettlement.
     */
    data: XOR<SupplierPayableSettlementUpdateInput, SupplierPayableSettlementUncheckedUpdateInput>
    /**
     * Choose, which SupplierPayableSettlement to update.
     */
    where: SupplierPayableSettlementWhereUniqueInput
  }

  /**
   * SupplierPayableSettlement updateMany
   */
  export type SupplierPayableSettlementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SupplierPayableSettlements.
     */
    data: XOR<SupplierPayableSettlementUpdateManyMutationInput, SupplierPayableSettlementUncheckedUpdateManyInput>
    /**
     * Filter which SupplierPayableSettlements to update
     */
    where?: SupplierPayableSettlementWhereInput
    /**
     * Limit how many SupplierPayableSettlements to update.
     */
    limit?: number
  }

  /**
   * SupplierPayableSettlement updateManyAndReturn
   */
  export type SupplierPayableSettlementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierPayableSettlement
     */
    select?: SupplierPayableSettlementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierPayableSettlement
     */
    omit?: SupplierPayableSettlementOmit<ExtArgs> | null
    /**
     * The data used to update SupplierPayableSettlements.
     */
    data: XOR<SupplierPayableSettlementUpdateManyMutationInput, SupplierPayableSettlementUncheckedUpdateManyInput>
    /**
     * Filter which SupplierPayableSettlements to update
     */
    where?: SupplierPayableSettlementWhereInput
    /**
     * Limit how many SupplierPayableSettlements to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierPayableSettlementIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SupplierPayableSettlement upsert
   */
  export type SupplierPayableSettlementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierPayableSettlement
     */
    select?: SupplierPayableSettlementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierPayableSettlement
     */
    omit?: SupplierPayableSettlementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierPayableSettlementInclude<ExtArgs> | null
    /**
     * The filter to search for the SupplierPayableSettlement to update in case it exists.
     */
    where: SupplierPayableSettlementWhereUniqueInput
    /**
     * In case the SupplierPayableSettlement found by the `where` argument doesn't exist, create a new SupplierPayableSettlement with this data.
     */
    create: XOR<SupplierPayableSettlementCreateInput, SupplierPayableSettlementUncheckedCreateInput>
    /**
     * In case the SupplierPayableSettlement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SupplierPayableSettlementUpdateInput, SupplierPayableSettlementUncheckedUpdateInput>
  }

  /**
   * SupplierPayableSettlement delete
   */
  export type SupplierPayableSettlementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierPayableSettlement
     */
    select?: SupplierPayableSettlementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierPayableSettlement
     */
    omit?: SupplierPayableSettlementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierPayableSettlementInclude<ExtArgs> | null
    /**
     * Filter which SupplierPayableSettlement to delete.
     */
    where: SupplierPayableSettlementWhereUniqueInput
  }

  /**
   * SupplierPayableSettlement deleteMany
   */
  export type SupplierPayableSettlementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SupplierPayableSettlements to delete
     */
    where?: SupplierPayableSettlementWhereInput
    /**
     * Limit how many SupplierPayableSettlements to delete.
     */
    limit?: number
  }

  /**
   * SupplierPayableSettlement without action
   */
  export type SupplierPayableSettlementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierPayableSettlement
     */
    select?: SupplierPayableSettlementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupplierPayableSettlement
     */
    omit?: SupplierPayableSettlementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierPayableSettlementInclude<ExtArgs> | null
  }


  /**
   * Model CustomerPayable
   */

  export type AggregateCustomerPayable = {
    _count: CustomerPayableCountAggregateOutputType | null
    _avg: CustomerPayableAvgAggregateOutputType | null
    _sum: CustomerPayableSumAggregateOutputType | null
    _min: CustomerPayableMinAggregateOutputType | null
    _max: CustomerPayableMaxAggregateOutputType | null
  }

  export type CustomerPayableAvgAggregateOutputType = {
    id: number | null
    totalAmount: number | null
    paidAmount: number | null
    pendingAmount: number | null
    createdFromCancellationId: number | null
    bookingId: number | null
  }

  export type CustomerPayableSumAggregateOutputType = {
    id: number | null
    totalAmount: number | null
    paidAmount: number | null
    pendingAmount: number | null
    createdFromCancellationId: number | null
    bookingId: number | null
  }

  export type CustomerPayableMinAggregateOutputType = {
    id: number | null
    totalAmount: number | null
    paidAmount: number | null
    pendingAmount: number | null
    reason: string | null
    status: string | null
    createdFromCancellationId: number | null
    bookingId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerPayableMaxAggregateOutputType = {
    id: number | null
    totalAmount: number | null
    paidAmount: number | null
    pendingAmount: number | null
    reason: string | null
    status: string | null
    createdFromCancellationId: number | null
    bookingId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerPayableCountAggregateOutputType = {
    id: number
    totalAmount: number
    paidAmount: number
    pendingAmount: number
    reason: number
    status: number
    createdFromCancellationId: number
    bookingId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CustomerPayableAvgAggregateInputType = {
    id?: true
    totalAmount?: true
    paidAmount?: true
    pendingAmount?: true
    createdFromCancellationId?: true
    bookingId?: true
  }

  export type CustomerPayableSumAggregateInputType = {
    id?: true
    totalAmount?: true
    paidAmount?: true
    pendingAmount?: true
    createdFromCancellationId?: true
    bookingId?: true
  }

  export type CustomerPayableMinAggregateInputType = {
    id?: true
    totalAmount?: true
    paidAmount?: true
    pendingAmount?: true
    reason?: true
    status?: true
    createdFromCancellationId?: true
    bookingId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerPayableMaxAggregateInputType = {
    id?: true
    totalAmount?: true
    paidAmount?: true
    pendingAmount?: true
    reason?: true
    status?: true
    createdFromCancellationId?: true
    bookingId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerPayableCountAggregateInputType = {
    id?: true
    totalAmount?: true
    paidAmount?: true
    pendingAmount?: true
    reason?: true
    status?: true
    createdFromCancellationId?: true
    bookingId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CustomerPayableAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerPayable to aggregate.
     */
    where?: CustomerPayableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerPayables to fetch.
     */
    orderBy?: CustomerPayableOrderByWithRelationInput | CustomerPayableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerPayableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerPayables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerPayables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomerPayables
    **/
    _count?: true | CustomerPayableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerPayableAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerPayableSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerPayableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerPayableMaxAggregateInputType
  }

  export type GetCustomerPayableAggregateType<T extends CustomerPayableAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomerPayable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomerPayable[P]>
      : GetScalarType<T[P], AggregateCustomerPayable[P]>
  }




  export type CustomerPayableGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerPayableWhereInput
    orderBy?: CustomerPayableOrderByWithAggregationInput | CustomerPayableOrderByWithAggregationInput[]
    by: CustomerPayableScalarFieldEnum[] | CustomerPayableScalarFieldEnum
    having?: CustomerPayableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerPayableCountAggregateInputType | true
    _avg?: CustomerPayableAvgAggregateInputType
    _sum?: CustomerPayableSumAggregateInputType
    _min?: CustomerPayableMinAggregateInputType
    _max?: CustomerPayableMaxAggregateInputType
  }

  export type CustomerPayableGroupByOutputType = {
    id: number
    totalAmount: number
    paidAmount: number
    pendingAmount: number
    reason: string
    status: string
    createdFromCancellationId: number
    bookingId: number
    createdAt: Date
    updatedAt: Date
    _count: CustomerPayableCountAggregateOutputType | null
    _avg: CustomerPayableAvgAggregateOutputType | null
    _sum: CustomerPayableSumAggregateOutputType | null
    _min: CustomerPayableMinAggregateOutputType | null
    _max: CustomerPayableMaxAggregateOutputType | null
  }

  type GetCustomerPayableGroupByPayload<T extends CustomerPayableGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerPayableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerPayableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerPayableGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerPayableGroupByOutputType[P]>
        }
      >
    >


  export type CustomerPayableSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    totalAmount?: boolean
    paidAmount?: boolean
    pendingAmount?: boolean
    reason?: boolean
    status?: boolean
    createdFromCancellationId?: boolean
    bookingId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    settlements?: boolean | CustomerPayable$settlementsArgs<ExtArgs>
    createdFromCancellation?: boolean | CancellationDefaultArgs<ExtArgs>
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    _count?: boolean | CustomerPayableCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerPayable"]>

  export type CustomerPayableSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    totalAmount?: boolean
    paidAmount?: boolean
    pendingAmount?: boolean
    reason?: boolean
    status?: boolean
    createdFromCancellationId?: boolean
    bookingId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdFromCancellation?: boolean | CancellationDefaultArgs<ExtArgs>
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerPayable"]>

  export type CustomerPayableSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    totalAmount?: boolean
    paidAmount?: boolean
    pendingAmount?: boolean
    reason?: boolean
    status?: boolean
    createdFromCancellationId?: boolean
    bookingId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    createdFromCancellation?: boolean | CancellationDefaultArgs<ExtArgs>
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerPayable"]>

  export type CustomerPayableSelectScalar = {
    id?: boolean
    totalAmount?: boolean
    paidAmount?: boolean
    pendingAmount?: boolean
    reason?: boolean
    status?: boolean
    createdFromCancellationId?: boolean
    bookingId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CustomerPayableOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "totalAmount" | "paidAmount" | "pendingAmount" | "reason" | "status" | "createdFromCancellationId" | "bookingId" | "createdAt" | "updatedAt", ExtArgs["result"]["customerPayable"]>
  export type CustomerPayableInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    settlements?: boolean | CustomerPayable$settlementsArgs<ExtArgs>
    createdFromCancellation?: boolean | CancellationDefaultArgs<ExtArgs>
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    _count?: boolean | CustomerPayableCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CustomerPayableIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdFromCancellation?: boolean | CancellationDefaultArgs<ExtArgs>
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }
  export type CustomerPayableIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdFromCancellation?: boolean | CancellationDefaultArgs<ExtArgs>
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }

  export type $CustomerPayablePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomerPayable"
    objects: {
      settlements: Prisma.$CustomerPayableSettlementPayload<ExtArgs>[]
      createdFromCancellation: Prisma.$CancellationPayload<ExtArgs>
      booking: Prisma.$BookingPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      totalAmount: number
      paidAmount: number
      pendingAmount: number
      reason: string
      status: string
      createdFromCancellationId: number
      bookingId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["customerPayable"]>
    composites: {}
  }

  type CustomerPayableGetPayload<S extends boolean | null | undefined | CustomerPayableDefaultArgs> = $Result.GetResult<Prisma.$CustomerPayablePayload, S>

  type CustomerPayableCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerPayableFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerPayableCountAggregateInputType | true
    }

  export interface CustomerPayableDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomerPayable'], meta: { name: 'CustomerPayable' } }
    /**
     * Find zero or one CustomerPayable that matches the filter.
     * @param {CustomerPayableFindUniqueArgs} args - Arguments to find a CustomerPayable
     * @example
     * // Get one CustomerPayable
     * const customerPayable = await prisma.customerPayable.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerPayableFindUniqueArgs>(args: SelectSubset<T, CustomerPayableFindUniqueArgs<ExtArgs>>): Prisma__CustomerPayableClient<$Result.GetResult<Prisma.$CustomerPayablePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CustomerPayable that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerPayableFindUniqueOrThrowArgs} args - Arguments to find a CustomerPayable
     * @example
     * // Get one CustomerPayable
     * const customerPayable = await prisma.customerPayable.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerPayableFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerPayableFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerPayableClient<$Result.GetResult<Prisma.$CustomerPayablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerPayable that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerPayableFindFirstArgs} args - Arguments to find a CustomerPayable
     * @example
     * // Get one CustomerPayable
     * const customerPayable = await prisma.customerPayable.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerPayableFindFirstArgs>(args?: SelectSubset<T, CustomerPayableFindFirstArgs<ExtArgs>>): Prisma__CustomerPayableClient<$Result.GetResult<Prisma.$CustomerPayablePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerPayable that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerPayableFindFirstOrThrowArgs} args - Arguments to find a CustomerPayable
     * @example
     * // Get one CustomerPayable
     * const customerPayable = await prisma.customerPayable.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerPayableFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerPayableFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerPayableClient<$Result.GetResult<Prisma.$CustomerPayablePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CustomerPayables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerPayableFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomerPayables
     * const customerPayables = await prisma.customerPayable.findMany()
     * 
     * // Get first 10 CustomerPayables
     * const customerPayables = await prisma.customerPayable.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerPayableWithIdOnly = await prisma.customerPayable.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerPayableFindManyArgs>(args?: SelectSubset<T, CustomerPayableFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CustomerPayable.
     * @param {CustomerPayableCreateArgs} args - Arguments to create a CustomerPayable.
     * @example
     * // Create one CustomerPayable
     * const CustomerPayable = await prisma.customerPayable.create({
     *   data: {
     *     // ... data to create a CustomerPayable
     *   }
     * })
     * 
     */
    create<T extends CustomerPayableCreateArgs>(args: SelectSubset<T, CustomerPayableCreateArgs<ExtArgs>>): Prisma__CustomerPayableClient<$Result.GetResult<Prisma.$CustomerPayablePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CustomerPayables.
     * @param {CustomerPayableCreateManyArgs} args - Arguments to create many CustomerPayables.
     * @example
     * // Create many CustomerPayables
     * const customerPayable = await prisma.customerPayable.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerPayableCreateManyArgs>(args?: SelectSubset<T, CustomerPayableCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CustomerPayables and returns the data saved in the database.
     * @param {CustomerPayableCreateManyAndReturnArgs} args - Arguments to create many CustomerPayables.
     * @example
     * // Create many CustomerPayables
     * const customerPayable = await prisma.customerPayable.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CustomerPayables and only return the `id`
     * const customerPayableWithIdOnly = await prisma.customerPayable.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerPayableCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerPayableCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayablePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CustomerPayable.
     * @param {CustomerPayableDeleteArgs} args - Arguments to delete one CustomerPayable.
     * @example
     * // Delete one CustomerPayable
     * const CustomerPayable = await prisma.customerPayable.delete({
     *   where: {
     *     // ... filter to delete one CustomerPayable
     *   }
     * })
     * 
     */
    delete<T extends CustomerPayableDeleteArgs>(args: SelectSubset<T, CustomerPayableDeleteArgs<ExtArgs>>): Prisma__CustomerPayableClient<$Result.GetResult<Prisma.$CustomerPayablePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CustomerPayable.
     * @param {CustomerPayableUpdateArgs} args - Arguments to update one CustomerPayable.
     * @example
     * // Update one CustomerPayable
     * const customerPayable = await prisma.customerPayable.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerPayableUpdateArgs>(args: SelectSubset<T, CustomerPayableUpdateArgs<ExtArgs>>): Prisma__CustomerPayableClient<$Result.GetResult<Prisma.$CustomerPayablePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CustomerPayables.
     * @param {CustomerPayableDeleteManyArgs} args - Arguments to filter CustomerPayables to delete.
     * @example
     * // Delete a few CustomerPayables
     * const { count } = await prisma.customerPayable.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerPayableDeleteManyArgs>(args?: SelectSubset<T, CustomerPayableDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerPayables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerPayableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomerPayables
     * const customerPayable = await prisma.customerPayable.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerPayableUpdateManyArgs>(args: SelectSubset<T, CustomerPayableUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerPayables and returns the data updated in the database.
     * @param {CustomerPayableUpdateManyAndReturnArgs} args - Arguments to update many CustomerPayables.
     * @example
     * // Update many CustomerPayables
     * const customerPayable = await prisma.customerPayable.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CustomerPayables and only return the `id`
     * const customerPayableWithIdOnly = await prisma.customerPayable.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomerPayableUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomerPayableUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayablePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CustomerPayable.
     * @param {CustomerPayableUpsertArgs} args - Arguments to update or create a CustomerPayable.
     * @example
     * // Update or create a CustomerPayable
     * const customerPayable = await prisma.customerPayable.upsert({
     *   create: {
     *     // ... data to create a CustomerPayable
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomerPayable we want to update
     *   }
     * })
     */
    upsert<T extends CustomerPayableUpsertArgs>(args: SelectSubset<T, CustomerPayableUpsertArgs<ExtArgs>>): Prisma__CustomerPayableClient<$Result.GetResult<Prisma.$CustomerPayablePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CustomerPayables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerPayableCountArgs} args - Arguments to filter CustomerPayables to count.
     * @example
     * // Count the number of CustomerPayables
     * const count = await prisma.customerPayable.count({
     *   where: {
     *     // ... the filter for the CustomerPayables we want to count
     *   }
     * })
    **/
    count<T extends CustomerPayableCountArgs>(
      args?: Subset<T, CustomerPayableCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerPayableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomerPayable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerPayableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerPayableAggregateArgs>(args: Subset<T, CustomerPayableAggregateArgs>): Prisma.PrismaPromise<GetCustomerPayableAggregateType<T>>

    /**
     * Group by CustomerPayable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerPayableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerPayableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerPayableGroupByArgs['orderBy'] }
        : { orderBy?: CustomerPayableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerPayableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerPayableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomerPayable model
   */
  readonly fields: CustomerPayableFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomerPayable.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerPayableClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    settlements<T extends CustomerPayable$settlementsArgs<ExtArgs> = {}>(args?: Subset<T, CustomerPayable$settlementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayableSettlementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    createdFromCancellation<T extends CancellationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CancellationDefaultArgs<ExtArgs>>): Prisma__CancellationClient<$Result.GetResult<Prisma.$CancellationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    booking<T extends BookingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BookingDefaultArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CustomerPayable model
   */
  interface CustomerPayableFieldRefs {
    readonly id: FieldRef<"CustomerPayable", 'Int'>
    readonly totalAmount: FieldRef<"CustomerPayable", 'Float'>
    readonly paidAmount: FieldRef<"CustomerPayable", 'Float'>
    readonly pendingAmount: FieldRef<"CustomerPayable", 'Float'>
    readonly reason: FieldRef<"CustomerPayable", 'String'>
    readonly status: FieldRef<"CustomerPayable", 'String'>
    readonly createdFromCancellationId: FieldRef<"CustomerPayable", 'Int'>
    readonly bookingId: FieldRef<"CustomerPayable", 'Int'>
    readonly createdAt: FieldRef<"CustomerPayable", 'DateTime'>
    readonly updatedAt: FieldRef<"CustomerPayable", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CustomerPayable findUnique
   */
  export type CustomerPayableFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPayable
     */
    select?: CustomerPayableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPayable
     */
    omit?: CustomerPayableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPayableInclude<ExtArgs> | null
    /**
     * Filter, which CustomerPayable to fetch.
     */
    where: CustomerPayableWhereUniqueInput
  }

  /**
   * CustomerPayable findUniqueOrThrow
   */
  export type CustomerPayableFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPayable
     */
    select?: CustomerPayableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPayable
     */
    omit?: CustomerPayableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPayableInclude<ExtArgs> | null
    /**
     * Filter, which CustomerPayable to fetch.
     */
    where: CustomerPayableWhereUniqueInput
  }

  /**
   * CustomerPayable findFirst
   */
  export type CustomerPayableFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPayable
     */
    select?: CustomerPayableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPayable
     */
    omit?: CustomerPayableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPayableInclude<ExtArgs> | null
    /**
     * Filter, which CustomerPayable to fetch.
     */
    where?: CustomerPayableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerPayables to fetch.
     */
    orderBy?: CustomerPayableOrderByWithRelationInput | CustomerPayableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerPayables.
     */
    cursor?: CustomerPayableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerPayables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerPayables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerPayables.
     */
    distinct?: CustomerPayableScalarFieldEnum | CustomerPayableScalarFieldEnum[]
  }

  /**
   * CustomerPayable findFirstOrThrow
   */
  export type CustomerPayableFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPayable
     */
    select?: CustomerPayableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPayable
     */
    omit?: CustomerPayableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPayableInclude<ExtArgs> | null
    /**
     * Filter, which CustomerPayable to fetch.
     */
    where?: CustomerPayableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerPayables to fetch.
     */
    orderBy?: CustomerPayableOrderByWithRelationInput | CustomerPayableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerPayables.
     */
    cursor?: CustomerPayableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerPayables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerPayables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerPayables.
     */
    distinct?: CustomerPayableScalarFieldEnum | CustomerPayableScalarFieldEnum[]
  }

  /**
   * CustomerPayable findMany
   */
  export type CustomerPayableFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPayable
     */
    select?: CustomerPayableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPayable
     */
    omit?: CustomerPayableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPayableInclude<ExtArgs> | null
    /**
     * Filter, which CustomerPayables to fetch.
     */
    where?: CustomerPayableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerPayables to fetch.
     */
    orderBy?: CustomerPayableOrderByWithRelationInput | CustomerPayableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomerPayables.
     */
    cursor?: CustomerPayableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerPayables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerPayables.
     */
    skip?: number
    distinct?: CustomerPayableScalarFieldEnum | CustomerPayableScalarFieldEnum[]
  }

  /**
   * CustomerPayable create
   */
  export type CustomerPayableCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPayable
     */
    select?: CustomerPayableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPayable
     */
    omit?: CustomerPayableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPayableInclude<ExtArgs> | null
    /**
     * The data needed to create a CustomerPayable.
     */
    data: XOR<CustomerPayableCreateInput, CustomerPayableUncheckedCreateInput>
  }

  /**
   * CustomerPayable createMany
   */
  export type CustomerPayableCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomerPayables.
     */
    data: CustomerPayableCreateManyInput | CustomerPayableCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CustomerPayable createManyAndReturn
   */
  export type CustomerPayableCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPayable
     */
    select?: CustomerPayableSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPayable
     */
    omit?: CustomerPayableOmit<ExtArgs> | null
    /**
     * The data used to create many CustomerPayables.
     */
    data: CustomerPayableCreateManyInput | CustomerPayableCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPayableIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomerPayable update
   */
  export type CustomerPayableUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPayable
     */
    select?: CustomerPayableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPayable
     */
    omit?: CustomerPayableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPayableInclude<ExtArgs> | null
    /**
     * The data needed to update a CustomerPayable.
     */
    data: XOR<CustomerPayableUpdateInput, CustomerPayableUncheckedUpdateInput>
    /**
     * Choose, which CustomerPayable to update.
     */
    where: CustomerPayableWhereUniqueInput
  }

  /**
   * CustomerPayable updateMany
   */
  export type CustomerPayableUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomerPayables.
     */
    data: XOR<CustomerPayableUpdateManyMutationInput, CustomerPayableUncheckedUpdateManyInput>
    /**
     * Filter which CustomerPayables to update
     */
    where?: CustomerPayableWhereInput
    /**
     * Limit how many CustomerPayables to update.
     */
    limit?: number
  }

  /**
   * CustomerPayable updateManyAndReturn
   */
  export type CustomerPayableUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPayable
     */
    select?: CustomerPayableSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPayable
     */
    omit?: CustomerPayableOmit<ExtArgs> | null
    /**
     * The data used to update CustomerPayables.
     */
    data: XOR<CustomerPayableUpdateManyMutationInput, CustomerPayableUncheckedUpdateManyInput>
    /**
     * Filter which CustomerPayables to update
     */
    where?: CustomerPayableWhereInput
    /**
     * Limit how many CustomerPayables to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPayableIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomerPayable upsert
   */
  export type CustomerPayableUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPayable
     */
    select?: CustomerPayableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPayable
     */
    omit?: CustomerPayableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPayableInclude<ExtArgs> | null
    /**
     * The filter to search for the CustomerPayable to update in case it exists.
     */
    where: CustomerPayableWhereUniqueInput
    /**
     * In case the CustomerPayable found by the `where` argument doesn't exist, create a new CustomerPayable with this data.
     */
    create: XOR<CustomerPayableCreateInput, CustomerPayableUncheckedCreateInput>
    /**
     * In case the CustomerPayable was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerPayableUpdateInput, CustomerPayableUncheckedUpdateInput>
  }

  /**
   * CustomerPayable delete
   */
  export type CustomerPayableDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPayable
     */
    select?: CustomerPayableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPayable
     */
    omit?: CustomerPayableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPayableInclude<ExtArgs> | null
    /**
     * Filter which CustomerPayable to delete.
     */
    where: CustomerPayableWhereUniqueInput
  }

  /**
   * CustomerPayable deleteMany
   */
  export type CustomerPayableDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerPayables to delete
     */
    where?: CustomerPayableWhereInput
    /**
     * Limit how many CustomerPayables to delete.
     */
    limit?: number
  }

  /**
   * CustomerPayable.settlements
   */
  export type CustomerPayable$settlementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPayableSettlement
     */
    select?: CustomerPayableSettlementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPayableSettlement
     */
    omit?: CustomerPayableSettlementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPayableSettlementInclude<ExtArgs> | null
    where?: CustomerPayableSettlementWhereInput
    orderBy?: CustomerPayableSettlementOrderByWithRelationInput | CustomerPayableSettlementOrderByWithRelationInput[]
    cursor?: CustomerPayableSettlementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerPayableSettlementScalarFieldEnum | CustomerPayableSettlementScalarFieldEnum[]
  }

  /**
   * CustomerPayable without action
   */
  export type CustomerPayableDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPayable
     */
    select?: CustomerPayableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPayable
     */
    omit?: CustomerPayableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPayableInclude<ExtArgs> | null
  }


  /**
   * Model CustomerPayableSettlement
   */

  export type AggregateCustomerPayableSettlement = {
    _count: CustomerPayableSettlementCountAggregateOutputType | null
    _avg: CustomerPayableSettlementAvgAggregateOutputType | null
    _sum: CustomerPayableSettlementSumAggregateOutputType | null
    _min: CustomerPayableSettlementMinAggregateOutputType | null
    _max: CustomerPayableSettlementMaxAggregateOutputType | null
  }

  export type CustomerPayableSettlementAvgAggregateOutputType = {
    id: number | null
    customerPayableId: number | null
    amount: number | null
  }

  export type CustomerPayableSettlementSumAggregateOutputType = {
    id: number | null
    customerPayableId: number | null
    amount: number | null
  }

  export type CustomerPayableSettlementMinAggregateOutputType = {
    id: number | null
    customerPayableId: number | null
    amount: number | null
    transactionMethod: string | null
    paymentDate: Date | null
    createdAt: Date | null
  }

  export type CustomerPayableSettlementMaxAggregateOutputType = {
    id: number | null
    customerPayableId: number | null
    amount: number | null
    transactionMethod: string | null
    paymentDate: Date | null
    createdAt: Date | null
  }

  export type CustomerPayableSettlementCountAggregateOutputType = {
    id: number
    customerPayableId: number
    amount: number
    transactionMethod: number
    paymentDate: number
    createdAt: number
    _all: number
  }


  export type CustomerPayableSettlementAvgAggregateInputType = {
    id?: true
    customerPayableId?: true
    amount?: true
  }

  export type CustomerPayableSettlementSumAggregateInputType = {
    id?: true
    customerPayableId?: true
    amount?: true
  }

  export type CustomerPayableSettlementMinAggregateInputType = {
    id?: true
    customerPayableId?: true
    amount?: true
    transactionMethod?: true
    paymentDate?: true
    createdAt?: true
  }

  export type CustomerPayableSettlementMaxAggregateInputType = {
    id?: true
    customerPayableId?: true
    amount?: true
    transactionMethod?: true
    paymentDate?: true
    createdAt?: true
  }

  export type CustomerPayableSettlementCountAggregateInputType = {
    id?: true
    customerPayableId?: true
    amount?: true
    transactionMethod?: true
    paymentDate?: true
    createdAt?: true
    _all?: true
  }

  export type CustomerPayableSettlementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerPayableSettlement to aggregate.
     */
    where?: CustomerPayableSettlementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerPayableSettlements to fetch.
     */
    orderBy?: CustomerPayableSettlementOrderByWithRelationInput | CustomerPayableSettlementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerPayableSettlementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerPayableSettlements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerPayableSettlements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CustomerPayableSettlements
    **/
    _count?: true | CustomerPayableSettlementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerPayableSettlementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerPayableSettlementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerPayableSettlementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerPayableSettlementMaxAggregateInputType
  }

  export type GetCustomerPayableSettlementAggregateType<T extends CustomerPayableSettlementAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomerPayableSettlement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomerPayableSettlement[P]>
      : GetScalarType<T[P], AggregateCustomerPayableSettlement[P]>
  }




  export type CustomerPayableSettlementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerPayableSettlementWhereInput
    orderBy?: CustomerPayableSettlementOrderByWithAggregationInput | CustomerPayableSettlementOrderByWithAggregationInput[]
    by: CustomerPayableSettlementScalarFieldEnum[] | CustomerPayableSettlementScalarFieldEnum
    having?: CustomerPayableSettlementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerPayableSettlementCountAggregateInputType | true
    _avg?: CustomerPayableSettlementAvgAggregateInputType
    _sum?: CustomerPayableSettlementSumAggregateInputType
    _min?: CustomerPayableSettlementMinAggregateInputType
    _max?: CustomerPayableSettlementMaxAggregateInputType
  }

  export type CustomerPayableSettlementGroupByOutputType = {
    id: number
    customerPayableId: number
    amount: number
    transactionMethod: string
    paymentDate: Date
    createdAt: Date
    _count: CustomerPayableSettlementCountAggregateOutputType | null
    _avg: CustomerPayableSettlementAvgAggregateOutputType | null
    _sum: CustomerPayableSettlementSumAggregateOutputType | null
    _min: CustomerPayableSettlementMinAggregateOutputType | null
    _max: CustomerPayableSettlementMaxAggregateOutputType | null
  }

  type GetCustomerPayableSettlementGroupByPayload<T extends CustomerPayableSettlementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerPayableSettlementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerPayableSettlementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerPayableSettlementGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerPayableSettlementGroupByOutputType[P]>
        }
      >
    >


  export type CustomerPayableSettlementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerPayableId?: boolean
    amount?: boolean
    transactionMethod?: boolean
    paymentDate?: boolean
    createdAt?: boolean
    payable?: boolean | CustomerPayableDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerPayableSettlement"]>

  export type CustomerPayableSettlementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerPayableId?: boolean
    amount?: boolean
    transactionMethod?: boolean
    paymentDate?: boolean
    createdAt?: boolean
    payable?: boolean | CustomerPayableDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerPayableSettlement"]>

  export type CustomerPayableSettlementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    customerPayableId?: boolean
    amount?: boolean
    transactionMethod?: boolean
    paymentDate?: boolean
    createdAt?: boolean
    payable?: boolean | CustomerPayableDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerPayableSettlement"]>

  export type CustomerPayableSettlementSelectScalar = {
    id?: boolean
    customerPayableId?: boolean
    amount?: boolean
    transactionMethod?: boolean
    paymentDate?: boolean
    createdAt?: boolean
  }

  export type CustomerPayableSettlementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "customerPayableId" | "amount" | "transactionMethod" | "paymentDate" | "createdAt", ExtArgs["result"]["customerPayableSettlement"]>
  export type CustomerPayableSettlementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payable?: boolean | CustomerPayableDefaultArgs<ExtArgs>
  }
  export type CustomerPayableSettlementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payable?: boolean | CustomerPayableDefaultArgs<ExtArgs>
  }
  export type CustomerPayableSettlementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payable?: boolean | CustomerPayableDefaultArgs<ExtArgs>
  }

  export type $CustomerPayableSettlementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CustomerPayableSettlement"
    objects: {
      payable: Prisma.$CustomerPayablePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      customerPayableId: number
      amount: number
      transactionMethod: string
      paymentDate: Date
      createdAt: Date
    }, ExtArgs["result"]["customerPayableSettlement"]>
    composites: {}
  }

  type CustomerPayableSettlementGetPayload<S extends boolean | null | undefined | CustomerPayableSettlementDefaultArgs> = $Result.GetResult<Prisma.$CustomerPayableSettlementPayload, S>

  type CustomerPayableSettlementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerPayableSettlementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerPayableSettlementCountAggregateInputType | true
    }

  export interface CustomerPayableSettlementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CustomerPayableSettlement'], meta: { name: 'CustomerPayableSettlement' } }
    /**
     * Find zero or one CustomerPayableSettlement that matches the filter.
     * @param {CustomerPayableSettlementFindUniqueArgs} args - Arguments to find a CustomerPayableSettlement
     * @example
     * // Get one CustomerPayableSettlement
     * const customerPayableSettlement = await prisma.customerPayableSettlement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerPayableSettlementFindUniqueArgs>(args: SelectSubset<T, CustomerPayableSettlementFindUniqueArgs<ExtArgs>>): Prisma__CustomerPayableSettlementClient<$Result.GetResult<Prisma.$CustomerPayableSettlementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CustomerPayableSettlement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerPayableSettlementFindUniqueOrThrowArgs} args - Arguments to find a CustomerPayableSettlement
     * @example
     * // Get one CustomerPayableSettlement
     * const customerPayableSettlement = await prisma.customerPayableSettlement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerPayableSettlementFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerPayableSettlementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerPayableSettlementClient<$Result.GetResult<Prisma.$CustomerPayableSettlementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerPayableSettlement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerPayableSettlementFindFirstArgs} args - Arguments to find a CustomerPayableSettlement
     * @example
     * // Get one CustomerPayableSettlement
     * const customerPayableSettlement = await prisma.customerPayableSettlement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerPayableSettlementFindFirstArgs>(args?: SelectSubset<T, CustomerPayableSettlementFindFirstArgs<ExtArgs>>): Prisma__CustomerPayableSettlementClient<$Result.GetResult<Prisma.$CustomerPayableSettlementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CustomerPayableSettlement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerPayableSettlementFindFirstOrThrowArgs} args - Arguments to find a CustomerPayableSettlement
     * @example
     * // Get one CustomerPayableSettlement
     * const customerPayableSettlement = await prisma.customerPayableSettlement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerPayableSettlementFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerPayableSettlementFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerPayableSettlementClient<$Result.GetResult<Prisma.$CustomerPayableSettlementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CustomerPayableSettlements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerPayableSettlementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CustomerPayableSettlements
     * const customerPayableSettlements = await prisma.customerPayableSettlement.findMany()
     * 
     * // Get first 10 CustomerPayableSettlements
     * const customerPayableSettlements = await prisma.customerPayableSettlement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerPayableSettlementWithIdOnly = await prisma.customerPayableSettlement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerPayableSettlementFindManyArgs>(args?: SelectSubset<T, CustomerPayableSettlementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayableSettlementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CustomerPayableSettlement.
     * @param {CustomerPayableSettlementCreateArgs} args - Arguments to create a CustomerPayableSettlement.
     * @example
     * // Create one CustomerPayableSettlement
     * const CustomerPayableSettlement = await prisma.customerPayableSettlement.create({
     *   data: {
     *     // ... data to create a CustomerPayableSettlement
     *   }
     * })
     * 
     */
    create<T extends CustomerPayableSettlementCreateArgs>(args: SelectSubset<T, CustomerPayableSettlementCreateArgs<ExtArgs>>): Prisma__CustomerPayableSettlementClient<$Result.GetResult<Prisma.$CustomerPayableSettlementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CustomerPayableSettlements.
     * @param {CustomerPayableSettlementCreateManyArgs} args - Arguments to create many CustomerPayableSettlements.
     * @example
     * // Create many CustomerPayableSettlements
     * const customerPayableSettlement = await prisma.customerPayableSettlement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerPayableSettlementCreateManyArgs>(args?: SelectSubset<T, CustomerPayableSettlementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CustomerPayableSettlements and returns the data saved in the database.
     * @param {CustomerPayableSettlementCreateManyAndReturnArgs} args - Arguments to create many CustomerPayableSettlements.
     * @example
     * // Create many CustomerPayableSettlements
     * const customerPayableSettlement = await prisma.customerPayableSettlement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CustomerPayableSettlements and only return the `id`
     * const customerPayableSettlementWithIdOnly = await prisma.customerPayableSettlement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerPayableSettlementCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerPayableSettlementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayableSettlementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CustomerPayableSettlement.
     * @param {CustomerPayableSettlementDeleteArgs} args - Arguments to delete one CustomerPayableSettlement.
     * @example
     * // Delete one CustomerPayableSettlement
     * const CustomerPayableSettlement = await prisma.customerPayableSettlement.delete({
     *   where: {
     *     // ... filter to delete one CustomerPayableSettlement
     *   }
     * })
     * 
     */
    delete<T extends CustomerPayableSettlementDeleteArgs>(args: SelectSubset<T, CustomerPayableSettlementDeleteArgs<ExtArgs>>): Prisma__CustomerPayableSettlementClient<$Result.GetResult<Prisma.$CustomerPayableSettlementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CustomerPayableSettlement.
     * @param {CustomerPayableSettlementUpdateArgs} args - Arguments to update one CustomerPayableSettlement.
     * @example
     * // Update one CustomerPayableSettlement
     * const customerPayableSettlement = await prisma.customerPayableSettlement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerPayableSettlementUpdateArgs>(args: SelectSubset<T, CustomerPayableSettlementUpdateArgs<ExtArgs>>): Prisma__CustomerPayableSettlementClient<$Result.GetResult<Prisma.$CustomerPayableSettlementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CustomerPayableSettlements.
     * @param {CustomerPayableSettlementDeleteManyArgs} args - Arguments to filter CustomerPayableSettlements to delete.
     * @example
     * // Delete a few CustomerPayableSettlements
     * const { count } = await prisma.customerPayableSettlement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerPayableSettlementDeleteManyArgs>(args?: SelectSubset<T, CustomerPayableSettlementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerPayableSettlements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerPayableSettlementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CustomerPayableSettlements
     * const customerPayableSettlement = await prisma.customerPayableSettlement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerPayableSettlementUpdateManyArgs>(args: SelectSubset<T, CustomerPayableSettlementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CustomerPayableSettlements and returns the data updated in the database.
     * @param {CustomerPayableSettlementUpdateManyAndReturnArgs} args - Arguments to update many CustomerPayableSettlements.
     * @example
     * // Update many CustomerPayableSettlements
     * const customerPayableSettlement = await prisma.customerPayableSettlement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CustomerPayableSettlements and only return the `id`
     * const customerPayableSettlementWithIdOnly = await prisma.customerPayableSettlement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomerPayableSettlementUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomerPayableSettlementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayableSettlementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CustomerPayableSettlement.
     * @param {CustomerPayableSettlementUpsertArgs} args - Arguments to update or create a CustomerPayableSettlement.
     * @example
     * // Update or create a CustomerPayableSettlement
     * const customerPayableSettlement = await prisma.customerPayableSettlement.upsert({
     *   create: {
     *     // ... data to create a CustomerPayableSettlement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CustomerPayableSettlement we want to update
     *   }
     * })
     */
    upsert<T extends CustomerPayableSettlementUpsertArgs>(args: SelectSubset<T, CustomerPayableSettlementUpsertArgs<ExtArgs>>): Prisma__CustomerPayableSettlementClient<$Result.GetResult<Prisma.$CustomerPayableSettlementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CustomerPayableSettlements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerPayableSettlementCountArgs} args - Arguments to filter CustomerPayableSettlements to count.
     * @example
     * // Count the number of CustomerPayableSettlements
     * const count = await prisma.customerPayableSettlement.count({
     *   where: {
     *     // ... the filter for the CustomerPayableSettlements we want to count
     *   }
     * })
    **/
    count<T extends CustomerPayableSettlementCountArgs>(
      args?: Subset<T, CustomerPayableSettlementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerPayableSettlementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CustomerPayableSettlement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerPayableSettlementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerPayableSettlementAggregateArgs>(args: Subset<T, CustomerPayableSettlementAggregateArgs>): Prisma.PrismaPromise<GetCustomerPayableSettlementAggregateType<T>>

    /**
     * Group by CustomerPayableSettlement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerPayableSettlementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerPayableSettlementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerPayableSettlementGroupByArgs['orderBy'] }
        : { orderBy?: CustomerPayableSettlementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerPayableSettlementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerPayableSettlementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CustomerPayableSettlement model
   */
  readonly fields: CustomerPayableSettlementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CustomerPayableSettlement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerPayableSettlementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    payable<T extends CustomerPayableDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerPayableDefaultArgs<ExtArgs>>): Prisma__CustomerPayableClient<$Result.GetResult<Prisma.$CustomerPayablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CustomerPayableSettlement model
   */
  interface CustomerPayableSettlementFieldRefs {
    readonly id: FieldRef<"CustomerPayableSettlement", 'Int'>
    readonly customerPayableId: FieldRef<"CustomerPayableSettlement", 'Int'>
    readonly amount: FieldRef<"CustomerPayableSettlement", 'Float'>
    readonly transactionMethod: FieldRef<"CustomerPayableSettlement", 'String'>
    readonly paymentDate: FieldRef<"CustomerPayableSettlement", 'DateTime'>
    readonly createdAt: FieldRef<"CustomerPayableSettlement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CustomerPayableSettlement findUnique
   */
  export type CustomerPayableSettlementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPayableSettlement
     */
    select?: CustomerPayableSettlementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPayableSettlement
     */
    omit?: CustomerPayableSettlementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPayableSettlementInclude<ExtArgs> | null
    /**
     * Filter, which CustomerPayableSettlement to fetch.
     */
    where: CustomerPayableSettlementWhereUniqueInput
  }

  /**
   * CustomerPayableSettlement findUniqueOrThrow
   */
  export type CustomerPayableSettlementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPayableSettlement
     */
    select?: CustomerPayableSettlementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPayableSettlement
     */
    omit?: CustomerPayableSettlementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPayableSettlementInclude<ExtArgs> | null
    /**
     * Filter, which CustomerPayableSettlement to fetch.
     */
    where: CustomerPayableSettlementWhereUniqueInput
  }

  /**
   * CustomerPayableSettlement findFirst
   */
  export type CustomerPayableSettlementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPayableSettlement
     */
    select?: CustomerPayableSettlementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPayableSettlement
     */
    omit?: CustomerPayableSettlementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPayableSettlementInclude<ExtArgs> | null
    /**
     * Filter, which CustomerPayableSettlement to fetch.
     */
    where?: CustomerPayableSettlementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerPayableSettlements to fetch.
     */
    orderBy?: CustomerPayableSettlementOrderByWithRelationInput | CustomerPayableSettlementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerPayableSettlements.
     */
    cursor?: CustomerPayableSettlementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerPayableSettlements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerPayableSettlements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerPayableSettlements.
     */
    distinct?: CustomerPayableSettlementScalarFieldEnum | CustomerPayableSettlementScalarFieldEnum[]
  }

  /**
   * CustomerPayableSettlement findFirstOrThrow
   */
  export type CustomerPayableSettlementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPayableSettlement
     */
    select?: CustomerPayableSettlementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPayableSettlement
     */
    omit?: CustomerPayableSettlementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPayableSettlementInclude<ExtArgs> | null
    /**
     * Filter, which CustomerPayableSettlement to fetch.
     */
    where?: CustomerPayableSettlementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerPayableSettlements to fetch.
     */
    orderBy?: CustomerPayableSettlementOrderByWithRelationInput | CustomerPayableSettlementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CustomerPayableSettlements.
     */
    cursor?: CustomerPayableSettlementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerPayableSettlements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerPayableSettlements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CustomerPayableSettlements.
     */
    distinct?: CustomerPayableSettlementScalarFieldEnum | CustomerPayableSettlementScalarFieldEnum[]
  }

  /**
   * CustomerPayableSettlement findMany
   */
  export type CustomerPayableSettlementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPayableSettlement
     */
    select?: CustomerPayableSettlementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPayableSettlement
     */
    omit?: CustomerPayableSettlementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPayableSettlementInclude<ExtArgs> | null
    /**
     * Filter, which CustomerPayableSettlements to fetch.
     */
    where?: CustomerPayableSettlementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CustomerPayableSettlements to fetch.
     */
    orderBy?: CustomerPayableSettlementOrderByWithRelationInput | CustomerPayableSettlementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CustomerPayableSettlements.
     */
    cursor?: CustomerPayableSettlementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CustomerPayableSettlements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CustomerPayableSettlements.
     */
    skip?: number
    distinct?: CustomerPayableSettlementScalarFieldEnum | CustomerPayableSettlementScalarFieldEnum[]
  }

  /**
   * CustomerPayableSettlement create
   */
  export type CustomerPayableSettlementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPayableSettlement
     */
    select?: CustomerPayableSettlementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPayableSettlement
     */
    omit?: CustomerPayableSettlementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPayableSettlementInclude<ExtArgs> | null
    /**
     * The data needed to create a CustomerPayableSettlement.
     */
    data: XOR<CustomerPayableSettlementCreateInput, CustomerPayableSettlementUncheckedCreateInput>
  }

  /**
   * CustomerPayableSettlement createMany
   */
  export type CustomerPayableSettlementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CustomerPayableSettlements.
     */
    data: CustomerPayableSettlementCreateManyInput | CustomerPayableSettlementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CustomerPayableSettlement createManyAndReturn
   */
  export type CustomerPayableSettlementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPayableSettlement
     */
    select?: CustomerPayableSettlementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPayableSettlement
     */
    omit?: CustomerPayableSettlementOmit<ExtArgs> | null
    /**
     * The data used to create many CustomerPayableSettlements.
     */
    data: CustomerPayableSettlementCreateManyInput | CustomerPayableSettlementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPayableSettlementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomerPayableSettlement update
   */
  export type CustomerPayableSettlementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPayableSettlement
     */
    select?: CustomerPayableSettlementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPayableSettlement
     */
    omit?: CustomerPayableSettlementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPayableSettlementInclude<ExtArgs> | null
    /**
     * The data needed to update a CustomerPayableSettlement.
     */
    data: XOR<CustomerPayableSettlementUpdateInput, CustomerPayableSettlementUncheckedUpdateInput>
    /**
     * Choose, which CustomerPayableSettlement to update.
     */
    where: CustomerPayableSettlementWhereUniqueInput
  }

  /**
   * CustomerPayableSettlement updateMany
   */
  export type CustomerPayableSettlementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CustomerPayableSettlements.
     */
    data: XOR<CustomerPayableSettlementUpdateManyMutationInput, CustomerPayableSettlementUncheckedUpdateManyInput>
    /**
     * Filter which CustomerPayableSettlements to update
     */
    where?: CustomerPayableSettlementWhereInput
    /**
     * Limit how many CustomerPayableSettlements to update.
     */
    limit?: number
  }

  /**
   * CustomerPayableSettlement updateManyAndReturn
   */
  export type CustomerPayableSettlementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPayableSettlement
     */
    select?: CustomerPayableSettlementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPayableSettlement
     */
    omit?: CustomerPayableSettlementOmit<ExtArgs> | null
    /**
     * The data used to update CustomerPayableSettlements.
     */
    data: XOR<CustomerPayableSettlementUpdateManyMutationInput, CustomerPayableSettlementUncheckedUpdateManyInput>
    /**
     * Filter which CustomerPayableSettlements to update
     */
    where?: CustomerPayableSettlementWhereInput
    /**
     * Limit how many CustomerPayableSettlements to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPayableSettlementIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CustomerPayableSettlement upsert
   */
  export type CustomerPayableSettlementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPayableSettlement
     */
    select?: CustomerPayableSettlementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPayableSettlement
     */
    omit?: CustomerPayableSettlementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPayableSettlementInclude<ExtArgs> | null
    /**
     * The filter to search for the CustomerPayableSettlement to update in case it exists.
     */
    where: CustomerPayableSettlementWhereUniqueInput
    /**
     * In case the CustomerPayableSettlement found by the `where` argument doesn't exist, create a new CustomerPayableSettlement with this data.
     */
    create: XOR<CustomerPayableSettlementCreateInput, CustomerPayableSettlementUncheckedCreateInput>
    /**
     * In case the CustomerPayableSettlement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerPayableSettlementUpdateInput, CustomerPayableSettlementUncheckedUpdateInput>
  }

  /**
   * CustomerPayableSettlement delete
   */
  export type CustomerPayableSettlementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPayableSettlement
     */
    select?: CustomerPayableSettlementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPayableSettlement
     */
    omit?: CustomerPayableSettlementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPayableSettlementInclude<ExtArgs> | null
    /**
     * Filter which CustomerPayableSettlement to delete.
     */
    where: CustomerPayableSettlementWhereUniqueInput
  }

  /**
   * CustomerPayableSettlement deleteMany
   */
  export type CustomerPayableSettlementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CustomerPayableSettlements to delete
     */
    where?: CustomerPayableSettlementWhereInput
    /**
     * Limit how many CustomerPayableSettlements to delete.
     */
    limit?: number
  }

  /**
   * CustomerPayableSettlement without action
   */
  export type CustomerPayableSettlementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerPayableSettlement
     */
    select?: CustomerPayableSettlementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CustomerPayableSettlement
     */
    omit?: CustomerPayableSettlementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerPayableSettlementInclude<ExtArgs> | null
  }


  /**
   * Model PassengerRefundPayment
   */

  export type AggregatePassengerRefundPayment = {
    _count: PassengerRefundPaymentCountAggregateOutputType | null
    _avg: PassengerRefundPaymentAvgAggregateOutputType | null
    _sum: PassengerRefundPaymentSumAggregateOutputType | null
    _min: PassengerRefundPaymentMinAggregateOutputType | null
    _max: PassengerRefundPaymentMaxAggregateOutputType | null
  }

  export type PassengerRefundPaymentAvgAggregateOutputType = {
    id: number | null
    amount: number | null
    cancellationId: number | null
  }

  export type PassengerRefundPaymentSumAggregateOutputType = {
    id: number | null
    amount: number | null
    cancellationId: number | null
  }

  export type PassengerRefundPaymentMinAggregateOutputType = {
    id: number | null
    amount: number | null
    transactionMethod: string | null
    refundDate: Date | null
    cancellationId: number | null
    createdAt: Date | null
  }

  export type PassengerRefundPaymentMaxAggregateOutputType = {
    id: number | null
    amount: number | null
    transactionMethod: string | null
    refundDate: Date | null
    cancellationId: number | null
    createdAt: Date | null
  }

  export type PassengerRefundPaymentCountAggregateOutputType = {
    id: number
    amount: number
    transactionMethod: number
    refundDate: number
    cancellationId: number
    createdAt: number
    _all: number
  }


  export type PassengerRefundPaymentAvgAggregateInputType = {
    id?: true
    amount?: true
    cancellationId?: true
  }

  export type PassengerRefundPaymentSumAggregateInputType = {
    id?: true
    amount?: true
    cancellationId?: true
  }

  export type PassengerRefundPaymentMinAggregateInputType = {
    id?: true
    amount?: true
    transactionMethod?: true
    refundDate?: true
    cancellationId?: true
    createdAt?: true
  }

  export type PassengerRefundPaymentMaxAggregateInputType = {
    id?: true
    amount?: true
    transactionMethod?: true
    refundDate?: true
    cancellationId?: true
    createdAt?: true
  }

  export type PassengerRefundPaymentCountAggregateInputType = {
    id?: true
    amount?: true
    transactionMethod?: true
    refundDate?: true
    cancellationId?: true
    createdAt?: true
    _all?: true
  }

  export type PassengerRefundPaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PassengerRefundPayment to aggregate.
     */
    where?: PassengerRefundPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PassengerRefundPayments to fetch.
     */
    orderBy?: PassengerRefundPaymentOrderByWithRelationInput | PassengerRefundPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PassengerRefundPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PassengerRefundPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PassengerRefundPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PassengerRefundPayments
    **/
    _count?: true | PassengerRefundPaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PassengerRefundPaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PassengerRefundPaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PassengerRefundPaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PassengerRefundPaymentMaxAggregateInputType
  }

  export type GetPassengerRefundPaymentAggregateType<T extends PassengerRefundPaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePassengerRefundPayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePassengerRefundPayment[P]>
      : GetScalarType<T[P], AggregatePassengerRefundPayment[P]>
  }




  export type PassengerRefundPaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PassengerRefundPaymentWhereInput
    orderBy?: PassengerRefundPaymentOrderByWithAggregationInput | PassengerRefundPaymentOrderByWithAggregationInput[]
    by: PassengerRefundPaymentScalarFieldEnum[] | PassengerRefundPaymentScalarFieldEnum
    having?: PassengerRefundPaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PassengerRefundPaymentCountAggregateInputType | true
    _avg?: PassengerRefundPaymentAvgAggregateInputType
    _sum?: PassengerRefundPaymentSumAggregateInputType
    _min?: PassengerRefundPaymentMinAggregateInputType
    _max?: PassengerRefundPaymentMaxAggregateInputType
  }

  export type PassengerRefundPaymentGroupByOutputType = {
    id: number
    amount: number
    transactionMethod: string
    refundDate: Date
    cancellationId: number
    createdAt: Date
    _count: PassengerRefundPaymentCountAggregateOutputType | null
    _avg: PassengerRefundPaymentAvgAggregateOutputType | null
    _sum: PassengerRefundPaymentSumAggregateOutputType | null
    _min: PassengerRefundPaymentMinAggregateOutputType | null
    _max: PassengerRefundPaymentMaxAggregateOutputType | null
  }

  type GetPassengerRefundPaymentGroupByPayload<T extends PassengerRefundPaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PassengerRefundPaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PassengerRefundPaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PassengerRefundPaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PassengerRefundPaymentGroupByOutputType[P]>
        }
      >
    >


  export type PassengerRefundPaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    transactionMethod?: boolean
    refundDate?: boolean
    cancellationId?: boolean
    createdAt?: boolean
    cancellation?: boolean | CancellationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passengerRefundPayment"]>

  export type PassengerRefundPaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    transactionMethod?: boolean
    refundDate?: boolean
    cancellationId?: boolean
    createdAt?: boolean
    cancellation?: boolean | CancellationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passengerRefundPayment"]>

  export type PassengerRefundPaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    transactionMethod?: boolean
    refundDate?: boolean
    cancellationId?: boolean
    createdAt?: boolean
    cancellation?: boolean | CancellationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passengerRefundPayment"]>

  export type PassengerRefundPaymentSelectScalar = {
    id?: boolean
    amount?: boolean
    transactionMethod?: boolean
    refundDate?: boolean
    cancellationId?: boolean
    createdAt?: boolean
  }

  export type PassengerRefundPaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "amount" | "transactionMethod" | "refundDate" | "cancellationId" | "createdAt", ExtArgs["result"]["passengerRefundPayment"]>
  export type PassengerRefundPaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cancellation?: boolean | CancellationDefaultArgs<ExtArgs>
  }
  export type PassengerRefundPaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cancellation?: boolean | CancellationDefaultArgs<ExtArgs>
  }
  export type PassengerRefundPaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cancellation?: boolean | CancellationDefaultArgs<ExtArgs>
  }

  export type $PassengerRefundPaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PassengerRefundPayment"
    objects: {
      cancellation: Prisma.$CancellationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      amount: number
      transactionMethod: string
      refundDate: Date
      cancellationId: number
      createdAt: Date
    }, ExtArgs["result"]["passengerRefundPayment"]>
    composites: {}
  }

  type PassengerRefundPaymentGetPayload<S extends boolean | null | undefined | PassengerRefundPaymentDefaultArgs> = $Result.GetResult<Prisma.$PassengerRefundPaymentPayload, S>

  type PassengerRefundPaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PassengerRefundPaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PassengerRefundPaymentCountAggregateInputType | true
    }

  export interface PassengerRefundPaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PassengerRefundPayment'], meta: { name: 'PassengerRefundPayment' } }
    /**
     * Find zero or one PassengerRefundPayment that matches the filter.
     * @param {PassengerRefundPaymentFindUniqueArgs} args - Arguments to find a PassengerRefundPayment
     * @example
     * // Get one PassengerRefundPayment
     * const passengerRefundPayment = await prisma.passengerRefundPayment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PassengerRefundPaymentFindUniqueArgs>(args: SelectSubset<T, PassengerRefundPaymentFindUniqueArgs<ExtArgs>>): Prisma__PassengerRefundPaymentClient<$Result.GetResult<Prisma.$PassengerRefundPaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PassengerRefundPayment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PassengerRefundPaymentFindUniqueOrThrowArgs} args - Arguments to find a PassengerRefundPayment
     * @example
     * // Get one PassengerRefundPayment
     * const passengerRefundPayment = await prisma.passengerRefundPayment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PassengerRefundPaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PassengerRefundPaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PassengerRefundPaymentClient<$Result.GetResult<Prisma.$PassengerRefundPaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PassengerRefundPayment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PassengerRefundPaymentFindFirstArgs} args - Arguments to find a PassengerRefundPayment
     * @example
     * // Get one PassengerRefundPayment
     * const passengerRefundPayment = await prisma.passengerRefundPayment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PassengerRefundPaymentFindFirstArgs>(args?: SelectSubset<T, PassengerRefundPaymentFindFirstArgs<ExtArgs>>): Prisma__PassengerRefundPaymentClient<$Result.GetResult<Prisma.$PassengerRefundPaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PassengerRefundPayment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PassengerRefundPaymentFindFirstOrThrowArgs} args - Arguments to find a PassengerRefundPayment
     * @example
     * // Get one PassengerRefundPayment
     * const passengerRefundPayment = await prisma.passengerRefundPayment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PassengerRefundPaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PassengerRefundPaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PassengerRefundPaymentClient<$Result.GetResult<Prisma.$PassengerRefundPaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PassengerRefundPayments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PassengerRefundPaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PassengerRefundPayments
     * const passengerRefundPayments = await prisma.passengerRefundPayment.findMany()
     * 
     * // Get first 10 PassengerRefundPayments
     * const passengerRefundPayments = await prisma.passengerRefundPayment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const passengerRefundPaymentWithIdOnly = await prisma.passengerRefundPayment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PassengerRefundPaymentFindManyArgs>(args?: SelectSubset<T, PassengerRefundPaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PassengerRefundPaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PassengerRefundPayment.
     * @param {PassengerRefundPaymentCreateArgs} args - Arguments to create a PassengerRefundPayment.
     * @example
     * // Create one PassengerRefundPayment
     * const PassengerRefundPayment = await prisma.passengerRefundPayment.create({
     *   data: {
     *     // ... data to create a PassengerRefundPayment
     *   }
     * })
     * 
     */
    create<T extends PassengerRefundPaymentCreateArgs>(args: SelectSubset<T, PassengerRefundPaymentCreateArgs<ExtArgs>>): Prisma__PassengerRefundPaymentClient<$Result.GetResult<Prisma.$PassengerRefundPaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PassengerRefundPayments.
     * @param {PassengerRefundPaymentCreateManyArgs} args - Arguments to create many PassengerRefundPayments.
     * @example
     * // Create many PassengerRefundPayments
     * const passengerRefundPayment = await prisma.passengerRefundPayment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PassengerRefundPaymentCreateManyArgs>(args?: SelectSubset<T, PassengerRefundPaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PassengerRefundPayments and returns the data saved in the database.
     * @param {PassengerRefundPaymentCreateManyAndReturnArgs} args - Arguments to create many PassengerRefundPayments.
     * @example
     * // Create many PassengerRefundPayments
     * const passengerRefundPayment = await prisma.passengerRefundPayment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PassengerRefundPayments and only return the `id`
     * const passengerRefundPaymentWithIdOnly = await prisma.passengerRefundPayment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PassengerRefundPaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PassengerRefundPaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PassengerRefundPaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PassengerRefundPayment.
     * @param {PassengerRefundPaymentDeleteArgs} args - Arguments to delete one PassengerRefundPayment.
     * @example
     * // Delete one PassengerRefundPayment
     * const PassengerRefundPayment = await prisma.passengerRefundPayment.delete({
     *   where: {
     *     // ... filter to delete one PassengerRefundPayment
     *   }
     * })
     * 
     */
    delete<T extends PassengerRefundPaymentDeleteArgs>(args: SelectSubset<T, PassengerRefundPaymentDeleteArgs<ExtArgs>>): Prisma__PassengerRefundPaymentClient<$Result.GetResult<Prisma.$PassengerRefundPaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PassengerRefundPayment.
     * @param {PassengerRefundPaymentUpdateArgs} args - Arguments to update one PassengerRefundPayment.
     * @example
     * // Update one PassengerRefundPayment
     * const passengerRefundPayment = await prisma.passengerRefundPayment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PassengerRefundPaymentUpdateArgs>(args: SelectSubset<T, PassengerRefundPaymentUpdateArgs<ExtArgs>>): Prisma__PassengerRefundPaymentClient<$Result.GetResult<Prisma.$PassengerRefundPaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PassengerRefundPayments.
     * @param {PassengerRefundPaymentDeleteManyArgs} args - Arguments to filter PassengerRefundPayments to delete.
     * @example
     * // Delete a few PassengerRefundPayments
     * const { count } = await prisma.passengerRefundPayment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PassengerRefundPaymentDeleteManyArgs>(args?: SelectSubset<T, PassengerRefundPaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PassengerRefundPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PassengerRefundPaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PassengerRefundPayments
     * const passengerRefundPayment = await prisma.passengerRefundPayment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PassengerRefundPaymentUpdateManyArgs>(args: SelectSubset<T, PassengerRefundPaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PassengerRefundPayments and returns the data updated in the database.
     * @param {PassengerRefundPaymentUpdateManyAndReturnArgs} args - Arguments to update many PassengerRefundPayments.
     * @example
     * // Update many PassengerRefundPayments
     * const passengerRefundPayment = await prisma.passengerRefundPayment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PassengerRefundPayments and only return the `id`
     * const passengerRefundPaymentWithIdOnly = await prisma.passengerRefundPayment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PassengerRefundPaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, PassengerRefundPaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PassengerRefundPaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PassengerRefundPayment.
     * @param {PassengerRefundPaymentUpsertArgs} args - Arguments to update or create a PassengerRefundPayment.
     * @example
     * // Update or create a PassengerRefundPayment
     * const passengerRefundPayment = await prisma.passengerRefundPayment.upsert({
     *   create: {
     *     // ... data to create a PassengerRefundPayment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PassengerRefundPayment we want to update
     *   }
     * })
     */
    upsert<T extends PassengerRefundPaymentUpsertArgs>(args: SelectSubset<T, PassengerRefundPaymentUpsertArgs<ExtArgs>>): Prisma__PassengerRefundPaymentClient<$Result.GetResult<Prisma.$PassengerRefundPaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PassengerRefundPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PassengerRefundPaymentCountArgs} args - Arguments to filter PassengerRefundPayments to count.
     * @example
     * // Count the number of PassengerRefundPayments
     * const count = await prisma.passengerRefundPayment.count({
     *   where: {
     *     // ... the filter for the PassengerRefundPayments we want to count
     *   }
     * })
    **/
    count<T extends PassengerRefundPaymentCountArgs>(
      args?: Subset<T, PassengerRefundPaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PassengerRefundPaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PassengerRefundPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PassengerRefundPaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PassengerRefundPaymentAggregateArgs>(args: Subset<T, PassengerRefundPaymentAggregateArgs>): Prisma.PrismaPromise<GetPassengerRefundPaymentAggregateType<T>>

    /**
     * Group by PassengerRefundPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PassengerRefundPaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PassengerRefundPaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PassengerRefundPaymentGroupByArgs['orderBy'] }
        : { orderBy?: PassengerRefundPaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PassengerRefundPaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPassengerRefundPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PassengerRefundPayment model
   */
  readonly fields: PassengerRefundPaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PassengerRefundPayment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PassengerRefundPaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cancellation<T extends CancellationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CancellationDefaultArgs<ExtArgs>>): Prisma__CancellationClient<$Result.GetResult<Prisma.$CancellationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PassengerRefundPayment model
   */
  interface PassengerRefundPaymentFieldRefs {
    readonly id: FieldRef<"PassengerRefundPayment", 'Int'>
    readonly amount: FieldRef<"PassengerRefundPayment", 'Float'>
    readonly transactionMethod: FieldRef<"PassengerRefundPayment", 'String'>
    readonly refundDate: FieldRef<"PassengerRefundPayment", 'DateTime'>
    readonly cancellationId: FieldRef<"PassengerRefundPayment", 'Int'>
    readonly createdAt: FieldRef<"PassengerRefundPayment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PassengerRefundPayment findUnique
   */
  export type PassengerRefundPaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PassengerRefundPayment
     */
    select?: PassengerRefundPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PassengerRefundPayment
     */
    omit?: PassengerRefundPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PassengerRefundPaymentInclude<ExtArgs> | null
    /**
     * Filter, which PassengerRefundPayment to fetch.
     */
    where: PassengerRefundPaymentWhereUniqueInput
  }

  /**
   * PassengerRefundPayment findUniqueOrThrow
   */
  export type PassengerRefundPaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PassengerRefundPayment
     */
    select?: PassengerRefundPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PassengerRefundPayment
     */
    omit?: PassengerRefundPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PassengerRefundPaymentInclude<ExtArgs> | null
    /**
     * Filter, which PassengerRefundPayment to fetch.
     */
    where: PassengerRefundPaymentWhereUniqueInput
  }

  /**
   * PassengerRefundPayment findFirst
   */
  export type PassengerRefundPaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PassengerRefundPayment
     */
    select?: PassengerRefundPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PassengerRefundPayment
     */
    omit?: PassengerRefundPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PassengerRefundPaymentInclude<ExtArgs> | null
    /**
     * Filter, which PassengerRefundPayment to fetch.
     */
    where?: PassengerRefundPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PassengerRefundPayments to fetch.
     */
    orderBy?: PassengerRefundPaymentOrderByWithRelationInput | PassengerRefundPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PassengerRefundPayments.
     */
    cursor?: PassengerRefundPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PassengerRefundPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PassengerRefundPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PassengerRefundPayments.
     */
    distinct?: PassengerRefundPaymentScalarFieldEnum | PassengerRefundPaymentScalarFieldEnum[]
  }

  /**
   * PassengerRefundPayment findFirstOrThrow
   */
  export type PassengerRefundPaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PassengerRefundPayment
     */
    select?: PassengerRefundPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PassengerRefundPayment
     */
    omit?: PassengerRefundPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PassengerRefundPaymentInclude<ExtArgs> | null
    /**
     * Filter, which PassengerRefundPayment to fetch.
     */
    where?: PassengerRefundPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PassengerRefundPayments to fetch.
     */
    orderBy?: PassengerRefundPaymentOrderByWithRelationInput | PassengerRefundPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PassengerRefundPayments.
     */
    cursor?: PassengerRefundPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PassengerRefundPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PassengerRefundPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PassengerRefundPayments.
     */
    distinct?: PassengerRefundPaymentScalarFieldEnum | PassengerRefundPaymentScalarFieldEnum[]
  }

  /**
   * PassengerRefundPayment findMany
   */
  export type PassengerRefundPaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PassengerRefundPayment
     */
    select?: PassengerRefundPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PassengerRefundPayment
     */
    omit?: PassengerRefundPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PassengerRefundPaymentInclude<ExtArgs> | null
    /**
     * Filter, which PassengerRefundPayments to fetch.
     */
    where?: PassengerRefundPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PassengerRefundPayments to fetch.
     */
    orderBy?: PassengerRefundPaymentOrderByWithRelationInput | PassengerRefundPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PassengerRefundPayments.
     */
    cursor?: PassengerRefundPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PassengerRefundPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PassengerRefundPayments.
     */
    skip?: number
    distinct?: PassengerRefundPaymentScalarFieldEnum | PassengerRefundPaymentScalarFieldEnum[]
  }

  /**
   * PassengerRefundPayment create
   */
  export type PassengerRefundPaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PassengerRefundPayment
     */
    select?: PassengerRefundPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PassengerRefundPayment
     */
    omit?: PassengerRefundPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PassengerRefundPaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a PassengerRefundPayment.
     */
    data: XOR<PassengerRefundPaymentCreateInput, PassengerRefundPaymentUncheckedCreateInput>
  }

  /**
   * PassengerRefundPayment createMany
   */
  export type PassengerRefundPaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PassengerRefundPayments.
     */
    data: PassengerRefundPaymentCreateManyInput | PassengerRefundPaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PassengerRefundPayment createManyAndReturn
   */
  export type PassengerRefundPaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PassengerRefundPayment
     */
    select?: PassengerRefundPaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PassengerRefundPayment
     */
    omit?: PassengerRefundPaymentOmit<ExtArgs> | null
    /**
     * The data used to create many PassengerRefundPayments.
     */
    data: PassengerRefundPaymentCreateManyInput | PassengerRefundPaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PassengerRefundPaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PassengerRefundPayment update
   */
  export type PassengerRefundPaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PassengerRefundPayment
     */
    select?: PassengerRefundPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PassengerRefundPayment
     */
    omit?: PassengerRefundPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PassengerRefundPaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a PassengerRefundPayment.
     */
    data: XOR<PassengerRefundPaymentUpdateInput, PassengerRefundPaymentUncheckedUpdateInput>
    /**
     * Choose, which PassengerRefundPayment to update.
     */
    where: PassengerRefundPaymentWhereUniqueInput
  }

  /**
   * PassengerRefundPayment updateMany
   */
  export type PassengerRefundPaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PassengerRefundPayments.
     */
    data: XOR<PassengerRefundPaymentUpdateManyMutationInput, PassengerRefundPaymentUncheckedUpdateManyInput>
    /**
     * Filter which PassengerRefundPayments to update
     */
    where?: PassengerRefundPaymentWhereInput
    /**
     * Limit how many PassengerRefundPayments to update.
     */
    limit?: number
  }

  /**
   * PassengerRefundPayment updateManyAndReturn
   */
  export type PassengerRefundPaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PassengerRefundPayment
     */
    select?: PassengerRefundPaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PassengerRefundPayment
     */
    omit?: PassengerRefundPaymentOmit<ExtArgs> | null
    /**
     * The data used to update PassengerRefundPayments.
     */
    data: XOR<PassengerRefundPaymentUpdateManyMutationInput, PassengerRefundPaymentUncheckedUpdateManyInput>
    /**
     * Filter which PassengerRefundPayments to update
     */
    where?: PassengerRefundPaymentWhereInput
    /**
     * Limit how many PassengerRefundPayments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PassengerRefundPaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PassengerRefundPayment upsert
   */
  export type PassengerRefundPaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PassengerRefundPayment
     */
    select?: PassengerRefundPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PassengerRefundPayment
     */
    omit?: PassengerRefundPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PassengerRefundPaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the PassengerRefundPayment to update in case it exists.
     */
    where: PassengerRefundPaymentWhereUniqueInput
    /**
     * In case the PassengerRefundPayment found by the `where` argument doesn't exist, create a new PassengerRefundPayment with this data.
     */
    create: XOR<PassengerRefundPaymentCreateInput, PassengerRefundPaymentUncheckedCreateInput>
    /**
     * In case the PassengerRefundPayment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PassengerRefundPaymentUpdateInput, PassengerRefundPaymentUncheckedUpdateInput>
  }

  /**
   * PassengerRefundPayment delete
   */
  export type PassengerRefundPaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PassengerRefundPayment
     */
    select?: PassengerRefundPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PassengerRefundPayment
     */
    omit?: PassengerRefundPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PassengerRefundPaymentInclude<ExtArgs> | null
    /**
     * Filter which PassengerRefundPayment to delete.
     */
    where: PassengerRefundPaymentWhereUniqueInput
  }

  /**
   * PassengerRefundPayment deleteMany
   */
  export type PassengerRefundPaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PassengerRefundPayments to delete
     */
    where?: PassengerRefundPaymentWhereInput
    /**
     * Limit how many PassengerRefundPayments to delete.
     */
    limit?: number
  }

  /**
   * PassengerRefundPayment without action
   */
  export type PassengerRefundPaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PassengerRefundPayment
     */
    select?: PassengerRefundPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PassengerRefundPayment
     */
    omit?: PassengerRefundPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PassengerRefundPaymentInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _avg: AuditLogAvgAggregateOutputType | null
    _sum: AuditLogSumAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogAvgAggregateOutputType = {
    id: number | null
    recordId: number | null
    userId: number | null
  }

  export type AuditLogSumAggregateOutputType = {
    id: number | null
    recordId: number | null
    userId: number | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: number | null
    modelName: string | null
    recordId: number | null
    userId: number | null
    action: $Enums.ActionType | null
    fieldName: string | null
    oldValue: string | null
    newValue: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: number | null
    modelName: string | null
    recordId: number | null
    userId: number | null
    action: $Enums.ActionType | null
    fieldName: string | null
    oldValue: string | null
    newValue: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    modelName: number
    recordId: number
    userId: number
    action: number
    fieldName: number
    oldValue: number
    newValue: number
    createdAt: number
    _all: number
  }


  export type AuditLogAvgAggregateInputType = {
    id?: true
    recordId?: true
    userId?: true
  }

  export type AuditLogSumAggregateInputType = {
    id?: true
    recordId?: true
    userId?: true
  }

  export type AuditLogMinAggregateInputType = {
    id?: true
    modelName?: true
    recordId?: true
    userId?: true
    action?: true
    fieldName?: true
    oldValue?: true
    newValue?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    modelName?: true
    recordId?: true
    userId?: true
    action?: true
    fieldName?: true
    oldValue?: true
    newValue?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    modelName?: true
    recordId?: true
    userId?: true
    action?: true
    fieldName?: true
    oldValue?: true
    newValue?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AuditLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AuditLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _avg?: AuditLogAvgAggregateInputType
    _sum?: AuditLogSumAggregateInputType
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: number
    modelName: string
    recordId: number
    userId: number
    action: $Enums.ActionType
    fieldName: string | null
    oldValue: string | null
    newValue: string | null
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _avg: AuditLogAvgAggregateOutputType | null
    _sum: AuditLogSumAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    modelName?: boolean
    recordId?: boolean
    userId?: boolean
    action?: boolean
    fieldName?: boolean
    oldValue?: boolean
    newValue?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    modelName?: boolean
    recordId?: boolean
    userId?: boolean
    action?: boolean
    fieldName?: boolean
    oldValue?: boolean
    newValue?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    modelName?: boolean
    recordId?: boolean
    userId?: boolean
    action?: boolean
    fieldName?: boolean
    oldValue?: boolean
    newValue?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    modelName?: boolean
    recordId?: boolean
    userId?: boolean
    action?: boolean
    fieldName?: boolean
    oldValue?: boolean
    newValue?: boolean
    createdAt?: boolean
  }

  export type AuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "modelName" | "recordId" | "userId" | "action" | "fieldName" | "oldValue" | "newValue" | "createdAt", ExtArgs["result"]["auditLog"]>
  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuditLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      modelName: string
      recordId: number
      userId: number
      action: $Enums.ActionType
      fieldName: string | null
      oldValue: string | null
      newValue: string | null
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs and returns the data updated in the database.
     * @param {AuditLogUpdateManyAndReturnArgs} args - Arguments to update many AuditLogs.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'Int'>
    readonly modelName: FieldRef<"AuditLog", 'String'>
    readonly recordId: FieldRef<"AuditLog", 'Int'>
    readonly userId: FieldRef<"AuditLog", 'Int'>
    readonly action: FieldRef<"AuditLog", 'ActionType'>
    readonly fieldName: FieldRef<"AuditLog", 'String'>
    readonly oldValue: FieldRef<"AuditLog", 'String'>
    readonly newValue: FieldRef<"AuditLog", 'String'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog updateManyAndReturn
   */
  export type AuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to delete.
     */
    limit?: number
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const BookingScalarFieldEnum: {
    id: 'id',
    folderNo: 'folderNo',
    refNo: 'refNo',
    paxName: 'paxName',
    agentName: 'agentName',
    teamName: 'teamName',
    pnr: 'pnr',
    airline: 'airline',
    fromTo: 'fromTo',
    bookingType: 'bookingType',
    bookingStatus: 'bookingStatus',
    pcDate: 'pcDate',
    issuedDate: 'issuedDate',
    paymentMethod: 'paymentMethod',
    lastPaymentDate: 'lastPaymentDate',
    travelDate: 'travelDate',
    revenue: 'revenue',
    prodCost: 'prodCost',
    transFee: 'transFee',
    surcharge: 'surcharge',
    received: 'received',
    transactionMethod: 'transactionMethod',
    receivedDate: 'receivedDate',
    balance: 'balance',
    profit: 'profit',
    invoiced: 'invoiced',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    numPax: 'numPax',
    initialDeposit: 'initialDeposit',
    originalBookingId: 'originalBookingId',
    statusBeforeVoid: 'statusBeforeVoid',
    voidReason: 'voidReason',
    voidedAt: 'voidedAt',
    voidedById: 'voidedById'
  };

  export type BookingScalarFieldEnum = (typeof BookingScalarFieldEnum)[keyof typeof BookingScalarFieldEnum]


  export const PendingBookingScalarFieldEnum: {
    id: 'id',
    refNo: 'refNo',
    paxName: 'paxName',
    agentName: 'agentName',
    teamName: 'teamName',
    pnr: 'pnr',
    airline: 'airline',
    fromTo: 'fromTo',
    bookingType: 'bookingType',
    bookingStatus: 'bookingStatus',
    pcDate: 'pcDate',
    issuedDate: 'issuedDate',
    paymentMethod: 'paymentMethod',
    lastPaymentDate: 'lastPaymentDate',
    travelDate: 'travelDate',
    revenue: 'revenue',
    prodCost: 'prodCost',
    transFee: 'transFee',
    surcharge: 'surcharge',
    received: 'received',
    transactionMethod: 'transactionMethod',
    receivedDate: 'receivedDate',
    balance: 'balance',
    profit: 'profit',
    invoiced: 'invoiced',
    description: 'description',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    numPax: 'numPax',
    createdById: 'createdById'
  };

  export type PendingBookingScalarFieldEnum = (typeof PendingBookingScalarFieldEnum)[keyof typeof PendingBookingScalarFieldEnum]


  export const InstalmentScalarFieldEnum: {
    id: 'id',
    bookingId: 'bookingId',
    dueDate: 'dueDate',
    amount: 'amount',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InstalmentScalarFieldEnum = (typeof InstalmentScalarFieldEnum)[keyof typeof InstalmentScalarFieldEnum]


  export const PendingInstalmentScalarFieldEnum: {
    id: 'id',
    pendingBookingId: 'pendingBookingId',
    dueDate: 'dueDate',
    amount: 'amount',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PendingInstalmentScalarFieldEnum = (typeof PendingInstalmentScalarFieldEnum)[keyof typeof PendingInstalmentScalarFieldEnum]


  export const InstalmentPaymentScalarFieldEnum: {
    id: 'id',
    instalmentId: 'instalmentId',
    amount: 'amount',
    transactionMethod: 'transactionMethod',
    paymentDate: 'paymentDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InstalmentPaymentScalarFieldEnum = (typeof InstalmentPaymentScalarFieldEnum)[keyof typeof InstalmentPaymentScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    title: 'title',
    firstName: 'firstName',
    lastName: 'lastName',
    contactNo: 'contactNo',
    role: 'role',
    team: 'team',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const CostItemScalarFieldEnum: {
    id: 'id',
    bookingId: 'bookingId',
    category: 'category',
    amount: 'amount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CostItemScalarFieldEnum = (typeof CostItemScalarFieldEnum)[keyof typeof CostItemScalarFieldEnum]


  export const PendingCostItemScalarFieldEnum: {
    id: 'id',
    pendingBookingId: 'pendingBookingId',
    category: 'category',
    amount: 'amount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PendingCostItemScalarFieldEnum = (typeof PendingCostItemScalarFieldEnum)[keyof typeof PendingCostItemScalarFieldEnum]


  export const PassengerScalarFieldEnum: {
    id: 'id',
    bookingId: 'bookingId',
    title: 'title',
    firstName: 'firstName',
    middleName: 'middleName',
    lastName: 'lastName',
    gender: 'gender',
    email: 'email',
    contactNo: 'contactNo',
    nationality: 'nationality',
    birthday: 'birthday',
    category: 'category',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PassengerScalarFieldEnum = (typeof PassengerScalarFieldEnum)[keyof typeof PassengerScalarFieldEnum]


  export const PendingPassengerScalarFieldEnum: {
    id: 'id',
    pendingBookingId: 'pendingBookingId',
    title: 'title',
    firstName: 'firstName',
    middleName: 'middleName',
    lastName: 'lastName',
    gender: 'gender',
    email: 'email',
    contactNo: 'contactNo',
    nationality: 'nationality',
    birthday: 'birthday',
    category: 'category',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PendingPassengerScalarFieldEnum = (typeof PendingPassengerScalarFieldEnum)[keyof typeof PendingPassengerScalarFieldEnum]


  export const CostItemSupplierScalarFieldEnum: {
    id: 'id',
    costItemId: 'costItemId',
    pendingCostItemId: 'pendingCostItemId',
    supplier: 'supplier',
    amount: 'amount',
    paymentMethod: 'paymentMethod',
    paidAmount: 'paidAmount',
    pendingAmount: 'pendingAmount',
    transactionMethod: 'transactionMethod',
    firstMethodAmount: 'firstMethodAmount',
    secondMethodAmount: 'secondMethodAmount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CostItemSupplierScalarFieldEnum = (typeof CostItemSupplierScalarFieldEnum)[keyof typeof CostItemSupplierScalarFieldEnum]


  export const SupplierPaymentSettlementScalarFieldEnum: {
    id: 'id',
    costItemSupplierId: 'costItemSupplierId',
    amount: 'amount',
    transactionMethod: 'transactionMethod',
    settlementDate: 'settlementDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SupplierPaymentSettlementScalarFieldEnum = (typeof SupplierPaymentSettlementScalarFieldEnum)[keyof typeof SupplierPaymentSettlementScalarFieldEnum]


  export const CancellationScalarFieldEnum: {
    id: 'id',
    originalBookingId: 'originalBookingId',
    folderNo: 'folderNo',
    refundTransactionMethod: 'refundTransactionMethod',
    originalRevenue: 'originalRevenue',
    originalProdCost: 'originalProdCost',
    supplierCancellationFee: 'supplierCancellationFee',
    refundToPassenger: 'refundToPassenger',
    adminFee: 'adminFee',
    refundStatus: 'refundStatus',
    creditNoteAmount: 'creditNoteAmount',
    profitOrLoss: 'profitOrLoss',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CancellationScalarFieldEnum = (typeof CancellationScalarFieldEnum)[keyof typeof CancellationScalarFieldEnum]


  export const SupplierCreditNoteScalarFieldEnum: {
    id: 'id',
    supplier: 'supplier',
    initialAmount: 'initialAmount',
    remainingAmount: 'remainingAmount',
    status: 'status',
    generatedFromCancellationId: 'generatedFromCancellationId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SupplierCreditNoteScalarFieldEnum = (typeof SupplierCreditNoteScalarFieldEnum)[keyof typeof SupplierCreditNoteScalarFieldEnum]


  export const CreditNoteUsageScalarFieldEnum: {
    id: 'id',
    amountUsed: 'amountUsed',
    usedAt: 'usedAt',
    creditNoteId: 'creditNoteId',
    usedOnCostItemSupplierId: 'usedOnCostItemSupplierId'
  };

  export type CreditNoteUsageScalarFieldEnum = (typeof CreditNoteUsageScalarFieldEnum)[keyof typeof CreditNoteUsageScalarFieldEnum]


  export const SupplierPayableScalarFieldEnum: {
    id: 'id',
    supplier: 'supplier',
    totalAmount: 'totalAmount',
    paidAmount: 'paidAmount',
    pendingAmount: 'pendingAmount',
    reason: 'reason',
    status: 'status',
    createdFromCancellationId: 'createdFromCancellationId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SupplierPayableScalarFieldEnum = (typeof SupplierPayableScalarFieldEnum)[keyof typeof SupplierPayableScalarFieldEnum]


  export const SupplierPayableSettlementScalarFieldEnum: {
    id: 'id',
    supplierPayableId: 'supplierPayableId',
    amount: 'amount',
    transactionMethod: 'transactionMethod',
    settlementDate: 'settlementDate',
    createdAt: 'createdAt'
  };

  export type SupplierPayableSettlementScalarFieldEnum = (typeof SupplierPayableSettlementScalarFieldEnum)[keyof typeof SupplierPayableSettlementScalarFieldEnum]


  export const CustomerPayableScalarFieldEnum: {
    id: 'id',
    totalAmount: 'totalAmount',
    paidAmount: 'paidAmount',
    pendingAmount: 'pendingAmount',
    reason: 'reason',
    status: 'status',
    createdFromCancellationId: 'createdFromCancellationId',
    bookingId: 'bookingId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CustomerPayableScalarFieldEnum = (typeof CustomerPayableScalarFieldEnum)[keyof typeof CustomerPayableScalarFieldEnum]


  export const CustomerPayableSettlementScalarFieldEnum: {
    id: 'id',
    customerPayableId: 'customerPayableId',
    amount: 'amount',
    transactionMethod: 'transactionMethod',
    paymentDate: 'paymentDate',
    createdAt: 'createdAt'
  };

  export type CustomerPayableSettlementScalarFieldEnum = (typeof CustomerPayableSettlementScalarFieldEnum)[keyof typeof CustomerPayableSettlementScalarFieldEnum]


  export const PassengerRefundPaymentScalarFieldEnum: {
    id: 'id',
    amount: 'amount',
    transactionMethod: 'transactionMethod',
    refundDate: 'refundDate',
    cancellationId: 'cancellationId',
    createdAt: 'createdAt'
  };

  export type PassengerRefundPaymentScalarFieldEnum = (typeof PassengerRefundPaymentScalarFieldEnum)[keyof typeof PassengerRefundPaymentScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    modelName: 'modelName',
    recordId: 'recordId',
    userId: 'userId',
    action: 'action',
    fieldName: 'fieldName',
    oldValue: 'oldValue',
    newValue: 'newValue',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Teams'
   */
  export type EnumTeamsFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Teams'>
    


  /**
   * Reference to a field of type 'Teams[]'
   */
  export type ListEnumTeamsFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Teams[]'>
    


  /**
   * Reference to a field of type 'BookingType'
   */
  export type EnumBookingTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BookingType'>
    


  /**
   * Reference to a field of type 'BookingType[]'
   */
  export type ListEnumBookingTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BookingType[]'>
    


  /**
   * Reference to a field of type 'BookingStatus'
   */
  export type EnumBookingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BookingStatus'>
    


  /**
   * Reference to a field of type 'BookingStatus[]'
   */
  export type ListEnumBookingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BookingStatus[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'PaymentMethod'
   */
  export type EnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod'>
    


  /**
   * Reference to a field of type 'PaymentMethod[]'
   */
  export type ListEnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'PendingStatus'
   */
  export type EnumPendingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PendingStatus'>
    


  /**
   * Reference to a field of type 'PendingStatus[]'
   */
  export type ListEnumPendingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PendingStatus[]'>
    


  /**
   * Reference to a field of type 'Title'
   */
  export type EnumTitleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Title'>
    


  /**
   * Reference to a field of type 'Title[]'
   */
  export type ListEnumTitleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Title[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'Gender'
   */
  export type EnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender'>
    


  /**
   * Reference to a field of type 'Gender[]'
   */
  export type ListEnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender[]'>
    


  /**
   * Reference to a field of type 'PassengerCategory'
   */
  export type EnumPassengerCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PassengerCategory'>
    


  /**
   * Reference to a field of type 'PassengerCategory[]'
   */
  export type ListEnumPassengerCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PassengerCategory[]'>
    


  /**
   * Reference to a field of type 'Suppliers'
   */
  export type EnumSuppliersFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Suppliers'>
    


  /**
   * Reference to a field of type 'Suppliers[]'
   */
  export type ListEnumSuppliersFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Suppliers[]'>
    


  /**
   * Reference to a field of type 'CreditNoteStatus'
   */
  export type EnumCreditNoteStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CreditNoteStatus'>
    


  /**
   * Reference to a field of type 'CreditNoteStatus[]'
   */
  export type ListEnumCreditNoteStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CreditNoteStatus[]'>
    


  /**
   * Reference to a field of type 'ActionType'
   */
  export type EnumActionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActionType'>
    


  /**
   * Reference to a field of type 'ActionType[]'
   */
  export type ListEnumActionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActionType[]'>
    
  /**
   * Deep Input Types
   */


  export type BookingWhereInput = {
    AND?: BookingWhereInput | BookingWhereInput[]
    OR?: BookingWhereInput[]
    NOT?: BookingWhereInput | BookingWhereInput[]
    id?: IntFilter<"Booking"> | number
    folderNo?: StringFilter<"Booking"> | string
    refNo?: StringFilter<"Booking"> | string
    paxName?: StringFilter<"Booking"> | string
    agentName?: StringFilter<"Booking"> | string
    teamName?: EnumTeamsNullableFilter<"Booking"> | $Enums.Teams | null
    pnr?: StringFilter<"Booking"> | string
    airline?: StringFilter<"Booking"> | string
    fromTo?: StringFilter<"Booking"> | string
    bookingType?: EnumBookingTypeFilter<"Booking"> | $Enums.BookingType
    bookingStatus?: EnumBookingStatusNullableFilter<"Booking"> | $Enums.BookingStatus | null
    pcDate?: DateTimeFilter<"Booking"> | Date | string
    issuedDate?: DateTimeNullableFilter<"Booking"> | Date | string | null
    paymentMethod?: EnumPaymentMethodFilter<"Booking"> | $Enums.PaymentMethod
    lastPaymentDate?: DateTimeNullableFilter<"Booking"> | Date | string | null
    travelDate?: DateTimeNullableFilter<"Booking"> | Date | string | null
    revenue?: FloatNullableFilter<"Booking"> | number | null
    prodCost?: FloatNullableFilter<"Booking"> | number | null
    transFee?: FloatNullableFilter<"Booking"> | number | null
    surcharge?: FloatNullableFilter<"Booking"> | number | null
    received?: FloatNullableFilter<"Booking"> | number | null
    transactionMethod?: StringNullableFilter<"Booking"> | string | null
    receivedDate?: DateTimeNullableFilter<"Booking"> | Date | string | null
    balance?: FloatNullableFilter<"Booking"> | number | null
    profit?: FloatNullableFilter<"Booking"> | number | null
    invoiced?: StringNullableFilter<"Booking"> | string | null
    description?: StringNullableFilter<"Booking"> | string | null
    createdAt?: DateTimeFilter<"Booking"> | Date | string
    updatedAt?: DateTimeFilter<"Booking"> | Date | string
    numPax?: IntFilter<"Booking"> | number
    initialDeposit?: FloatNullableFilter<"Booking"> | number | null
    originalBookingId?: IntNullableFilter<"Booking"> | number | null
    statusBeforeVoid?: EnumBookingStatusNullableFilter<"Booking"> | $Enums.BookingStatus | null
    voidReason?: StringNullableFilter<"Booking"> | string | null
    voidedAt?: DateTimeNullableFilter<"Booking"> | Date | string | null
    voidedById?: IntNullableFilter<"Booking"> | number | null
    costItems?: CostItemListRelationFilter
    instalments?: InstalmentListRelationFilter
    passengers?: PassengerListRelationFilter
    originalBooking?: XOR<BookingNullableScalarRelationFilter, BookingWhereInput> | null
    followUpBookings?: BookingListRelationFilter
    voidedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    customerPayables?: CustomerPayableListRelationFilter
    cancellation?: XOR<CancellationNullableScalarRelationFilter, CancellationWhereInput> | null
  }

  export type BookingOrderByWithRelationInput = {
    id?: SortOrder
    folderNo?: SortOrder
    refNo?: SortOrder
    paxName?: SortOrder
    agentName?: SortOrder
    teamName?: SortOrderInput | SortOrder
    pnr?: SortOrder
    airline?: SortOrder
    fromTo?: SortOrder
    bookingType?: SortOrder
    bookingStatus?: SortOrderInput | SortOrder
    pcDate?: SortOrder
    issuedDate?: SortOrderInput | SortOrder
    paymentMethod?: SortOrder
    lastPaymentDate?: SortOrderInput | SortOrder
    travelDate?: SortOrderInput | SortOrder
    revenue?: SortOrderInput | SortOrder
    prodCost?: SortOrderInput | SortOrder
    transFee?: SortOrderInput | SortOrder
    surcharge?: SortOrderInput | SortOrder
    received?: SortOrderInput | SortOrder
    transactionMethod?: SortOrderInput | SortOrder
    receivedDate?: SortOrderInput | SortOrder
    balance?: SortOrderInput | SortOrder
    profit?: SortOrderInput | SortOrder
    invoiced?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    numPax?: SortOrder
    initialDeposit?: SortOrderInput | SortOrder
    originalBookingId?: SortOrderInput | SortOrder
    statusBeforeVoid?: SortOrderInput | SortOrder
    voidReason?: SortOrderInput | SortOrder
    voidedAt?: SortOrderInput | SortOrder
    voidedById?: SortOrderInput | SortOrder
    costItems?: CostItemOrderByRelationAggregateInput
    instalments?: InstalmentOrderByRelationAggregateInput
    passengers?: PassengerOrderByRelationAggregateInput
    originalBooking?: BookingOrderByWithRelationInput
    followUpBookings?: BookingOrderByRelationAggregateInput
    voidedBy?: UserOrderByWithRelationInput
    customerPayables?: CustomerPayableOrderByRelationAggregateInput
    cancellation?: CancellationOrderByWithRelationInput
  }

  export type BookingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    folderNo?: string
    AND?: BookingWhereInput | BookingWhereInput[]
    OR?: BookingWhereInput[]
    NOT?: BookingWhereInput | BookingWhereInput[]
    refNo?: StringFilter<"Booking"> | string
    paxName?: StringFilter<"Booking"> | string
    agentName?: StringFilter<"Booking"> | string
    teamName?: EnumTeamsNullableFilter<"Booking"> | $Enums.Teams | null
    pnr?: StringFilter<"Booking"> | string
    airline?: StringFilter<"Booking"> | string
    fromTo?: StringFilter<"Booking"> | string
    bookingType?: EnumBookingTypeFilter<"Booking"> | $Enums.BookingType
    bookingStatus?: EnumBookingStatusNullableFilter<"Booking"> | $Enums.BookingStatus | null
    pcDate?: DateTimeFilter<"Booking"> | Date | string
    issuedDate?: DateTimeNullableFilter<"Booking"> | Date | string | null
    paymentMethod?: EnumPaymentMethodFilter<"Booking"> | $Enums.PaymentMethod
    lastPaymentDate?: DateTimeNullableFilter<"Booking"> | Date | string | null
    travelDate?: DateTimeNullableFilter<"Booking"> | Date | string | null
    revenue?: FloatNullableFilter<"Booking"> | number | null
    prodCost?: FloatNullableFilter<"Booking"> | number | null
    transFee?: FloatNullableFilter<"Booking"> | number | null
    surcharge?: FloatNullableFilter<"Booking"> | number | null
    received?: FloatNullableFilter<"Booking"> | number | null
    transactionMethod?: StringNullableFilter<"Booking"> | string | null
    receivedDate?: DateTimeNullableFilter<"Booking"> | Date | string | null
    balance?: FloatNullableFilter<"Booking"> | number | null
    profit?: FloatNullableFilter<"Booking"> | number | null
    invoiced?: StringNullableFilter<"Booking"> | string | null
    description?: StringNullableFilter<"Booking"> | string | null
    createdAt?: DateTimeFilter<"Booking"> | Date | string
    updatedAt?: DateTimeFilter<"Booking"> | Date | string
    numPax?: IntFilter<"Booking"> | number
    initialDeposit?: FloatNullableFilter<"Booking"> | number | null
    originalBookingId?: IntNullableFilter<"Booking"> | number | null
    statusBeforeVoid?: EnumBookingStatusNullableFilter<"Booking"> | $Enums.BookingStatus | null
    voidReason?: StringNullableFilter<"Booking"> | string | null
    voidedAt?: DateTimeNullableFilter<"Booking"> | Date | string | null
    voidedById?: IntNullableFilter<"Booking"> | number | null
    costItems?: CostItemListRelationFilter
    instalments?: InstalmentListRelationFilter
    passengers?: PassengerListRelationFilter
    originalBooking?: XOR<BookingNullableScalarRelationFilter, BookingWhereInput> | null
    followUpBookings?: BookingListRelationFilter
    voidedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    customerPayables?: CustomerPayableListRelationFilter
    cancellation?: XOR<CancellationNullableScalarRelationFilter, CancellationWhereInput> | null
  }, "id" | "folderNo">

  export type BookingOrderByWithAggregationInput = {
    id?: SortOrder
    folderNo?: SortOrder
    refNo?: SortOrder
    paxName?: SortOrder
    agentName?: SortOrder
    teamName?: SortOrderInput | SortOrder
    pnr?: SortOrder
    airline?: SortOrder
    fromTo?: SortOrder
    bookingType?: SortOrder
    bookingStatus?: SortOrderInput | SortOrder
    pcDate?: SortOrder
    issuedDate?: SortOrderInput | SortOrder
    paymentMethod?: SortOrder
    lastPaymentDate?: SortOrderInput | SortOrder
    travelDate?: SortOrderInput | SortOrder
    revenue?: SortOrderInput | SortOrder
    prodCost?: SortOrderInput | SortOrder
    transFee?: SortOrderInput | SortOrder
    surcharge?: SortOrderInput | SortOrder
    received?: SortOrderInput | SortOrder
    transactionMethod?: SortOrderInput | SortOrder
    receivedDate?: SortOrderInput | SortOrder
    balance?: SortOrderInput | SortOrder
    profit?: SortOrderInput | SortOrder
    invoiced?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    numPax?: SortOrder
    initialDeposit?: SortOrderInput | SortOrder
    originalBookingId?: SortOrderInput | SortOrder
    statusBeforeVoid?: SortOrderInput | SortOrder
    voidReason?: SortOrderInput | SortOrder
    voidedAt?: SortOrderInput | SortOrder
    voidedById?: SortOrderInput | SortOrder
    _count?: BookingCountOrderByAggregateInput
    _avg?: BookingAvgOrderByAggregateInput
    _max?: BookingMaxOrderByAggregateInput
    _min?: BookingMinOrderByAggregateInput
    _sum?: BookingSumOrderByAggregateInput
  }

  export type BookingScalarWhereWithAggregatesInput = {
    AND?: BookingScalarWhereWithAggregatesInput | BookingScalarWhereWithAggregatesInput[]
    OR?: BookingScalarWhereWithAggregatesInput[]
    NOT?: BookingScalarWhereWithAggregatesInput | BookingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Booking"> | number
    folderNo?: StringWithAggregatesFilter<"Booking"> | string
    refNo?: StringWithAggregatesFilter<"Booking"> | string
    paxName?: StringWithAggregatesFilter<"Booking"> | string
    agentName?: StringWithAggregatesFilter<"Booking"> | string
    teamName?: EnumTeamsNullableWithAggregatesFilter<"Booking"> | $Enums.Teams | null
    pnr?: StringWithAggregatesFilter<"Booking"> | string
    airline?: StringWithAggregatesFilter<"Booking"> | string
    fromTo?: StringWithAggregatesFilter<"Booking"> | string
    bookingType?: EnumBookingTypeWithAggregatesFilter<"Booking"> | $Enums.BookingType
    bookingStatus?: EnumBookingStatusNullableWithAggregatesFilter<"Booking"> | $Enums.BookingStatus | null
    pcDate?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
    issuedDate?: DateTimeNullableWithAggregatesFilter<"Booking"> | Date | string | null
    paymentMethod?: EnumPaymentMethodWithAggregatesFilter<"Booking"> | $Enums.PaymentMethod
    lastPaymentDate?: DateTimeNullableWithAggregatesFilter<"Booking"> | Date | string | null
    travelDate?: DateTimeNullableWithAggregatesFilter<"Booking"> | Date | string | null
    revenue?: FloatNullableWithAggregatesFilter<"Booking"> | number | null
    prodCost?: FloatNullableWithAggregatesFilter<"Booking"> | number | null
    transFee?: FloatNullableWithAggregatesFilter<"Booking"> | number | null
    surcharge?: FloatNullableWithAggregatesFilter<"Booking"> | number | null
    received?: FloatNullableWithAggregatesFilter<"Booking"> | number | null
    transactionMethod?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    receivedDate?: DateTimeNullableWithAggregatesFilter<"Booking"> | Date | string | null
    balance?: FloatNullableWithAggregatesFilter<"Booking"> | number | null
    profit?: FloatNullableWithAggregatesFilter<"Booking"> | number | null
    invoiced?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    description?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
    numPax?: IntWithAggregatesFilter<"Booking"> | number
    initialDeposit?: FloatNullableWithAggregatesFilter<"Booking"> | number | null
    originalBookingId?: IntNullableWithAggregatesFilter<"Booking"> | number | null
    statusBeforeVoid?: EnumBookingStatusNullableWithAggregatesFilter<"Booking"> | $Enums.BookingStatus | null
    voidReason?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    voidedAt?: DateTimeNullableWithAggregatesFilter<"Booking"> | Date | string | null
    voidedById?: IntNullableWithAggregatesFilter<"Booking"> | number | null
  }

  export type PendingBookingWhereInput = {
    AND?: PendingBookingWhereInput | PendingBookingWhereInput[]
    OR?: PendingBookingWhereInput[]
    NOT?: PendingBookingWhereInput | PendingBookingWhereInput[]
    id?: IntFilter<"PendingBooking"> | number
    refNo?: StringFilter<"PendingBooking"> | string
    paxName?: StringFilter<"PendingBooking"> | string
    agentName?: StringFilter<"PendingBooking"> | string
    teamName?: EnumTeamsNullableFilter<"PendingBooking"> | $Enums.Teams | null
    pnr?: StringFilter<"PendingBooking"> | string
    airline?: StringFilter<"PendingBooking"> | string
    fromTo?: StringFilter<"PendingBooking"> | string
    bookingType?: EnumBookingTypeFilter<"PendingBooking"> | $Enums.BookingType
    bookingStatus?: EnumBookingStatusNullableFilter<"PendingBooking"> | $Enums.BookingStatus | null
    pcDate?: DateTimeFilter<"PendingBooking"> | Date | string
    issuedDate?: DateTimeNullableFilter<"PendingBooking"> | Date | string | null
    paymentMethod?: EnumPaymentMethodFilter<"PendingBooking"> | $Enums.PaymentMethod
    lastPaymentDate?: DateTimeNullableFilter<"PendingBooking"> | Date | string | null
    travelDate?: DateTimeNullableFilter<"PendingBooking"> | Date | string | null
    revenue?: FloatNullableFilter<"PendingBooking"> | number | null
    prodCost?: FloatNullableFilter<"PendingBooking"> | number | null
    transFee?: FloatNullableFilter<"PendingBooking"> | number | null
    surcharge?: FloatNullableFilter<"PendingBooking"> | number | null
    received?: FloatNullableFilter<"PendingBooking"> | number | null
    transactionMethod?: StringNullableFilter<"PendingBooking"> | string | null
    receivedDate?: DateTimeNullableFilter<"PendingBooking"> | Date | string | null
    balance?: FloatNullableFilter<"PendingBooking"> | number | null
    profit?: FloatNullableFilter<"PendingBooking"> | number | null
    invoiced?: StringNullableFilter<"PendingBooking"> | string | null
    description?: StringNullableFilter<"PendingBooking"> | string | null
    status?: EnumPendingStatusFilter<"PendingBooking"> | $Enums.PendingStatus
    createdAt?: DateTimeFilter<"PendingBooking"> | Date | string
    updatedAt?: DateTimeFilter<"PendingBooking"> | Date | string
    numPax?: IntFilter<"PendingBooking"> | number
    createdById?: IntFilter<"PendingBooking"> | number
    costItems?: PendingCostItemListRelationFilter
    instalments?: PendingInstalmentListRelationFilter
    passengers?: PendingPassengerListRelationFilter
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PendingBookingOrderByWithRelationInput = {
    id?: SortOrder
    refNo?: SortOrder
    paxName?: SortOrder
    agentName?: SortOrder
    teamName?: SortOrderInput | SortOrder
    pnr?: SortOrder
    airline?: SortOrder
    fromTo?: SortOrder
    bookingType?: SortOrder
    bookingStatus?: SortOrderInput | SortOrder
    pcDate?: SortOrder
    issuedDate?: SortOrderInput | SortOrder
    paymentMethod?: SortOrder
    lastPaymentDate?: SortOrderInput | SortOrder
    travelDate?: SortOrderInput | SortOrder
    revenue?: SortOrderInput | SortOrder
    prodCost?: SortOrderInput | SortOrder
    transFee?: SortOrderInput | SortOrder
    surcharge?: SortOrderInput | SortOrder
    received?: SortOrderInput | SortOrder
    transactionMethod?: SortOrderInput | SortOrder
    receivedDate?: SortOrderInput | SortOrder
    balance?: SortOrderInput | SortOrder
    profit?: SortOrderInput | SortOrder
    invoiced?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    numPax?: SortOrder
    createdById?: SortOrder
    costItems?: PendingCostItemOrderByRelationAggregateInput
    instalments?: PendingInstalmentOrderByRelationAggregateInput
    passengers?: PendingPassengerOrderByRelationAggregateInput
    createdBy?: UserOrderByWithRelationInput
  }

  export type PendingBookingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PendingBookingWhereInput | PendingBookingWhereInput[]
    OR?: PendingBookingWhereInput[]
    NOT?: PendingBookingWhereInput | PendingBookingWhereInput[]
    refNo?: StringFilter<"PendingBooking"> | string
    paxName?: StringFilter<"PendingBooking"> | string
    agentName?: StringFilter<"PendingBooking"> | string
    teamName?: EnumTeamsNullableFilter<"PendingBooking"> | $Enums.Teams | null
    pnr?: StringFilter<"PendingBooking"> | string
    airline?: StringFilter<"PendingBooking"> | string
    fromTo?: StringFilter<"PendingBooking"> | string
    bookingType?: EnumBookingTypeFilter<"PendingBooking"> | $Enums.BookingType
    bookingStatus?: EnumBookingStatusNullableFilter<"PendingBooking"> | $Enums.BookingStatus | null
    pcDate?: DateTimeFilter<"PendingBooking"> | Date | string
    issuedDate?: DateTimeNullableFilter<"PendingBooking"> | Date | string | null
    paymentMethod?: EnumPaymentMethodFilter<"PendingBooking"> | $Enums.PaymentMethod
    lastPaymentDate?: DateTimeNullableFilter<"PendingBooking"> | Date | string | null
    travelDate?: DateTimeNullableFilter<"PendingBooking"> | Date | string | null
    revenue?: FloatNullableFilter<"PendingBooking"> | number | null
    prodCost?: FloatNullableFilter<"PendingBooking"> | number | null
    transFee?: FloatNullableFilter<"PendingBooking"> | number | null
    surcharge?: FloatNullableFilter<"PendingBooking"> | number | null
    received?: FloatNullableFilter<"PendingBooking"> | number | null
    transactionMethod?: StringNullableFilter<"PendingBooking"> | string | null
    receivedDate?: DateTimeNullableFilter<"PendingBooking"> | Date | string | null
    balance?: FloatNullableFilter<"PendingBooking"> | number | null
    profit?: FloatNullableFilter<"PendingBooking"> | number | null
    invoiced?: StringNullableFilter<"PendingBooking"> | string | null
    description?: StringNullableFilter<"PendingBooking"> | string | null
    status?: EnumPendingStatusFilter<"PendingBooking"> | $Enums.PendingStatus
    createdAt?: DateTimeFilter<"PendingBooking"> | Date | string
    updatedAt?: DateTimeFilter<"PendingBooking"> | Date | string
    numPax?: IntFilter<"PendingBooking"> | number
    createdById?: IntFilter<"PendingBooking"> | number
    costItems?: PendingCostItemListRelationFilter
    instalments?: PendingInstalmentListRelationFilter
    passengers?: PendingPassengerListRelationFilter
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type PendingBookingOrderByWithAggregationInput = {
    id?: SortOrder
    refNo?: SortOrder
    paxName?: SortOrder
    agentName?: SortOrder
    teamName?: SortOrderInput | SortOrder
    pnr?: SortOrder
    airline?: SortOrder
    fromTo?: SortOrder
    bookingType?: SortOrder
    bookingStatus?: SortOrderInput | SortOrder
    pcDate?: SortOrder
    issuedDate?: SortOrderInput | SortOrder
    paymentMethod?: SortOrder
    lastPaymentDate?: SortOrderInput | SortOrder
    travelDate?: SortOrderInput | SortOrder
    revenue?: SortOrderInput | SortOrder
    prodCost?: SortOrderInput | SortOrder
    transFee?: SortOrderInput | SortOrder
    surcharge?: SortOrderInput | SortOrder
    received?: SortOrderInput | SortOrder
    transactionMethod?: SortOrderInput | SortOrder
    receivedDate?: SortOrderInput | SortOrder
    balance?: SortOrderInput | SortOrder
    profit?: SortOrderInput | SortOrder
    invoiced?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    numPax?: SortOrder
    createdById?: SortOrder
    _count?: PendingBookingCountOrderByAggregateInput
    _avg?: PendingBookingAvgOrderByAggregateInput
    _max?: PendingBookingMaxOrderByAggregateInput
    _min?: PendingBookingMinOrderByAggregateInput
    _sum?: PendingBookingSumOrderByAggregateInput
  }

  export type PendingBookingScalarWhereWithAggregatesInput = {
    AND?: PendingBookingScalarWhereWithAggregatesInput | PendingBookingScalarWhereWithAggregatesInput[]
    OR?: PendingBookingScalarWhereWithAggregatesInput[]
    NOT?: PendingBookingScalarWhereWithAggregatesInput | PendingBookingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PendingBooking"> | number
    refNo?: StringWithAggregatesFilter<"PendingBooking"> | string
    paxName?: StringWithAggregatesFilter<"PendingBooking"> | string
    agentName?: StringWithAggregatesFilter<"PendingBooking"> | string
    teamName?: EnumTeamsNullableWithAggregatesFilter<"PendingBooking"> | $Enums.Teams | null
    pnr?: StringWithAggregatesFilter<"PendingBooking"> | string
    airline?: StringWithAggregatesFilter<"PendingBooking"> | string
    fromTo?: StringWithAggregatesFilter<"PendingBooking"> | string
    bookingType?: EnumBookingTypeWithAggregatesFilter<"PendingBooking"> | $Enums.BookingType
    bookingStatus?: EnumBookingStatusNullableWithAggregatesFilter<"PendingBooking"> | $Enums.BookingStatus | null
    pcDate?: DateTimeWithAggregatesFilter<"PendingBooking"> | Date | string
    issuedDate?: DateTimeNullableWithAggregatesFilter<"PendingBooking"> | Date | string | null
    paymentMethod?: EnumPaymentMethodWithAggregatesFilter<"PendingBooking"> | $Enums.PaymentMethod
    lastPaymentDate?: DateTimeNullableWithAggregatesFilter<"PendingBooking"> | Date | string | null
    travelDate?: DateTimeNullableWithAggregatesFilter<"PendingBooking"> | Date | string | null
    revenue?: FloatNullableWithAggregatesFilter<"PendingBooking"> | number | null
    prodCost?: FloatNullableWithAggregatesFilter<"PendingBooking"> | number | null
    transFee?: FloatNullableWithAggregatesFilter<"PendingBooking"> | number | null
    surcharge?: FloatNullableWithAggregatesFilter<"PendingBooking"> | number | null
    received?: FloatNullableWithAggregatesFilter<"PendingBooking"> | number | null
    transactionMethod?: StringNullableWithAggregatesFilter<"PendingBooking"> | string | null
    receivedDate?: DateTimeNullableWithAggregatesFilter<"PendingBooking"> | Date | string | null
    balance?: FloatNullableWithAggregatesFilter<"PendingBooking"> | number | null
    profit?: FloatNullableWithAggregatesFilter<"PendingBooking"> | number | null
    invoiced?: StringNullableWithAggregatesFilter<"PendingBooking"> | string | null
    description?: StringNullableWithAggregatesFilter<"PendingBooking"> | string | null
    status?: EnumPendingStatusWithAggregatesFilter<"PendingBooking"> | $Enums.PendingStatus
    createdAt?: DateTimeWithAggregatesFilter<"PendingBooking"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PendingBooking"> | Date | string
    numPax?: IntWithAggregatesFilter<"PendingBooking"> | number
    createdById?: IntWithAggregatesFilter<"PendingBooking"> | number
  }

  export type InstalmentWhereInput = {
    AND?: InstalmentWhereInput | InstalmentWhereInput[]
    OR?: InstalmentWhereInput[]
    NOT?: InstalmentWhereInput | InstalmentWhereInput[]
    id?: IntFilter<"Instalment"> | number
    bookingId?: IntFilter<"Instalment"> | number
    dueDate?: DateTimeFilter<"Instalment"> | Date | string
    amount?: FloatFilter<"Instalment"> | number
    status?: StringFilter<"Instalment"> | string
    createdAt?: DateTimeFilter<"Instalment"> | Date | string
    updatedAt?: DateTimeFilter<"Instalment"> | Date | string
    booking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
    payments?: InstalmentPaymentListRelationFilter
  }

  export type InstalmentOrderByWithRelationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    dueDate?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    booking?: BookingOrderByWithRelationInput
    payments?: InstalmentPaymentOrderByRelationAggregateInput
  }

  export type InstalmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: InstalmentWhereInput | InstalmentWhereInput[]
    OR?: InstalmentWhereInput[]
    NOT?: InstalmentWhereInput | InstalmentWhereInput[]
    bookingId?: IntFilter<"Instalment"> | number
    dueDate?: DateTimeFilter<"Instalment"> | Date | string
    amount?: FloatFilter<"Instalment"> | number
    status?: StringFilter<"Instalment"> | string
    createdAt?: DateTimeFilter<"Instalment"> | Date | string
    updatedAt?: DateTimeFilter<"Instalment"> | Date | string
    booking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
    payments?: InstalmentPaymentListRelationFilter
  }, "id">

  export type InstalmentOrderByWithAggregationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    dueDate?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InstalmentCountOrderByAggregateInput
    _avg?: InstalmentAvgOrderByAggregateInput
    _max?: InstalmentMaxOrderByAggregateInput
    _min?: InstalmentMinOrderByAggregateInput
    _sum?: InstalmentSumOrderByAggregateInput
  }

  export type InstalmentScalarWhereWithAggregatesInput = {
    AND?: InstalmentScalarWhereWithAggregatesInput | InstalmentScalarWhereWithAggregatesInput[]
    OR?: InstalmentScalarWhereWithAggregatesInput[]
    NOT?: InstalmentScalarWhereWithAggregatesInput | InstalmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Instalment"> | number
    bookingId?: IntWithAggregatesFilter<"Instalment"> | number
    dueDate?: DateTimeWithAggregatesFilter<"Instalment"> | Date | string
    amount?: FloatWithAggregatesFilter<"Instalment"> | number
    status?: StringWithAggregatesFilter<"Instalment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Instalment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Instalment"> | Date | string
  }

  export type PendingInstalmentWhereInput = {
    AND?: PendingInstalmentWhereInput | PendingInstalmentWhereInput[]
    OR?: PendingInstalmentWhereInput[]
    NOT?: PendingInstalmentWhereInput | PendingInstalmentWhereInput[]
    id?: IntFilter<"PendingInstalment"> | number
    pendingBookingId?: IntFilter<"PendingInstalment"> | number
    dueDate?: DateTimeFilter<"PendingInstalment"> | Date | string
    amount?: FloatFilter<"PendingInstalment"> | number
    status?: StringFilter<"PendingInstalment"> | string
    createdAt?: DateTimeFilter<"PendingInstalment"> | Date | string
    updatedAt?: DateTimeFilter<"PendingInstalment"> | Date | string
    pendingBooking?: XOR<PendingBookingScalarRelationFilter, PendingBookingWhereInput>
  }

  export type PendingInstalmentOrderByWithRelationInput = {
    id?: SortOrder
    pendingBookingId?: SortOrder
    dueDate?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    pendingBooking?: PendingBookingOrderByWithRelationInput
  }

  export type PendingInstalmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PendingInstalmentWhereInput | PendingInstalmentWhereInput[]
    OR?: PendingInstalmentWhereInput[]
    NOT?: PendingInstalmentWhereInput | PendingInstalmentWhereInput[]
    pendingBookingId?: IntFilter<"PendingInstalment"> | number
    dueDate?: DateTimeFilter<"PendingInstalment"> | Date | string
    amount?: FloatFilter<"PendingInstalment"> | number
    status?: StringFilter<"PendingInstalment"> | string
    createdAt?: DateTimeFilter<"PendingInstalment"> | Date | string
    updatedAt?: DateTimeFilter<"PendingInstalment"> | Date | string
    pendingBooking?: XOR<PendingBookingScalarRelationFilter, PendingBookingWhereInput>
  }, "id">

  export type PendingInstalmentOrderByWithAggregationInput = {
    id?: SortOrder
    pendingBookingId?: SortOrder
    dueDate?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PendingInstalmentCountOrderByAggregateInput
    _avg?: PendingInstalmentAvgOrderByAggregateInput
    _max?: PendingInstalmentMaxOrderByAggregateInput
    _min?: PendingInstalmentMinOrderByAggregateInput
    _sum?: PendingInstalmentSumOrderByAggregateInput
  }

  export type PendingInstalmentScalarWhereWithAggregatesInput = {
    AND?: PendingInstalmentScalarWhereWithAggregatesInput | PendingInstalmentScalarWhereWithAggregatesInput[]
    OR?: PendingInstalmentScalarWhereWithAggregatesInput[]
    NOT?: PendingInstalmentScalarWhereWithAggregatesInput | PendingInstalmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PendingInstalment"> | number
    pendingBookingId?: IntWithAggregatesFilter<"PendingInstalment"> | number
    dueDate?: DateTimeWithAggregatesFilter<"PendingInstalment"> | Date | string
    amount?: FloatWithAggregatesFilter<"PendingInstalment"> | number
    status?: StringWithAggregatesFilter<"PendingInstalment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PendingInstalment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PendingInstalment"> | Date | string
  }

  export type InstalmentPaymentWhereInput = {
    AND?: InstalmentPaymentWhereInput | InstalmentPaymentWhereInput[]
    OR?: InstalmentPaymentWhereInput[]
    NOT?: InstalmentPaymentWhereInput | InstalmentPaymentWhereInput[]
    id?: IntFilter<"InstalmentPayment"> | number
    instalmentId?: IntFilter<"InstalmentPayment"> | number
    amount?: FloatFilter<"InstalmentPayment"> | number
    transactionMethod?: StringFilter<"InstalmentPayment"> | string
    paymentDate?: DateTimeFilter<"InstalmentPayment"> | Date | string
    createdAt?: DateTimeFilter<"InstalmentPayment"> | Date | string
    updatedAt?: DateTimeFilter<"InstalmentPayment"> | Date | string
    instalment?: XOR<InstalmentScalarRelationFilter, InstalmentWhereInput>
  }

  export type InstalmentPaymentOrderByWithRelationInput = {
    id?: SortOrder
    instalmentId?: SortOrder
    amount?: SortOrder
    transactionMethod?: SortOrder
    paymentDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    instalment?: InstalmentOrderByWithRelationInput
  }

  export type InstalmentPaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: InstalmentPaymentWhereInput | InstalmentPaymentWhereInput[]
    OR?: InstalmentPaymentWhereInput[]
    NOT?: InstalmentPaymentWhereInput | InstalmentPaymentWhereInput[]
    instalmentId?: IntFilter<"InstalmentPayment"> | number
    amount?: FloatFilter<"InstalmentPayment"> | number
    transactionMethod?: StringFilter<"InstalmentPayment"> | string
    paymentDate?: DateTimeFilter<"InstalmentPayment"> | Date | string
    createdAt?: DateTimeFilter<"InstalmentPayment"> | Date | string
    updatedAt?: DateTimeFilter<"InstalmentPayment"> | Date | string
    instalment?: XOR<InstalmentScalarRelationFilter, InstalmentWhereInput>
  }, "id">

  export type InstalmentPaymentOrderByWithAggregationInput = {
    id?: SortOrder
    instalmentId?: SortOrder
    amount?: SortOrder
    transactionMethod?: SortOrder
    paymentDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InstalmentPaymentCountOrderByAggregateInput
    _avg?: InstalmentPaymentAvgOrderByAggregateInput
    _max?: InstalmentPaymentMaxOrderByAggregateInput
    _min?: InstalmentPaymentMinOrderByAggregateInput
    _sum?: InstalmentPaymentSumOrderByAggregateInput
  }

  export type InstalmentPaymentScalarWhereWithAggregatesInput = {
    AND?: InstalmentPaymentScalarWhereWithAggregatesInput | InstalmentPaymentScalarWhereWithAggregatesInput[]
    OR?: InstalmentPaymentScalarWhereWithAggregatesInput[]
    NOT?: InstalmentPaymentScalarWhereWithAggregatesInput | InstalmentPaymentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"InstalmentPayment"> | number
    instalmentId?: IntWithAggregatesFilter<"InstalmentPayment"> | number
    amount?: FloatWithAggregatesFilter<"InstalmentPayment"> | number
    transactionMethod?: StringWithAggregatesFilter<"InstalmentPayment"> | string
    paymentDate?: DateTimeWithAggregatesFilter<"InstalmentPayment"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"InstalmentPayment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"InstalmentPayment"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    title?: EnumTitleNullableFilter<"User"> | $Enums.Title | null
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    contactNo?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    team?: EnumTeamsNullableFilter<"User"> | $Enums.Teams | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    createdPendingBookings?: PendingBookingListRelationFilter
    voidedBookings?: BookingListRelationFilter
    auditLogs?: AuditLogListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    title?: SortOrderInput | SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    contactNo?: SortOrderInput | SortOrder
    role?: SortOrder
    team?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdPendingBookings?: PendingBookingOrderByRelationAggregateInput
    voidedBookings?: BookingOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    title?: EnumTitleNullableFilter<"User"> | $Enums.Title | null
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    contactNo?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    team?: EnumTeamsNullableFilter<"User"> | $Enums.Teams | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    createdPendingBookings?: PendingBookingListRelationFilter
    voidedBookings?: BookingListRelationFilter
    auditLogs?: AuditLogListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    title?: SortOrderInput | SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    contactNo?: SortOrderInput | SortOrder
    role?: SortOrder
    team?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    title?: EnumTitleNullableWithAggregatesFilter<"User"> | $Enums.Title | null
    firstName?: StringWithAggregatesFilter<"User"> | string
    lastName?: StringWithAggregatesFilter<"User"> | string
    contactNo?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    team?: EnumTeamsNullableWithAggregatesFilter<"User"> | $Enums.Teams | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type CostItemWhereInput = {
    AND?: CostItemWhereInput | CostItemWhereInput[]
    OR?: CostItemWhereInput[]
    NOT?: CostItemWhereInput | CostItemWhereInput[]
    id?: IntFilter<"CostItem"> | number
    bookingId?: IntFilter<"CostItem"> | number
    category?: StringFilter<"CostItem"> | string
    amount?: FloatFilter<"CostItem"> | number
    createdAt?: DateTimeFilter<"CostItem"> | Date | string
    updatedAt?: DateTimeFilter<"CostItem"> | Date | string
    booking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
    suppliers?: CostItemSupplierListRelationFilter
  }

  export type CostItemOrderByWithRelationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    category?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    booking?: BookingOrderByWithRelationInput
    suppliers?: CostItemSupplierOrderByRelationAggregateInput
  }

  export type CostItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CostItemWhereInput | CostItemWhereInput[]
    OR?: CostItemWhereInput[]
    NOT?: CostItemWhereInput | CostItemWhereInput[]
    bookingId?: IntFilter<"CostItem"> | number
    category?: StringFilter<"CostItem"> | string
    amount?: FloatFilter<"CostItem"> | number
    createdAt?: DateTimeFilter<"CostItem"> | Date | string
    updatedAt?: DateTimeFilter<"CostItem"> | Date | string
    booking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
    suppliers?: CostItemSupplierListRelationFilter
  }, "id">

  export type CostItemOrderByWithAggregationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    category?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CostItemCountOrderByAggregateInput
    _avg?: CostItemAvgOrderByAggregateInput
    _max?: CostItemMaxOrderByAggregateInput
    _min?: CostItemMinOrderByAggregateInput
    _sum?: CostItemSumOrderByAggregateInput
  }

  export type CostItemScalarWhereWithAggregatesInput = {
    AND?: CostItemScalarWhereWithAggregatesInput | CostItemScalarWhereWithAggregatesInput[]
    OR?: CostItemScalarWhereWithAggregatesInput[]
    NOT?: CostItemScalarWhereWithAggregatesInput | CostItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CostItem"> | number
    bookingId?: IntWithAggregatesFilter<"CostItem"> | number
    category?: StringWithAggregatesFilter<"CostItem"> | string
    amount?: FloatWithAggregatesFilter<"CostItem"> | number
    createdAt?: DateTimeWithAggregatesFilter<"CostItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CostItem"> | Date | string
  }

  export type PendingCostItemWhereInput = {
    AND?: PendingCostItemWhereInput | PendingCostItemWhereInput[]
    OR?: PendingCostItemWhereInput[]
    NOT?: PendingCostItemWhereInput | PendingCostItemWhereInput[]
    id?: IntFilter<"PendingCostItem"> | number
    pendingBookingId?: IntFilter<"PendingCostItem"> | number
    category?: StringFilter<"PendingCostItem"> | string
    amount?: FloatFilter<"PendingCostItem"> | number
    createdAt?: DateTimeFilter<"PendingCostItem"> | Date | string
    updatedAt?: DateTimeFilter<"PendingCostItem"> | Date | string
    pendingBooking?: XOR<PendingBookingScalarRelationFilter, PendingBookingWhereInput>
    suppliers?: CostItemSupplierListRelationFilter
  }

  export type PendingCostItemOrderByWithRelationInput = {
    id?: SortOrder
    pendingBookingId?: SortOrder
    category?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    pendingBooking?: PendingBookingOrderByWithRelationInput
    suppliers?: CostItemSupplierOrderByRelationAggregateInput
  }

  export type PendingCostItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PendingCostItemWhereInput | PendingCostItemWhereInput[]
    OR?: PendingCostItemWhereInput[]
    NOT?: PendingCostItemWhereInput | PendingCostItemWhereInput[]
    pendingBookingId?: IntFilter<"PendingCostItem"> | number
    category?: StringFilter<"PendingCostItem"> | string
    amount?: FloatFilter<"PendingCostItem"> | number
    createdAt?: DateTimeFilter<"PendingCostItem"> | Date | string
    updatedAt?: DateTimeFilter<"PendingCostItem"> | Date | string
    pendingBooking?: XOR<PendingBookingScalarRelationFilter, PendingBookingWhereInput>
    suppliers?: CostItemSupplierListRelationFilter
  }, "id">

  export type PendingCostItemOrderByWithAggregationInput = {
    id?: SortOrder
    pendingBookingId?: SortOrder
    category?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PendingCostItemCountOrderByAggregateInput
    _avg?: PendingCostItemAvgOrderByAggregateInput
    _max?: PendingCostItemMaxOrderByAggregateInput
    _min?: PendingCostItemMinOrderByAggregateInput
    _sum?: PendingCostItemSumOrderByAggregateInput
  }

  export type PendingCostItemScalarWhereWithAggregatesInput = {
    AND?: PendingCostItemScalarWhereWithAggregatesInput | PendingCostItemScalarWhereWithAggregatesInput[]
    OR?: PendingCostItemScalarWhereWithAggregatesInput[]
    NOT?: PendingCostItemScalarWhereWithAggregatesInput | PendingCostItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PendingCostItem"> | number
    pendingBookingId?: IntWithAggregatesFilter<"PendingCostItem"> | number
    category?: StringWithAggregatesFilter<"PendingCostItem"> | string
    amount?: FloatWithAggregatesFilter<"PendingCostItem"> | number
    createdAt?: DateTimeWithAggregatesFilter<"PendingCostItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PendingCostItem"> | Date | string
  }

  export type PassengerWhereInput = {
    AND?: PassengerWhereInput | PassengerWhereInput[]
    OR?: PassengerWhereInput[]
    NOT?: PassengerWhereInput | PassengerWhereInput[]
    id?: IntFilter<"Passenger"> | number
    bookingId?: IntFilter<"Passenger"> | number
    title?: EnumTitleFilter<"Passenger"> | $Enums.Title
    firstName?: StringFilter<"Passenger"> | string
    middleName?: StringNullableFilter<"Passenger"> | string | null
    lastName?: StringFilter<"Passenger"> | string
    gender?: EnumGenderFilter<"Passenger"> | $Enums.Gender
    email?: StringNullableFilter<"Passenger"> | string | null
    contactNo?: StringNullableFilter<"Passenger"> | string | null
    nationality?: StringNullableFilter<"Passenger"> | string | null
    birthday?: DateTimeNullableFilter<"Passenger"> | Date | string | null
    category?: EnumPassengerCategoryFilter<"Passenger"> | $Enums.PassengerCategory
    createdAt?: DateTimeFilter<"Passenger"> | Date | string
    updatedAt?: DateTimeFilter<"Passenger"> | Date | string
    booking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
  }

  export type PassengerOrderByWithRelationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    title?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrderInput | SortOrder
    lastName?: SortOrder
    gender?: SortOrder
    email?: SortOrderInput | SortOrder
    contactNo?: SortOrderInput | SortOrder
    nationality?: SortOrderInput | SortOrder
    birthday?: SortOrderInput | SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    booking?: BookingOrderByWithRelationInput
  }

  export type PassengerWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PassengerWhereInput | PassengerWhereInput[]
    OR?: PassengerWhereInput[]
    NOT?: PassengerWhereInput | PassengerWhereInput[]
    bookingId?: IntFilter<"Passenger"> | number
    title?: EnumTitleFilter<"Passenger"> | $Enums.Title
    firstName?: StringFilter<"Passenger"> | string
    middleName?: StringNullableFilter<"Passenger"> | string | null
    lastName?: StringFilter<"Passenger"> | string
    gender?: EnumGenderFilter<"Passenger"> | $Enums.Gender
    email?: StringNullableFilter<"Passenger"> | string | null
    contactNo?: StringNullableFilter<"Passenger"> | string | null
    nationality?: StringNullableFilter<"Passenger"> | string | null
    birthday?: DateTimeNullableFilter<"Passenger"> | Date | string | null
    category?: EnumPassengerCategoryFilter<"Passenger"> | $Enums.PassengerCategory
    createdAt?: DateTimeFilter<"Passenger"> | Date | string
    updatedAt?: DateTimeFilter<"Passenger"> | Date | string
    booking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
  }, "id">

  export type PassengerOrderByWithAggregationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    title?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrderInput | SortOrder
    lastName?: SortOrder
    gender?: SortOrder
    email?: SortOrderInput | SortOrder
    contactNo?: SortOrderInput | SortOrder
    nationality?: SortOrderInput | SortOrder
    birthday?: SortOrderInput | SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PassengerCountOrderByAggregateInput
    _avg?: PassengerAvgOrderByAggregateInput
    _max?: PassengerMaxOrderByAggregateInput
    _min?: PassengerMinOrderByAggregateInput
    _sum?: PassengerSumOrderByAggregateInput
  }

  export type PassengerScalarWhereWithAggregatesInput = {
    AND?: PassengerScalarWhereWithAggregatesInput | PassengerScalarWhereWithAggregatesInput[]
    OR?: PassengerScalarWhereWithAggregatesInput[]
    NOT?: PassengerScalarWhereWithAggregatesInput | PassengerScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Passenger"> | number
    bookingId?: IntWithAggregatesFilter<"Passenger"> | number
    title?: EnumTitleWithAggregatesFilter<"Passenger"> | $Enums.Title
    firstName?: StringWithAggregatesFilter<"Passenger"> | string
    middleName?: StringNullableWithAggregatesFilter<"Passenger"> | string | null
    lastName?: StringWithAggregatesFilter<"Passenger"> | string
    gender?: EnumGenderWithAggregatesFilter<"Passenger"> | $Enums.Gender
    email?: StringNullableWithAggregatesFilter<"Passenger"> | string | null
    contactNo?: StringNullableWithAggregatesFilter<"Passenger"> | string | null
    nationality?: StringNullableWithAggregatesFilter<"Passenger"> | string | null
    birthday?: DateTimeNullableWithAggregatesFilter<"Passenger"> | Date | string | null
    category?: EnumPassengerCategoryWithAggregatesFilter<"Passenger"> | $Enums.PassengerCategory
    createdAt?: DateTimeWithAggregatesFilter<"Passenger"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Passenger"> | Date | string
  }

  export type PendingPassengerWhereInput = {
    AND?: PendingPassengerWhereInput | PendingPassengerWhereInput[]
    OR?: PendingPassengerWhereInput[]
    NOT?: PendingPassengerWhereInput | PendingPassengerWhereInput[]
    id?: IntFilter<"PendingPassenger"> | number
    pendingBookingId?: IntFilter<"PendingPassenger"> | number
    title?: EnumTitleFilter<"PendingPassenger"> | $Enums.Title
    firstName?: StringFilter<"PendingPassenger"> | string
    middleName?: StringNullableFilter<"PendingPassenger"> | string | null
    lastName?: StringFilter<"PendingPassenger"> | string
    gender?: EnumGenderFilter<"PendingPassenger"> | $Enums.Gender
    email?: StringNullableFilter<"PendingPassenger"> | string | null
    contactNo?: StringNullableFilter<"PendingPassenger"> | string | null
    nationality?: StringNullableFilter<"PendingPassenger"> | string | null
    birthday?: DateTimeNullableFilter<"PendingPassenger"> | Date | string | null
    category?: EnumPassengerCategoryFilter<"PendingPassenger"> | $Enums.PassengerCategory
    createdAt?: DateTimeFilter<"PendingPassenger"> | Date | string
    updatedAt?: DateTimeFilter<"PendingPassenger"> | Date | string
    pendingBooking?: XOR<PendingBookingScalarRelationFilter, PendingBookingWhereInput>
  }

  export type PendingPassengerOrderByWithRelationInput = {
    id?: SortOrder
    pendingBookingId?: SortOrder
    title?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrderInput | SortOrder
    lastName?: SortOrder
    gender?: SortOrder
    email?: SortOrderInput | SortOrder
    contactNo?: SortOrderInput | SortOrder
    nationality?: SortOrderInput | SortOrder
    birthday?: SortOrderInput | SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    pendingBooking?: PendingBookingOrderByWithRelationInput
  }

  export type PendingPassengerWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PendingPassengerWhereInput | PendingPassengerWhereInput[]
    OR?: PendingPassengerWhereInput[]
    NOT?: PendingPassengerWhereInput | PendingPassengerWhereInput[]
    pendingBookingId?: IntFilter<"PendingPassenger"> | number
    title?: EnumTitleFilter<"PendingPassenger"> | $Enums.Title
    firstName?: StringFilter<"PendingPassenger"> | string
    middleName?: StringNullableFilter<"PendingPassenger"> | string | null
    lastName?: StringFilter<"PendingPassenger"> | string
    gender?: EnumGenderFilter<"PendingPassenger"> | $Enums.Gender
    email?: StringNullableFilter<"PendingPassenger"> | string | null
    contactNo?: StringNullableFilter<"PendingPassenger"> | string | null
    nationality?: StringNullableFilter<"PendingPassenger"> | string | null
    birthday?: DateTimeNullableFilter<"PendingPassenger"> | Date | string | null
    category?: EnumPassengerCategoryFilter<"PendingPassenger"> | $Enums.PassengerCategory
    createdAt?: DateTimeFilter<"PendingPassenger"> | Date | string
    updatedAt?: DateTimeFilter<"PendingPassenger"> | Date | string
    pendingBooking?: XOR<PendingBookingScalarRelationFilter, PendingBookingWhereInput>
  }, "id">

  export type PendingPassengerOrderByWithAggregationInput = {
    id?: SortOrder
    pendingBookingId?: SortOrder
    title?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrderInput | SortOrder
    lastName?: SortOrder
    gender?: SortOrder
    email?: SortOrderInput | SortOrder
    contactNo?: SortOrderInput | SortOrder
    nationality?: SortOrderInput | SortOrder
    birthday?: SortOrderInput | SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PendingPassengerCountOrderByAggregateInput
    _avg?: PendingPassengerAvgOrderByAggregateInput
    _max?: PendingPassengerMaxOrderByAggregateInput
    _min?: PendingPassengerMinOrderByAggregateInput
    _sum?: PendingPassengerSumOrderByAggregateInput
  }

  export type PendingPassengerScalarWhereWithAggregatesInput = {
    AND?: PendingPassengerScalarWhereWithAggregatesInput | PendingPassengerScalarWhereWithAggregatesInput[]
    OR?: PendingPassengerScalarWhereWithAggregatesInput[]
    NOT?: PendingPassengerScalarWhereWithAggregatesInput | PendingPassengerScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PendingPassenger"> | number
    pendingBookingId?: IntWithAggregatesFilter<"PendingPassenger"> | number
    title?: EnumTitleWithAggregatesFilter<"PendingPassenger"> | $Enums.Title
    firstName?: StringWithAggregatesFilter<"PendingPassenger"> | string
    middleName?: StringNullableWithAggregatesFilter<"PendingPassenger"> | string | null
    lastName?: StringWithAggregatesFilter<"PendingPassenger"> | string
    gender?: EnumGenderWithAggregatesFilter<"PendingPassenger"> | $Enums.Gender
    email?: StringNullableWithAggregatesFilter<"PendingPassenger"> | string | null
    contactNo?: StringNullableWithAggregatesFilter<"PendingPassenger"> | string | null
    nationality?: StringNullableWithAggregatesFilter<"PendingPassenger"> | string | null
    birthday?: DateTimeNullableWithAggregatesFilter<"PendingPassenger"> | Date | string | null
    category?: EnumPassengerCategoryWithAggregatesFilter<"PendingPassenger"> | $Enums.PassengerCategory
    createdAt?: DateTimeWithAggregatesFilter<"PendingPassenger"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PendingPassenger"> | Date | string
  }

  export type CostItemSupplierWhereInput = {
    AND?: CostItemSupplierWhereInput | CostItemSupplierWhereInput[]
    OR?: CostItemSupplierWhereInput[]
    NOT?: CostItemSupplierWhereInput | CostItemSupplierWhereInput[]
    id?: IntFilter<"CostItemSupplier"> | number
    costItemId?: IntNullableFilter<"CostItemSupplier"> | number | null
    pendingCostItemId?: IntNullableFilter<"CostItemSupplier"> | number | null
    supplier?: EnumSuppliersFilter<"CostItemSupplier"> | $Enums.Suppliers
    amount?: FloatFilter<"CostItemSupplier"> | number
    paymentMethod?: StringFilter<"CostItemSupplier"> | string
    paidAmount?: FloatFilter<"CostItemSupplier"> | number
    pendingAmount?: FloatFilter<"CostItemSupplier"> | number
    transactionMethod?: StringNullableFilter<"CostItemSupplier"> | string | null
    firstMethodAmount?: FloatNullableFilter<"CostItemSupplier"> | number | null
    secondMethodAmount?: FloatNullableFilter<"CostItemSupplier"> | number | null
    createdAt?: DateTimeFilter<"CostItemSupplier"> | Date | string
    updatedAt?: DateTimeFilter<"CostItemSupplier"> | Date | string
    costItem?: XOR<CostItemNullableScalarRelationFilter, CostItemWhereInput> | null
    pendingCostItem?: XOR<PendingCostItemNullableScalarRelationFilter, PendingCostItemWhereInput> | null
    settlements?: SupplierPaymentSettlementListRelationFilter
    paidByCreditNoteUsage?: CreditNoteUsageListRelationFilter
  }

  export type CostItemSupplierOrderByWithRelationInput = {
    id?: SortOrder
    costItemId?: SortOrderInput | SortOrder
    pendingCostItemId?: SortOrderInput | SortOrder
    supplier?: SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrder
    paidAmount?: SortOrder
    pendingAmount?: SortOrder
    transactionMethod?: SortOrderInput | SortOrder
    firstMethodAmount?: SortOrderInput | SortOrder
    secondMethodAmount?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    costItem?: CostItemOrderByWithRelationInput
    pendingCostItem?: PendingCostItemOrderByWithRelationInput
    settlements?: SupplierPaymentSettlementOrderByRelationAggregateInput
    paidByCreditNoteUsage?: CreditNoteUsageOrderByRelationAggregateInput
  }

  export type CostItemSupplierWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CostItemSupplierWhereInput | CostItemSupplierWhereInput[]
    OR?: CostItemSupplierWhereInput[]
    NOT?: CostItemSupplierWhereInput | CostItemSupplierWhereInput[]
    costItemId?: IntNullableFilter<"CostItemSupplier"> | number | null
    pendingCostItemId?: IntNullableFilter<"CostItemSupplier"> | number | null
    supplier?: EnumSuppliersFilter<"CostItemSupplier"> | $Enums.Suppliers
    amount?: FloatFilter<"CostItemSupplier"> | number
    paymentMethod?: StringFilter<"CostItemSupplier"> | string
    paidAmount?: FloatFilter<"CostItemSupplier"> | number
    pendingAmount?: FloatFilter<"CostItemSupplier"> | number
    transactionMethod?: StringNullableFilter<"CostItemSupplier"> | string | null
    firstMethodAmount?: FloatNullableFilter<"CostItemSupplier"> | number | null
    secondMethodAmount?: FloatNullableFilter<"CostItemSupplier"> | number | null
    createdAt?: DateTimeFilter<"CostItemSupplier"> | Date | string
    updatedAt?: DateTimeFilter<"CostItemSupplier"> | Date | string
    costItem?: XOR<CostItemNullableScalarRelationFilter, CostItemWhereInput> | null
    pendingCostItem?: XOR<PendingCostItemNullableScalarRelationFilter, PendingCostItemWhereInput> | null
    settlements?: SupplierPaymentSettlementListRelationFilter
    paidByCreditNoteUsage?: CreditNoteUsageListRelationFilter
  }, "id">

  export type CostItemSupplierOrderByWithAggregationInput = {
    id?: SortOrder
    costItemId?: SortOrderInput | SortOrder
    pendingCostItemId?: SortOrderInput | SortOrder
    supplier?: SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrder
    paidAmount?: SortOrder
    pendingAmount?: SortOrder
    transactionMethod?: SortOrderInput | SortOrder
    firstMethodAmount?: SortOrderInput | SortOrder
    secondMethodAmount?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CostItemSupplierCountOrderByAggregateInput
    _avg?: CostItemSupplierAvgOrderByAggregateInput
    _max?: CostItemSupplierMaxOrderByAggregateInput
    _min?: CostItemSupplierMinOrderByAggregateInput
    _sum?: CostItemSupplierSumOrderByAggregateInput
  }

  export type CostItemSupplierScalarWhereWithAggregatesInput = {
    AND?: CostItemSupplierScalarWhereWithAggregatesInput | CostItemSupplierScalarWhereWithAggregatesInput[]
    OR?: CostItemSupplierScalarWhereWithAggregatesInput[]
    NOT?: CostItemSupplierScalarWhereWithAggregatesInput | CostItemSupplierScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CostItemSupplier"> | number
    costItemId?: IntNullableWithAggregatesFilter<"CostItemSupplier"> | number | null
    pendingCostItemId?: IntNullableWithAggregatesFilter<"CostItemSupplier"> | number | null
    supplier?: EnumSuppliersWithAggregatesFilter<"CostItemSupplier"> | $Enums.Suppliers
    amount?: FloatWithAggregatesFilter<"CostItemSupplier"> | number
    paymentMethod?: StringWithAggregatesFilter<"CostItemSupplier"> | string
    paidAmount?: FloatWithAggregatesFilter<"CostItemSupplier"> | number
    pendingAmount?: FloatWithAggregatesFilter<"CostItemSupplier"> | number
    transactionMethod?: StringNullableWithAggregatesFilter<"CostItemSupplier"> | string | null
    firstMethodAmount?: FloatNullableWithAggregatesFilter<"CostItemSupplier"> | number | null
    secondMethodAmount?: FloatNullableWithAggregatesFilter<"CostItemSupplier"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"CostItemSupplier"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CostItemSupplier"> | Date | string
  }

  export type SupplierPaymentSettlementWhereInput = {
    AND?: SupplierPaymentSettlementWhereInput | SupplierPaymentSettlementWhereInput[]
    OR?: SupplierPaymentSettlementWhereInput[]
    NOT?: SupplierPaymentSettlementWhereInput | SupplierPaymentSettlementWhereInput[]
    id?: IntFilter<"SupplierPaymentSettlement"> | number
    costItemSupplierId?: IntFilter<"SupplierPaymentSettlement"> | number
    amount?: FloatFilter<"SupplierPaymentSettlement"> | number
    transactionMethod?: StringFilter<"SupplierPaymentSettlement"> | string
    settlementDate?: DateTimeFilter<"SupplierPaymentSettlement"> | Date | string
    createdAt?: DateTimeFilter<"SupplierPaymentSettlement"> | Date | string
    updatedAt?: DateTimeFilter<"SupplierPaymentSettlement"> | Date | string
    costItemSupplier?: XOR<CostItemSupplierScalarRelationFilter, CostItemSupplierWhereInput>
  }

  export type SupplierPaymentSettlementOrderByWithRelationInput = {
    id?: SortOrder
    costItemSupplierId?: SortOrder
    amount?: SortOrder
    transactionMethod?: SortOrder
    settlementDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    costItemSupplier?: CostItemSupplierOrderByWithRelationInput
  }

  export type SupplierPaymentSettlementWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SupplierPaymentSettlementWhereInput | SupplierPaymentSettlementWhereInput[]
    OR?: SupplierPaymentSettlementWhereInput[]
    NOT?: SupplierPaymentSettlementWhereInput | SupplierPaymentSettlementWhereInput[]
    costItemSupplierId?: IntFilter<"SupplierPaymentSettlement"> | number
    amount?: FloatFilter<"SupplierPaymentSettlement"> | number
    transactionMethod?: StringFilter<"SupplierPaymentSettlement"> | string
    settlementDate?: DateTimeFilter<"SupplierPaymentSettlement"> | Date | string
    createdAt?: DateTimeFilter<"SupplierPaymentSettlement"> | Date | string
    updatedAt?: DateTimeFilter<"SupplierPaymentSettlement"> | Date | string
    costItemSupplier?: XOR<CostItemSupplierScalarRelationFilter, CostItemSupplierWhereInput>
  }, "id">

  export type SupplierPaymentSettlementOrderByWithAggregationInput = {
    id?: SortOrder
    costItemSupplierId?: SortOrder
    amount?: SortOrder
    transactionMethod?: SortOrder
    settlementDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SupplierPaymentSettlementCountOrderByAggregateInput
    _avg?: SupplierPaymentSettlementAvgOrderByAggregateInput
    _max?: SupplierPaymentSettlementMaxOrderByAggregateInput
    _min?: SupplierPaymentSettlementMinOrderByAggregateInput
    _sum?: SupplierPaymentSettlementSumOrderByAggregateInput
  }

  export type SupplierPaymentSettlementScalarWhereWithAggregatesInput = {
    AND?: SupplierPaymentSettlementScalarWhereWithAggregatesInput | SupplierPaymentSettlementScalarWhereWithAggregatesInput[]
    OR?: SupplierPaymentSettlementScalarWhereWithAggregatesInput[]
    NOT?: SupplierPaymentSettlementScalarWhereWithAggregatesInput | SupplierPaymentSettlementScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SupplierPaymentSettlement"> | number
    costItemSupplierId?: IntWithAggregatesFilter<"SupplierPaymentSettlement"> | number
    amount?: FloatWithAggregatesFilter<"SupplierPaymentSettlement"> | number
    transactionMethod?: StringWithAggregatesFilter<"SupplierPaymentSettlement"> | string
    settlementDate?: DateTimeWithAggregatesFilter<"SupplierPaymentSettlement"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"SupplierPaymentSettlement"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SupplierPaymentSettlement"> | Date | string
  }

  export type CancellationWhereInput = {
    AND?: CancellationWhereInput | CancellationWhereInput[]
    OR?: CancellationWhereInput[]
    NOT?: CancellationWhereInput | CancellationWhereInput[]
    id?: IntFilter<"Cancellation"> | number
    originalBookingId?: IntFilter<"Cancellation"> | number
    folderNo?: StringFilter<"Cancellation"> | string
    refundTransactionMethod?: StringFilter<"Cancellation"> | string
    originalRevenue?: FloatFilter<"Cancellation"> | number
    originalProdCost?: FloatFilter<"Cancellation"> | number
    supplierCancellationFee?: FloatFilter<"Cancellation"> | number
    refundToPassenger?: FloatFilter<"Cancellation"> | number
    adminFee?: FloatFilter<"Cancellation"> | number
    refundStatus?: StringFilter<"Cancellation"> | string
    creditNoteAmount?: FloatNullableFilter<"Cancellation"> | number | null
    profitOrLoss?: FloatFilter<"Cancellation"> | number
    description?: StringNullableFilter<"Cancellation"> | string | null
    createdAt?: DateTimeFilter<"Cancellation"> | Date | string
    updatedAt?: DateTimeFilter<"Cancellation"> | Date | string
    originalBooking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
    refundPayment?: XOR<PassengerRefundPaymentNullableScalarRelationFilter, PassengerRefundPaymentWhereInput> | null
    createdCustomerPayable?: XOR<CustomerPayableNullableScalarRelationFilter, CustomerPayableWhereInput> | null
    createdPayable?: XOR<SupplierPayableNullableScalarRelationFilter, SupplierPayableWhereInput> | null
    generatedCreditNote?: XOR<SupplierCreditNoteNullableScalarRelationFilter, SupplierCreditNoteWhereInput> | null
  }

  export type CancellationOrderByWithRelationInput = {
    id?: SortOrder
    originalBookingId?: SortOrder
    folderNo?: SortOrder
    refundTransactionMethod?: SortOrder
    originalRevenue?: SortOrder
    originalProdCost?: SortOrder
    supplierCancellationFee?: SortOrder
    refundToPassenger?: SortOrder
    adminFee?: SortOrder
    refundStatus?: SortOrder
    creditNoteAmount?: SortOrderInput | SortOrder
    profitOrLoss?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    originalBooking?: BookingOrderByWithRelationInput
    refundPayment?: PassengerRefundPaymentOrderByWithRelationInput
    createdCustomerPayable?: CustomerPayableOrderByWithRelationInput
    createdPayable?: SupplierPayableOrderByWithRelationInput
    generatedCreditNote?: SupplierCreditNoteOrderByWithRelationInput
  }

  export type CancellationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    originalBookingId?: number
    folderNo?: string
    AND?: CancellationWhereInput | CancellationWhereInput[]
    OR?: CancellationWhereInput[]
    NOT?: CancellationWhereInput | CancellationWhereInput[]
    refundTransactionMethod?: StringFilter<"Cancellation"> | string
    originalRevenue?: FloatFilter<"Cancellation"> | number
    originalProdCost?: FloatFilter<"Cancellation"> | number
    supplierCancellationFee?: FloatFilter<"Cancellation"> | number
    refundToPassenger?: FloatFilter<"Cancellation"> | number
    adminFee?: FloatFilter<"Cancellation"> | number
    refundStatus?: StringFilter<"Cancellation"> | string
    creditNoteAmount?: FloatNullableFilter<"Cancellation"> | number | null
    profitOrLoss?: FloatFilter<"Cancellation"> | number
    description?: StringNullableFilter<"Cancellation"> | string | null
    createdAt?: DateTimeFilter<"Cancellation"> | Date | string
    updatedAt?: DateTimeFilter<"Cancellation"> | Date | string
    originalBooking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
    refundPayment?: XOR<PassengerRefundPaymentNullableScalarRelationFilter, PassengerRefundPaymentWhereInput> | null
    createdCustomerPayable?: XOR<CustomerPayableNullableScalarRelationFilter, CustomerPayableWhereInput> | null
    createdPayable?: XOR<SupplierPayableNullableScalarRelationFilter, SupplierPayableWhereInput> | null
    generatedCreditNote?: XOR<SupplierCreditNoteNullableScalarRelationFilter, SupplierCreditNoteWhereInput> | null
  }, "id" | "originalBookingId" | "folderNo">

  export type CancellationOrderByWithAggregationInput = {
    id?: SortOrder
    originalBookingId?: SortOrder
    folderNo?: SortOrder
    refundTransactionMethod?: SortOrder
    originalRevenue?: SortOrder
    originalProdCost?: SortOrder
    supplierCancellationFee?: SortOrder
    refundToPassenger?: SortOrder
    adminFee?: SortOrder
    refundStatus?: SortOrder
    creditNoteAmount?: SortOrderInput | SortOrder
    profitOrLoss?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CancellationCountOrderByAggregateInput
    _avg?: CancellationAvgOrderByAggregateInput
    _max?: CancellationMaxOrderByAggregateInput
    _min?: CancellationMinOrderByAggregateInput
    _sum?: CancellationSumOrderByAggregateInput
  }

  export type CancellationScalarWhereWithAggregatesInput = {
    AND?: CancellationScalarWhereWithAggregatesInput | CancellationScalarWhereWithAggregatesInput[]
    OR?: CancellationScalarWhereWithAggregatesInput[]
    NOT?: CancellationScalarWhereWithAggregatesInput | CancellationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Cancellation"> | number
    originalBookingId?: IntWithAggregatesFilter<"Cancellation"> | number
    folderNo?: StringWithAggregatesFilter<"Cancellation"> | string
    refundTransactionMethod?: StringWithAggregatesFilter<"Cancellation"> | string
    originalRevenue?: FloatWithAggregatesFilter<"Cancellation"> | number
    originalProdCost?: FloatWithAggregatesFilter<"Cancellation"> | number
    supplierCancellationFee?: FloatWithAggregatesFilter<"Cancellation"> | number
    refundToPassenger?: FloatWithAggregatesFilter<"Cancellation"> | number
    adminFee?: FloatWithAggregatesFilter<"Cancellation"> | number
    refundStatus?: StringWithAggregatesFilter<"Cancellation"> | string
    creditNoteAmount?: FloatNullableWithAggregatesFilter<"Cancellation"> | number | null
    profitOrLoss?: FloatWithAggregatesFilter<"Cancellation"> | number
    description?: StringNullableWithAggregatesFilter<"Cancellation"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Cancellation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Cancellation"> | Date | string
  }

  export type SupplierCreditNoteWhereInput = {
    AND?: SupplierCreditNoteWhereInput | SupplierCreditNoteWhereInput[]
    OR?: SupplierCreditNoteWhereInput[]
    NOT?: SupplierCreditNoteWhereInput | SupplierCreditNoteWhereInput[]
    id?: IntFilter<"SupplierCreditNote"> | number
    supplier?: EnumSuppliersFilter<"SupplierCreditNote"> | $Enums.Suppliers
    initialAmount?: FloatFilter<"SupplierCreditNote"> | number
    remainingAmount?: FloatFilter<"SupplierCreditNote"> | number
    status?: EnumCreditNoteStatusFilter<"SupplierCreditNote"> | $Enums.CreditNoteStatus
    generatedFromCancellationId?: IntFilter<"SupplierCreditNote"> | number
    createdAt?: DateTimeFilter<"SupplierCreditNote"> | Date | string
    updatedAt?: DateTimeFilter<"SupplierCreditNote"> | Date | string
    generatedFromCancellation?: XOR<CancellationScalarRelationFilter, CancellationWhereInput>
    usageHistory?: CreditNoteUsageListRelationFilter
  }

  export type SupplierCreditNoteOrderByWithRelationInput = {
    id?: SortOrder
    supplier?: SortOrder
    initialAmount?: SortOrder
    remainingAmount?: SortOrder
    status?: SortOrder
    generatedFromCancellationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    generatedFromCancellation?: CancellationOrderByWithRelationInput
    usageHistory?: CreditNoteUsageOrderByRelationAggregateInput
  }

  export type SupplierCreditNoteWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    generatedFromCancellationId?: number
    AND?: SupplierCreditNoteWhereInput | SupplierCreditNoteWhereInput[]
    OR?: SupplierCreditNoteWhereInput[]
    NOT?: SupplierCreditNoteWhereInput | SupplierCreditNoteWhereInput[]
    supplier?: EnumSuppliersFilter<"SupplierCreditNote"> | $Enums.Suppliers
    initialAmount?: FloatFilter<"SupplierCreditNote"> | number
    remainingAmount?: FloatFilter<"SupplierCreditNote"> | number
    status?: EnumCreditNoteStatusFilter<"SupplierCreditNote"> | $Enums.CreditNoteStatus
    createdAt?: DateTimeFilter<"SupplierCreditNote"> | Date | string
    updatedAt?: DateTimeFilter<"SupplierCreditNote"> | Date | string
    generatedFromCancellation?: XOR<CancellationScalarRelationFilter, CancellationWhereInput>
    usageHistory?: CreditNoteUsageListRelationFilter
  }, "id" | "generatedFromCancellationId">

  export type SupplierCreditNoteOrderByWithAggregationInput = {
    id?: SortOrder
    supplier?: SortOrder
    initialAmount?: SortOrder
    remainingAmount?: SortOrder
    status?: SortOrder
    generatedFromCancellationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SupplierCreditNoteCountOrderByAggregateInput
    _avg?: SupplierCreditNoteAvgOrderByAggregateInput
    _max?: SupplierCreditNoteMaxOrderByAggregateInput
    _min?: SupplierCreditNoteMinOrderByAggregateInput
    _sum?: SupplierCreditNoteSumOrderByAggregateInput
  }

  export type SupplierCreditNoteScalarWhereWithAggregatesInput = {
    AND?: SupplierCreditNoteScalarWhereWithAggregatesInput | SupplierCreditNoteScalarWhereWithAggregatesInput[]
    OR?: SupplierCreditNoteScalarWhereWithAggregatesInput[]
    NOT?: SupplierCreditNoteScalarWhereWithAggregatesInput | SupplierCreditNoteScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SupplierCreditNote"> | number
    supplier?: EnumSuppliersWithAggregatesFilter<"SupplierCreditNote"> | $Enums.Suppliers
    initialAmount?: FloatWithAggregatesFilter<"SupplierCreditNote"> | number
    remainingAmount?: FloatWithAggregatesFilter<"SupplierCreditNote"> | number
    status?: EnumCreditNoteStatusWithAggregatesFilter<"SupplierCreditNote"> | $Enums.CreditNoteStatus
    generatedFromCancellationId?: IntWithAggregatesFilter<"SupplierCreditNote"> | number
    createdAt?: DateTimeWithAggregatesFilter<"SupplierCreditNote"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SupplierCreditNote"> | Date | string
  }

  export type CreditNoteUsageWhereInput = {
    AND?: CreditNoteUsageWhereInput | CreditNoteUsageWhereInput[]
    OR?: CreditNoteUsageWhereInput[]
    NOT?: CreditNoteUsageWhereInput | CreditNoteUsageWhereInput[]
    id?: IntFilter<"CreditNoteUsage"> | number
    amountUsed?: FloatFilter<"CreditNoteUsage"> | number
    usedAt?: DateTimeFilter<"CreditNoteUsage"> | Date | string
    creditNoteId?: IntFilter<"CreditNoteUsage"> | number
    usedOnCostItemSupplierId?: IntFilter<"CreditNoteUsage"> | number
    creditNote?: XOR<SupplierCreditNoteScalarRelationFilter, SupplierCreditNoteWhereInput>
    usedOnCostItemSupplier?: XOR<CostItemSupplierScalarRelationFilter, CostItemSupplierWhereInput>
  }

  export type CreditNoteUsageOrderByWithRelationInput = {
    id?: SortOrder
    amountUsed?: SortOrder
    usedAt?: SortOrder
    creditNoteId?: SortOrder
    usedOnCostItemSupplierId?: SortOrder
    creditNote?: SupplierCreditNoteOrderByWithRelationInput
    usedOnCostItemSupplier?: CostItemSupplierOrderByWithRelationInput
  }

  export type CreditNoteUsageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CreditNoteUsageWhereInput | CreditNoteUsageWhereInput[]
    OR?: CreditNoteUsageWhereInput[]
    NOT?: CreditNoteUsageWhereInput | CreditNoteUsageWhereInput[]
    amountUsed?: FloatFilter<"CreditNoteUsage"> | number
    usedAt?: DateTimeFilter<"CreditNoteUsage"> | Date | string
    creditNoteId?: IntFilter<"CreditNoteUsage"> | number
    usedOnCostItemSupplierId?: IntFilter<"CreditNoteUsage"> | number
    creditNote?: XOR<SupplierCreditNoteScalarRelationFilter, SupplierCreditNoteWhereInput>
    usedOnCostItemSupplier?: XOR<CostItemSupplierScalarRelationFilter, CostItemSupplierWhereInput>
  }, "id">

  export type CreditNoteUsageOrderByWithAggregationInput = {
    id?: SortOrder
    amountUsed?: SortOrder
    usedAt?: SortOrder
    creditNoteId?: SortOrder
    usedOnCostItemSupplierId?: SortOrder
    _count?: CreditNoteUsageCountOrderByAggregateInput
    _avg?: CreditNoteUsageAvgOrderByAggregateInput
    _max?: CreditNoteUsageMaxOrderByAggregateInput
    _min?: CreditNoteUsageMinOrderByAggregateInput
    _sum?: CreditNoteUsageSumOrderByAggregateInput
  }

  export type CreditNoteUsageScalarWhereWithAggregatesInput = {
    AND?: CreditNoteUsageScalarWhereWithAggregatesInput | CreditNoteUsageScalarWhereWithAggregatesInput[]
    OR?: CreditNoteUsageScalarWhereWithAggregatesInput[]
    NOT?: CreditNoteUsageScalarWhereWithAggregatesInput | CreditNoteUsageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CreditNoteUsage"> | number
    amountUsed?: FloatWithAggregatesFilter<"CreditNoteUsage"> | number
    usedAt?: DateTimeWithAggregatesFilter<"CreditNoteUsage"> | Date | string
    creditNoteId?: IntWithAggregatesFilter<"CreditNoteUsage"> | number
    usedOnCostItemSupplierId?: IntWithAggregatesFilter<"CreditNoteUsage"> | number
  }

  export type SupplierPayableWhereInput = {
    AND?: SupplierPayableWhereInput | SupplierPayableWhereInput[]
    OR?: SupplierPayableWhereInput[]
    NOT?: SupplierPayableWhereInput | SupplierPayableWhereInput[]
    id?: IntFilter<"SupplierPayable"> | number
    supplier?: EnumSuppliersFilter<"SupplierPayable"> | $Enums.Suppliers
    totalAmount?: FloatFilter<"SupplierPayable"> | number
    paidAmount?: FloatFilter<"SupplierPayable"> | number
    pendingAmount?: FloatFilter<"SupplierPayable"> | number
    reason?: StringFilter<"SupplierPayable"> | string
    status?: StringFilter<"SupplierPayable"> | string
    createdFromCancellationId?: IntFilter<"SupplierPayable"> | number
    createdAt?: DateTimeFilter<"SupplierPayable"> | Date | string
    updatedAt?: DateTimeFilter<"SupplierPayable"> | Date | string
    createdFromCancellation?: XOR<CancellationScalarRelationFilter, CancellationWhereInput>
    settlements?: SupplierPayableSettlementListRelationFilter
  }

  export type SupplierPayableOrderByWithRelationInput = {
    id?: SortOrder
    supplier?: SortOrder
    totalAmount?: SortOrder
    paidAmount?: SortOrder
    pendingAmount?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    createdFromCancellationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    createdFromCancellation?: CancellationOrderByWithRelationInput
    settlements?: SupplierPayableSettlementOrderByRelationAggregateInput
  }

  export type SupplierPayableWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    createdFromCancellationId?: number
    AND?: SupplierPayableWhereInput | SupplierPayableWhereInput[]
    OR?: SupplierPayableWhereInput[]
    NOT?: SupplierPayableWhereInput | SupplierPayableWhereInput[]
    supplier?: EnumSuppliersFilter<"SupplierPayable"> | $Enums.Suppliers
    totalAmount?: FloatFilter<"SupplierPayable"> | number
    paidAmount?: FloatFilter<"SupplierPayable"> | number
    pendingAmount?: FloatFilter<"SupplierPayable"> | number
    reason?: StringFilter<"SupplierPayable"> | string
    status?: StringFilter<"SupplierPayable"> | string
    createdAt?: DateTimeFilter<"SupplierPayable"> | Date | string
    updatedAt?: DateTimeFilter<"SupplierPayable"> | Date | string
    createdFromCancellation?: XOR<CancellationScalarRelationFilter, CancellationWhereInput>
    settlements?: SupplierPayableSettlementListRelationFilter
  }, "id" | "createdFromCancellationId">

  export type SupplierPayableOrderByWithAggregationInput = {
    id?: SortOrder
    supplier?: SortOrder
    totalAmount?: SortOrder
    paidAmount?: SortOrder
    pendingAmount?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    createdFromCancellationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SupplierPayableCountOrderByAggregateInput
    _avg?: SupplierPayableAvgOrderByAggregateInput
    _max?: SupplierPayableMaxOrderByAggregateInput
    _min?: SupplierPayableMinOrderByAggregateInput
    _sum?: SupplierPayableSumOrderByAggregateInput
  }

  export type SupplierPayableScalarWhereWithAggregatesInput = {
    AND?: SupplierPayableScalarWhereWithAggregatesInput | SupplierPayableScalarWhereWithAggregatesInput[]
    OR?: SupplierPayableScalarWhereWithAggregatesInput[]
    NOT?: SupplierPayableScalarWhereWithAggregatesInput | SupplierPayableScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SupplierPayable"> | number
    supplier?: EnumSuppliersWithAggregatesFilter<"SupplierPayable"> | $Enums.Suppliers
    totalAmount?: FloatWithAggregatesFilter<"SupplierPayable"> | number
    paidAmount?: FloatWithAggregatesFilter<"SupplierPayable"> | number
    pendingAmount?: FloatWithAggregatesFilter<"SupplierPayable"> | number
    reason?: StringWithAggregatesFilter<"SupplierPayable"> | string
    status?: StringWithAggregatesFilter<"SupplierPayable"> | string
    createdFromCancellationId?: IntWithAggregatesFilter<"SupplierPayable"> | number
    createdAt?: DateTimeWithAggregatesFilter<"SupplierPayable"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SupplierPayable"> | Date | string
  }

  export type SupplierPayableSettlementWhereInput = {
    AND?: SupplierPayableSettlementWhereInput | SupplierPayableSettlementWhereInput[]
    OR?: SupplierPayableSettlementWhereInput[]
    NOT?: SupplierPayableSettlementWhereInput | SupplierPayableSettlementWhereInput[]
    id?: IntFilter<"SupplierPayableSettlement"> | number
    supplierPayableId?: IntFilter<"SupplierPayableSettlement"> | number
    amount?: FloatFilter<"SupplierPayableSettlement"> | number
    transactionMethod?: StringFilter<"SupplierPayableSettlement"> | string
    settlementDate?: DateTimeFilter<"SupplierPayableSettlement"> | Date | string
    createdAt?: DateTimeFilter<"SupplierPayableSettlement"> | Date | string
    payable?: XOR<SupplierPayableScalarRelationFilter, SupplierPayableWhereInput>
  }

  export type SupplierPayableSettlementOrderByWithRelationInput = {
    id?: SortOrder
    supplierPayableId?: SortOrder
    amount?: SortOrder
    transactionMethod?: SortOrder
    settlementDate?: SortOrder
    createdAt?: SortOrder
    payable?: SupplierPayableOrderByWithRelationInput
  }

  export type SupplierPayableSettlementWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SupplierPayableSettlementWhereInput | SupplierPayableSettlementWhereInput[]
    OR?: SupplierPayableSettlementWhereInput[]
    NOT?: SupplierPayableSettlementWhereInput | SupplierPayableSettlementWhereInput[]
    supplierPayableId?: IntFilter<"SupplierPayableSettlement"> | number
    amount?: FloatFilter<"SupplierPayableSettlement"> | number
    transactionMethod?: StringFilter<"SupplierPayableSettlement"> | string
    settlementDate?: DateTimeFilter<"SupplierPayableSettlement"> | Date | string
    createdAt?: DateTimeFilter<"SupplierPayableSettlement"> | Date | string
    payable?: XOR<SupplierPayableScalarRelationFilter, SupplierPayableWhereInput>
  }, "id">

  export type SupplierPayableSettlementOrderByWithAggregationInput = {
    id?: SortOrder
    supplierPayableId?: SortOrder
    amount?: SortOrder
    transactionMethod?: SortOrder
    settlementDate?: SortOrder
    createdAt?: SortOrder
    _count?: SupplierPayableSettlementCountOrderByAggregateInput
    _avg?: SupplierPayableSettlementAvgOrderByAggregateInput
    _max?: SupplierPayableSettlementMaxOrderByAggregateInput
    _min?: SupplierPayableSettlementMinOrderByAggregateInput
    _sum?: SupplierPayableSettlementSumOrderByAggregateInput
  }

  export type SupplierPayableSettlementScalarWhereWithAggregatesInput = {
    AND?: SupplierPayableSettlementScalarWhereWithAggregatesInput | SupplierPayableSettlementScalarWhereWithAggregatesInput[]
    OR?: SupplierPayableSettlementScalarWhereWithAggregatesInput[]
    NOT?: SupplierPayableSettlementScalarWhereWithAggregatesInput | SupplierPayableSettlementScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SupplierPayableSettlement"> | number
    supplierPayableId?: IntWithAggregatesFilter<"SupplierPayableSettlement"> | number
    amount?: FloatWithAggregatesFilter<"SupplierPayableSettlement"> | number
    transactionMethod?: StringWithAggregatesFilter<"SupplierPayableSettlement"> | string
    settlementDate?: DateTimeWithAggregatesFilter<"SupplierPayableSettlement"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"SupplierPayableSettlement"> | Date | string
  }

  export type CustomerPayableWhereInput = {
    AND?: CustomerPayableWhereInput | CustomerPayableWhereInput[]
    OR?: CustomerPayableWhereInput[]
    NOT?: CustomerPayableWhereInput | CustomerPayableWhereInput[]
    id?: IntFilter<"CustomerPayable"> | number
    totalAmount?: FloatFilter<"CustomerPayable"> | number
    paidAmount?: FloatFilter<"CustomerPayable"> | number
    pendingAmount?: FloatFilter<"CustomerPayable"> | number
    reason?: StringFilter<"CustomerPayable"> | string
    status?: StringFilter<"CustomerPayable"> | string
    createdFromCancellationId?: IntFilter<"CustomerPayable"> | number
    bookingId?: IntFilter<"CustomerPayable"> | number
    createdAt?: DateTimeFilter<"CustomerPayable"> | Date | string
    updatedAt?: DateTimeFilter<"CustomerPayable"> | Date | string
    settlements?: CustomerPayableSettlementListRelationFilter
    createdFromCancellation?: XOR<CancellationScalarRelationFilter, CancellationWhereInput>
    booking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
  }

  export type CustomerPayableOrderByWithRelationInput = {
    id?: SortOrder
    totalAmount?: SortOrder
    paidAmount?: SortOrder
    pendingAmount?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    createdFromCancellationId?: SortOrder
    bookingId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    settlements?: CustomerPayableSettlementOrderByRelationAggregateInput
    createdFromCancellation?: CancellationOrderByWithRelationInput
    booking?: BookingOrderByWithRelationInput
  }

  export type CustomerPayableWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    createdFromCancellationId?: number
    AND?: CustomerPayableWhereInput | CustomerPayableWhereInput[]
    OR?: CustomerPayableWhereInput[]
    NOT?: CustomerPayableWhereInput | CustomerPayableWhereInput[]
    totalAmount?: FloatFilter<"CustomerPayable"> | number
    paidAmount?: FloatFilter<"CustomerPayable"> | number
    pendingAmount?: FloatFilter<"CustomerPayable"> | number
    reason?: StringFilter<"CustomerPayable"> | string
    status?: StringFilter<"CustomerPayable"> | string
    bookingId?: IntFilter<"CustomerPayable"> | number
    createdAt?: DateTimeFilter<"CustomerPayable"> | Date | string
    updatedAt?: DateTimeFilter<"CustomerPayable"> | Date | string
    settlements?: CustomerPayableSettlementListRelationFilter
    createdFromCancellation?: XOR<CancellationScalarRelationFilter, CancellationWhereInput>
    booking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
  }, "id" | "createdFromCancellationId">

  export type CustomerPayableOrderByWithAggregationInput = {
    id?: SortOrder
    totalAmount?: SortOrder
    paidAmount?: SortOrder
    pendingAmount?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    createdFromCancellationId?: SortOrder
    bookingId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CustomerPayableCountOrderByAggregateInput
    _avg?: CustomerPayableAvgOrderByAggregateInput
    _max?: CustomerPayableMaxOrderByAggregateInput
    _min?: CustomerPayableMinOrderByAggregateInput
    _sum?: CustomerPayableSumOrderByAggregateInput
  }

  export type CustomerPayableScalarWhereWithAggregatesInput = {
    AND?: CustomerPayableScalarWhereWithAggregatesInput | CustomerPayableScalarWhereWithAggregatesInput[]
    OR?: CustomerPayableScalarWhereWithAggregatesInput[]
    NOT?: CustomerPayableScalarWhereWithAggregatesInput | CustomerPayableScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CustomerPayable"> | number
    totalAmount?: FloatWithAggregatesFilter<"CustomerPayable"> | number
    paidAmount?: FloatWithAggregatesFilter<"CustomerPayable"> | number
    pendingAmount?: FloatWithAggregatesFilter<"CustomerPayable"> | number
    reason?: StringWithAggregatesFilter<"CustomerPayable"> | string
    status?: StringWithAggregatesFilter<"CustomerPayable"> | string
    createdFromCancellationId?: IntWithAggregatesFilter<"CustomerPayable"> | number
    bookingId?: IntWithAggregatesFilter<"CustomerPayable"> | number
    createdAt?: DateTimeWithAggregatesFilter<"CustomerPayable"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CustomerPayable"> | Date | string
  }

  export type CustomerPayableSettlementWhereInput = {
    AND?: CustomerPayableSettlementWhereInput | CustomerPayableSettlementWhereInput[]
    OR?: CustomerPayableSettlementWhereInput[]
    NOT?: CustomerPayableSettlementWhereInput | CustomerPayableSettlementWhereInput[]
    id?: IntFilter<"CustomerPayableSettlement"> | number
    customerPayableId?: IntFilter<"CustomerPayableSettlement"> | number
    amount?: FloatFilter<"CustomerPayableSettlement"> | number
    transactionMethod?: StringFilter<"CustomerPayableSettlement"> | string
    paymentDate?: DateTimeFilter<"CustomerPayableSettlement"> | Date | string
    createdAt?: DateTimeFilter<"CustomerPayableSettlement"> | Date | string
    payable?: XOR<CustomerPayableScalarRelationFilter, CustomerPayableWhereInput>
  }

  export type CustomerPayableSettlementOrderByWithRelationInput = {
    id?: SortOrder
    customerPayableId?: SortOrder
    amount?: SortOrder
    transactionMethod?: SortOrder
    paymentDate?: SortOrder
    createdAt?: SortOrder
    payable?: CustomerPayableOrderByWithRelationInput
  }

  export type CustomerPayableSettlementWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CustomerPayableSettlementWhereInput | CustomerPayableSettlementWhereInput[]
    OR?: CustomerPayableSettlementWhereInput[]
    NOT?: CustomerPayableSettlementWhereInput | CustomerPayableSettlementWhereInput[]
    customerPayableId?: IntFilter<"CustomerPayableSettlement"> | number
    amount?: FloatFilter<"CustomerPayableSettlement"> | number
    transactionMethod?: StringFilter<"CustomerPayableSettlement"> | string
    paymentDate?: DateTimeFilter<"CustomerPayableSettlement"> | Date | string
    createdAt?: DateTimeFilter<"CustomerPayableSettlement"> | Date | string
    payable?: XOR<CustomerPayableScalarRelationFilter, CustomerPayableWhereInput>
  }, "id">

  export type CustomerPayableSettlementOrderByWithAggregationInput = {
    id?: SortOrder
    customerPayableId?: SortOrder
    amount?: SortOrder
    transactionMethod?: SortOrder
    paymentDate?: SortOrder
    createdAt?: SortOrder
    _count?: CustomerPayableSettlementCountOrderByAggregateInput
    _avg?: CustomerPayableSettlementAvgOrderByAggregateInput
    _max?: CustomerPayableSettlementMaxOrderByAggregateInput
    _min?: CustomerPayableSettlementMinOrderByAggregateInput
    _sum?: CustomerPayableSettlementSumOrderByAggregateInput
  }

  export type CustomerPayableSettlementScalarWhereWithAggregatesInput = {
    AND?: CustomerPayableSettlementScalarWhereWithAggregatesInput | CustomerPayableSettlementScalarWhereWithAggregatesInput[]
    OR?: CustomerPayableSettlementScalarWhereWithAggregatesInput[]
    NOT?: CustomerPayableSettlementScalarWhereWithAggregatesInput | CustomerPayableSettlementScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CustomerPayableSettlement"> | number
    customerPayableId?: IntWithAggregatesFilter<"CustomerPayableSettlement"> | number
    amount?: FloatWithAggregatesFilter<"CustomerPayableSettlement"> | number
    transactionMethod?: StringWithAggregatesFilter<"CustomerPayableSettlement"> | string
    paymentDate?: DateTimeWithAggregatesFilter<"CustomerPayableSettlement"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"CustomerPayableSettlement"> | Date | string
  }

  export type PassengerRefundPaymentWhereInput = {
    AND?: PassengerRefundPaymentWhereInput | PassengerRefundPaymentWhereInput[]
    OR?: PassengerRefundPaymentWhereInput[]
    NOT?: PassengerRefundPaymentWhereInput | PassengerRefundPaymentWhereInput[]
    id?: IntFilter<"PassengerRefundPayment"> | number
    amount?: FloatFilter<"PassengerRefundPayment"> | number
    transactionMethod?: StringFilter<"PassengerRefundPayment"> | string
    refundDate?: DateTimeFilter<"PassengerRefundPayment"> | Date | string
    cancellationId?: IntFilter<"PassengerRefundPayment"> | number
    createdAt?: DateTimeFilter<"PassengerRefundPayment"> | Date | string
    cancellation?: XOR<CancellationScalarRelationFilter, CancellationWhereInput>
  }

  export type PassengerRefundPaymentOrderByWithRelationInput = {
    id?: SortOrder
    amount?: SortOrder
    transactionMethod?: SortOrder
    refundDate?: SortOrder
    cancellationId?: SortOrder
    createdAt?: SortOrder
    cancellation?: CancellationOrderByWithRelationInput
  }

  export type PassengerRefundPaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    cancellationId?: number
    AND?: PassengerRefundPaymentWhereInput | PassengerRefundPaymentWhereInput[]
    OR?: PassengerRefundPaymentWhereInput[]
    NOT?: PassengerRefundPaymentWhereInput | PassengerRefundPaymentWhereInput[]
    amount?: FloatFilter<"PassengerRefundPayment"> | number
    transactionMethod?: StringFilter<"PassengerRefundPayment"> | string
    refundDate?: DateTimeFilter<"PassengerRefundPayment"> | Date | string
    createdAt?: DateTimeFilter<"PassengerRefundPayment"> | Date | string
    cancellation?: XOR<CancellationScalarRelationFilter, CancellationWhereInput>
  }, "id" | "cancellationId">

  export type PassengerRefundPaymentOrderByWithAggregationInput = {
    id?: SortOrder
    amount?: SortOrder
    transactionMethod?: SortOrder
    refundDate?: SortOrder
    cancellationId?: SortOrder
    createdAt?: SortOrder
    _count?: PassengerRefundPaymentCountOrderByAggregateInput
    _avg?: PassengerRefundPaymentAvgOrderByAggregateInput
    _max?: PassengerRefundPaymentMaxOrderByAggregateInput
    _min?: PassengerRefundPaymentMinOrderByAggregateInput
    _sum?: PassengerRefundPaymentSumOrderByAggregateInput
  }

  export type PassengerRefundPaymentScalarWhereWithAggregatesInput = {
    AND?: PassengerRefundPaymentScalarWhereWithAggregatesInput | PassengerRefundPaymentScalarWhereWithAggregatesInput[]
    OR?: PassengerRefundPaymentScalarWhereWithAggregatesInput[]
    NOT?: PassengerRefundPaymentScalarWhereWithAggregatesInput | PassengerRefundPaymentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PassengerRefundPayment"> | number
    amount?: FloatWithAggregatesFilter<"PassengerRefundPayment"> | number
    transactionMethod?: StringWithAggregatesFilter<"PassengerRefundPayment"> | string
    refundDate?: DateTimeWithAggregatesFilter<"PassengerRefundPayment"> | Date | string
    cancellationId?: IntWithAggregatesFilter<"PassengerRefundPayment"> | number
    createdAt?: DateTimeWithAggregatesFilter<"PassengerRefundPayment"> | Date | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: IntFilter<"AuditLog"> | number
    modelName?: StringFilter<"AuditLog"> | string
    recordId?: IntFilter<"AuditLog"> | number
    userId?: IntFilter<"AuditLog"> | number
    action?: EnumActionTypeFilter<"AuditLog"> | $Enums.ActionType
    fieldName?: StringNullableFilter<"AuditLog"> | string | null
    oldValue?: StringNullableFilter<"AuditLog"> | string | null
    newValue?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    modelName?: SortOrder
    recordId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    fieldName?: SortOrderInput | SortOrder
    oldValue?: SortOrderInput | SortOrder
    newValue?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    modelName?: StringFilter<"AuditLog"> | string
    recordId?: IntFilter<"AuditLog"> | number
    userId?: IntFilter<"AuditLog"> | number
    action?: EnumActionTypeFilter<"AuditLog"> | $Enums.ActionType
    fieldName?: StringNullableFilter<"AuditLog"> | string | null
    oldValue?: StringNullableFilter<"AuditLog"> | string | null
    newValue?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    modelName?: SortOrder
    recordId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    fieldName?: SortOrderInput | SortOrder
    oldValue?: SortOrderInput | SortOrder
    newValue?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _avg?: AuditLogAvgOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
    _sum?: AuditLogSumOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AuditLog"> | number
    modelName?: StringWithAggregatesFilter<"AuditLog"> | string
    recordId?: IntWithAggregatesFilter<"AuditLog"> | number
    userId?: IntWithAggregatesFilter<"AuditLog"> | number
    action?: EnumActionTypeWithAggregatesFilter<"AuditLog"> | $Enums.ActionType
    fieldName?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    oldValue?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    newValue?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type BookingCreateInput = {
    folderNo: string
    refNo: string
    paxName: string
    agentName: string
    teamName?: $Enums.Teams | null
    pnr: string
    airline: string
    fromTo: string
    bookingType: $Enums.BookingType
    bookingStatus?: $Enums.BookingStatus | null
    pcDate: Date | string
    issuedDate?: Date | string | null
    paymentMethod: $Enums.PaymentMethod
    lastPaymentDate?: Date | string | null
    travelDate?: Date | string | null
    revenue?: number | null
    prodCost?: number | null
    transFee?: number | null
    surcharge?: number | null
    received?: number | null
    transactionMethod?: string | null
    receivedDate?: Date | string | null
    balance?: number | null
    profit?: number | null
    invoiced?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    numPax: number
    initialDeposit?: number | null
    statusBeforeVoid?: $Enums.BookingStatus | null
    voidReason?: string | null
    voidedAt?: Date | string | null
    costItems?: CostItemCreateNestedManyWithoutBookingInput
    instalments?: InstalmentCreateNestedManyWithoutBookingInput
    passengers?: PassengerCreateNestedManyWithoutBookingInput
    originalBooking?: BookingCreateNestedOneWithoutFollowUpBookingsInput
    followUpBookings?: BookingCreateNestedManyWithoutOriginalBookingInput
    voidedBy?: UserCreateNestedOneWithoutVoidedBookingsInput
    customerPayables?: CustomerPayableCreateNestedManyWithoutBookingInput
    cancellation?: CancellationCreateNestedOneWithoutOriginalBookingInput
  }

  export type BookingUncheckedCreateInput = {
    id?: number
    folderNo: string
    refNo: string
    paxName: string
    agentName: string
    teamName?: $Enums.Teams | null
    pnr: string
    airline: string
    fromTo: string
    bookingType: $Enums.BookingType
    bookingStatus?: $Enums.BookingStatus | null
    pcDate: Date | string
    issuedDate?: Date | string | null
    paymentMethod: $Enums.PaymentMethod
    lastPaymentDate?: Date | string | null
    travelDate?: Date | string | null
    revenue?: number | null
    prodCost?: number | null
    transFee?: number | null
    surcharge?: number | null
    received?: number | null
    transactionMethod?: string | null
    receivedDate?: Date | string | null
    balance?: number | null
    profit?: number | null
    invoiced?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    numPax: number
    initialDeposit?: number | null
    originalBookingId?: number | null
    statusBeforeVoid?: $Enums.BookingStatus | null
    voidReason?: string | null
    voidedAt?: Date | string | null
    voidedById?: number | null
    costItems?: CostItemUncheckedCreateNestedManyWithoutBookingInput
    instalments?: InstalmentUncheckedCreateNestedManyWithoutBookingInput
    passengers?: PassengerUncheckedCreateNestedManyWithoutBookingInput
    followUpBookings?: BookingUncheckedCreateNestedManyWithoutOriginalBookingInput
    customerPayables?: CustomerPayableUncheckedCreateNestedManyWithoutBookingInput
    cancellation?: CancellationUncheckedCreateNestedOneWithoutOriginalBookingInput
  }

  export type BookingUpdateInput = {
    folderNo?: StringFieldUpdateOperationsInput | string
    refNo?: StringFieldUpdateOperationsInput | string
    paxName?: StringFieldUpdateOperationsInput | string
    agentName?: StringFieldUpdateOperationsInput | string
    teamName?: NullableEnumTeamsFieldUpdateOperationsInput | $Enums.Teams | null
    pnr?: StringFieldUpdateOperationsInput | string
    airline?: StringFieldUpdateOperationsInput | string
    fromTo?: StringFieldUpdateOperationsInput | string
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    bookingStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    pcDate?: DateTimeFieldUpdateOperationsInput | Date | string
    issuedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    travelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    prodCost?: NullableFloatFieldUpdateOperationsInput | number | null
    transFee?: NullableFloatFieldUpdateOperationsInput | number | null
    surcharge?: NullableFloatFieldUpdateOperationsInput | number | null
    received?: NullableFloatFieldUpdateOperationsInput | number | null
    transactionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    profit?: NullableFloatFieldUpdateOperationsInput | number | null
    invoiced?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    numPax?: IntFieldUpdateOperationsInput | number
    initialDeposit?: NullableFloatFieldUpdateOperationsInput | number | null
    statusBeforeVoid?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    voidReason?: NullableStringFieldUpdateOperationsInput | string | null
    voidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    costItems?: CostItemUpdateManyWithoutBookingNestedInput
    instalments?: InstalmentUpdateManyWithoutBookingNestedInput
    passengers?: PassengerUpdateManyWithoutBookingNestedInput
    originalBooking?: BookingUpdateOneWithoutFollowUpBookingsNestedInput
    followUpBookings?: BookingUpdateManyWithoutOriginalBookingNestedInput
    voidedBy?: UserUpdateOneWithoutVoidedBookingsNestedInput
    customerPayables?: CustomerPayableUpdateManyWithoutBookingNestedInput
    cancellation?: CancellationUpdateOneWithoutOriginalBookingNestedInput
  }

  export type BookingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    folderNo?: StringFieldUpdateOperationsInput | string
    refNo?: StringFieldUpdateOperationsInput | string
    paxName?: StringFieldUpdateOperationsInput | string
    agentName?: StringFieldUpdateOperationsInput | string
    teamName?: NullableEnumTeamsFieldUpdateOperationsInput | $Enums.Teams | null
    pnr?: StringFieldUpdateOperationsInput | string
    airline?: StringFieldUpdateOperationsInput | string
    fromTo?: StringFieldUpdateOperationsInput | string
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    bookingStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    pcDate?: DateTimeFieldUpdateOperationsInput | Date | string
    issuedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    travelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    prodCost?: NullableFloatFieldUpdateOperationsInput | number | null
    transFee?: NullableFloatFieldUpdateOperationsInput | number | null
    surcharge?: NullableFloatFieldUpdateOperationsInput | number | null
    received?: NullableFloatFieldUpdateOperationsInput | number | null
    transactionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    profit?: NullableFloatFieldUpdateOperationsInput | number | null
    invoiced?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    numPax?: IntFieldUpdateOperationsInput | number
    initialDeposit?: NullableFloatFieldUpdateOperationsInput | number | null
    originalBookingId?: NullableIntFieldUpdateOperationsInput | number | null
    statusBeforeVoid?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    voidReason?: NullableStringFieldUpdateOperationsInput | string | null
    voidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    voidedById?: NullableIntFieldUpdateOperationsInput | number | null
    costItems?: CostItemUncheckedUpdateManyWithoutBookingNestedInput
    instalments?: InstalmentUncheckedUpdateManyWithoutBookingNestedInput
    passengers?: PassengerUncheckedUpdateManyWithoutBookingNestedInput
    followUpBookings?: BookingUncheckedUpdateManyWithoutOriginalBookingNestedInput
    customerPayables?: CustomerPayableUncheckedUpdateManyWithoutBookingNestedInput
    cancellation?: CancellationUncheckedUpdateOneWithoutOriginalBookingNestedInput
  }

  export type BookingCreateManyInput = {
    id?: number
    folderNo: string
    refNo: string
    paxName: string
    agentName: string
    teamName?: $Enums.Teams | null
    pnr: string
    airline: string
    fromTo: string
    bookingType: $Enums.BookingType
    bookingStatus?: $Enums.BookingStatus | null
    pcDate: Date | string
    issuedDate?: Date | string | null
    paymentMethod: $Enums.PaymentMethod
    lastPaymentDate?: Date | string | null
    travelDate?: Date | string | null
    revenue?: number | null
    prodCost?: number | null
    transFee?: number | null
    surcharge?: number | null
    received?: number | null
    transactionMethod?: string | null
    receivedDate?: Date | string | null
    balance?: number | null
    profit?: number | null
    invoiced?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    numPax: number
    initialDeposit?: number | null
    originalBookingId?: number | null
    statusBeforeVoid?: $Enums.BookingStatus | null
    voidReason?: string | null
    voidedAt?: Date | string | null
    voidedById?: number | null
  }

  export type BookingUpdateManyMutationInput = {
    folderNo?: StringFieldUpdateOperationsInput | string
    refNo?: StringFieldUpdateOperationsInput | string
    paxName?: StringFieldUpdateOperationsInput | string
    agentName?: StringFieldUpdateOperationsInput | string
    teamName?: NullableEnumTeamsFieldUpdateOperationsInput | $Enums.Teams | null
    pnr?: StringFieldUpdateOperationsInput | string
    airline?: StringFieldUpdateOperationsInput | string
    fromTo?: StringFieldUpdateOperationsInput | string
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    bookingStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    pcDate?: DateTimeFieldUpdateOperationsInput | Date | string
    issuedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    travelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    prodCost?: NullableFloatFieldUpdateOperationsInput | number | null
    transFee?: NullableFloatFieldUpdateOperationsInput | number | null
    surcharge?: NullableFloatFieldUpdateOperationsInput | number | null
    received?: NullableFloatFieldUpdateOperationsInput | number | null
    transactionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    profit?: NullableFloatFieldUpdateOperationsInput | number | null
    invoiced?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    numPax?: IntFieldUpdateOperationsInput | number
    initialDeposit?: NullableFloatFieldUpdateOperationsInput | number | null
    statusBeforeVoid?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    voidReason?: NullableStringFieldUpdateOperationsInput | string | null
    voidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BookingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    folderNo?: StringFieldUpdateOperationsInput | string
    refNo?: StringFieldUpdateOperationsInput | string
    paxName?: StringFieldUpdateOperationsInput | string
    agentName?: StringFieldUpdateOperationsInput | string
    teamName?: NullableEnumTeamsFieldUpdateOperationsInput | $Enums.Teams | null
    pnr?: StringFieldUpdateOperationsInput | string
    airline?: StringFieldUpdateOperationsInput | string
    fromTo?: StringFieldUpdateOperationsInput | string
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    bookingStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    pcDate?: DateTimeFieldUpdateOperationsInput | Date | string
    issuedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    travelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    prodCost?: NullableFloatFieldUpdateOperationsInput | number | null
    transFee?: NullableFloatFieldUpdateOperationsInput | number | null
    surcharge?: NullableFloatFieldUpdateOperationsInput | number | null
    received?: NullableFloatFieldUpdateOperationsInput | number | null
    transactionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    profit?: NullableFloatFieldUpdateOperationsInput | number | null
    invoiced?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    numPax?: IntFieldUpdateOperationsInput | number
    initialDeposit?: NullableFloatFieldUpdateOperationsInput | number | null
    originalBookingId?: NullableIntFieldUpdateOperationsInput | number | null
    statusBeforeVoid?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    voidReason?: NullableStringFieldUpdateOperationsInput | string | null
    voidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    voidedById?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PendingBookingCreateInput = {
    refNo: string
    paxName: string
    agentName: string
    teamName?: $Enums.Teams | null
    pnr: string
    airline: string
    fromTo: string
    bookingType: $Enums.BookingType
    bookingStatus?: $Enums.BookingStatus | null
    pcDate: Date | string
    issuedDate?: Date | string | null
    paymentMethod: $Enums.PaymentMethod
    lastPaymentDate?: Date | string | null
    travelDate?: Date | string | null
    revenue?: number | null
    prodCost?: number | null
    transFee?: number | null
    surcharge?: number | null
    received?: number | null
    transactionMethod?: string | null
    receivedDate?: Date | string | null
    balance?: number | null
    profit?: number | null
    invoiced?: string | null
    description?: string | null
    status?: $Enums.PendingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    numPax: number
    costItems?: PendingCostItemCreateNestedManyWithoutPendingBookingInput
    instalments?: PendingInstalmentCreateNestedManyWithoutPendingBookingInput
    passengers?: PendingPassengerCreateNestedManyWithoutPendingBookingInput
    createdBy: UserCreateNestedOneWithoutCreatedPendingBookingsInput
  }

  export type PendingBookingUncheckedCreateInput = {
    id?: number
    refNo: string
    paxName: string
    agentName: string
    teamName?: $Enums.Teams | null
    pnr: string
    airline: string
    fromTo: string
    bookingType: $Enums.BookingType
    bookingStatus?: $Enums.BookingStatus | null
    pcDate: Date | string
    issuedDate?: Date | string | null
    paymentMethod: $Enums.PaymentMethod
    lastPaymentDate?: Date | string | null
    travelDate?: Date | string | null
    revenue?: number | null
    prodCost?: number | null
    transFee?: number | null
    surcharge?: number | null
    received?: number | null
    transactionMethod?: string | null
    receivedDate?: Date | string | null
    balance?: number | null
    profit?: number | null
    invoiced?: string | null
    description?: string | null
    status?: $Enums.PendingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    numPax: number
    createdById: number
    costItems?: PendingCostItemUncheckedCreateNestedManyWithoutPendingBookingInput
    instalments?: PendingInstalmentUncheckedCreateNestedManyWithoutPendingBookingInput
    passengers?: PendingPassengerUncheckedCreateNestedManyWithoutPendingBookingInput
  }

  export type PendingBookingUpdateInput = {
    refNo?: StringFieldUpdateOperationsInput | string
    paxName?: StringFieldUpdateOperationsInput | string
    agentName?: StringFieldUpdateOperationsInput | string
    teamName?: NullableEnumTeamsFieldUpdateOperationsInput | $Enums.Teams | null
    pnr?: StringFieldUpdateOperationsInput | string
    airline?: StringFieldUpdateOperationsInput | string
    fromTo?: StringFieldUpdateOperationsInput | string
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    bookingStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    pcDate?: DateTimeFieldUpdateOperationsInput | Date | string
    issuedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    travelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    prodCost?: NullableFloatFieldUpdateOperationsInput | number | null
    transFee?: NullableFloatFieldUpdateOperationsInput | number | null
    surcharge?: NullableFloatFieldUpdateOperationsInput | number | null
    received?: NullableFloatFieldUpdateOperationsInput | number | null
    transactionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    profit?: NullableFloatFieldUpdateOperationsInput | number | null
    invoiced?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPendingStatusFieldUpdateOperationsInput | $Enums.PendingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    numPax?: IntFieldUpdateOperationsInput | number
    costItems?: PendingCostItemUpdateManyWithoutPendingBookingNestedInput
    instalments?: PendingInstalmentUpdateManyWithoutPendingBookingNestedInput
    passengers?: PendingPassengerUpdateManyWithoutPendingBookingNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedPendingBookingsNestedInput
  }

  export type PendingBookingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    refNo?: StringFieldUpdateOperationsInput | string
    paxName?: StringFieldUpdateOperationsInput | string
    agentName?: StringFieldUpdateOperationsInput | string
    teamName?: NullableEnumTeamsFieldUpdateOperationsInput | $Enums.Teams | null
    pnr?: StringFieldUpdateOperationsInput | string
    airline?: StringFieldUpdateOperationsInput | string
    fromTo?: StringFieldUpdateOperationsInput | string
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    bookingStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    pcDate?: DateTimeFieldUpdateOperationsInput | Date | string
    issuedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    travelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    prodCost?: NullableFloatFieldUpdateOperationsInput | number | null
    transFee?: NullableFloatFieldUpdateOperationsInput | number | null
    surcharge?: NullableFloatFieldUpdateOperationsInput | number | null
    received?: NullableFloatFieldUpdateOperationsInput | number | null
    transactionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    profit?: NullableFloatFieldUpdateOperationsInput | number | null
    invoiced?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPendingStatusFieldUpdateOperationsInput | $Enums.PendingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    numPax?: IntFieldUpdateOperationsInput | number
    createdById?: IntFieldUpdateOperationsInput | number
    costItems?: PendingCostItemUncheckedUpdateManyWithoutPendingBookingNestedInput
    instalments?: PendingInstalmentUncheckedUpdateManyWithoutPendingBookingNestedInput
    passengers?: PendingPassengerUncheckedUpdateManyWithoutPendingBookingNestedInput
  }

  export type PendingBookingCreateManyInput = {
    id?: number
    refNo: string
    paxName: string
    agentName: string
    teamName?: $Enums.Teams | null
    pnr: string
    airline: string
    fromTo: string
    bookingType: $Enums.BookingType
    bookingStatus?: $Enums.BookingStatus | null
    pcDate: Date | string
    issuedDate?: Date | string | null
    paymentMethod: $Enums.PaymentMethod
    lastPaymentDate?: Date | string | null
    travelDate?: Date | string | null
    revenue?: number | null
    prodCost?: number | null
    transFee?: number | null
    surcharge?: number | null
    received?: number | null
    transactionMethod?: string | null
    receivedDate?: Date | string | null
    balance?: number | null
    profit?: number | null
    invoiced?: string | null
    description?: string | null
    status?: $Enums.PendingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    numPax: number
    createdById: number
  }

  export type PendingBookingUpdateManyMutationInput = {
    refNo?: StringFieldUpdateOperationsInput | string
    paxName?: StringFieldUpdateOperationsInput | string
    agentName?: StringFieldUpdateOperationsInput | string
    teamName?: NullableEnumTeamsFieldUpdateOperationsInput | $Enums.Teams | null
    pnr?: StringFieldUpdateOperationsInput | string
    airline?: StringFieldUpdateOperationsInput | string
    fromTo?: StringFieldUpdateOperationsInput | string
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    bookingStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    pcDate?: DateTimeFieldUpdateOperationsInput | Date | string
    issuedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    travelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    prodCost?: NullableFloatFieldUpdateOperationsInput | number | null
    transFee?: NullableFloatFieldUpdateOperationsInput | number | null
    surcharge?: NullableFloatFieldUpdateOperationsInput | number | null
    received?: NullableFloatFieldUpdateOperationsInput | number | null
    transactionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    profit?: NullableFloatFieldUpdateOperationsInput | number | null
    invoiced?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPendingStatusFieldUpdateOperationsInput | $Enums.PendingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    numPax?: IntFieldUpdateOperationsInput | number
  }

  export type PendingBookingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    refNo?: StringFieldUpdateOperationsInput | string
    paxName?: StringFieldUpdateOperationsInput | string
    agentName?: StringFieldUpdateOperationsInput | string
    teamName?: NullableEnumTeamsFieldUpdateOperationsInput | $Enums.Teams | null
    pnr?: StringFieldUpdateOperationsInput | string
    airline?: StringFieldUpdateOperationsInput | string
    fromTo?: StringFieldUpdateOperationsInput | string
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    bookingStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    pcDate?: DateTimeFieldUpdateOperationsInput | Date | string
    issuedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    travelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    prodCost?: NullableFloatFieldUpdateOperationsInput | number | null
    transFee?: NullableFloatFieldUpdateOperationsInput | number | null
    surcharge?: NullableFloatFieldUpdateOperationsInput | number | null
    received?: NullableFloatFieldUpdateOperationsInput | number | null
    transactionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    profit?: NullableFloatFieldUpdateOperationsInput | number | null
    invoiced?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPendingStatusFieldUpdateOperationsInput | $Enums.PendingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    numPax?: IntFieldUpdateOperationsInput | number
    createdById?: IntFieldUpdateOperationsInput | number
  }

  export type InstalmentCreateInput = {
    dueDate: Date | string
    amount: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    booking: BookingCreateNestedOneWithoutInstalmentsInput
    payments?: InstalmentPaymentCreateNestedManyWithoutInstalmentInput
  }

  export type InstalmentUncheckedCreateInput = {
    id?: number
    bookingId: number
    dueDate: Date | string
    amount: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: InstalmentPaymentUncheckedCreateNestedManyWithoutInstalmentInput
  }

  export type InstalmentUpdateInput = {
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUpdateOneRequiredWithoutInstalmentsNestedInput
    payments?: InstalmentPaymentUpdateManyWithoutInstalmentNestedInput
  }

  export type InstalmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookingId?: IntFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: InstalmentPaymentUncheckedUpdateManyWithoutInstalmentNestedInput
  }

  export type InstalmentCreateManyInput = {
    id?: number
    bookingId: number
    dueDate: Date | string
    amount: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InstalmentUpdateManyMutationInput = {
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstalmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookingId?: IntFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PendingInstalmentCreateInput = {
    dueDate: Date | string
    amount: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    pendingBooking: PendingBookingCreateNestedOneWithoutInstalmentsInput
  }

  export type PendingInstalmentUncheckedCreateInput = {
    id?: number
    pendingBookingId: number
    dueDate: Date | string
    amount: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PendingInstalmentUpdateInput = {
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pendingBooking?: PendingBookingUpdateOneRequiredWithoutInstalmentsNestedInput
  }

  export type PendingInstalmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    pendingBookingId?: IntFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PendingInstalmentCreateManyInput = {
    id?: number
    pendingBookingId: number
    dueDate: Date | string
    amount: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PendingInstalmentUpdateManyMutationInput = {
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PendingInstalmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    pendingBookingId?: IntFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstalmentPaymentCreateInput = {
    amount: number
    transactionMethod: string
    paymentDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    instalment: InstalmentCreateNestedOneWithoutPaymentsInput
  }

  export type InstalmentPaymentUncheckedCreateInput = {
    id?: number
    instalmentId: number
    amount: number
    transactionMethod: string
    paymentDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InstalmentPaymentUpdateInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    transactionMethod?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    instalment?: InstalmentUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type InstalmentPaymentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    instalmentId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    transactionMethod?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstalmentPaymentCreateManyInput = {
    id?: number
    instalmentId: number
    amount: number
    transactionMethod: string
    paymentDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InstalmentPaymentUpdateManyMutationInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    transactionMethod?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstalmentPaymentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    instalmentId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    transactionMethod?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    email: string
    password: string
    title?: $Enums.Title | null
    firstName: string
    lastName: string
    contactNo?: string | null
    role: $Enums.Role
    team?: $Enums.Teams | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdPendingBookings?: PendingBookingCreateNestedManyWithoutCreatedByInput
    voidedBookings?: BookingCreateNestedManyWithoutVoidedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    email: string
    password: string
    title?: $Enums.Title | null
    firstName: string
    lastName: string
    contactNo?: string | null
    role: $Enums.Role
    team?: $Enums.Teams | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdPendingBookings?: PendingBookingUncheckedCreateNestedManyWithoutCreatedByInput
    voidedBookings?: BookingUncheckedCreateNestedManyWithoutVoidedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    title?: NullableEnumTitleFieldUpdateOperationsInput | $Enums.Title | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    team?: NullableEnumTeamsFieldUpdateOperationsInput | $Enums.Teams | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdPendingBookings?: PendingBookingUpdateManyWithoutCreatedByNestedInput
    voidedBookings?: BookingUpdateManyWithoutVoidedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    title?: NullableEnumTitleFieldUpdateOperationsInput | $Enums.Title | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    team?: NullableEnumTeamsFieldUpdateOperationsInput | $Enums.Teams | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdPendingBookings?: PendingBookingUncheckedUpdateManyWithoutCreatedByNestedInput
    voidedBookings?: BookingUncheckedUpdateManyWithoutVoidedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    email: string
    password: string
    title?: $Enums.Title | null
    firstName: string
    lastName: string
    contactNo?: string | null
    role: $Enums.Role
    team?: $Enums.Teams | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    title?: NullableEnumTitleFieldUpdateOperationsInput | $Enums.Title | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    team?: NullableEnumTeamsFieldUpdateOperationsInput | $Enums.Teams | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    title?: NullableEnumTitleFieldUpdateOperationsInput | $Enums.Title | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    team?: NullableEnumTeamsFieldUpdateOperationsInput | $Enums.Teams | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CostItemCreateInput = {
    category: string
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    booking: BookingCreateNestedOneWithoutCostItemsInput
    suppliers?: CostItemSupplierCreateNestedManyWithoutCostItemInput
  }

  export type CostItemUncheckedCreateInput = {
    id?: number
    bookingId: number
    category: string
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    suppliers?: CostItemSupplierUncheckedCreateNestedManyWithoutCostItemInput
  }

  export type CostItemUpdateInput = {
    category?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUpdateOneRequiredWithoutCostItemsNestedInput
    suppliers?: CostItemSupplierUpdateManyWithoutCostItemNestedInput
  }

  export type CostItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookingId?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    suppliers?: CostItemSupplierUncheckedUpdateManyWithoutCostItemNestedInput
  }

  export type CostItemCreateManyInput = {
    id?: number
    bookingId: number
    category: string
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CostItemUpdateManyMutationInput = {
    category?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CostItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookingId?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PendingCostItemCreateInput = {
    category: string
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    pendingBooking: PendingBookingCreateNestedOneWithoutCostItemsInput
    suppliers?: CostItemSupplierCreateNestedManyWithoutPendingCostItemInput
  }

  export type PendingCostItemUncheckedCreateInput = {
    id?: number
    pendingBookingId: number
    category: string
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    suppliers?: CostItemSupplierUncheckedCreateNestedManyWithoutPendingCostItemInput
  }

  export type PendingCostItemUpdateInput = {
    category?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pendingBooking?: PendingBookingUpdateOneRequiredWithoutCostItemsNestedInput
    suppliers?: CostItemSupplierUpdateManyWithoutPendingCostItemNestedInput
  }

  export type PendingCostItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    pendingBookingId?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    suppliers?: CostItemSupplierUncheckedUpdateManyWithoutPendingCostItemNestedInput
  }

  export type PendingCostItemCreateManyInput = {
    id?: number
    pendingBookingId: number
    category: string
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PendingCostItemUpdateManyMutationInput = {
    category?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PendingCostItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    pendingBookingId?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PassengerCreateInput = {
    title: $Enums.Title
    firstName: string
    middleName?: string | null
    lastName: string
    gender: $Enums.Gender
    email?: string | null
    contactNo?: string | null
    nationality?: string | null
    birthday?: Date | string | null
    category: $Enums.PassengerCategory
    createdAt?: Date | string
    updatedAt?: Date | string
    booking: BookingCreateNestedOneWithoutPassengersInput
  }

  export type PassengerUncheckedCreateInput = {
    id?: number
    bookingId: number
    title: $Enums.Title
    firstName: string
    middleName?: string | null
    lastName: string
    gender: $Enums.Gender
    email?: string | null
    contactNo?: string | null
    nationality?: string | null
    birthday?: Date | string | null
    category: $Enums.PassengerCategory
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PassengerUpdateInput = {
    title?: EnumTitleFieldUpdateOperationsInput | $Enums.Title
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: EnumPassengerCategoryFieldUpdateOperationsInput | $Enums.PassengerCategory
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUpdateOneRequiredWithoutPassengersNestedInput
  }

  export type PassengerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookingId?: IntFieldUpdateOperationsInput | number
    title?: EnumTitleFieldUpdateOperationsInput | $Enums.Title
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: EnumPassengerCategoryFieldUpdateOperationsInput | $Enums.PassengerCategory
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PassengerCreateManyInput = {
    id?: number
    bookingId: number
    title: $Enums.Title
    firstName: string
    middleName?: string | null
    lastName: string
    gender: $Enums.Gender
    email?: string | null
    contactNo?: string | null
    nationality?: string | null
    birthday?: Date | string | null
    category: $Enums.PassengerCategory
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PassengerUpdateManyMutationInput = {
    title?: EnumTitleFieldUpdateOperationsInput | $Enums.Title
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: EnumPassengerCategoryFieldUpdateOperationsInput | $Enums.PassengerCategory
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PassengerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookingId?: IntFieldUpdateOperationsInput | number
    title?: EnumTitleFieldUpdateOperationsInput | $Enums.Title
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: EnumPassengerCategoryFieldUpdateOperationsInput | $Enums.PassengerCategory
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PendingPassengerCreateInput = {
    title: $Enums.Title
    firstName: string
    middleName?: string | null
    lastName: string
    gender: $Enums.Gender
    email?: string | null
    contactNo?: string | null
    nationality?: string | null
    birthday?: Date | string | null
    category: $Enums.PassengerCategory
    createdAt?: Date | string
    updatedAt?: Date | string
    pendingBooking: PendingBookingCreateNestedOneWithoutPassengersInput
  }

  export type PendingPassengerUncheckedCreateInput = {
    id?: number
    pendingBookingId: number
    title: $Enums.Title
    firstName: string
    middleName?: string | null
    lastName: string
    gender: $Enums.Gender
    email?: string | null
    contactNo?: string | null
    nationality?: string | null
    birthday?: Date | string | null
    category: $Enums.PassengerCategory
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PendingPassengerUpdateInput = {
    title?: EnumTitleFieldUpdateOperationsInput | $Enums.Title
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: EnumPassengerCategoryFieldUpdateOperationsInput | $Enums.PassengerCategory
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pendingBooking?: PendingBookingUpdateOneRequiredWithoutPassengersNestedInput
  }

  export type PendingPassengerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    pendingBookingId?: IntFieldUpdateOperationsInput | number
    title?: EnumTitleFieldUpdateOperationsInput | $Enums.Title
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: EnumPassengerCategoryFieldUpdateOperationsInput | $Enums.PassengerCategory
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PendingPassengerCreateManyInput = {
    id?: number
    pendingBookingId: number
    title: $Enums.Title
    firstName: string
    middleName?: string | null
    lastName: string
    gender: $Enums.Gender
    email?: string | null
    contactNo?: string | null
    nationality?: string | null
    birthday?: Date | string | null
    category: $Enums.PassengerCategory
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PendingPassengerUpdateManyMutationInput = {
    title?: EnumTitleFieldUpdateOperationsInput | $Enums.Title
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: EnumPassengerCategoryFieldUpdateOperationsInput | $Enums.PassengerCategory
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PendingPassengerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    pendingBookingId?: IntFieldUpdateOperationsInput | number
    title?: EnumTitleFieldUpdateOperationsInput | $Enums.Title
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: EnumPassengerCategoryFieldUpdateOperationsInput | $Enums.PassengerCategory
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CostItemSupplierCreateInput = {
    supplier: $Enums.Suppliers
    amount: number
    paymentMethod?: string
    paidAmount?: number
    pendingAmount?: number
    transactionMethod?: string | null
    firstMethodAmount?: number | null
    secondMethodAmount?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    costItem?: CostItemCreateNestedOneWithoutSuppliersInput
    pendingCostItem?: PendingCostItemCreateNestedOneWithoutSuppliersInput
    settlements?: SupplierPaymentSettlementCreateNestedManyWithoutCostItemSupplierInput
    paidByCreditNoteUsage?: CreditNoteUsageCreateNestedManyWithoutUsedOnCostItemSupplierInput
  }

  export type CostItemSupplierUncheckedCreateInput = {
    id?: number
    costItemId?: number | null
    pendingCostItemId?: number | null
    supplier: $Enums.Suppliers
    amount: number
    paymentMethod?: string
    paidAmount?: number
    pendingAmount?: number
    transactionMethod?: string | null
    firstMethodAmount?: number | null
    secondMethodAmount?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    settlements?: SupplierPaymentSettlementUncheckedCreateNestedManyWithoutCostItemSupplierInput
    paidByCreditNoteUsage?: CreditNoteUsageUncheckedCreateNestedManyWithoutUsedOnCostItemSupplierInput
  }

  export type CostItemSupplierUpdateInput = {
    supplier?: EnumSuppliersFieldUpdateOperationsInput | $Enums.Suppliers
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: StringFieldUpdateOperationsInput | string
    paidAmount?: FloatFieldUpdateOperationsInput | number
    pendingAmount?: FloatFieldUpdateOperationsInput | number
    transactionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    firstMethodAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    secondMethodAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    costItem?: CostItemUpdateOneWithoutSuppliersNestedInput
    pendingCostItem?: PendingCostItemUpdateOneWithoutSuppliersNestedInput
    settlements?: SupplierPaymentSettlementUpdateManyWithoutCostItemSupplierNestedInput
    paidByCreditNoteUsage?: CreditNoteUsageUpdateManyWithoutUsedOnCostItemSupplierNestedInput
  }

  export type CostItemSupplierUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    costItemId?: NullableIntFieldUpdateOperationsInput | number | null
    pendingCostItemId?: NullableIntFieldUpdateOperationsInput | number | null
    supplier?: EnumSuppliersFieldUpdateOperationsInput | $Enums.Suppliers
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: StringFieldUpdateOperationsInput | string
    paidAmount?: FloatFieldUpdateOperationsInput | number
    pendingAmount?: FloatFieldUpdateOperationsInput | number
    transactionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    firstMethodAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    secondMethodAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settlements?: SupplierPaymentSettlementUncheckedUpdateManyWithoutCostItemSupplierNestedInput
    paidByCreditNoteUsage?: CreditNoteUsageUncheckedUpdateManyWithoutUsedOnCostItemSupplierNestedInput
  }

  export type CostItemSupplierCreateManyInput = {
    id?: number
    costItemId?: number | null
    pendingCostItemId?: number | null
    supplier: $Enums.Suppliers
    amount: number
    paymentMethod?: string
    paidAmount?: number
    pendingAmount?: number
    transactionMethod?: string | null
    firstMethodAmount?: number | null
    secondMethodAmount?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CostItemSupplierUpdateManyMutationInput = {
    supplier?: EnumSuppliersFieldUpdateOperationsInput | $Enums.Suppliers
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: StringFieldUpdateOperationsInput | string
    paidAmount?: FloatFieldUpdateOperationsInput | number
    pendingAmount?: FloatFieldUpdateOperationsInput | number
    transactionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    firstMethodAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    secondMethodAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CostItemSupplierUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    costItemId?: NullableIntFieldUpdateOperationsInput | number | null
    pendingCostItemId?: NullableIntFieldUpdateOperationsInput | number | null
    supplier?: EnumSuppliersFieldUpdateOperationsInput | $Enums.Suppliers
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: StringFieldUpdateOperationsInput | string
    paidAmount?: FloatFieldUpdateOperationsInput | number
    pendingAmount?: FloatFieldUpdateOperationsInput | number
    transactionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    firstMethodAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    secondMethodAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierPaymentSettlementCreateInput = {
    amount: number
    transactionMethod: string
    settlementDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    costItemSupplier: CostItemSupplierCreateNestedOneWithoutSettlementsInput
  }

  export type SupplierPaymentSettlementUncheckedCreateInput = {
    id?: number
    costItemSupplierId: number
    amount: number
    transactionMethod: string
    settlementDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupplierPaymentSettlementUpdateInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    transactionMethod?: StringFieldUpdateOperationsInput | string
    settlementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    costItemSupplier?: CostItemSupplierUpdateOneRequiredWithoutSettlementsNestedInput
  }

  export type SupplierPaymentSettlementUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    costItemSupplierId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    transactionMethod?: StringFieldUpdateOperationsInput | string
    settlementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierPaymentSettlementCreateManyInput = {
    id?: number
    costItemSupplierId: number
    amount: number
    transactionMethod: string
    settlementDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupplierPaymentSettlementUpdateManyMutationInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    transactionMethod?: StringFieldUpdateOperationsInput | string
    settlementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierPaymentSettlementUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    costItemSupplierId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    transactionMethod?: StringFieldUpdateOperationsInput | string
    settlementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CancellationCreateInput = {
    folderNo: string
    refundTransactionMethod: string
    originalRevenue: number
    originalProdCost: number
    supplierCancellationFee: number
    refundToPassenger: number
    adminFee?: number
    refundStatus?: string
    creditNoteAmount?: number | null
    profitOrLoss: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    originalBooking: BookingCreateNestedOneWithoutCancellationInput
    refundPayment?: PassengerRefundPaymentCreateNestedOneWithoutCancellationInput
    createdCustomerPayable?: CustomerPayableCreateNestedOneWithoutCreatedFromCancellationInput
    createdPayable?: SupplierPayableCreateNestedOneWithoutCreatedFromCancellationInput
    generatedCreditNote?: SupplierCreditNoteCreateNestedOneWithoutGeneratedFromCancellationInput
  }

  export type CancellationUncheckedCreateInput = {
    id?: number
    originalBookingId: number
    folderNo: string
    refundTransactionMethod: string
    originalRevenue: number
    originalProdCost: number
    supplierCancellationFee: number
    refundToPassenger: number
    adminFee?: number
    refundStatus?: string
    creditNoteAmount?: number | null
    profitOrLoss: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    refundPayment?: PassengerRefundPaymentUncheckedCreateNestedOneWithoutCancellationInput
    createdCustomerPayable?: CustomerPayableUncheckedCreateNestedOneWithoutCreatedFromCancellationInput
    createdPayable?: SupplierPayableUncheckedCreateNestedOneWithoutCreatedFromCancellationInput
    generatedCreditNote?: SupplierCreditNoteUncheckedCreateNestedOneWithoutGeneratedFromCancellationInput
  }

  export type CancellationUpdateInput = {
    folderNo?: StringFieldUpdateOperationsInput | string
    refundTransactionMethod?: StringFieldUpdateOperationsInput | string
    originalRevenue?: FloatFieldUpdateOperationsInput | number
    originalProdCost?: FloatFieldUpdateOperationsInput | number
    supplierCancellationFee?: FloatFieldUpdateOperationsInput | number
    refundToPassenger?: FloatFieldUpdateOperationsInput | number
    adminFee?: FloatFieldUpdateOperationsInput | number
    refundStatus?: StringFieldUpdateOperationsInput | string
    creditNoteAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    profitOrLoss?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    originalBooking?: BookingUpdateOneRequiredWithoutCancellationNestedInput
    refundPayment?: PassengerRefundPaymentUpdateOneWithoutCancellationNestedInput
    createdCustomerPayable?: CustomerPayableUpdateOneWithoutCreatedFromCancellationNestedInput
    createdPayable?: SupplierPayableUpdateOneWithoutCreatedFromCancellationNestedInput
    generatedCreditNote?: SupplierCreditNoteUpdateOneWithoutGeneratedFromCancellationNestedInput
  }

  export type CancellationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    originalBookingId?: IntFieldUpdateOperationsInput | number
    folderNo?: StringFieldUpdateOperationsInput | string
    refundTransactionMethod?: StringFieldUpdateOperationsInput | string
    originalRevenue?: FloatFieldUpdateOperationsInput | number
    originalProdCost?: FloatFieldUpdateOperationsInput | number
    supplierCancellationFee?: FloatFieldUpdateOperationsInput | number
    refundToPassenger?: FloatFieldUpdateOperationsInput | number
    adminFee?: FloatFieldUpdateOperationsInput | number
    refundStatus?: StringFieldUpdateOperationsInput | string
    creditNoteAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    profitOrLoss?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refundPayment?: PassengerRefundPaymentUncheckedUpdateOneWithoutCancellationNestedInput
    createdCustomerPayable?: CustomerPayableUncheckedUpdateOneWithoutCreatedFromCancellationNestedInput
    createdPayable?: SupplierPayableUncheckedUpdateOneWithoutCreatedFromCancellationNestedInput
    generatedCreditNote?: SupplierCreditNoteUncheckedUpdateOneWithoutGeneratedFromCancellationNestedInput
  }

  export type CancellationCreateManyInput = {
    id?: number
    originalBookingId: number
    folderNo: string
    refundTransactionMethod: string
    originalRevenue: number
    originalProdCost: number
    supplierCancellationFee: number
    refundToPassenger: number
    adminFee?: number
    refundStatus?: string
    creditNoteAmount?: number | null
    profitOrLoss: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CancellationUpdateManyMutationInput = {
    folderNo?: StringFieldUpdateOperationsInput | string
    refundTransactionMethod?: StringFieldUpdateOperationsInput | string
    originalRevenue?: FloatFieldUpdateOperationsInput | number
    originalProdCost?: FloatFieldUpdateOperationsInput | number
    supplierCancellationFee?: FloatFieldUpdateOperationsInput | number
    refundToPassenger?: FloatFieldUpdateOperationsInput | number
    adminFee?: FloatFieldUpdateOperationsInput | number
    refundStatus?: StringFieldUpdateOperationsInput | string
    creditNoteAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    profitOrLoss?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CancellationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    originalBookingId?: IntFieldUpdateOperationsInput | number
    folderNo?: StringFieldUpdateOperationsInput | string
    refundTransactionMethod?: StringFieldUpdateOperationsInput | string
    originalRevenue?: FloatFieldUpdateOperationsInput | number
    originalProdCost?: FloatFieldUpdateOperationsInput | number
    supplierCancellationFee?: FloatFieldUpdateOperationsInput | number
    refundToPassenger?: FloatFieldUpdateOperationsInput | number
    adminFee?: FloatFieldUpdateOperationsInput | number
    refundStatus?: StringFieldUpdateOperationsInput | string
    creditNoteAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    profitOrLoss?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierCreditNoteCreateInput = {
    supplier: $Enums.Suppliers
    initialAmount: number
    remainingAmount: number
    status?: $Enums.CreditNoteStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    generatedFromCancellation: CancellationCreateNestedOneWithoutGeneratedCreditNoteInput
    usageHistory?: CreditNoteUsageCreateNestedManyWithoutCreditNoteInput
  }

  export type SupplierCreditNoteUncheckedCreateInput = {
    id?: number
    supplier: $Enums.Suppliers
    initialAmount: number
    remainingAmount: number
    status?: $Enums.CreditNoteStatus
    generatedFromCancellationId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    usageHistory?: CreditNoteUsageUncheckedCreateNestedManyWithoutCreditNoteInput
  }

  export type SupplierCreditNoteUpdateInput = {
    supplier?: EnumSuppliersFieldUpdateOperationsInput | $Enums.Suppliers
    initialAmount?: FloatFieldUpdateOperationsInput | number
    remainingAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumCreditNoteStatusFieldUpdateOperationsInput | $Enums.CreditNoteStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    generatedFromCancellation?: CancellationUpdateOneRequiredWithoutGeneratedCreditNoteNestedInput
    usageHistory?: CreditNoteUsageUpdateManyWithoutCreditNoteNestedInput
  }

  export type SupplierCreditNoteUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplier?: EnumSuppliersFieldUpdateOperationsInput | $Enums.Suppliers
    initialAmount?: FloatFieldUpdateOperationsInput | number
    remainingAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumCreditNoteStatusFieldUpdateOperationsInput | $Enums.CreditNoteStatus
    generatedFromCancellationId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usageHistory?: CreditNoteUsageUncheckedUpdateManyWithoutCreditNoteNestedInput
  }

  export type SupplierCreditNoteCreateManyInput = {
    id?: number
    supplier: $Enums.Suppliers
    initialAmount: number
    remainingAmount: number
    status?: $Enums.CreditNoteStatus
    generatedFromCancellationId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupplierCreditNoteUpdateManyMutationInput = {
    supplier?: EnumSuppliersFieldUpdateOperationsInput | $Enums.Suppliers
    initialAmount?: FloatFieldUpdateOperationsInput | number
    remainingAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumCreditNoteStatusFieldUpdateOperationsInput | $Enums.CreditNoteStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierCreditNoteUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplier?: EnumSuppliersFieldUpdateOperationsInput | $Enums.Suppliers
    initialAmount?: FloatFieldUpdateOperationsInput | number
    remainingAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumCreditNoteStatusFieldUpdateOperationsInput | $Enums.CreditNoteStatus
    generatedFromCancellationId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditNoteUsageCreateInput = {
    amountUsed: number
    usedAt?: Date | string
    creditNote: SupplierCreditNoteCreateNestedOneWithoutUsageHistoryInput
    usedOnCostItemSupplier: CostItemSupplierCreateNestedOneWithoutPaidByCreditNoteUsageInput
  }

  export type CreditNoteUsageUncheckedCreateInput = {
    id?: number
    amountUsed: number
    usedAt?: Date | string
    creditNoteId: number
    usedOnCostItemSupplierId: number
  }

  export type CreditNoteUsageUpdateInput = {
    amountUsed?: FloatFieldUpdateOperationsInput | number
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creditNote?: SupplierCreditNoteUpdateOneRequiredWithoutUsageHistoryNestedInput
    usedOnCostItemSupplier?: CostItemSupplierUpdateOneRequiredWithoutPaidByCreditNoteUsageNestedInput
  }

  export type CreditNoteUsageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    amountUsed?: FloatFieldUpdateOperationsInput | number
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creditNoteId?: IntFieldUpdateOperationsInput | number
    usedOnCostItemSupplierId?: IntFieldUpdateOperationsInput | number
  }

  export type CreditNoteUsageCreateManyInput = {
    id?: number
    amountUsed: number
    usedAt?: Date | string
    creditNoteId: number
    usedOnCostItemSupplierId: number
  }

  export type CreditNoteUsageUpdateManyMutationInput = {
    amountUsed?: FloatFieldUpdateOperationsInput | number
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditNoteUsageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    amountUsed?: FloatFieldUpdateOperationsInput | number
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creditNoteId?: IntFieldUpdateOperationsInput | number
    usedOnCostItemSupplierId?: IntFieldUpdateOperationsInput | number
  }

  export type SupplierPayableCreateInput = {
    supplier: $Enums.Suppliers
    totalAmount: number
    paidAmount?: number
    pendingAmount: number
    reason: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdFromCancellation: CancellationCreateNestedOneWithoutCreatedPayableInput
    settlements?: SupplierPayableSettlementCreateNestedManyWithoutPayableInput
  }

  export type SupplierPayableUncheckedCreateInput = {
    id?: number
    supplier: $Enums.Suppliers
    totalAmount: number
    paidAmount?: number
    pendingAmount: number
    reason: string
    status?: string
    createdFromCancellationId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    settlements?: SupplierPayableSettlementUncheckedCreateNestedManyWithoutPayableInput
  }

  export type SupplierPayableUpdateInput = {
    supplier?: EnumSuppliersFieldUpdateOperationsInput | $Enums.Suppliers
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    pendingAmount?: FloatFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdFromCancellation?: CancellationUpdateOneRequiredWithoutCreatedPayableNestedInput
    settlements?: SupplierPayableSettlementUpdateManyWithoutPayableNestedInput
  }

  export type SupplierPayableUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplier?: EnumSuppliersFieldUpdateOperationsInput | $Enums.Suppliers
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    pendingAmount?: FloatFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdFromCancellationId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settlements?: SupplierPayableSettlementUncheckedUpdateManyWithoutPayableNestedInput
  }

  export type SupplierPayableCreateManyInput = {
    id?: number
    supplier: $Enums.Suppliers
    totalAmount: number
    paidAmount?: number
    pendingAmount: number
    reason: string
    status?: string
    createdFromCancellationId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupplierPayableUpdateManyMutationInput = {
    supplier?: EnumSuppliersFieldUpdateOperationsInput | $Enums.Suppliers
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    pendingAmount?: FloatFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierPayableUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplier?: EnumSuppliersFieldUpdateOperationsInput | $Enums.Suppliers
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    pendingAmount?: FloatFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdFromCancellationId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierPayableSettlementCreateInput = {
    amount: number
    transactionMethod: string
    settlementDate: Date | string
    createdAt?: Date | string
    payable: SupplierPayableCreateNestedOneWithoutSettlementsInput
  }

  export type SupplierPayableSettlementUncheckedCreateInput = {
    id?: number
    supplierPayableId: number
    amount: number
    transactionMethod: string
    settlementDate: Date | string
    createdAt?: Date | string
  }

  export type SupplierPayableSettlementUpdateInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    transactionMethod?: StringFieldUpdateOperationsInput | string
    settlementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payable?: SupplierPayableUpdateOneRequiredWithoutSettlementsNestedInput
  }

  export type SupplierPayableSettlementUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplierPayableId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    transactionMethod?: StringFieldUpdateOperationsInput | string
    settlementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierPayableSettlementCreateManyInput = {
    id?: number
    supplierPayableId: number
    amount: number
    transactionMethod: string
    settlementDate: Date | string
    createdAt?: Date | string
  }

  export type SupplierPayableSettlementUpdateManyMutationInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    transactionMethod?: StringFieldUpdateOperationsInput | string
    settlementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierPayableSettlementUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplierPayableId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    transactionMethod?: StringFieldUpdateOperationsInput | string
    settlementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerPayableCreateInput = {
    totalAmount: number
    paidAmount?: number
    pendingAmount: number
    reason: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    settlements?: CustomerPayableSettlementCreateNestedManyWithoutPayableInput
    createdFromCancellation: CancellationCreateNestedOneWithoutCreatedCustomerPayableInput
    booking: BookingCreateNestedOneWithoutCustomerPayablesInput
  }

  export type CustomerPayableUncheckedCreateInput = {
    id?: number
    totalAmount: number
    paidAmount?: number
    pendingAmount: number
    reason: string
    status?: string
    createdFromCancellationId: number
    bookingId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    settlements?: CustomerPayableSettlementUncheckedCreateNestedManyWithoutPayableInput
  }

  export type CustomerPayableUpdateInput = {
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    pendingAmount?: FloatFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settlements?: CustomerPayableSettlementUpdateManyWithoutPayableNestedInput
    createdFromCancellation?: CancellationUpdateOneRequiredWithoutCreatedCustomerPayableNestedInput
    booking?: BookingUpdateOneRequiredWithoutCustomerPayablesNestedInput
  }

  export type CustomerPayableUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    pendingAmount?: FloatFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdFromCancellationId?: IntFieldUpdateOperationsInput | number
    bookingId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settlements?: CustomerPayableSettlementUncheckedUpdateManyWithoutPayableNestedInput
  }

  export type CustomerPayableCreateManyInput = {
    id?: number
    totalAmount: number
    paidAmount?: number
    pendingAmount: number
    reason: string
    status?: string
    createdFromCancellationId: number
    bookingId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerPayableUpdateManyMutationInput = {
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    pendingAmount?: FloatFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerPayableUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    pendingAmount?: FloatFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdFromCancellationId?: IntFieldUpdateOperationsInput | number
    bookingId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerPayableSettlementCreateInput = {
    amount: number
    transactionMethod: string
    paymentDate: Date | string
    createdAt?: Date | string
    payable: CustomerPayableCreateNestedOneWithoutSettlementsInput
  }

  export type CustomerPayableSettlementUncheckedCreateInput = {
    id?: number
    customerPayableId: number
    amount: number
    transactionMethod: string
    paymentDate: Date | string
    createdAt?: Date | string
  }

  export type CustomerPayableSettlementUpdateInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    transactionMethod?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payable?: CustomerPayableUpdateOneRequiredWithoutSettlementsNestedInput
  }

  export type CustomerPayableSettlementUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerPayableId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    transactionMethod?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerPayableSettlementCreateManyInput = {
    id?: number
    customerPayableId: number
    amount: number
    transactionMethod: string
    paymentDate: Date | string
    createdAt?: Date | string
  }

  export type CustomerPayableSettlementUpdateManyMutationInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    transactionMethod?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerPayableSettlementUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    customerPayableId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    transactionMethod?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PassengerRefundPaymentCreateInput = {
    amount: number
    transactionMethod: string
    refundDate: Date | string
    createdAt?: Date | string
    cancellation: CancellationCreateNestedOneWithoutRefundPaymentInput
  }

  export type PassengerRefundPaymentUncheckedCreateInput = {
    id?: number
    amount: number
    transactionMethod: string
    refundDate: Date | string
    cancellationId: number
    createdAt?: Date | string
  }

  export type PassengerRefundPaymentUpdateInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    transactionMethod?: StringFieldUpdateOperationsInput | string
    refundDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cancellation?: CancellationUpdateOneRequiredWithoutRefundPaymentNestedInput
  }

  export type PassengerRefundPaymentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    transactionMethod?: StringFieldUpdateOperationsInput | string
    refundDate?: DateTimeFieldUpdateOperationsInput | Date | string
    cancellationId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PassengerRefundPaymentCreateManyInput = {
    id?: number
    amount: number
    transactionMethod: string
    refundDate: Date | string
    cancellationId: number
    createdAt?: Date | string
  }

  export type PassengerRefundPaymentUpdateManyMutationInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    transactionMethod?: StringFieldUpdateOperationsInput | string
    refundDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PassengerRefundPaymentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    transactionMethod?: StringFieldUpdateOperationsInput | string
    refundDate?: DateTimeFieldUpdateOperationsInput | Date | string
    cancellationId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateInput = {
    modelName: string
    recordId: number
    action: $Enums.ActionType
    fieldName?: string | null
    oldValue?: string | null
    newValue?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: number
    modelName: string
    recordId: number
    userId: number
    action: $Enums.ActionType
    fieldName?: string | null
    oldValue?: string | null
    newValue?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    modelName?: StringFieldUpdateOperationsInput | string
    recordId?: IntFieldUpdateOperationsInput | number
    action?: EnumActionTypeFieldUpdateOperationsInput | $Enums.ActionType
    fieldName?: NullableStringFieldUpdateOperationsInput | string | null
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    modelName?: StringFieldUpdateOperationsInput | string
    recordId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    action?: EnumActionTypeFieldUpdateOperationsInput | $Enums.ActionType
    fieldName?: NullableStringFieldUpdateOperationsInput | string | null
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: number
    modelName: string
    recordId: number
    userId: number
    action: $Enums.ActionType
    fieldName?: string | null
    oldValue?: string | null
    newValue?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    modelName?: StringFieldUpdateOperationsInput | string
    recordId?: IntFieldUpdateOperationsInput | number
    action?: EnumActionTypeFieldUpdateOperationsInput | $Enums.ActionType
    fieldName?: NullableStringFieldUpdateOperationsInput | string | null
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    modelName?: StringFieldUpdateOperationsInput | string
    recordId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    action?: EnumActionTypeFieldUpdateOperationsInput | $Enums.ActionType
    fieldName?: NullableStringFieldUpdateOperationsInput | string | null
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumTeamsNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Teams | EnumTeamsFieldRefInput<$PrismaModel> | null
    in?: $Enums.Teams[] | ListEnumTeamsFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Teams[] | ListEnumTeamsFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTeamsNullableFilter<$PrismaModel> | $Enums.Teams | null
  }

  export type EnumBookingTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingType | EnumBookingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BookingType[] | ListEnumBookingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingType[] | ListEnumBookingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingTypeFilter<$PrismaModel> | $Enums.BookingType
  }

  export type EnumBookingStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumBookingStatusNullableFilter<$PrismaModel> | $Enums.BookingStatus | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type CostItemListRelationFilter = {
    every?: CostItemWhereInput
    some?: CostItemWhereInput
    none?: CostItemWhereInput
  }

  export type InstalmentListRelationFilter = {
    every?: InstalmentWhereInput
    some?: InstalmentWhereInput
    none?: InstalmentWhereInput
  }

  export type PassengerListRelationFilter = {
    every?: PassengerWhereInput
    some?: PassengerWhereInput
    none?: PassengerWhereInput
  }

  export type BookingNullableScalarRelationFilter = {
    is?: BookingWhereInput | null
    isNot?: BookingWhereInput | null
  }

  export type BookingListRelationFilter = {
    every?: BookingWhereInput
    some?: BookingWhereInput
    none?: BookingWhereInput
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type CustomerPayableListRelationFilter = {
    every?: CustomerPayableWhereInput
    some?: CustomerPayableWhereInput
    none?: CustomerPayableWhereInput
  }

  export type CancellationNullableScalarRelationFilter = {
    is?: CancellationWhereInput | null
    isNot?: CancellationWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type CostItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InstalmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PassengerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BookingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerPayableOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BookingCountOrderByAggregateInput = {
    id?: SortOrder
    folderNo?: SortOrder
    refNo?: SortOrder
    paxName?: SortOrder
    agentName?: SortOrder
    teamName?: SortOrder
    pnr?: SortOrder
    airline?: SortOrder
    fromTo?: SortOrder
    bookingType?: SortOrder
    bookingStatus?: SortOrder
    pcDate?: SortOrder
    issuedDate?: SortOrder
    paymentMethod?: SortOrder
    lastPaymentDate?: SortOrder
    travelDate?: SortOrder
    revenue?: SortOrder
    prodCost?: SortOrder
    transFee?: SortOrder
    surcharge?: SortOrder
    received?: SortOrder
    transactionMethod?: SortOrder
    receivedDate?: SortOrder
    balance?: SortOrder
    profit?: SortOrder
    invoiced?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    numPax?: SortOrder
    initialDeposit?: SortOrder
    originalBookingId?: SortOrder
    statusBeforeVoid?: SortOrder
    voidReason?: SortOrder
    voidedAt?: SortOrder
    voidedById?: SortOrder
  }

  export type BookingAvgOrderByAggregateInput = {
    id?: SortOrder
    revenue?: SortOrder
    prodCost?: SortOrder
    transFee?: SortOrder
    surcharge?: SortOrder
    received?: SortOrder
    balance?: SortOrder
    profit?: SortOrder
    numPax?: SortOrder
    initialDeposit?: SortOrder
    originalBookingId?: SortOrder
    voidedById?: SortOrder
  }

  export type BookingMaxOrderByAggregateInput = {
    id?: SortOrder
    folderNo?: SortOrder
    refNo?: SortOrder
    paxName?: SortOrder
    agentName?: SortOrder
    teamName?: SortOrder
    pnr?: SortOrder
    airline?: SortOrder
    fromTo?: SortOrder
    bookingType?: SortOrder
    bookingStatus?: SortOrder
    pcDate?: SortOrder
    issuedDate?: SortOrder
    paymentMethod?: SortOrder
    lastPaymentDate?: SortOrder
    travelDate?: SortOrder
    revenue?: SortOrder
    prodCost?: SortOrder
    transFee?: SortOrder
    surcharge?: SortOrder
    received?: SortOrder
    transactionMethod?: SortOrder
    receivedDate?: SortOrder
    balance?: SortOrder
    profit?: SortOrder
    invoiced?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    numPax?: SortOrder
    initialDeposit?: SortOrder
    originalBookingId?: SortOrder
    statusBeforeVoid?: SortOrder
    voidReason?: SortOrder
    voidedAt?: SortOrder
    voidedById?: SortOrder
  }

  export type BookingMinOrderByAggregateInput = {
    id?: SortOrder
    folderNo?: SortOrder
    refNo?: SortOrder
    paxName?: SortOrder
    agentName?: SortOrder
    teamName?: SortOrder
    pnr?: SortOrder
    airline?: SortOrder
    fromTo?: SortOrder
    bookingType?: SortOrder
    bookingStatus?: SortOrder
    pcDate?: SortOrder
    issuedDate?: SortOrder
    paymentMethod?: SortOrder
    lastPaymentDate?: SortOrder
    travelDate?: SortOrder
    revenue?: SortOrder
    prodCost?: SortOrder
    transFee?: SortOrder
    surcharge?: SortOrder
    received?: SortOrder
    transactionMethod?: SortOrder
    receivedDate?: SortOrder
    balance?: SortOrder
    profit?: SortOrder
    invoiced?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    numPax?: SortOrder
    initialDeposit?: SortOrder
    originalBookingId?: SortOrder
    statusBeforeVoid?: SortOrder
    voidReason?: SortOrder
    voidedAt?: SortOrder
    voidedById?: SortOrder
  }

  export type BookingSumOrderByAggregateInput = {
    id?: SortOrder
    revenue?: SortOrder
    prodCost?: SortOrder
    transFee?: SortOrder
    surcharge?: SortOrder
    received?: SortOrder
    balance?: SortOrder
    profit?: SortOrder
    numPax?: SortOrder
    initialDeposit?: SortOrder
    originalBookingId?: SortOrder
    voidedById?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumTeamsNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Teams | EnumTeamsFieldRefInput<$PrismaModel> | null
    in?: $Enums.Teams[] | ListEnumTeamsFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Teams[] | ListEnumTeamsFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTeamsNullableWithAggregatesFilter<$PrismaModel> | $Enums.Teams | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumTeamsNullableFilter<$PrismaModel>
    _max?: NestedEnumTeamsNullableFilter<$PrismaModel>
  }

  export type EnumBookingTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingType | EnumBookingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BookingType[] | ListEnumBookingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingType[] | ListEnumBookingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingTypeWithAggregatesFilter<$PrismaModel> | $Enums.BookingType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBookingTypeFilter<$PrismaModel>
    _max?: NestedEnumBookingTypeFilter<$PrismaModel>
  }

  export type EnumBookingStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumBookingStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.BookingStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumBookingStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumBookingStatusNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumPendingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PendingStatus | EnumPendingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PendingStatus[] | ListEnumPendingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PendingStatus[] | ListEnumPendingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPendingStatusFilter<$PrismaModel> | $Enums.PendingStatus
  }

  export type PendingCostItemListRelationFilter = {
    every?: PendingCostItemWhereInput
    some?: PendingCostItemWhereInput
    none?: PendingCostItemWhereInput
  }

  export type PendingInstalmentListRelationFilter = {
    every?: PendingInstalmentWhereInput
    some?: PendingInstalmentWhereInput
    none?: PendingInstalmentWhereInput
  }

  export type PendingPassengerListRelationFilter = {
    every?: PendingPassengerWhereInput
    some?: PendingPassengerWhereInput
    none?: PendingPassengerWhereInput
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type PendingCostItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PendingInstalmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PendingPassengerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PendingBookingCountOrderByAggregateInput = {
    id?: SortOrder
    refNo?: SortOrder
    paxName?: SortOrder
    agentName?: SortOrder
    teamName?: SortOrder
    pnr?: SortOrder
    airline?: SortOrder
    fromTo?: SortOrder
    bookingType?: SortOrder
    bookingStatus?: SortOrder
    pcDate?: SortOrder
    issuedDate?: SortOrder
    paymentMethod?: SortOrder
    lastPaymentDate?: SortOrder
    travelDate?: SortOrder
    revenue?: SortOrder
    prodCost?: SortOrder
    transFee?: SortOrder
    surcharge?: SortOrder
    received?: SortOrder
    transactionMethod?: SortOrder
    receivedDate?: SortOrder
    balance?: SortOrder
    profit?: SortOrder
    invoiced?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    numPax?: SortOrder
    createdById?: SortOrder
  }

  export type PendingBookingAvgOrderByAggregateInput = {
    id?: SortOrder
    revenue?: SortOrder
    prodCost?: SortOrder
    transFee?: SortOrder
    surcharge?: SortOrder
    received?: SortOrder
    balance?: SortOrder
    profit?: SortOrder
    numPax?: SortOrder
    createdById?: SortOrder
  }

  export type PendingBookingMaxOrderByAggregateInput = {
    id?: SortOrder
    refNo?: SortOrder
    paxName?: SortOrder
    agentName?: SortOrder
    teamName?: SortOrder
    pnr?: SortOrder
    airline?: SortOrder
    fromTo?: SortOrder
    bookingType?: SortOrder
    bookingStatus?: SortOrder
    pcDate?: SortOrder
    issuedDate?: SortOrder
    paymentMethod?: SortOrder
    lastPaymentDate?: SortOrder
    travelDate?: SortOrder
    revenue?: SortOrder
    prodCost?: SortOrder
    transFee?: SortOrder
    surcharge?: SortOrder
    received?: SortOrder
    transactionMethod?: SortOrder
    receivedDate?: SortOrder
    balance?: SortOrder
    profit?: SortOrder
    invoiced?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    numPax?: SortOrder
    createdById?: SortOrder
  }

  export type PendingBookingMinOrderByAggregateInput = {
    id?: SortOrder
    refNo?: SortOrder
    paxName?: SortOrder
    agentName?: SortOrder
    teamName?: SortOrder
    pnr?: SortOrder
    airline?: SortOrder
    fromTo?: SortOrder
    bookingType?: SortOrder
    bookingStatus?: SortOrder
    pcDate?: SortOrder
    issuedDate?: SortOrder
    paymentMethod?: SortOrder
    lastPaymentDate?: SortOrder
    travelDate?: SortOrder
    revenue?: SortOrder
    prodCost?: SortOrder
    transFee?: SortOrder
    surcharge?: SortOrder
    received?: SortOrder
    transactionMethod?: SortOrder
    receivedDate?: SortOrder
    balance?: SortOrder
    profit?: SortOrder
    invoiced?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    numPax?: SortOrder
    createdById?: SortOrder
  }

  export type PendingBookingSumOrderByAggregateInput = {
    id?: SortOrder
    revenue?: SortOrder
    prodCost?: SortOrder
    transFee?: SortOrder
    surcharge?: SortOrder
    received?: SortOrder
    balance?: SortOrder
    profit?: SortOrder
    numPax?: SortOrder
    createdById?: SortOrder
  }

  export type EnumPendingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PendingStatus | EnumPendingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PendingStatus[] | ListEnumPendingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PendingStatus[] | ListEnumPendingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPendingStatusWithAggregatesFilter<$PrismaModel> | $Enums.PendingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPendingStatusFilter<$PrismaModel>
    _max?: NestedEnumPendingStatusFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type BookingScalarRelationFilter = {
    is?: BookingWhereInput
    isNot?: BookingWhereInput
  }

  export type InstalmentPaymentListRelationFilter = {
    every?: InstalmentPaymentWhereInput
    some?: InstalmentPaymentWhereInput
    none?: InstalmentPaymentWhereInput
  }

  export type InstalmentPaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InstalmentCountOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    dueDate?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InstalmentAvgOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    amount?: SortOrder
  }

  export type InstalmentMaxOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    dueDate?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InstalmentMinOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    dueDate?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InstalmentSumOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    amount?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type PendingBookingScalarRelationFilter = {
    is?: PendingBookingWhereInput
    isNot?: PendingBookingWhereInput
  }

  export type PendingInstalmentCountOrderByAggregateInput = {
    id?: SortOrder
    pendingBookingId?: SortOrder
    dueDate?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PendingInstalmentAvgOrderByAggregateInput = {
    id?: SortOrder
    pendingBookingId?: SortOrder
    amount?: SortOrder
  }

  export type PendingInstalmentMaxOrderByAggregateInput = {
    id?: SortOrder
    pendingBookingId?: SortOrder
    dueDate?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PendingInstalmentMinOrderByAggregateInput = {
    id?: SortOrder
    pendingBookingId?: SortOrder
    dueDate?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PendingInstalmentSumOrderByAggregateInput = {
    id?: SortOrder
    pendingBookingId?: SortOrder
    amount?: SortOrder
  }

  export type InstalmentScalarRelationFilter = {
    is?: InstalmentWhereInput
    isNot?: InstalmentWhereInput
  }

  export type InstalmentPaymentCountOrderByAggregateInput = {
    id?: SortOrder
    instalmentId?: SortOrder
    amount?: SortOrder
    transactionMethod?: SortOrder
    paymentDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InstalmentPaymentAvgOrderByAggregateInput = {
    id?: SortOrder
    instalmentId?: SortOrder
    amount?: SortOrder
  }

  export type InstalmentPaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    instalmentId?: SortOrder
    amount?: SortOrder
    transactionMethod?: SortOrder
    paymentDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InstalmentPaymentMinOrderByAggregateInput = {
    id?: SortOrder
    instalmentId?: SortOrder
    amount?: SortOrder
    transactionMethod?: SortOrder
    paymentDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InstalmentPaymentSumOrderByAggregateInput = {
    id?: SortOrder
    instalmentId?: SortOrder
    amount?: SortOrder
  }

  export type EnumTitleNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Title | EnumTitleFieldRefInput<$PrismaModel> | null
    in?: $Enums.Title[] | ListEnumTitleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Title[] | ListEnumTitleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTitleNullableFilter<$PrismaModel> | $Enums.Title | null
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type PendingBookingListRelationFilter = {
    every?: PendingBookingWhereInput
    some?: PendingBookingWhereInput
    none?: PendingBookingWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type PendingBookingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    title?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    contactNo?: SortOrder
    role?: SortOrder
    team?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    title?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    contactNo?: SortOrder
    role?: SortOrder
    team?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    title?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    contactNo?: SortOrder
    role?: SortOrder
    team?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumTitleNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Title | EnumTitleFieldRefInput<$PrismaModel> | null
    in?: $Enums.Title[] | ListEnumTitleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Title[] | ListEnumTitleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTitleNullableWithAggregatesFilter<$PrismaModel> | $Enums.Title | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumTitleNullableFilter<$PrismaModel>
    _max?: NestedEnumTitleNullableFilter<$PrismaModel>
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type CostItemSupplierListRelationFilter = {
    every?: CostItemSupplierWhereInput
    some?: CostItemSupplierWhereInput
    none?: CostItemSupplierWhereInput
  }

  export type CostItemSupplierOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CostItemCountOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    category?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CostItemAvgOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    amount?: SortOrder
  }

  export type CostItemMaxOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    category?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CostItemMinOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    category?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CostItemSumOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    amount?: SortOrder
  }

  export type PendingCostItemCountOrderByAggregateInput = {
    id?: SortOrder
    pendingBookingId?: SortOrder
    category?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PendingCostItemAvgOrderByAggregateInput = {
    id?: SortOrder
    pendingBookingId?: SortOrder
    amount?: SortOrder
  }

  export type PendingCostItemMaxOrderByAggregateInput = {
    id?: SortOrder
    pendingBookingId?: SortOrder
    category?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PendingCostItemMinOrderByAggregateInput = {
    id?: SortOrder
    pendingBookingId?: SortOrder
    category?: SortOrder
    amount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PendingCostItemSumOrderByAggregateInput = {
    id?: SortOrder
    pendingBookingId?: SortOrder
    amount?: SortOrder
  }

  export type EnumTitleFilter<$PrismaModel = never> = {
    equals?: $Enums.Title | EnumTitleFieldRefInput<$PrismaModel>
    in?: $Enums.Title[] | ListEnumTitleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Title[] | ListEnumTitleFieldRefInput<$PrismaModel>
    not?: NestedEnumTitleFilter<$PrismaModel> | $Enums.Title
  }

  export type EnumGenderFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderFilter<$PrismaModel> | $Enums.Gender
  }

  export type EnumPassengerCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.PassengerCategory | EnumPassengerCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.PassengerCategory[] | ListEnumPassengerCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.PassengerCategory[] | ListEnumPassengerCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumPassengerCategoryFilter<$PrismaModel> | $Enums.PassengerCategory
  }

  export type PassengerCountOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    title?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrder
    lastName?: SortOrder
    gender?: SortOrder
    email?: SortOrder
    contactNo?: SortOrder
    nationality?: SortOrder
    birthday?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PassengerAvgOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
  }

  export type PassengerMaxOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    title?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrder
    lastName?: SortOrder
    gender?: SortOrder
    email?: SortOrder
    contactNo?: SortOrder
    nationality?: SortOrder
    birthday?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PassengerMinOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    title?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrder
    lastName?: SortOrder
    gender?: SortOrder
    email?: SortOrder
    contactNo?: SortOrder
    nationality?: SortOrder
    birthday?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PassengerSumOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
  }

  export type EnumTitleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Title | EnumTitleFieldRefInput<$PrismaModel>
    in?: $Enums.Title[] | ListEnumTitleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Title[] | ListEnumTitleFieldRefInput<$PrismaModel>
    not?: NestedEnumTitleWithAggregatesFilter<$PrismaModel> | $Enums.Title
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTitleFilter<$PrismaModel>
    _max?: NestedEnumTitleFilter<$PrismaModel>
  }

  export type EnumGenderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderWithAggregatesFilter<$PrismaModel> | $Enums.Gender
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGenderFilter<$PrismaModel>
    _max?: NestedEnumGenderFilter<$PrismaModel>
  }

  export type EnumPassengerCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PassengerCategory | EnumPassengerCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.PassengerCategory[] | ListEnumPassengerCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.PassengerCategory[] | ListEnumPassengerCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumPassengerCategoryWithAggregatesFilter<$PrismaModel> | $Enums.PassengerCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPassengerCategoryFilter<$PrismaModel>
    _max?: NestedEnumPassengerCategoryFilter<$PrismaModel>
  }

  export type PendingPassengerCountOrderByAggregateInput = {
    id?: SortOrder
    pendingBookingId?: SortOrder
    title?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrder
    lastName?: SortOrder
    gender?: SortOrder
    email?: SortOrder
    contactNo?: SortOrder
    nationality?: SortOrder
    birthday?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PendingPassengerAvgOrderByAggregateInput = {
    id?: SortOrder
    pendingBookingId?: SortOrder
  }

  export type PendingPassengerMaxOrderByAggregateInput = {
    id?: SortOrder
    pendingBookingId?: SortOrder
    title?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrder
    lastName?: SortOrder
    gender?: SortOrder
    email?: SortOrder
    contactNo?: SortOrder
    nationality?: SortOrder
    birthday?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PendingPassengerMinOrderByAggregateInput = {
    id?: SortOrder
    pendingBookingId?: SortOrder
    title?: SortOrder
    firstName?: SortOrder
    middleName?: SortOrder
    lastName?: SortOrder
    gender?: SortOrder
    email?: SortOrder
    contactNo?: SortOrder
    nationality?: SortOrder
    birthday?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PendingPassengerSumOrderByAggregateInput = {
    id?: SortOrder
    pendingBookingId?: SortOrder
  }

  export type EnumSuppliersFilter<$PrismaModel = never> = {
    equals?: $Enums.Suppliers | EnumSuppliersFieldRefInput<$PrismaModel>
    in?: $Enums.Suppliers[] | ListEnumSuppliersFieldRefInput<$PrismaModel>
    notIn?: $Enums.Suppliers[] | ListEnumSuppliersFieldRefInput<$PrismaModel>
    not?: NestedEnumSuppliersFilter<$PrismaModel> | $Enums.Suppliers
  }

  export type CostItemNullableScalarRelationFilter = {
    is?: CostItemWhereInput | null
    isNot?: CostItemWhereInput | null
  }

  export type PendingCostItemNullableScalarRelationFilter = {
    is?: PendingCostItemWhereInput | null
    isNot?: PendingCostItemWhereInput | null
  }

  export type SupplierPaymentSettlementListRelationFilter = {
    every?: SupplierPaymentSettlementWhereInput
    some?: SupplierPaymentSettlementWhereInput
    none?: SupplierPaymentSettlementWhereInput
  }

  export type CreditNoteUsageListRelationFilter = {
    every?: CreditNoteUsageWhereInput
    some?: CreditNoteUsageWhereInput
    none?: CreditNoteUsageWhereInput
  }

  export type SupplierPaymentSettlementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CreditNoteUsageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CostItemSupplierCountOrderByAggregateInput = {
    id?: SortOrder
    costItemId?: SortOrder
    pendingCostItemId?: SortOrder
    supplier?: SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrder
    paidAmount?: SortOrder
    pendingAmount?: SortOrder
    transactionMethod?: SortOrder
    firstMethodAmount?: SortOrder
    secondMethodAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CostItemSupplierAvgOrderByAggregateInput = {
    id?: SortOrder
    costItemId?: SortOrder
    pendingCostItemId?: SortOrder
    amount?: SortOrder
    paidAmount?: SortOrder
    pendingAmount?: SortOrder
    firstMethodAmount?: SortOrder
    secondMethodAmount?: SortOrder
  }

  export type CostItemSupplierMaxOrderByAggregateInput = {
    id?: SortOrder
    costItemId?: SortOrder
    pendingCostItemId?: SortOrder
    supplier?: SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrder
    paidAmount?: SortOrder
    pendingAmount?: SortOrder
    transactionMethod?: SortOrder
    firstMethodAmount?: SortOrder
    secondMethodAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CostItemSupplierMinOrderByAggregateInput = {
    id?: SortOrder
    costItemId?: SortOrder
    pendingCostItemId?: SortOrder
    supplier?: SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrder
    paidAmount?: SortOrder
    pendingAmount?: SortOrder
    transactionMethod?: SortOrder
    firstMethodAmount?: SortOrder
    secondMethodAmount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CostItemSupplierSumOrderByAggregateInput = {
    id?: SortOrder
    costItemId?: SortOrder
    pendingCostItemId?: SortOrder
    amount?: SortOrder
    paidAmount?: SortOrder
    pendingAmount?: SortOrder
    firstMethodAmount?: SortOrder
    secondMethodAmount?: SortOrder
  }

  export type EnumSuppliersWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Suppliers | EnumSuppliersFieldRefInput<$PrismaModel>
    in?: $Enums.Suppliers[] | ListEnumSuppliersFieldRefInput<$PrismaModel>
    notIn?: $Enums.Suppliers[] | ListEnumSuppliersFieldRefInput<$PrismaModel>
    not?: NestedEnumSuppliersWithAggregatesFilter<$PrismaModel> | $Enums.Suppliers
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSuppliersFilter<$PrismaModel>
    _max?: NestedEnumSuppliersFilter<$PrismaModel>
  }

  export type CostItemSupplierScalarRelationFilter = {
    is?: CostItemSupplierWhereInput
    isNot?: CostItemSupplierWhereInput
  }

  export type SupplierPaymentSettlementCountOrderByAggregateInput = {
    id?: SortOrder
    costItemSupplierId?: SortOrder
    amount?: SortOrder
    transactionMethod?: SortOrder
    settlementDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupplierPaymentSettlementAvgOrderByAggregateInput = {
    id?: SortOrder
    costItemSupplierId?: SortOrder
    amount?: SortOrder
  }

  export type SupplierPaymentSettlementMaxOrderByAggregateInput = {
    id?: SortOrder
    costItemSupplierId?: SortOrder
    amount?: SortOrder
    transactionMethod?: SortOrder
    settlementDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupplierPaymentSettlementMinOrderByAggregateInput = {
    id?: SortOrder
    costItemSupplierId?: SortOrder
    amount?: SortOrder
    transactionMethod?: SortOrder
    settlementDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupplierPaymentSettlementSumOrderByAggregateInput = {
    id?: SortOrder
    costItemSupplierId?: SortOrder
    amount?: SortOrder
  }

  export type PassengerRefundPaymentNullableScalarRelationFilter = {
    is?: PassengerRefundPaymentWhereInput | null
    isNot?: PassengerRefundPaymentWhereInput | null
  }

  export type CustomerPayableNullableScalarRelationFilter = {
    is?: CustomerPayableWhereInput | null
    isNot?: CustomerPayableWhereInput | null
  }

  export type SupplierPayableNullableScalarRelationFilter = {
    is?: SupplierPayableWhereInput | null
    isNot?: SupplierPayableWhereInput | null
  }

  export type SupplierCreditNoteNullableScalarRelationFilter = {
    is?: SupplierCreditNoteWhereInput | null
    isNot?: SupplierCreditNoteWhereInput | null
  }

  export type CancellationCountOrderByAggregateInput = {
    id?: SortOrder
    originalBookingId?: SortOrder
    folderNo?: SortOrder
    refundTransactionMethod?: SortOrder
    originalRevenue?: SortOrder
    originalProdCost?: SortOrder
    supplierCancellationFee?: SortOrder
    refundToPassenger?: SortOrder
    adminFee?: SortOrder
    refundStatus?: SortOrder
    creditNoteAmount?: SortOrder
    profitOrLoss?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CancellationAvgOrderByAggregateInput = {
    id?: SortOrder
    originalBookingId?: SortOrder
    originalRevenue?: SortOrder
    originalProdCost?: SortOrder
    supplierCancellationFee?: SortOrder
    refundToPassenger?: SortOrder
    adminFee?: SortOrder
    creditNoteAmount?: SortOrder
    profitOrLoss?: SortOrder
  }

  export type CancellationMaxOrderByAggregateInput = {
    id?: SortOrder
    originalBookingId?: SortOrder
    folderNo?: SortOrder
    refundTransactionMethod?: SortOrder
    originalRevenue?: SortOrder
    originalProdCost?: SortOrder
    supplierCancellationFee?: SortOrder
    refundToPassenger?: SortOrder
    adminFee?: SortOrder
    refundStatus?: SortOrder
    creditNoteAmount?: SortOrder
    profitOrLoss?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CancellationMinOrderByAggregateInput = {
    id?: SortOrder
    originalBookingId?: SortOrder
    folderNo?: SortOrder
    refundTransactionMethod?: SortOrder
    originalRevenue?: SortOrder
    originalProdCost?: SortOrder
    supplierCancellationFee?: SortOrder
    refundToPassenger?: SortOrder
    adminFee?: SortOrder
    refundStatus?: SortOrder
    creditNoteAmount?: SortOrder
    profitOrLoss?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CancellationSumOrderByAggregateInput = {
    id?: SortOrder
    originalBookingId?: SortOrder
    originalRevenue?: SortOrder
    originalProdCost?: SortOrder
    supplierCancellationFee?: SortOrder
    refundToPassenger?: SortOrder
    adminFee?: SortOrder
    creditNoteAmount?: SortOrder
    profitOrLoss?: SortOrder
  }

  export type EnumCreditNoteStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CreditNoteStatus | EnumCreditNoteStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CreditNoteStatus[] | ListEnumCreditNoteStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CreditNoteStatus[] | ListEnumCreditNoteStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCreditNoteStatusFilter<$PrismaModel> | $Enums.CreditNoteStatus
  }

  export type CancellationScalarRelationFilter = {
    is?: CancellationWhereInput
    isNot?: CancellationWhereInput
  }

  export type SupplierCreditNoteCountOrderByAggregateInput = {
    id?: SortOrder
    supplier?: SortOrder
    initialAmount?: SortOrder
    remainingAmount?: SortOrder
    status?: SortOrder
    generatedFromCancellationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupplierCreditNoteAvgOrderByAggregateInput = {
    id?: SortOrder
    initialAmount?: SortOrder
    remainingAmount?: SortOrder
    generatedFromCancellationId?: SortOrder
  }

  export type SupplierCreditNoteMaxOrderByAggregateInput = {
    id?: SortOrder
    supplier?: SortOrder
    initialAmount?: SortOrder
    remainingAmount?: SortOrder
    status?: SortOrder
    generatedFromCancellationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupplierCreditNoteMinOrderByAggregateInput = {
    id?: SortOrder
    supplier?: SortOrder
    initialAmount?: SortOrder
    remainingAmount?: SortOrder
    status?: SortOrder
    generatedFromCancellationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupplierCreditNoteSumOrderByAggregateInput = {
    id?: SortOrder
    initialAmount?: SortOrder
    remainingAmount?: SortOrder
    generatedFromCancellationId?: SortOrder
  }

  export type EnumCreditNoteStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CreditNoteStatus | EnumCreditNoteStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CreditNoteStatus[] | ListEnumCreditNoteStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CreditNoteStatus[] | ListEnumCreditNoteStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCreditNoteStatusWithAggregatesFilter<$PrismaModel> | $Enums.CreditNoteStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCreditNoteStatusFilter<$PrismaModel>
    _max?: NestedEnumCreditNoteStatusFilter<$PrismaModel>
  }

  export type SupplierCreditNoteScalarRelationFilter = {
    is?: SupplierCreditNoteWhereInput
    isNot?: SupplierCreditNoteWhereInput
  }

  export type CreditNoteUsageCountOrderByAggregateInput = {
    id?: SortOrder
    amountUsed?: SortOrder
    usedAt?: SortOrder
    creditNoteId?: SortOrder
    usedOnCostItemSupplierId?: SortOrder
  }

  export type CreditNoteUsageAvgOrderByAggregateInput = {
    id?: SortOrder
    amountUsed?: SortOrder
    creditNoteId?: SortOrder
    usedOnCostItemSupplierId?: SortOrder
  }

  export type CreditNoteUsageMaxOrderByAggregateInput = {
    id?: SortOrder
    amountUsed?: SortOrder
    usedAt?: SortOrder
    creditNoteId?: SortOrder
    usedOnCostItemSupplierId?: SortOrder
  }

  export type CreditNoteUsageMinOrderByAggregateInput = {
    id?: SortOrder
    amountUsed?: SortOrder
    usedAt?: SortOrder
    creditNoteId?: SortOrder
    usedOnCostItemSupplierId?: SortOrder
  }

  export type CreditNoteUsageSumOrderByAggregateInput = {
    id?: SortOrder
    amountUsed?: SortOrder
    creditNoteId?: SortOrder
    usedOnCostItemSupplierId?: SortOrder
  }

  export type SupplierPayableSettlementListRelationFilter = {
    every?: SupplierPayableSettlementWhereInput
    some?: SupplierPayableSettlementWhereInput
    none?: SupplierPayableSettlementWhereInput
  }

  export type SupplierPayableSettlementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SupplierPayableCountOrderByAggregateInput = {
    id?: SortOrder
    supplier?: SortOrder
    totalAmount?: SortOrder
    paidAmount?: SortOrder
    pendingAmount?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    createdFromCancellationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupplierPayableAvgOrderByAggregateInput = {
    id?: SortOrder
    totalAmount?: SortOrder
    paidAmount?: SortOrder
    pendingAmount?: SortOrder
    createdFromCancellationId?: SortOrder
  }

  export type SupplierPayableMaxOrderByAggregateInput = {
    id?: SortOrder
    supplier?: SortOrder
    totalAmount?: SortOrder
    paidAmount?: SortOrder
    pendingAmount?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    createdFromCancellationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupplierPayableMinOrderByAggregateInput = {
    id?: SortOrder
    supplier?: SortOrder
    totalAmount?: SortOrder
    paidAmount?: SortOrder
    pendingAmount?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    createdFromCancellationId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SupplierPayableSumOrderByAggregateInput = {
    id?: SortOrder
    totalAmount?: SortOrder
    paidAmount?: SortOrder
    pendingAmount?: SortOrder
    createdFromCancellationId?: SortOrder
  }

  export type SupplierPayableScalarRelationFilter = {
    is?: SupplierPayableWhereInput
    isNot?: SupplierPayableWhereInput
  }

  export type SupplierPayableSettlementCountOrderByAggregateInput = {
    id?: SortOrder
    supplierPayableId?: SortOrder
    amount?: SortOrder
    transactionMethod?: SortOrder
    settlementDate?: SortOrder
    createdAt?: SortOrder
  }

  export type SupplierPayableSettlementAvgOrderByAggregateInput = {
    id?: SortOrder
    supplierPayableId?: SortOrder
    amount?: SortOrder
  }

  export type SupplierPayableSettlementMaxOrderByAggregateInput = {
    id?: SortOrder
    supplierPayableId?: SortOrder
    amount?: SortOrder
    transactionMethod?: SortOrder
    settlementDate?: SortOrder
    createdAt?: SortOrder
  }

  export type SupplierPayableSettlementMinOrderByAggregateInput = {
    id?: SortOrder
    supplierPayableId?: SortOrder
    amount?: SortOrder
    transactionMethod?: SortOrder
    settlementDate?: SortOrder
    createdAt?: SortOrder
  }

  export type SupplierPayableSettlementSumOrderByAggregateInput = {
    id?: SortOrder
    supplierPayableId?: SortOrder
    amount?: SortOrder
  }

  export type CustomerPayableSettlementListRelationFilter = {
    every?: CustomerPayableSettlementWhereInput
    some?: CustomerPayableSettlementWhereInput
    none?: CustomerPayableSettlementWhereInput
  }

  export type CustomerPayableSettlementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CustomerPayableCountOrderByAggregateInput = {
    id?: SortOrder
    totalAmount?: SortOrder
    paidAmount?: SortOrder
    pendingAmount?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    createdFromCancellationId?: SortOrder
    bookingId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerPayableAvgOrderByAggregateInput = {
    id?: SortOrder
    totalAmount?: SortOrder
    paidAmount?: SortOrder
    pendingAmount?: SortOrder
    createdFromCancellationId?: SortOrder
    bookingId?: SortOrder
  }

  export type CustomerPayableMaxOrderByAggregateInput = {
    id?: SortOrder
    totalAmount?: SortOrder
    paidAmount?: SortOrder
    pendingAmount?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    createdFromCancellationId?: SortOrder
    bookingId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerPayableMinOrderByAggregateInput = {
    id?: SortOrder
    totalAmount?: SortOrder
    paidAmount?: SortOrder
    pendingAmount?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    createdFromCancellationId?: SortOrder
    bookingId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerPayableSumOrderByAggregateInput = {
    id?: SortOrder
    totalAmount?: SortOrder
    paidAmount?: SortOrder
    pendingAmount?: SortOrder
    createdFromCancellationId?: SortOrder
    bookingId?: SortOrder
  }

  export type CustomerPayableScalarRelationFilter = {
    is?: CustomerPayableWhereInput
    isNot?: CustomerPayableWhereInput
  }

  export type CustomerPayableSettlementCountOrderByAggregateInput = {
    id?: SortOrder
    customerPayableId?: SortOrder
    amount?: SortOrder
    transactionMethod?: SortOrder
    paymentDate?: SortOrder
    createdAt?: SortOrder
  }

  export type CustomerPayableSettlementAvgOrderByAggregateInput = {
    id?: SortOrder
    customerPayableId?: SortOrder
    amount?: SortOrder
  }

  export type CustomerPayableSettlementMaxOrderByAggregateInput = {
    id?: SortOrder
    customerPayableId?: SortOrder
    amount?: SortOrder
    transactionMethod?: SortOrder
    paymentDate?: SortOrder
    createdAt?: SortOrder
  }

  export type CustomerPayableSettlementMinOrderByAggregateInput = {
    id?: SortOrder
    customerPayableId?: SortOrder
    amount?: SortOrder
    transactionMethod?: SortOrder
    paymentDate?: SortOrder
    createdAt?: SortOrder
  }

  export type CustomerPayableSettlementSumOrderByAggregateInput = {
    id?: SortOrder
    customerPayableId?: SortOrder
    amount?: SortOrder
  }

  export type PassengerRefundPaymentCountOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    transactionMethod?: SortOrder
    refundDate?: SortOrder
    cancellationId?: SortOrder
    createdAt?: SortOrder
  }

  export type PassengerRefundPaymentAvgOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    cancellationId?: SortOrder
  }

  export type PassengerRefundPaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    transactionMethod?: SortOrder
    refundDate?: SortOrder
    cancellationId?: SortOrder
    createdAt?: SortOrder
  }

  export type PassengerRefundPaymentMinOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    transactionMethod?: SortOrder
    refundDate?: SortOrder
    cancellationId?: SortOrder
    createdAt?: SortOrder
  }

  export type PassengerRefundPaymentSumOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    cancellationId?: SortOrder
  }

  export type EnumActionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ActionType | EnumActionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActionType[] | ListEnumActionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActionType[] | ListEnumActionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActionTypeFilter<$PrismaModel> | $Enums.ActionType
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    modelName?: SortOrder
    recordId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    fieldName?: SortOrder
    oldValue?: SortOrder
    newValue?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogAvgOrderByAggregateInput = {
    id?: SortOrder
    recordId?: SortOrder
    userId?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    modelName?: SortOrder
    recordId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    fieldName?: SortOrder
    oldValue?: SortOrder
    newValue?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    modelName?: SortOrder
    recordId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    fieldName?: SortOrder
    oldValue?: SortOrder
    newValue?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogSumOrderByAggregateInput = {
    id?: SortOrder
    recordId?: SortOrder
    userId?: SortOrder
  }

  export type EnumActionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActionType | EnumActionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActionType[] | ListEnumActionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActionType[] | ListEnumActionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActionTypeWithAggregatesFilter<$PrismaModel> | $Enums.ActionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActionTypeFilter<$PrismaModel>
    _max?: NestedEnumActionTypeFilter<$PrismaModel>
  }

  export type CostItemCreateNestedManyWithoutBookingInput = {
    create?: XOR<CostItemCreateWithoutBookingInput, CostItemUncheckedCreateWithoutBookingInput> | CostItemCreateWithoutBookingInput[] | CostItemUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: CostItemCreateOrConnectWithoutBookingInput | CostItemCreateOrConnectWithoutBookingInput[]
    createMany?: CostItemCreateManyBookingInputEnvelope
    connect?: CostItemWhereUniqueInput | CostItemWhereUniqueInput[]
  }

  export type InstalmentCreateNestedManyWithoutBookingInput = {
    create?: XOR<InstalmentCreateWithoutBookingInput, InstalmentUncheckedCreateWithoutBookingInput> | InstalmentCreateWithoutBookingInput[] | InstalmentUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: InstalmentCreateOrConnectWithoutBookingInput | InstalmentCreateOrConnectWithoutBookingInput[]
    createMany?: InstalmentCreateManyBookingInputEnvelope
    connect?: InstalmentWhereUniqueInput | InstalmentWhereUniqueInput[]
  }

  export type PassengerCreateNestedManyWithoutBookingInput = {
    create?: XOR<PassengerCreateWithoutBookingInput, PassengerUncheckedCreateWithoutBookingInput> | PassengerCreateWithoutBookingInput[] | PassengerUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: PassengerCreateOrConnectWithoutBookingInput | PassengerCreateOrConnectWithoutBookingInput[]
    createMany?: PassengerCreateManyBookingInputEnvelope
    connect?: PassengerWhereUniqueInput | PassengerWhereUniqueInput[]
  }

  export type BookingCreateNestedOneWithoutFollowUpBookingsInput = {
    create?: XOR<BookingCreateWithoutFollowUpBookingsInput, BookingUncheckedCreateWithoutFollowUpBookingsInput>
    connectOrCreate?: BookingCreateOrConnectWithoutFollowUpBookingsInput
    connect?: BookingWhereUniqueInput
  }

  export type BookingCreateNestedManyWithoutOriginalBookingInput = {
    create?: XOR<BookingCreateWithoutOriginalBookingInput, BookingUncheckedCreateWithoutOriginalBookingInput> | BookingCreateWithoutOriginalBookingInput[] | BookingUncheckedCreateWithoutOriginalBookingInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutOriginalBookingInput | BookingCreateOrConnectWithoutOriginalBookingInput[]
    createMany?: BookingCreateManyOriginalBookingInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutVoidedBookingsInput = {
    create?: XOR<UserCreateWithoutVoidedBookingsInput, UserUncheckedCreateWithoutVoidedBookingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutVoidedBookingsInput
    connect?: UserWhereUniqueInput
  }

  export type CustomerPayableCreateNestedManyWithoutBookingInput = {
    create?: XOR<CustomerPayableCreateWithoutBookingInput, CustomerPayableUncheckedCreateWithoutBookingInput> | CustomerPayableCreateWithoutBookingInput[] | CustomerPayableUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: CustomerPayableCreateOrConnectWithoutBookingInput | CustomerPayableCreateOrConnectWithoutBookingInput[]
    createMany?: CustomerPayableCreateManyBookingInputEnvelope
    connect?: CustomerPayableWhereUniqueInput | CustomerPayableWhereUniqueInput[]
  }

  export type CancellationCreateNestedOneWithoutOriginalBookingInput = {
    create?: XOR<CancellationCreateWithoutOriginalBookingInput, CancellationUncheckedCreateWithoutOriginalBookingInput>
    connectOrCreate?: CancellationCreateOrConnectWithoutOriginalBookingInput
    connect?: CancellationWhereUniqueInput
  }

  export type CostItemUncheckedCreateNestedManyWithoutBookingInput = {
    create?: XOR<CostItemCreateWithoutBookingInput, CostItemUncheckedCreateWithoutBookingInput> | CostItemCreateWithoutBookingInput[] | CostItemUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: CostItemCreateOrConnectWithoutBookingInput | CostItemCreateOrConnectWithoutBookingInput[]
    createMany?: CostItemCreateManyBookingInputEnvelope
    connect?: CostItemWhereUniqueInput | CostItemWhereUniqueInput[]
  }

  export type InstalmentUncheckedCreateNestedManyWithoutBookingInput = {
    create?: XOR<InstalmentCreateWithoutBookingInput, InstalmentUncheckedCreateWithoutBookingInput> | InstalmentCreateWithoutBookingInput[] | InstalmentUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: InstalmentCreateOrConnectWithoutBookingInput | InstalmentCreateOrConnectWithoutBookingInput[]
    createMany?: InstalmentCreateManyBookingInputEnvelope
    connect?: InstalmentWhereUniqueInput | InstalmentWhereUniqueInput[]
  }

  export type PassengerUncheckedCreateNestedManyWithoutBookingInput = {
    create?: XOR<PassengerCreateWithoutBookingInput, PassengerUncheckedCreateWithoutBookingInput> | PassengerCreateWithoutBookingInput[] | PassengerUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: PassengerCreateOrConnectWithoutBookingInput | PassengerCreateOrConnectWithoutBookingInput[]
    createMany?: PassengerCreateManyBookingInputEnvelope
    connect?: PassengerWhereUniqueInput | PassengerWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutOriginalBookingInput = {
    create?: XOR<BookingCreateWithoutOriginalBookingInput, BookingUncheckedCreateWithoutOriginalBookingInput> | BookingCreateWithoutOriginalBookingInput[] | BookingUncheckedCreateWithoutOriginalBookingInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutOriginalBookingInput | BookingCreateOrConnectWithoutOriginalBookingInput[]
    createMany?: BookingCreateManyOriginalBookingInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type CustomerPayableUncheckedCreateNestedManyWithoutBookingInput = {
    create?: XOR<CustomerPayableCreateWithoutBookingInput, CustomerPayableUncheckedCreateWithoutBookingInput> | CustomerPayableCreateWithoutBookingInput[] | CustomerPayableUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: CustomerPayableCreateOrConnectWithoutBookingInput | CustomerPayableCreateOrConnectWithoutBookingInput[]
    createMany?: CustomerPayableCreateManyBookingInputEnvelope
    connect?: CustomerPayableWhereUniqueInput | CustomerPayableWhereUniqueInput[]
  }

  export type CancellationUncheckedCreateNestedOneWithoutOriginalBookingInput = {
    create?: XOR<CancellationCreateWithoutOriginalBookingInput, CancellationUncheckedCreateWithoutOriginalBookingInput>
    connectOrCreate?: CancellationCreateOrConnectWithoutOriginalBookingInput
    connect?: CancellationWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableEnumTeamsFieldUpdateOperationsInput = {
    set?: $Enums.Teams | null
  }

  export type EnumBookingTypeFieldUpdateOperationsInput = {
    set?: $Enums.BookingType
  }

  export type NullableEnumBookingStatusFieldUpdateOperationsInput = {
    set?: $Enums.BookingStatus | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EnumPaymentMethodFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMethod
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CostItemUpdateManyWithoutBookingNestedInput = {
    create?: XOR<CostItemCreateWithoutBookingInput, CostItemUncheckedCreateWithoutBookingInput> | CostItemCreateWithoutBookingInput[] | CostItemUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: CostItemCreateOrConnectWithoutBookingInput | CostItemCreateOrConnectWithoutBookingInput[]
    upsert?: CostItemUpsertWithWhereUniqueWithoutBookingInput | CostItemUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: CostItemCreateManyBookingInputEnvelope
    set?: CostItemWhereUniqueInput | CostItemWhereUniqueInput[]
    disconnect?: CostItemWhereUniqueInput | CostItemWhereUniqueInput[]
    delete?: CostItemWhereUniqueInput | CostItemWhereUniqueInput[]
    connect?: CostItemWhereUniqueInput | CostItemWhereUniqueInput[]
    update?: CostItemUpdateWithWhereUniqueWithoutBookingInput | CostItemUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: CostItemUpdateManyWithWhereWithoutBookingInput | CostItemUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: CostItemScalarWhereInput | CostItemScalarWhereInput[]
  }

  export type InstalmentUpdateManyWithoutBookingNestedInput = {
    create?: XOR<InstalmentCreateWithoutBookingInput, InstalmentUncheckedCreateWithoutBookingInput> | InstalmentCreateWithoutBookingInput[] | InstalmentUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: InstalmentCreateOrConnectWithoutBookingInput | InstalmentCreateOrConnectWithoutBookingInput[]
    upsert?: InstalmentUpsertWithWhereUniqueWithoutBookingInput | InstalmentUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: InstalmentCreateManyBookingInputEnvelope
    set?: InstalmentWhereUniqueInput | InstalmentWhereUniqueInput[]
    disconnect?: InstalmentWhereUniqueInput | InstalmentWhereUniqueInput[]
    delete?: InstalmentWhereUniqueInput | InstalmentWhereUniqueInput[]
    connect?: InstalmentWhereUniqueInput | InstalmentWhereUniqueInput[]
    update?: InstalmentUpdateWithWhereUniqueWithoutBookingInput | InstalmentUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: InstalmentUpdateManyWithWhereWithoutBookingInput | InstalmentUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: InstalmentScalarWhereInput | InstalmentScalarWhereInput[]
  }

  export type PassengerUpdateManyWithoutBookingNestedInput = {
    create?: XOR<PassengerCreateWithoutBookingInput, PassengerUncheckedCreateWithoutBookingInput> | PassengerCreateWithoutBookingInput[] | PassengerUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: PassengerCreateOrConnectWithoutBookingInput | PassengerCreateOrConnectWithoutBookingInput[]
    upsert?: PassengerUpsertWithWhereUniqueWithoutBookingInput | PassengerUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: PassengerCreateManyBookingInputEnvelope
    set?: PassengerWhereUniqueInput | PassengerWhereUniqueInput[]
    disconnect?: PassengerWhereUniqueInput | PassengerWhereUniqueInput[]
    delete?: PassengerWhereUniqueInput | PassengerWhereUniqueInput[]
    connect?: PassengerWhereUniqueInput | PassengerWhereUniqueInput[]
    update?: PassengerUpdateWithWhereUniqueWithoutBookingInput | PassengerUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: PassengerUpdateManyWithWhereWithoutBookingInput | PassengerUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: PassengerScalarWhereInput | PassengerScalarWhereInput[]
  }

  export type BookingUpdateOneWithoutFollowUpBookingsNestedInput = {
    create?: XOR<BookingCreateWithoutFollowUpBookingsInput, BookingUncheckedCreateWithoutFollowUpBookingsInput>
    connectOrCreate?: BookingCreateOrConnectWithoutFollowUpBookingsInput
    upsert?: BookingUpsertWithoutFollowUpBookingsInput
    disconnect?: BookingWhereInput | boolean
    delete?: BookingWhereInput | boolean
    connect?: BookingWhereUniqueInput
    update?: XOR<XOR<BookingUpdateToOneWithWhereWithoutFollowUpBookingsInput, BookingUpdateWithoutFollowUpBookingsInput>, BookingUncheckedUpdateWithoutFollowUpBookingsInput>
  }

  export type BookingUpdateManyWithoutOriginalBookingNestedInput = {
    create?: XOR<BookingCreateWithoutOriginalBookingInput, BookingUncheckedCreateWithoutOriginalBookingInput> | BookingCreateWithoutOriginalBookingInput[] | BookingUncheckedCreateWithoutOriginalBookingInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutOriginalBookingInput | BookingCreateOrConnectWithoutOriginalBookingInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutOriginalBookingInput | BookingUpsertWithWhereUniqueWithoutOriginalBookingInput[]
    createMany?: BookingCreateManyOriginalBookingInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutOriginalBookingInput | BookingUpdateWithWhereUniqueWithoutOriginalBookingInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutOriginalBookingInput | BookingUpdateManyWithWhereWithoutOriginalBookingInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type UserUpdateOneWithoutVoidedBookingsNestedInput = {
    create?: XOR<UserCreateWithoutVoidedBookingsInput, UserUncheckedCreateWithoutVoidedBookingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutVoidedBookingsInput
    upsert?: UserUpsertWithoutVoidedBookingsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutVoidedBookingsInput, UserUpdateWithoutVoidedBookingsInput>, UserUncheckedUpdateWithoutVoidedBookingsInput>
  }

  export type CustomerPayableUpdateManyWithoutBookingNestedInput = {
    create?: XOR<CustomerPayableCreateWithoutBookingInput, CustomerPayableUncheckedCreateWithoutBookingInput> | CustomerPayableCreateWithoutBookingInput[] | CustomerPayableUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: CustomerPayableCreateOrConnectWithoutBookingInput | CustomerPayableCreateOrConnectWithoutBookingInput[]
    upsert?: CustomerPayableUpsertWithWhereUniqueWithoutBookingInput | CustomerPayableUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: CustomerPayableCreateManyBookingInputEnvelope
    set?: CustomerPayableWhereUniqueInput | CustomerPayableWhereUniqueInput[]
    disconnect?: CustomerPayableWhereUniqueInput | CustomerPayableWhereUniqueInput[]
    delete?: CustomerPayableWhereUniqueInput | CustomerPayableWhereUniqueInput[]
    connect?: CustomerPayableWhereUniqueInput | CustomerPayableWhereUniqueInput[]
    update?: CustomerPayableUpdateWithWhereUniqueWithoutBookingInput | CustomerPayableUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: CustomerPayableUpdateManyWithWhereWithoutBookingInput | CustomerPayableUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: CustomerPayableScalarWhereInput | CustomerPayableScalarWhereInput[]
  }

  export type CancellationUpdateOneWithoutOriginalBookingNestedInput = {
    create?: XOR<CancellationCreateWithoutOriginalBookingInput, CancellationUncheckedCreateWithoutOriginalBookingInput>
    connectOrCreate?: CancellationCreateOrConnectWithoutOriginalBookingInput
    upsert?: CancellationUpsertWithoutOriginalBookingInput
    disconnect?: CancellationWhereInput | boolean
    delete?: CancellationWhereInput | boolean
    connect?: CancellationWhereUniqueInput
    update?: XOR<XOR<CancellationUpdateToOneWithWhereWithoutOriginalBookingInput, CancellationUpdateWithoutOriginalBookingInput>, CancellationUncheckedUpdateWithoutOriginalBookingInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CostItemUncheckedUpdateManyWithoutBookingNestedInput = {
    create?: XOR<CostItemCreateWithoutBookingInput, CostItemUncheckedCreateWithoutBookingInput> | CostItemCreateWithoutBookingInput[] | CostItemUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: CostItemCreateOrConnectWithoutBookingInput | CostItemCreateOrConnectWithoutBookingInput[]
    upsert?: CostItemUpsertWithWhereUniqueWithoutBookingInput | CostItemUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: CostItemCreateManyBookingInputEnvelope
    set?: CostItemWhereUniqueInput | CostItemWhereUniqueInput[]
    disconnect?: CostItemWhereUniqueInput | CostItemWhereUniqueInput[]
    delete?: CostItemWhereUniqueInput | CostItemWhereUniqueInput[]
    connect?: CostItemWhereUniqueInput | CostItemWhereUniqueInput[]
    update?: CostItemUpdateWithWhereUniqueWithoutBookingInput | CostItemUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: CostItemUpdateManyWithWhereWithoutBookingInput | CostItemUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: CostItemScalarWhereInput | CostItemScalarWhereInput[]
  }

  export type InstalmentUncheckedUpdateManyWithoutBookingNestedInput = {
    create?: XOR<InstalmentCreateWithoutBookingInput, InstalmentUncheckedCreateWithoutBookingInput> | InstalmentCreateWithoutBookingInput[] | InstalmentUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: InstalmentCreateOrConnectWithoutBookingInput | InstalmentCreateOrConnectWithoutBookingInput[]
    upsert?: InstalmentUpsertWithWhereUniqueWithoutBookingInput | InstalmentUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: InstalmentCreateManyBookingInputEnvelope
    set?: InstalmentWhereUniqueInput | InstalmentWhereUniqueInput[]
    disconnect?: InstalmentWhereUniqueInput | InstalmentWhereUniqueInput[]
    delete?: InstalmentWhereUniqueInput | InstalmentWhereUniqueInput[]
    connect?: InstalmentWhereUniqueInput | InstalmentWhereUniqueInput[]
    update?: InstalmentUpdateWithWhereUniqueWithoutBookingInput | InstalmentUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: InstalmentUpdateManyWithWhereWithoutBookingInput | InstalmentUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: InstalmentScalarWhereInput | InstalmentScalarWhereInput[]
  }

  export type PassengerUncheckedUpdateManyWithoutBookingNestedInput = {
    create?: XOR<PassengerCreateWithoutBookingInput, PassengerUncheckedCreateWithoutBookingInput> | PassengerCreateWithoutBookingInput[] | PassengerUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: PassengerCreateOrConnectWithoutBookingInput | PassengerCreateOrConnectWithoutBookingInput[]
    upsert?: PassengerUpsertWithWhereUniqueWithoutBookingInput | PassengerUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: PassengerCreateManyBookingInputEnvelope
    set?: PassengerWhereUniqueInput | PassengerWhereUniqueInput[]
    disconnect?: PassengerWhereUniqueInput | PassengerWhereUniqueInput[]
    delete?: PassengerWhereUniqueInput | PassengerWhereUniqueInput[]
    connect?: PassengerWhereUniqueInput | PassengerWhereUniqueInput[]
    update?: PassengerUpdateWithWhereUniqueWithoutBookingInput | PassengerUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: PassengerUpdateManyWithWhereWithoutBookingInput | PassengerUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: PassengerScalarWhereInput | PassengerScalarWhereInput[]
  }

  export type BookingUncheckedUpdateManyWithoutOriginalBookingNestedInput = {
    create?: XOR<BookingCreateWithoutOriginalBookingInput, BookingUncheckedCreateWithoutOriginalBookingInput> | BookingCreateWithoutOriginalBookingInput[] | BookingUncheckedCreateWithoutOriginalBookingInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutOriginalBookingInput | BookingCreateOrConnectWithoutOriginalBookingInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutOriginalBookingInput | BookingUpsertWithWhereUniqueWithoutOriginalBookingInput[]
    createMany?: BookingCreateManyOriginalBookingInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutOriginalBookingInput | BookingUpdateWithWhereUniqueWithoutOriginalBookingInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutOriginalBookingInput | BookingUpdateManyWithWhereWithoutOriginalBookingInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type CustomerPayableUncheckedUpdateManyWithoutBookingNestedInput = {
    create?: XOR<CustomerPayableCreateWithoutBookingInput, CustomerPayableUncheckedCreateWithoutBookingInput> | CustomerPayableCreateWithoutBookingInput[] | CustomerPayableUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: CustomerPayableCreateOrConnectWithoutBookingInput | CustomerPayableCreateOrConnectWithoutBookingInput[]
    upsert?: CustomerPayableUpsertWithWhereUniqueWithoutBookingInput | CustomerPayableUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: CustomerPayableCreateManyBookingInputEnvelope
    set?: CustomerPayableWhereUniqueInput | CustomerPayableWhereUniqueInput[]
    disconnect?: CustomerPayableWhereUniqueInput | CustomerPayableWhereUniqueInput[]
    delete?: CustomerPayableWhereUniqueInput | CustomerPayableWhereUniqueInput[]
    connect?: CustomerPayableWhereUniqueInput | CustomerPayableWhereUniqueInput[]
    update?: CustomerPayableUpdateWithWhereUniqueWithoutBookingInput | CustomerPayableUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: CustomerPayableUpdateManyWithWhereWithoutBookingInput | CustomerPayableUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: CustomerPayableScalarWhereInput | CustomerPayableScalarWhereInput[]
  }

  export type CancellationUncheckedUpdateOneWithoutOriginalBookingNestedInput = {
    create?: XOR<CancellationCreateWithoutOriginalBookingInput, CancellationUncheckedCreateWithoutOriginalBookingInput>
    connectOrCreate?: CancellationCreateOrConnectWithoutOriginalBookingInput
    upsert?: CancellationUpsertWithoutOriginalBookingInput
    disconnect?: CancellationWhereInput | boolean
    delete?: CancellationWhereInput | boolean
    connect?: CancellationWhereUniqueInput
    update?: XOR<XOR<CancellationUpdateToOneWithWhereWithoutOriginalBookingInput, CancellationUpdateWithoutOriginalBookingInput>, CancellationUncheckedUpdateWithoutOriginalBookingInput>
  }

  export type PendingCostItemCreateNestedManyWithoutPendingBookingInput = {
    create?: XOR<PendingCostItemCreateWithoutPendingBookingInput, PendingCostItemUncheckedCreateWithoutPendingBookingInput> | PendingCostItemCreateWithoutPendingBookingInput[] | PendingCostItemUncheckedCreateWithoutPendingBookingInput[]
    connectOrCreate?: PendingCostItemCreateOrConnectWithoutPendingBookingInput | PendingCostItemCreateOrConnectWithoutPendingBookingInput[]
    createMany?: PendingCostItemCreateManyPendingBookingInputEnvelope
    connect?: PendingCostItemWhereUniqueInput | PendingCostItemWhereUniqueInput[]
  }

  export type PendingInstalmentCreateNestedManyWithoutPendingBookingInput = {
    create?: XOR<PendingInstalmentCreateWithoutPendingBookingInput, PendingInstalmentUncheckedCreateWithoutPendingBookingInput> | PendingInstalmentCreateWithoutPendingBookingInput[] | PendingInstalmentUncheckedCreateWithoutPendingBookingInput[]
    connectOrCreate?: PendingInstalmentCreateOrConnectWithoutPendingBookingInput | PendingInstalmentCreateOrConnectWithoutPendingBookingInput[]
    createMany?: PendingInstalmentCreateManyPendingBookingInputEnvelope
    connect?: PendingInstalmentWhereUniqueInput | PendingInstalmentWhereUniqueInput[]
  }

  export type PendingPassengerCreateNestedManyWithoutPendingBookingInput = {
    create?: XOR<PendingPassengerCreateWithoutPendingBookingInput, PendingPassengerUncheckedCreateWithoutPendingBookingInput> | PendingPassengerCreateWithoutPendingBookingInput[] | PendingPassengerUncheckedCreateWithoutPendingBookingInput[]
    connectOrCreate?: PendingPassengerCreateOrConnectWithoutPendingBookingInput | PendingPassengerCreateOrConnectWithoutPendingBookingInput[]
    createMany?: PendingPassengerCreateManyPendingBookingInputEnvelope
    connect?: PendingPassengerWhereUniqueInput | PendingPassengerWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutCreatedPendingBookingsInput = {
    create?: XOR<UserCreateWithoutCreatedPendingBookingsInput, UserUncheckedCreateWithoutCreatedPendingBookingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedPendingBookingsInput
    connect?: UserWhereUniqueInput
  }

  export type PendingCostItemUncheckedCreateNestedManyWithoutPendingBookingInput = {
    create?: XOR<PendingCostItemCreateWithoutPendingBookingInput, PendingCostItemUncheckedCreateWithoutPendingBookingInput> | PendingCostItemCreateWithoutPendingBookingInput[] | PendingCostItemUncheckedCreateWithoutPendingBookingInput[]
    connectOrCreate?: PendingCostItemCreateOrConnectWithoutPendingBookingInput | PendingCostItemCreateOrConnectWithoutPendingBookingInput[]
    createMany?: PendingCostItemCreateManyPendingBookingInputEnvelope
    connect?: PendingCostItemWhereUniqueInput | PendingCostItemWhereUniqueInput[]
  }

  export type PendingInstalmentUncheckedCreateNestedManyWithoutPendingBookingInput = {
    create?: XOR<PendingInstalmentCreateWithoutPendingBookingInput, PendingInstalmentUncheckedCreateWithoutPendingBookingInput> | PendingInstalmentCreateWithoutPendingBookingInput[] | PendingInstalmentUncheckedCreateWithoutPendingBookingInput[]
    connectOrCreate?: PendingInstalmentCreateOrConnectWithoutPendingBookingInput | PendingInstalmentCreateOrConnectWithoutPendingBookingInput[]
    createMany?: PendingInstalmentCreateManyPendingBookingInputEnvelope
    connect?: PendingInstalmentWhereUniqueInput | PendingInstalmentWhereUniqueInput[]
  }

  export type PendingPassengerUncheckedCreateNestedManyWithoutPendingBookingInput = {
    create?: XOR<PendingPassengerCreateWithoutPendingBookingInput, PendingPassengerUncheckedCreateWithoutPendingBookingInput> | PendingPassengerCreateWithoutPendingBookingInput[] | PendingPassengerUncheckedCreateWithoutPendingBookingInput[]
    connectOrCreate?: PendingPassengerCreateOrConnectWithoutPendingBookingInput | PendingPassengerCreateOrConnectWithoutPendingBookingInput[]
    createMany?: PendingPassengerCreateManyPendingBookingInputEnvelope
    connect?: PendingPassengerWhereUniqueInput | PendingPassengerWhereUniqueInput[]
  }

  export type EnumPendingStatusFieldUpdateOperationsInput = {
    set?: $Enums.PendingStatus
  }

  export type PendingCostItemUpdateManyWithoutPendingBookingNestedInput = {
    create?: XOR<PendingCostItemCreateWithoutPendingBookingInput, PendingCostItemUncheckedCreateWithoutPendingBookingInput> | PendingCostItemCreateWithoutPendingBookingInput[] | PendingCostItemUncheckedCreateWithoutPendingBookingInput[]
    connectOrCreate?: PendingCostItemCreateOrConnectWithoutPendingBookingInput | PendingCostItemCreateOrConnectWithoutPendingBookingInput[]
    upsert?: PendingCostItemUpsertWithWhereUniqueWithoutPendingBookingInput | PendingCostItemUpsertWithWhereUniqueWithoutPendingBookingInput[]
    createMany?: PendingCostItemCreateManyPendingBookingInputEnvelope
    set?: PendingCostItemWhereUniqueInput | PendingCostItemWhereUniqueInput[]
    disconnect?: PendingCostItemWhereUniqueInput | PendingCostItemWhereUniqueInput[]
    delete?: PendingCostItemWhereUniqueInput | PendingCostItemWhereUniqueInput[]
    connect?: PendingCostItemWhereUniqueInput | PendingCostItemWhereUniqueInput[]
    update?: PendingCostItemUpdateWithWhereUniqueWithoutPendingBookingInput | PendingCostItemUpdateWithWhereUniqueWithoutPendingBookingInput[]
    updateMany?: PendingCostItemUpdateManyWithWhereWithoutPendingBookingInput | PendingCostItemUpdateManyWithWhereWithoutPendingBookingInput[]
    deleteMany?: PendingCostItemScalarWhereInput | PendingCostItemScalarWhereInput[]
  }

  export type PendingInstalmentUpdateManyWithoutPendingBookingNestedInput = {
    create?: XOR<PendingInstalmentCreateWithoutPendingBookingInput, PendingInstalmentUncheckedCreateWithoutPendingBookingInput> | PendingInstalmentCreateWithoutPendingBookingInput[] | PendingInstalmentUncheckedCreateWithoutPendingBookingInput[]
    connectOrCreate?: PendingInstalmentCreateOrConnectWithoutPendingBookingInput | PendingInstalmentCreateOrConnectWithoutPendingBookingInput[]
    upsert?: PendingInstalmentUpsertWithWhereUniqueWithoutPendingBookingInput | PendingInstalmentUpsertWithWhereUniqueWithoutPendingBookingInput[]
    createMany?: PendingInstalmentCreateManyPendingBookingInputEnvelope
    set?: PendingInstalmentWhereUniqueInput | PendingInstalmentWhereUniqueInput[]
    disconnect?: PendingInstalmentWhereUniqueInput | PendingInstalmentWhereUniqueInput[]
    delete?: PendingInstalmentWhereUniqueInput | PendingInstalmentWhereUniqueInput[]
    connect?: PendingInstalmentWhereUniqueInput | PendingInstalmentWhereUniqueInput[]
    update?: PendingInstalmentUpdateWithWhereUniqueWithoutPendingBookingInput | PendingInstalmentUpdateWithWhereUniqueWithoutPendingBookingInput[]
    updateMany?: PendingInstalmentUpdateManyWithWhereWithoutPendingBookingInput | PendingInstalmentUpdateManyWithWhereWithoutPendingBookingInput[]
    deleteMany?: PendingInstalmentScalarWhereInput | PendingInstalmentScalarWhereInput[]
  }

  export type PendingPassengerUpdateManyWithoutPendingBookingNestedInput = {
    create?: XOR<PendingPassengerCreateWithoutPendingBookingInput, PendingPassengerUncheckedCreateWithoutPendingBookingInput> | PendingPassengerCreateWithoutPendingBookingInput[] | PendingPassengerUncheckedCreateWithoutPendingBookingInput[]
    connectOrCreate?: PendingPassengerCreateOrConnectWithoutPendingBookingInput | PendingPassengerCreateOrConnectWithoutPendingBookingInput[]
    upsert?: PendingPassengerUpsertWithWhereUniqueWithoutPendingBookingInput | PendingPassengerUpsertWithWhereUniqueWithoutPendingBookingInput[]
    createMany?: PendingPassengerCreateManyPendingBookingInputEnvelope
    set?: PendingPassengerWhereUniqueInput | PendingPassengerWhereUniqueInput[]
    disconnect?: PendingPassengerWhereUniqueInput | PendingPassengerWhereUniqueInput[]
    delete?: PendingPassengerWhereUniqueInput | PendingPassengerWhereUniqueInput[]
    connect?: PendingPassengerWhereUniqueInput | PendingPassengerWhereUniqueInput[]
    update?: PendingPassengerUpdateWithWhereUniqueWithoutPendingBookingInput | PendingPassengerUpdateWithWhereUniqueWithoutPendingBookingInput[]
    updateMany?: PendingPassengerUpdateManyWithWhereWithoutPendingBookingInput | PendingPassengerUpdateManyWithWhereWithoutPendingBookingInput[]
    deleteMany?: PendingPassengerScalarWhereInput | PendingPassengerScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutCreatedPendingBookingsNestedInput = {
    create?: XOR<UserCreateWithoutCreatedPendingBookingsInput, UserUncheckedCreateWithoutCreatedPendingBookingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCreatedPendingBookingsInput
    upsert?: UserUpsertWithoutCreatedPendingBookingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCreatedPendingBookingsInput, UserUpdateWithoutCreatedPendingBookingsInput>, UserUncheckedUpdateWithoutCreatedPendingBookingsInput>
  }

  export type PendingCostItemUncheckedUpdateManyWithoutPendingBookingNestedInput = {
    create?: XOR<PendingCostItemCreateWithoutPendingBookingInput, PendingCostItemUncheckedCreateWithoutPendingBookingInput> | PendingCostItemCreateWithoutPendingBookingInput[] | PendingCostItemUncheckedCreateWithoutPendingBookingInput[]
    connectOrCreate?: PendingCostItemCreateOrConnectWithoutPendingBookingInput | PendingCostItemCreateOrConnectWithoutPendingBookingInput[]
    upsert?: PendingCostItemUpsertWithWhereUniqueWithoutPendingBookingInput | PendingCostItemUpsertWithWhereUniqueWithoutPendingBookingInput[]
    createMany?: PendingCostItemCreateManyPendingBookingInputEnvelope
    set?: PendingCostItemWhereUniqueInput | PendingCostItemWhereUniqueInput[]
    disconnect?: PendingCostItemWhereUniqueInput | PendingCostItemWhereUniqueInput[]
    delete?: PendingCostItemWhereUniqueInput | PendingCostItemWhereUniqueInput[]
    connect?: PendingCostItemWhereUniqueInput | PendingCostItemWhereUniqueInput[]
    update?: PendingCostItemUpdateWithWhereUniqueWithoutPendingBookingInput | PendingCostItemUpdateWithWhereUniqueWithoutPendingBookingInput[]
    updateMany?: PendingCostItemUpdateManyWithWhereWithoutPendingBookingInput | PendingCostItemUpdateManyWithWhereWithoutPendingBookingInput[]
    deleteMany?: PendingCostItemScalarWhereInput | PendingCostItemScalarWhereInput[]
  }

  export type PendingInstalmentUncheckedUpdateManyWithoutPendingBookingNestedInput = {
    create?: XOR<PendingInstalmentCreateWithoutPendingBookingInput, PendingInstalmentUncheckedCreateWithoutPendingBookingInput> | PendingInstalmentCreateWithoutPendingBookingInput[] | PendingInstalmentUncheckedCreateWithoutPendingBookingInput[]
    connectOrCreate?: PendingInstalmentCreateOrConnectWithoutPendingBookingInput | PendingInstalmentCreateOrConnectWithoutPendingBookingInput[]
    upsert?: PendingInstalmentUpsertWithWhereUniqueWithoutPendingBookingInput | PendingInstalmentUpsertWithWhereUniqueWithoutPendingBookingInput[]
    createMany?: PendingInstalmentCreateManyPendingBookingInputEnvelope
    set?: PendingInstalmentWhereUniqueInput | PendingInstalmentWhereUniqueInput[]
    disconnect?: PendingInstalmentWhereUniqueInput | PendingInstalmentWhereUniqueInput[]
    delete?: PendingInstalmentWhereUniqueInput | PendingInstalmentWhereUniqueInput[]
    connect?: PendingInstalmentWhereUniqueInput | PendingInstalmentWhereUniqueInput[]
    update?: PendingInstalmentUpdateWithWhereUniqueWithoutPendingBookingInput | PendingInstalmentUpdateWithWhereUniqueWithoutPendingBookingInput[]
    updateMany?: PendingInstalmentUpdateManyWithWhereWithoutPendingBookingInput | PendingInstalmentUpdateManyWithWhereWithoutPendingBookingInput[]
    deleteMany?: PendingInstalmentScalarWhereInput | PendingInstalmentScalarWhereInput[]
  }

  export type PendingPassengerUncheckedUpdateManyWithoutPendingBookingNestedInput = {
    create?: XOR<PendingPassengerCreateWithoutPendingBookingInput, PendingPassengerUncheckedCreateWithoutPendingBookingInput> | PendingPassengerCreateWithoutPendingBookingInput[] | PendingPassengerUncheckedCreateWithoutPendingBookingInput[]
    connectOrCreate?: PendingPassengerCreateOrConnectWithoutPendingBookingInput | PendingPassengerCreateOrConnectWithoutPendingBookingInput[]
    upsert?: PendingPassengerUpsertWithWhereUniqueWithoutPendingBookingInput | PendingPassengerUpsertWithWhereUniqueWithoutPendingBookingInput[]
    createMany?: PendingPassengerCreateManyPendingBookingInputEnvelope
    set?: PendingPassengerWhereUniqueInput | PendingPassengerWhereUniqueInput[]
    disconnect?: PendingPassengerWhereUniqueInput | PendingPassengerWhereUniqueInput[]
    delete?: PendingPassengerWhereUniqueInput | PendingPassengerWhereUniqueInput[]
    connect?: PendingPassengerWhereUniqueInput | PendingPassengerWhereUniqueInput[]
    update?: PendingPassengerUpdateWithWhereUniqueWithoutPendingBookingInput | PendingPassengerUpdateWithWhereUniqueWithoutPendingBookingInput[]
    updateMany?: PendingPassengerUpdateManyWithWhereWithoutPendingBookingInput | PendingPassengerUpdateManyWithWhereWithoutPendingBookingInput[]
    deleteMany?: PendingPassengerScalarWhereInput | PendingPassengerScalarWhereInput[]
  }

  export type BookingCreateNestedOneWithoutInstalmentsInput = {
    create?: XOR<BookingCreateWithoutInstalmentsInput, BookingUncheckedCreateWithoutInstalmentsInput>
    connectOrCreate?: BookingCreateOrConnectWithoutInstalmentsInput
    connect?: BookingWhereUniqueInput
  }

  export type InstalmentPaymentCreateNestedManyWithoutInstalmentInput = {
    create?: XOR<InstalmentPaymentCreateWithoutInstalmentInput, InstalmentPaymentUncheckedCreateWithoutInstalmentInput> | InstalmentPaymentCreateWithoutInstalmentInput[] | InstalmentPaymentUncheckedCreateWithoutInstalmentInput[]
    connectOrCreate?: InstalmentPaymentCreateOrConnectWithoutInstalmentInput | InstalmentPaymentCreateOrConnectWithoutInstalmentInput[]
    createMany?: InstalmentPaymentCreateManyInstalmentInputEnvelope
    connect?: InstalmentPaymentWhereUniqueInput | InstalmentPaymentWhereUniqueInput[]
  }

  export type InstalmentPaymentUncheckedCreateNestedManyWithoutInstalmentInput = {
    create?: XOR<InstalmentPaymentCreateWithoutInstalmentInput, InstalmentPaymentUncheckedCreateWithoutInstalmentInput> | InstalmentPaymentCreateWithoutInstalmentInput[] | InstalmentPaymentUncheckedCreateWithoutInstalmentInput[]
    connectOrCreate?: InstalmentPaymentCreateOrConnectWithoutInstalmentInput | InstalmentPaymentCreateOrConnectWithoutInstalmentInput[]
    createMany?: InstalmentPaymentCreateManyInstalmentInputEnvelope
    connect?: InstalmentPaymentWhereUniqueInput | InstalmentPaymentWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BookingUpdateOneRequiredWithoutInstalmentsNestedInput = {
    create?: XOR<BookingCreateWithoutInstalmentsInput, BookingUncheckedCreateWithoutInstalmentsInput>
    connectOrCreate?: BookingCreateOrConnectWithoutInstalmentsInput
    upsert?: BookingUpsertWithoutInstalmentsInput
    connect?: BookingWhereUniqueInput
    update?: XOR<XOR<BookingUpdateToOneWithWhereWithoutInstalmentsInput, BookingUpdateWithoutInstalmentsInput>, BookingUncheckedUpdateWithoutInstalmentsInput>
  }

  export type InstalmentPaymentUpdateManyWithoutInstalmentNestedInput = {
    create?: XOR<InstalmentPaymentCreateWithoutInstalmentInput, InstalmentPaymentUncheckedCreateWithoutInstalmentInput> | InstalmentPaymentCreateWithoutInstalmentInput[] | InstalmentPaymentUncheckedCreateWithoutInstalmentInput[]
    connectOrCreate?: InstalmentPaymentCreateOrConnectWithoutInstalmentInput | InstalmentPaymentCreateOrConnectWithoutInstalmentInput[]
    upsert?: InstalmentPaymentUpsertWithWhereUniqueWithoutInstalmentInput | InstalmentPaymentUpsertWithWhereUniqueWithoutInstalmentInput[]
    createMany?: InstalmentPaymentCreateManyInstalmentInputEnvelope
    set?: InstalmentPaymentWhereUniqueInput | InstalmentPaymentWhereUniqueInput[]
    disconnect?: InstalmentPaymentWhereUniqueInput | InstalmentPaymentWhereUniqueInput[]
    delete?: InstalmentPaymentWhereUniqueInput | InstalmentPaymentWhereUniqueInput[]
    connect?: InstalmentPaymentWhereUniqueInput | InstalmentPaymentWhereUniqueInput[]
    update?: InstalmentPaymentUpdateWithWhereUniqueWithoutInstalmentInput | InstalmentPaymentUpdateWithWhereUniqueWithoutInstalmentInput[]
    updateMany?: InstalmentPaymentUpdateManyWithWhereWithoutInstalmentInput | InstalmentPaymentUpdateManyWithWhereWithoutInstalmentInput[]
    deleteMany?: InstalmentPaymentScalarWhereInput | InstalmentPaymentScalarWhereInput[]
  }

  export type InstalmentPaymentUncheckedUpdateManyWithoutInstalmentNestedInput = {
    create?: XOR<InstalmentPaymentCreateWithoutInstalmentInput, InstalmentPaymentUncheckedCreateWithoutInstalmentInput> | InstalmentPaymentCreateWithoutInstalmentInput[] | InstalmentPaymentUncheckedCreateWithoutInstalmentInput[]
    connectOrCreate?: InstalmentPaymentCreateOrConnectWithoutInstalmentInput | InstalmentPaymentCreateOrConnectWithoutInstalmentInput[]
    upsert?: InstalmentPaymentUpsertWithWhereUniqueWithoutInstalmentInput | InstalmentPaymentUpsertWithWhereUniqueWithoutInstalmentInput[]
    createMany?: InstalmentPaymentCreateManyInstalmentInputEnvelope
    set?: InstalmentPaymentWhereUniqueInput | InstalmentPaymentWhereUniqueInput[]
    disconnect?: InstalmentPaymentWhereUniqueInput | InstalmentPaymentWhereUniqueInput[]
    delete?: InstalmentPaymentWhereUniqueInput | InstalmentPaymentWhereUniqueInput[]
    connect?: InstalmentPaymentWhereUniqueInput | InstalmentPaymentWhereUniqueInput[]
    update?: InstalmentPaymentUpdateWithWhereUniqueWithoutInstalmentInput | InstalmentPaymentUpdateWithWhereUniqueWithoutInstalmentInput[]
    updateMany?: InstalmentPaymentUpdateManyWithWhereWithoutInstalmentInput | InstalmentPaymentUpdateManyWithWhereWithoutInstalmentInput[]
    deleteMany?: InstalmentPaymentScalarWhereInput | InstalmentPaymentScalarWhereInput[]
  }

  export type PendingBookingCreateNestedOneWithoutInstalmentsInput = {
    create?: XOR<PendingBookingCreateWithoutInstalmentsInput, PendingBookingUncheckedCreateWithoutInstalmentsInput>
    connectOrCreate?: PendingBookingCreateOrConnectWithoutInstalmentsInput
    connect?: PendingBookingWhereUniqueInput
  }

  export type PendingBookingUpdateOneRequiredWithoutInstalmentsNestedInput = {
    create?: XOR<PendingBookingCreateWithoutInstalmentsInput, PendingBookingUncheckedCreateWithoutInstalmentsInput>
    connectOrCreate?: PendingBookingCreateOrConnectWithoutInstalmentsInput
    upsert?: PendingBookingUpsertWithoutInstalmentsInput
    connect?: PendingBookingWhereUniqueInput
    update?: XOR<XOR<PendingBookingUpdateToOneWithWhereWithoutInstalmentsInput, PendingBookingUpdateWithoutInstalmentsInput>, PendingBookingUncheckedUpdateWithoutInstalmentsInput>
  }

  export type InstalmentCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<InstalmentCreateWithoutPaymentsInput, InstalmentUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: InstalmentCreateOrConnectWithoutPaymentsInput
    connect?: InstalmentWhereUniqueInput
  }

  export type InstalmentUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<InstalmentCreateWithoutPaymentsInput, InstalmentUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: InstalmentCreateOrConnectWithoutPaymentsInput
    upsert?: InstalmentUpsertWithoutPaymentsInput
    connect?: InstalmentWhereUniqueInput
    update?: XOR<XOR<InstalmentUpdateToOneWithWhereWithoutPaymentsInput, InstalmentUpdateWithoutPaymentsInput>, InstalmentUncheckedUpdateWithoutPaymentsInput>
  }

  export type PendingBookingCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<PendingBookingCreateWithoutCreatedByInput, PendingBookingUncheckedCreateWithoutCreatedByInput> | PendingBookingCreateWithoutCreatedByInput[] | PendingBookingUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: PendingBookingCreateOrConnectWithoutCreatedByInput | PendingBookingCreateOrConnectWithoutCreatedByInput[]
    createMany?: PendingBookingCreateManyCreatedByInputEnvelope
    connect?: PendingBookingWhereUniqueInput | PendingBookingWhereUniqueInput[]
  }

  export type BookingCreateNestedManyWithoutVoidedByInput = {
    create?: XOR<BookingCreateWithoutVoidedByInput, BookingUncheckedCreateWithoutVoidedByInput> | BookingCreateWithoutVoidedByInput[] | BookingUncheckedCreateWithoutVoidedByInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutVoidedByInput | BookingCreateOrConnectWithoutVoidedByInput[]
    createMany?: BookingCreateManyVoidedByInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type PendingBookingUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<PendingBookingCreateWithoutCreatedByInput, PendingBookingUncheckedCreateWithoutCreatedByInput> | PendingBookingCreateWithoutCreatedByInput[] | PendingBookingUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: PendingBookingCreateOrConnectWithoutCreatedByInput | PendingBookingCreateOrConnectWithoutCreatedByInput[]
    createMany?: PendingBookingCreateManyCreatedByInputEnvelope
    connect?: PendingBookingWhereUniqueInput | PendingBookingWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutVoidedByInput = {
    create?: XOR<BookingCreateWithoutVoidedByInput, BookingUncheckedCreateWithoutVoidedByInput> | BookingCreateWithoutVoidedByInput[] | BookingUncheckedCreateWithoutVoidedByInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutVoidedByInput | BookingCreateOrConnectWithoutVoidedByInput[]
    createMany?: BookingCreateManyVoidedByInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type NullableEnumTitleFieldUpdateOperationsInput = {
    set?: $Enums.Title | null
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type PendingBookingUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<PendingBookingCreateWithoutCreatedByInput, PendingBookingUncheckedCreateWithoutCreatedByInput> | PendingBookingCreateWithoutCreatedByInput[] | PendingBookingUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: PendingBookingCreateOrConnectWithoutCreatedByInput | PendingBookingCreateOrConnectWithoutCreatedByInput[]
    upsert?: PendingBookingUpsertWithWhereUniqueWithoutCreatedByInput | PendingBookingUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: PendingBookingCreateManyCreatedByInputEnvelope
    set?: PendingBookingWhereUniqueInput | PendingBookingWhereUniqueInput[]
    disconnect?: PendingBookingWhereUniqueInput | PendingBookingWhereUniqueInput[]
    delete?: PendingBookingWhereUniqueInput | PendingBookingWhereUniqueInput[]
    connect?: PendingBookingWhereUniqueInput | PendingBookingWhereUniqueInput[]
    update?: PendingBookingUpdateWithWhereUniqueWithoutCreatedByInput | PendingBookingUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: PendingBookingUpdateManyWithWhereWithoutCreatedByInput | PendingBookingUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: PendingBookingScalarWhereInput | PendingBookingScalarWhereInput[]
  }

  export type BookingUpdateManyWithoutVoidedByNestedInput = {
    create?: XOR<BookingCreateWithoutVoidedByInput, BookingUncheckedCreateWithoutVoidedByInput> | BookingCreateWithoutVoidedByInput[] | BookingUncheckedCreateWithoutVoidedByInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutVoidedByInput | BookingCreateOrConnectWithoutVoidedByInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutVoidedByInput | BookingUpsertWithWhereUniqueWithoutVoidedByInput[]
    createMany?: BookingCreateManyVoidedByInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutVoidedByInput | BookingUpdateWithWhereUniqueWithoutVoidedByInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutVoidedByInput | BookingUpdateManyWithWhereWithoutVoidedByInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type PendingBookingUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<PendingBookingCreateWithoutCreatedByInput, PendingBookingUncheckedCreateWithoutCreatedByInput> | PendingBookingCreateWithoutCreatedByInput[] | PendingBookingUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: PendingBookingCreateOrConnectWithoutCreatedByInput | PendingBookingCreateOrConnectWithoutCreatedByInput[]
    upsert?: PendingBookingUpsertWithWhereUniqueWithoutCreatedByInput | PendingBookingUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: PendingBookingCreateManyCreatedByInputEnvelope
    set?: PendingBookingWhereUniqueInput | PendingBookingWhereUniqueInput[]
    disconnect?: PendingBookingWhereUniqueInput | PendingBookingWhereUniqueInput[]
    delete?: PendingBookingWhereUniqueInput | PendingBookingWhereUniqueInput[]
    connect?: PendingBookingWhereUniqueInput | PendingBookingWhereUniqueInput[]
    update?: PendingBookingUpdateWithWhereUniqueWithoutCreatedByInput | PendingBookingUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: PendingBookingUpdateManyWithWhereWithoutCreatedByInput | PendingBookingUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: PendingBookingScalarWhereInput | PendingBookingScalarWhereInput[]
  }

  export type BookingUncheckedUpdateManyWithoutVoidedByNestedInput = {
    create?: XOR<BookingCreateWithoutVoidedByInput, BookingUncheckedCreateWithoutVoidedByInput> | BookingCreateWithoutVoidedByInput[] | BookingUncheckedCreateWithoutVoidedByInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutVoidedByInput | BookingCreateOrConnectWithoutVoidedByInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutVoidedByInput | BookingUpsertWithWhereUniqueWithoutVoidedByInput[]
    createMany?: BookingCreateManyVoidedByInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutVoidedByInput | BookingUpdateWithWhereUniqueWithoutVoidedByInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutVoidedByInput | BookingUpdateManyWithWhereWithoutVoidedByInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type BookingCreateNestedOneWithoutCostItemsInput = {
    create?: XOR<BookingCreateWithoutCostItemsInput, BookingUncheckedCreateWithoutCostItemsInput>
    connectOrCreate?: BookingCreateOrConnectWithoutCostItemsInput
    connect?: BookingWhereUniqueInput
  }

  export type CostItemSupplierCreateNestedManyWithoutCostItemInput = {
    create?: XOR<CostItemSupplierCreateWithoutCostItemInput, CostItemSupplierUncheckedCreateWithoutCostItemInput> | CostItemSupplierCreateWithoutCostItemInput[] | CostItemSupplierUncheckedCreateWithoutCostItemInput[]
    connectOrCreate?: CostItemSupplierCreateOrConnectWithoutCostItemInput | CostItemSupplierCreateOrConnectWithoutCostItemInput[]
    createMany?: CostItemSupplierCreateManyCostItemInputEnvelope
    connect?: CostItemSupplierWhereUniqueInput | CostItemSupplierWhereUniqueInput[]
  }

  export type CostItemSupplierUncheckedCreateNestedManyWithoutCostItemInput = {
    create?: XOR<CostItemSupplierCreateWithoutCostItemInput, CostItemSupplierUncheckedCreateWithoutCostItemInput> | CostItemSupplierCreateWithoutCostItemInput[] | CostItemSupplierUncheckedCreateWithoutCostItemInput[]
    connectOrCreate?: CostItemSupplierCreateOrConnectWithoutCostItemInput | CostItemSupplierCreateOrConnectWithoutCostItemInput[]
    createMany?: CostItemSupplierCreateManyCostItemInputEnvelope
    connect?: CostItemSupplierWhereUniqueInput | CostItemSupplierWhereUniqueInput[]
  }

  export type BookingUpdateOneRequiredWithoutCostItemsNestedInput = {
    create?: XOR<BookingCreateWithoutCostItemsInput, BookingUncheckedCreateWithoutCostItemsInput>
    connectOrCreate?: BookingCreateOrConnectWithoutCostItemsInput
    upsert?: BookingUpsertWithoutCostItemsInput
    connect?: BookingWhereUniqueInput
    update?: XOR<XOR<BookingUpdateToOneWithWhereWithoutCostItemsInput, BookingUpdateWithoutCostItemsInput>, BookingUncheckedUpdateWithoutCostItemsInput>
  }

  export type CostItemSupplierUpdateManyWithoutCostItemNestedInput = {
    create?: XOR<CostItemSupplierCreateWithoutCostItemInput, CostItemSupplierUncheckedCreateWithoutCostItemInput> | CostItemSupplierCreateWithoutCostItemInput[] | CostItemSupplierUncheckedCreateWithoutCostItemInput[]
    connectOrCreate?: CostItemSupplierCreateOrConnectWithoutCostItemInput | CostItemSupplierCreateOrConnectWithoutCostItemInput[]
    upsert?: CostItemSupplierUpsertWithWhereUniqueWithoutCostItemInput | CostItemSupplierUpsertWithWhereUniqueWithoutCostItemInput[]
    createMany?: CostItemSupplierCreateManyCostItemInputEnvelope
    set?: CostItemSupplierWhereUniqueInput | CostItemSupplierWhereUniqueInput[]
    disconnect?: CostItemSupplierWhereUniqueInput | CostItemSupplierWhereUniqueInput[]
    delete?: CostItemSupplierWhereUniqueInput | CostItemSupplierWhereUniqueInput[]
    connect?: CostItemSupplierWhereUniqueInput | CostItemSupplierWhereUniqueInput[]
    update?: CostItemSupplierUpdateWithWhereUniqueWithoutCostItemInput | CostItemSupplierUpdateWithWhereUniqueWithoutCostItemInput[]
    updateMany?: CostItemSupplierUpdateManyWithWhereWithoutCostItemInput | CostItemSupplierUpdateManyWithWhereWithoutCostItemInput[]
    deleteMany?: CostItemSupplierScalarWhereInput | CostItemSupplierScalarWhereInput[]
  }

  export type CostItemSupplierUncheckedUpdateManyWithoutCostItemNestedInput = {
    create?: XOR<CostItemSupplierCreateWithoutCostItemInput, CostItemSupplierUncheckedCreateWithoutCostItemInput> | CostItemSupplierCreateWithoutCostItemInput[] | CostItemSupplierUncheckedCreateWithoutCostItemInput[]
    connectOrCreate?: CostItemSupplierCreateOrConnectWithoutCostItemInput | CostItemSupplierCreateOrConnectWithoutCostItemInput[]
    upsert?: CostItemSupplierUpsertWithWhereUniqueWithoutCostItemInput | CostItemSupplierUpsertWithWhereUniqueWithoutCostItemInput[]
    createMany?: CostItemSupplierCreateManyCostItemInputEnvelope
    set?: CostItemSupplierWhereUniqueInput | CostItemSupplierWhereUniqueInput[]
    disconnect?: CostItemSupplierWhereUniqueInput | CostItemSupplierWhereUniqueInput[]
    delete?: CostItemSupplierWhereUniqueInput | CostItemSupplierWhereUniqueInput[]
    connect?: CostItemSupplierWhereUniqueInput | CostItemSupplierWhereUniqueInput[]
    update?: CostItemSupplierUpdateWithWhereUniqueWithoutCostItemInput | CostItemSupplierUpdateWithWhereUniqueWithoutCostItemInput[]
    updateMany?: CostItemSupplierUpdateManyWithWhereWithoutCostItemInput | CostItemSupplierUpdateManyWithWhereWithoutCostItemInput[]
    deleteMany?: CostItemSupplierScalarWhereInput | CostItemSupplierScalarWhereInput[]
  }

  export type PendingBookingCreateNestedOneWithoutCostItemsInput = {
    create?: XOR<PendingBookingCreateWithoutCostItemsInput, PendingBookingUncheckedCreateWithoutCostItemsInput>
    connectOrCreate?: PendingBookingCreateOrConnectWithoutCostItemsInput
    connect?: PendingBookingWhereUniqueInput
  }

  export type CostItemSupplierCreateNestedManyWithoutPendingCostItemInput = {
    create?: XOR<CostItemSupplierCreateWithoutPendingCostItemInput, CostItemSupplierUncheckedCreateWithoutPendingCostItemInput> | CostItemSupplierCreateWithoutPendingCostItemInput[] | CostItemSupplierUncheckedCreateWithoutPendingCostItemInput[]
    connectOrCreate?: CostItemSupplierCreateOrConnectWithoutPendingCostItemInput | CostItemSupplierCreateOrConnectWithoutPendingCostItemInput[]
    createMany?: CostItemSupplierCreateManyPendingCostItemInputEnvelope
    connect?: CostItemSupplierWhereUniqueInput | CostItemSupplierWhereUniqueInput[]
  }

  export type CostItemSupplierUncheckedCreateNestedManyWithoutPendingCostItemInput = {
    create?: XOR<CostItemSupplierCreateWithoutPendingCostItemInput, CostItemSupplierUncheckedCreateWithoutPendingCostItemInput> | CostItemSupplierCreateWithoutPendingCostItemInput[] | CostItemSupplierUncheckedCreateWithoutPendingCostItemInput[]
    connectOrCreate?: CostItemSupplierCreateOrConnectWithoutPendingCostItemInput | CostItemSupplierCreateOrConnectWithoutPendingCostItemInput[]
    createMany?: CostItemSupplierCreateManyPendingCostItemInputEnvelope
    connect?: CostItemSupplierWhereUniqueInput | CostItemSupplierWhereUniqueInput[]
  }

  export type PendingBookingUpdateOneRequiredWithoutCostItemsNestedInput = {
    create?: XOR<PendingBookingCreateWithoutCostItemsInput, PendingBookingUncheckedCreateWithoutCostItemsInput>
    connectOrCreate?: PendingBookingCreateOrConnectWithoutCostItemsInput
    upsert?: PendingBookingUpsertWithoutCostItemsInput
    connect?: PendingBookingWhereUniqueInput
    update?: XOR<XOR<PendingBookingUpdateToOneWithWhereWithoutCostItemsInput, PendingBookingUpdateWithoutCostItemsInput>, PendingBookingUncheckedUpdateWithoutCostItemsInput>
  }

  export type CostItemSupplierUpdateManyWithoutPendingCostItemNestedInput = {
    create?: XOR<CostItemSupplierCreateWithoutPendingCostItemInput, CostItemSupplierUncheckedCreateWithoutPendingCostItemInput> | CostItemSupplierCreateWithoutPendingCostItemInput[] | CostItemSupplierUncheckedCreateWithoutPendingCostItemInput[]
    connectOrCreate?: CostItemSupplierCreateOrConnectWithoutPendingCostItemInput | CostItemSupplierCreateOrConnectWithoutPendingCostItemInput[]
    upsert?: CostItemSupplierUpsertWithWhereUniqueWithoutPendingCostItemInput | CostItemSupplierUpsertWithWhereUniqueWithoutPendingCostItemInput[]
    createMany?: CostItemSupplierCreateManyPendingCostItemInputEnvelope
    set?: CostItemSupplierWhereUniqueInput | CostItemSupplierWhereUniqueInput[]
    disconnect?: CostItemSupplierWhereUniqueInput | CostItemSupplierWhereUniqueInput[]
    delete?: CostItemSupplierWhereUniqueInput | CostItemSupplierWhereUniqueInput[]
    connect?: CostItemSupplierWhereUniqueInput | CostItemSupplierWhereUniqueInput[]
    update?: CostItemSupplierUpdateWithWhereUniqueWithoutPendingCostItemInput | CostItemSupplierUpdateWithWhereUniqueWithoutPendingCostItemInput[]
    updateMany?: CostItemSupplierUpdateManyWithWhereWithoutPendingCostItemInput | CostItemSupplierUpdateManyWithWhereWithoutPendingCostItemInput[]
    deleteMany?: CostItemSupplierScalarWhereInput | CostItemSupplierScalarWhereInput[]
  }

  export type CostItemSupplierUncheckedUpdateManyWithoutPendingCostItemNestedInput = {
    create?: XOR<CostItemSupplierCreateWithoutPendingCostItemInput, CostItemSupplierUncheckedCreateWithoutPendingCostItemInput> | CostItemSupplierCreateWithoutPendingCostItemInput[] | CostItemSupplierUncheckedCreateWithoutPendingCostItemInput[]
    connectOrCreate?: CostItemSupplierCreateOrConnectWithoutPendingCostItemInput | CostItemSupplierCreateOrConnectWithoutPendingCostItemInput[]
    upsert?: CostItemSupplierUpsertWithWhereUniqueWithoutPendingCostItemInput | CostItemSupplierUpsertWithWhereUniqueWithoutPendingCostItemInput[]
    createMany?: CostItemSupplierCreateManyPendingCostItemInputEnvelope
    set?: CostItemSupplierWhereUniqueInput | CostItemSupplierWhereUniqueInput[]
    disconnect?: CostItemSupplierWhereUniqueInput | CostItemSupplierWhereUniqueInput[]
    delete?: CostItemSupplierWhereUniqueInput | CostItemSupplierWhereUniqueInput[]
    connect?: CostItemSupplierWhereUniqueInput | CostItemSupplierWhereUniqueInput[]
    update?: CostItemSupplierUpdateWithWhereUniqueWithoutPendingCostItemInput | CostItemSupplierUpdateWithWhereUniqueWithoutPendingCostItemInput[]
    updateMany?: CostItemSupplierUpdateManyWithWhereWithoutPendingCostItemInput | CostItemSupplierUpdateManyWithWhereWithoutPendingCostItemInput[]
    deleteMany?: CostItemSupplierScalarWhereInput | CostItemSupplierScalarWhereInput[]
  }

  export type BookingCreateNestedOneWithoutPassengersInput = {
    create?: XOR<BookingCreateWithoutPassengersInput, BookingUncheckedCreateWithoutPassengersInput>
    connectOrCreate?: BookingCreateOrConnectWithoutPassengersInput
    connect?: BookingWhereUniqueInput
  }

  export type EnumTitleFieldUpdateOperationsInput = {
    set?: $Enums.Title
  }

  export type EnumGenderFieldUpdateOperationsInput = {
    set?: $Enums.Gender
  }

  export type EnumPassengerCategoryFieldUpdateOperationsInput = {
    set?: $Enums.PassengerCategory
  }

  export type BookingUpdateOneRequiredWithoutPassengersNestedInput = {
    create?: XOR<BookingCreateWithoutPassengersInput, BookingUncheckedCreateWithoutPassengersInput>
    connectOrCreate?: BookingCreateOrConnectWithoutPassengersInput
    upsert?: BookingUpsertWithoutPassengersInput
    connect?: BookingWhereUniqueInput
    update?: XOR<XOR<BookingUpdateToOneWithWhereWithoutPassengersInput, BookingUpdateWithoutPassengersInput>, BookingUncheckedUpdateWithoutPassengersInput>
  }

  export type PendingBookingCreateNestedOneWithoutPassengersInput = {
    create?: XOR<PendingBookingCreateWithoutPassengersInput, PendingBookingUncheckedCreateWithoutPassengersInput>
    connectOrCreate?: PendingBookingCreateOrConnectWithoutPassengersInput
    connect?: PendingBookingWhereUniqueInput
  }

  export type PendingBookingUpdateOneRequiredWithoutPassengersNestedInput = {
    create?: XOR<PendingBookingCreateWithoutPassengersInput, PendingBookingUncheckedCreateWithoutPassengersInput>
    connectOrCreate?: PendingBookingCreateOrConnectWithoutPassengersInput
    upsert?: PendingBookingUpsertWithoutPassengersInput
    connect?: PendingBookingWhereUniqueInput
    update?: XOR<XOR<PendingBookingUpdateToOneWithWhereWithoutPassengersInput, PendingBookingUpdateWithoutPassengersInput>, PendingBookingUncheckedUpdateWithoutPassengersInput>
  }

  export type CostItemCreateNestedOneWithoutSuppliersInput = {
    create?: XOR<CostItemCreateWithoutSuppliersInput, CostItemUncheckedCreateWithoutSuppliersInput>
    connectOrCreate?: CostItemCreateOrConnectWithoutSuppliersInput
    connect?: CostItemWhereUniqueInput
  }

  export type PendingCostItemCreateNestedOneWithoutSuppliersInput = {
    create?: XOR<PendingCostItemCreateWithoutSuppliersInput, PendingCostItemUncheckedCreateWithoutSuppliersInput>
    connectOrCreate?: PendingCostItemCreateOrConnectWithoutSuppliersInput
    connect?: PendingCostItemWhereUniqueInput
  }

  export type SupplierPaymentSettlementCreateNestedManyWithoutCostItemSupplierInput = {
    create?: XOR<SupplierPaymentSettlementCreateWithoutCostItemSupplierInput, SupplierPaymentSettlementUncheckedCreateWithoutCostItemSupplierInput> | SupplierPaymentSettlementCreateWithoutCostItemSupplierInput[] | SupplierPaymentSettlementUncheckedCreateWithoutCostItemSupplierInput[]
    connectOrCreate?: SupplierPaymentSettlementCreateOrConnectWithoutCostItemSupplierInput | SupplierPaymentSettlementCreateOrConnectWithoutCostItemSupplierInput[]
    createMany?: SupplierPaymentSettlementCreateManyCostItemSupplierInputEnvelope
    connect?: SupplierPaymentSettlementWhereUniqueInput | SupplierPaymentSettlementWhereUniqueInput[]
  }

  export type CreditNoteUsageCreateNestedManyWithoutUsedOnCostItemSupplierInput = {
    create?: XOR<CreditNoteUsageCreateWithoutUsedOnCostItemSupplierInput, CreditNoteUsageUncheckedCreateWithoutUsedOnCostItemSupplierInput> | CreditNoteUsageCreateWithoutUsedOnCostItemSupplierInput[] | CreditNoteUsageUncheckedCreateWithoutUsedOnCostItemSupplierInput[]
    connectOrCreate?: CreditNoteUsageCreateOrConnectWithoutUsedOnCostItemSupplierInput | CreditNoteUsageCreateOrConnectWithoutUsedOnCostItemSupplierInput[]
    createMany?: CreditNoteUsageCreateManyUsedOnCostItemSupplierInputEnvelope
    connect?: CreditNoteUsageWhereUniqueInput | CreditNoteUsageWhereUniqueInput[]
  }

  export type SupplierPaymentSettlementUncheckedCreateNestedManyWithoutCostItemSupplierInput = {
    create?: XOR<SupplierPaymentSettlementCreateWithoutCostItemSupplierInput, SupplierPaymentSettlementUncheckedCreateWithoutCostItemSupplierInput> | SupplierPaymentSettlementCreateWithoutCostItemSupplierInput[] | SupplierPaymentSettlementUncheckedCreateWithoutCostItemSupplierInput[]
    connectOrCreate?: SupplierPaymentSettlementCreateOrConnectWithoutCostItemSupplierInput | SupplierPaymentSettlementCreateOrConnectWithoutCostItemSupplierInput[]
    createMany?: SupplierPaymentSettlementCreateManyCostItemSupplierInputEnvelope
    connect?: SupplierPaymentSettlementWhereUniqueInput | SupplierPaymentSettlementWhereUniqueInput[]
  }

  export type CreditNoteUsageUncheckedCreateNestedManyWithoutUsedOnCostItemSupplierInput = {
    create?: XOR<CreditNoteUsageCreateWithoutUsedOnCostItemSupplierInput, CreditNoteUsageUncheckedCreateWithoutUsedOnCostItemSupplierInput> | CreditNoteUsageCreateWithoutUsedOnCostItemSupplierInput[] | CreditNoteUsageUncheckedCreateWithoutUsedOnCostItemSupplierInput[]
    connectOrCreate?: CreditNoteUsageCreateOrConnectWithoutUsedOnCostItemSupplierInput | CreditNoteUsageCreateOrConnectWithoutUsedOnCostItemSupplierInput[]
    createMany?: CreditNoteUsageCreateManyUsedOnCostItemSupplierInputEnvelope
    connect?: CreditNoteUsageWhereUniqueInput | CreditNoteUsageWhereUniqueInput[]
  }

  export type EnumSuppliersFieldUpdateOperationsInput = {
    set?: $Enums.Suppliers
  }

  export type CostItemUpdateOneWithoutSuppliersNestedInput = {
    create?: XOR<CostItemCreateWithoutSuppliersInput, CostItemUncheckedCreateWithoutSuppliersInput>
    connectOrCreate?: CostItemCreateOrConnectWithoutSuppliersInput
    upsert?: CostItemUpsertWithoutSuppliersInput
    disconnect?: CostItemWhereInput | boolean
    delete?: CostItemWhereInput | boolean
    connect?: CostItemWhereUniqueInput
    update?: XOR<XOR<CostItemUpdateToOneWithWhereWithoutSuppliersInput, CostItemUpdateWithoutSuppliersInput>, CostItemUncheckedUpdateWithoutSuppliersInput>
  }

  export type PendingCostItemUpdateOneWithoutSuppliersNestedInput = {
    create?: XOR<PendingCostItemCreateWithoutSuppliersInput, PendingCostItemUncheckedCreateWithoutSuppliersInput>
    connectOrCreate?: PendingCostItemCreateOrConnectWithoutSuppliersInput
    upsert?: PendingCostItemUpsertWithoutSuppliersInput
    disconnect?: PendingCostItemWhereInput | boolean
    delete?: PendingCostItemWhereInput | boolean
    connect?: PendingCostItemWhereUniqueInput
    update?: XOR<XOR<PendingCostItemUpdateToOneWithWhereWithoutSuppliersInput, PendingCostItemUpdateWithoutSuppliersInput>, PendingCostItemUncheckedUpdateWithoutSuppliersInput>
  }

  export type SupplierPaymentSettlementUpdateManyWithoutCostItemSupplierNestedInput = {
    create?: XOR<SupplierPaymentSettlementCreateWithoutCostItemSupplierInput, SupplierPaymentSettlementUncheckedCreateWithoutCostItemSupplierInput> | SupplierPaymentSettlementCreateWithoutCostItemSupplierInput[] | SupplierPaymentSettlementUncheckedCreateWithoutCostItemSupplierInput[]
    connectOrCreate?: SupplierPaymentSettlementCreateOrConnectWithoutCostItemSupplierInput | SupplierPaymentSettlementCreateOrConnectWithoutCostItemSupplierInput[]
    upsert?: SupplierPaymentSettlementUpsertWithWhereUniqueWithoutCostItemSupplierInput | SupplierPaymentSettlementUpsertWithWhereUniqueWithoutCostItemSupplierInput[]
    createMany?: SupplierPaymentSettlementCreateManyCostItemSupplierInputEnvelope
    set?: SupplierPaymentSettlementWhereUniqueInput | SupplierPaymentSettlementWhereUniqueInput[]
    disconnect?: SupplierPaymentSettlementWhereUniqueInput | SupplierPaymentSettlementWhereUniqueInput[]
    delete?: SupplierPaymentSettlementWhereUniqueInput | SupplierPaymentSettlementWhereUniqueInput[]
    connect?: SupplierPaymentSettlementWhereUniqueInput | SupplierPaymentSettlementWhereUniqueInput[]
    update?: SupplierPaymentSettlementUpdateWithWhereUniqueWithoutCostItemSupplierInput | SupplierPaymentSettlementUpdateWithWhereUniqueWithoutCostItemSupplierInput[]
    updateMany?: SupplierPaymentSettlementUpdateManyWithWhereWithoutCostItemSupplierInput | SupplierPaymentSettlementUpdateManyWithWhereWithoutCostItemSupplierInput[]
    deleteMany?: SupplierPaymentSettlementScalarWhereInput | SupplierPaymentSettlementScalarWhereInput[]
  }

  export type CreditNoteUsageUpdateManyWithoutUsedOnCostItemSupplierNestedInput = {
    create?: XOR<CreditNoteUsageCreateWithoutUsedOnCostItemSupplierInput, CreditNoteUsageUncheckedCreateWithoutUsedOnCostItemSupplierInput> | CreditNoteUsageCreateWithoutUsedOnCostItemSupplierInput[] | CreditNoteUsageUncheckedCreateWithoutUsedOnCostItemSupplierInput[]
    connectOrCreate?: CreditNoteUsageCreateOrConnectWithoutUsedOnCostItemSupplierInput | CreditNoteUsageCreateOrConnectWithoutUsedOnCostItemSupplierInput[]
    upsert?: CreditNoteUsageUpsertWithWhereUniqueWithoutUsedOnCostItemSupplierInput | CreditNoteUsageUpsertWithWhereUniqueWithoutUsedOnCostItemSupplierInput[]
    createMany?: CreditNoteUsageCreateManyUsedOnCostItemSupplierInputEnvelope
    set?: CreditNoteUsageWhereUniqueInput | CreditNoteUsageWhereUniqueInput[]
    disconnect?: CreditNoteUsageWhereUniqueInput | CreditNoteUsageWhereUniqueInput[]
    delete?: CreditNoteUsageWhereUniqueInput | CreditNoteUsageWhereUniqueInput[]
    connect?: CreditNoteUsageWhereUniqueInput | CreditNoteUsageWhereUniqueInput[]
    update?: CreditNoteUsageUpdateWithWhereUniqueWithoutUsedOnCostItemSupplierInput | CreditNoteUsageUpdateWithWhereUniqueWithoutUsedOnCostItemSupplierInput[]
    updateMany?: CreditNoteUsageUpdateManyWithWhereWithoutUsedOnCostItemSupplierInput | CreditNoteUsageUpdateManyWithWhereWithoutUsedOnCostItemSupplierInput[]
    deleteMany?: CreditNoteUsageScalarWhereInput | CreditNoteUsageScalarWhereInput[]
  }

  export type SupplierPaymentSettlementUncheckedUpdateManyWithoutCostItemSupplierNestedInput = {
    create?: XOR<SupplierPaymentSettlementCreateWithoutCostItemSupplierInput, SupplierPaymentSettlementUncheckedCreateWithoutCostItemSupplierInput> | SupplierPaymentSettlementCreateWithoutCostItemSupplierInput[] | SupplierPaymentSettlementUncheckedCreateWithoutCostItemSupplierInput[]
    connectOrCreate?: SupplierPaymentSettlementCreateOrConnectWithoutCostItemSupplierInput | SupplierPaymentSettlementCreateOrConnectWithoutCostItemSupplierInput[]
    upsert?: SupplierPaymentSettlementUpsertWithWhereUniqueWithoutCostItemSupplierInput | SupplierPaymentSettlementUpsertWithWhereUniqueWithoutCostItemSupplierInput[]
    createMany?: SupplierPaymentSettlementCreateManyCostItemSupplierInputEnvelope
    set?: SupplierPaymentSettlementWhereUniqueInput | SupplierPaymentSettlementWhereUniqueInput[]
    disconnect?: SupplierPaymentSettlementWhereUniqueInput | SupplierPaymentSettlementWhereUniqueInput[]
    delete?: SupplierPaymentSettlementWhereUniqueInput | SupplierPaymentSettlementWhereUniqueInput[]
    connect?: SupplierPaymentSettlementWhereUniqueInput | SupplierPaymentSettlementWhereUniqueInput[]
    update?: SupplierPaymentSettlementUpdateWithWhereUniqueWithoutCostItemSupplierInput | SupplierPaymentSettlementUpdateWithWhereUniqueWithoutCostItemSupplierInput[]
    updateMany?: SupplierPaymentSettlementUpdateManyWithWhereWithoutCostItemSupplierInput | SupplierPaymentSettlementUpdateManyWithWhereWithoutCostItemSupplierInput[]
    deleteMany?: SupplierPaymentSettlementScalarWhereInput | SupplierPaymentSettlementScalarWhereInput[]
  }

  export type CreditNoteUsageUncheckedUpdateManyWithoutUsedOnCostItemSupplierNestedInput = {
    create?: XOR<CreditNoteUsageCreateWithoutUsedOnCostItemSupplierInput, CreditNoteUsageUncheckedCreateWithoutUsedOnCostItemSupplierInput> | CreditNoteUsageCreateWithoutUsedOnCostItemSupplierInput[] | CreditNoteUsageUncheckedCreateWithoutUsedOnCostItemSupplierInput[]
    connectOrCreate?: CreditNoteUsageCreateOrConnectWithoutUsedOnCostItemSupplierInput | CreditNoteUsageCreateOrConnectWithoutUsedOnCostItemSupplierInput[]
    upsert?: CreditNoteUsageUpsertWithWhereUniqueWithoutUsedOnCostItemSupplierInput | CreditNoteUsageUpsertWithWhereUniqueWithoutUsedOnCostItemSupplierInput[]
    createMany?: CreditNoteUsageCreateManyUsedOnCostItemSupplierInputEnvelope
    set?: CreditNoteUsageWhereUniqueInput | CreditNoteUsageWhereUniqueInput[]
    disconnect?: CreditNoteUsageWhereUniqueInput | CreditNoteUsageWhereUniqueInput[]
    delete?: CreditNoteUsageWhereUniqueInput | CreditNoteUsageWhereUniqueInput[]
    connect?: CreditNoteUsageWhereUniqueInput | CreditNoteUsageWhereUniqueInput[]
    update?: CreditNoteUsageUpdateWithWhereUniqueWithoutUsedOnCostItemSupplierInput | CreditNoteUsageUpdateWithWhereUniqueWithoutUsedOnCostItemSupplierInput[]
    updateMany?: CreditNoteUsageUpdateManyWithWhereWithoutUsedOnCostItemSupplierInput | CreditNoteUsageUpdateManyWithWhereWithoutUsedOnCostItemSupplierInput[]
    deleteMany?: CreditNoteUsageScalarWhereInput | CreditNoteUsageScalarWhereInput[]
  }

  export type CostItemSupplierCreateNestedOneWithoutSettlementsInput = {
    create?: XOR<CostItemSupplierCreateWithoutSettlementsInput, CostItemSupplierUncheckedCreateWithoutSettlementsInput>
    connectOrCreate?: CostItemSupplierCreateOrConnectWithoutSettlementsInput
    connect?: CostItemSupplierWhereUniqueInput
  }

  export type CostItemSupplierUpdateOneRequiredWithoutSettlementsNestedInput = {
    create?: XOR<CostItemSupplierCreateWithoutSettlementsInput, CostItemSupplierUncheckedCreateWithoutSettlementsInput>
    connectOrCreate?: CostItemSupplierCreateOrConnectWithoutSettlementsInput
    upsert?: CostItemSupplierUpsertWithoutSettlementsInput
    connect?: CostItemSupplierWhereUniqueInput
    update?: XOR<XOR<CostItemSupplierUpdateToOneWithWhereWithoutSettlementsInput, CostItemSupplierUpdateWithoutSettlementsInput>, CostItemSupplierUncheckedUpdateWithoutSettlementsInput>
  }

  export type BookingCreateNestedOneWithoutCancellationInput = {
    create?: XOR<BookingCreateWithoutCancellationInput, BookingUncheckedCreateWithoutCancellationInput>
    connectOrCreate?: BookingCreateOrConnectWithoutCancellationInput
    connect?: BookingWhereUniqueInput
  }

  export type PassengerRefundPaymentCreateNestedOneWithoutCancellationInput = {
    create?: XOR<PassengerRefundPaymentCreateWithoutCancellationInput, PassengerRefundPaymentUncheckedCreateWithoutCancellationInput>
    connectOrCreate?: PassengerRefundPaymentCreateOrConnectWithoutCancellationInput
    connect?: PassengerRefundPaymentWhereUniqueInput
  }

  export type CustomerPayableCreateNestedOneWithoutCreatedFromCancellationInput = {
    create?: XOR<CustomerPayableCreateWithoutCreatedFromCancellationInput, CustomerPayableUncheckedCreateWithoutCreatedFromCancellationInput>
    connectOrCreate?: CustomerPayableCreateOrConnectWithoutCreatedFromCancellationInput
    connect?: CustomerPayableWhereUniqueInput
  }

  export type SupplierPayableCreateNestedOneWithoutCreatedFromCancellationInput = {
    create?: XOR<SupplierPayableCreateWithoutCreatedFromCancellationInput, SupplierPayableUncheckedCreateWithoutCreatedFromCancellationInput>
    connectOrCreate?: SupplierPayableCreateOrConnectWithoutCreatedFromCancellationInput
    connect?: SupplierPayableWhereUniqueInput
  }

  export type SupplierCreditNoteCreateNestedOneWithoutGeneratedFromCancellationInput = {
    create?: XOR<SupplierCreditNoteCreateWithoutGeneratedFromCancellationInput, SupplierCreditNoteUncheckedCreateWithoutGeneratedFromCancellationInput>
    connectOrCreate?: SupplierCreditNoteCreateOrConnectWithoutGeneratedFromCancellationInput
    connect?: SupplierCreditNoteWhereUniqueInput
  }

  export type PassengerRefundPaymentUncheckedCreateNestedOneWithoutCancellationInput = {
    create?: XOR<PassengerRefundPaymentCreateWithoutCancellationInput, PassengerRefundPaymentUncheckedCreateWithoutCancellationInput>
    connectOrCreate?: PassengerRefundPaymentCreateOrConnectWithoutCancellationInput
    connect?: PassengerRefundPaymentWhereUniqueInput
  }

  export type CustomerPayableUncheckedCreateNestedOneWithoutCreatedFromCancellationInput = {
    create?: XOR<CustomerPayableCreateWithoutCreatedFromCancellationInput, CustomerPayableUncheckedCreateWithoutCreatedFromCancellationInput>
    connectOrCreate?: CustomerPayableCreateOrConnectWithoutCreatedFromCancellationInput
    connect?: CustomerPayableWhereUniqueInput
  }

  export type SupplierPayableUncheckedCreateNestedOneWithoutCreatedFromCancellationInput = {
    create?: XOR<SupplierPayableCreateWithoutCreatedFromCancellationInput, SupplierPayableUncheckedCreateWithoutCreatedFromCancellationInput>
    connectOrCreate?: SupplierPayableCreateOrConnectWithoutCreatedFromCancellationInput
    connect?: SupplierPayableWhereUniqueInput
  }

  export type SupplierCreditNoteUncheckedCreateNestedOneWithoutGeneratedFromCancellationInput = {
    create?: XOR<SupplierCreditNoteCreateWithoutGeneratedFromCancellationInput, SupplierCreditNoteUncheckedCreateWithoutGeneratedFromCancellationInput>
    connectOrCreate?: SupplierCreditNoteCreateOrConnectWithoutGeneratedFromCancellationInput
    connect?: SupplierCreditNoteWhereUniqueInput
  }

  export type BookingUpdateOneRequiredWithoutCancellationNestedInput = {
    create?: XOR<BookingCreateWithoutCancellationInput, BookingUncheckedCreateWithoutCancellationInput>
    connectOrCreate?: BookingCreateOrConnectWithoutCancellationInput
    upsert?: BookingUpsertWithoutCancellationInput
    connect?: BookingWhereUniqueInput
    update?: XOR<XOR<BookingUpdateToOneWithWhereWithoutCancellationInput, BookingUpdateWithoutCancellationInput>, BookingUncheckedUpdateWithoutCancellationInput>
  }

  export type PassengerRefundPaymentUpdateOneWithoutCancellationNestedInput = {
    create?: XOR<PassengerRefundPaymentCreateWithoutCancellationInput, PassengerRefundPaymentUncheckedCreateWithoutCancellationInput>
    connectOrCreate?: PassengerRefundPaymentCreateOrConnectWithoutCancellationInput
    upsert?: PassengerRefundPaymentUpsertWithoutCancellationInput
    disconnect?: PassengerRefundPaymentWhereInput | boolean
    delete?: PassengerRefundPaymentWhereInput | boolean
    connect?: PassengerRefundPaymentWhereUniqueInput
    update?: XOR<XOR<PassengerRefundPaymentUpdateToOneWithWhereWithoutCancellationInput, PassengerRefundPaymentUpdateWithoutCancellationInput>, PassengerRefundPaymentUncheckedUpdateWithoutCancellationInput>
  }

  export type CustomerPayableUpdateOneWithoutCreatedFromCancellationNestedInput = {
    create?: XOR<CustomerPayableCreateWithoutCreatedFromCancellationInput, CustomerPayableUncheckedCreateWithoutCreatedFromCancellationInput>
    connectOrCreate?: CustomerPayableCreateOrConnectWithoutCreatedFromCancellationInput
    upsert?: CustomerPayableUpsertWithoutCreatedFromCancellationInput
    disconnect?: CustomerPayableWhereInput | boolean
    delete?: CustomerPayableWhereInput | boolean
    connect?: CustomerPayableWhereUniqueInput
    update?: XOR<XOR<CustomerPayableUpdateToOneWithWhereWithoutCreatedFromCancellationInput, CustomerPayableUpdateWithoutCreatedFromCancellationInput>, CustomerPayableUncheckedUpdateWithoutCreatedFromCancellationInput>
  }

  export type SupplierPayableUpdateOneWithoutCreatedFromCancellationNestedInput = {
    create?: XOR<SupplierPayableCreateWithoutCreatedFromCancellationInput, SupplierPayableUncheckedCreateWithoutCreatedFromCancellationInput>
    connectOrCreate?: SupplierPayableCreateOrConnectWithoutCreatedFromCancellationInput
    upsert?: SupplierPayableUpsertWithoutCreatedFromCancellationInput
    disconnect?: SupplierPayableWhereInput | boolean
    delete?: SupplierPayableWhereInput | boolean
    connect?: SupplierPayableWhereUniqueInput
    update?: XOR<XOR<SupplierPayableUpdateToOneWithWhereWithoutCreatedFromCancellationInput, SupplierPayableUpdateWithoutCreatedFromCancellationInput>, SupplierPayableUncheckedUpdateWithoutCreatedFromCancellationInput>
  }

  export type SupplierCreditNoteUpdateOneWithoutGeneratedFromCancellationNestedInput = {
    create?: XOR<SupplierCreditNoteCreateWithoutGeneratedFromCancellationInput, SupplierCreditNoteUncheckedCreateWithoutGeneratedFromCancellationInput>
    connectOrCreate?: SupplierCreditNoteCreateOrConnectWithoutGeneratedFromCancellationInput
    upsert?: SupplierCreditNoteUpsertWithoutGeneratedFromCancellationInput
    disconnect?: SupplierCreditNoteWhereInput | boolean
    delete?: SupplierCreditNoteWhereInput | boolean
    connect?: SupplierCreditNoteWhereUniqueInput
    update?: XOR<XOR<SupplierCreditNoteUpdateToOneWithWhereWithoutGeneratedFromCancellationInput, SupplierCreditNoteUpdateWithoutGeneratedFromCancellationInput>, SupplierCreditNoteUncheckedUpdateWithoutGeneratedFromCancellationInput>
  }

  export type PassengerRefundPaymentUncheckedUpdateOneWithoutCancellationNestedInput = {
    create?: XOR<PassengerRefundPaymentCreateWithoutCancellationInput, PassengerRefundPaymentUncheckedCreateWithoutCancellationInput>
    connectOrCreate?: PassengerRefundPaymentCreateOrConnectWithoutCancellationInput
    upsert?: PassengerRefundPaymentUpsertWithoutCancellationInput
    disconnect?: PassengerRefundPaymentWhereInput | boolean
    delete?: PassengerRefundPaymentWhereInput | boolean
    connect?: PassengerRefundPaymentWhereUniqueInput
    update?: XOR<XOR<PassengerRefundPaymentUpdateToOneWithWhereWithoutCancellationInput, PassengerRefundPaymentUpdateWithoutCancellationInput>, PassengerRefundPaymentUncheckedUpdateWithoutCancellationInput>
  }

  export type CustomerPayableUncheckedUpdateOneWithoutCreatedFromCancellationNestedInput = {
    create?: XOR<CustomerPayableCreateWithoutCreatedFromCancellationInput, CustomerPayableUncheckedCreateWithoutCreatedFromCancellationInput>
    connectOrCreate?: CustomerPayableCreateOrConnectWithoutCreatedFromCancellationInput
    upsert?: CustomerPayableUpsertWithoutCreatedFromCancellationInput
    disconnect?: CustomerPayableWhereInput | boolean
    delete?: CustomerPayableWhereInput | boolean
    connect?: CustomerPayableWhereUniqueInput
    update?: XOR<XOR<CustomerPayableUpdateToOneWithWhereWithoutCreatedFromCancellationInput, CustomerPayableUpdateWithoutCreatedFromCancellationInput>, CustomerPayableUncheckedUpdateWithoutCreatedFromCancellationInput>
  }

  export type SupplierPayableUncheckedUpdateOneWithoutCreatedFromCancellationNestedInput = {
    create?: XOR<SupplierPayableCreateWithoutCreatedFromCancellationInput, SupplierPayableUncheckedCreateWithoutCreatedFromCancellationInput>
    connectOrCreate?: SupplierPayableCreateOrConnectWithoutCreatedFromCancellationInput
    upsert?: SupplierPayableUpsertWithoutCreatedFromCancellationInput
    disconnect?: SupplierPayableWhereInput | boolean
    delete?: SupplierPayableWhereInput | boolean
    connect?: SupplierPayableWhereUniqueInput
    update?: XOR<XOR<SupplierPayableUpdateToOneWithWhereWithoutCreatedFromCancellationInput, SupplierPayableUpdateWithoutCreatedFromCancellationInput>, SupplierPayableUncheckedUpdateWithoutCreatedFromCancellationInput>
  }

  export type SupplierCreditNoteUncheckedUpdateOneWithoutGeneratedFromCancellationNestedInput = {
    create?: XOR<SupplierCreditNoteCreateWithoutGeneratedFromCancellationInput, SupplierCreditNoteUncheckedCreateWithoutGeneratedFromCancellationInput>
    connectOrCreate?: SupplierCreditNoteCreateOrConnectWithoutGeneratedFromCancellationInput
    upsert?: SupplierCreditNoteUpsertWithoutGeneratedFromCancellationInput
    disconnect?: SupplierCreditNoteWhereInput | boolean
    delete?: SupplierCreditNoteWhereInput | boolean
    connect?: SupplierCreditNoteWhereUniqueInput
    update?: XOR<XOR<SupplierCreditNoteUpdateToOneWithWhereWithoutGeneratedFromCancellationInput, SupplierCreditNoteUpdateWithoutGeneratedFromCancellationInput>, SupplierCreditNoteUncheckedUpdateWithoutGeneratedFromCancellationInput>
  }

  export type CancellationCreateNestedOneWithoutGeneratedCreditNoteInput = {
    create?: XOR<CancellationCreateWithoutGeneratedCreditNoteInput, CancellationUncheckedCreateWithoutGeneratedCreditNoteInput>
    connectOrCreate?: CancellationCreateOrConnectWithoutGeneratedCreditNoteInput
    connect?: CancellationWhereUniqueInput
  }

  export type CreditNoteUsageCreateNestedManyWithoutCreditNoteInput = {
    create?: XOR<CreditNoteUsageCreateWithoutCreditNoteInput, CreditNoteUsageUncheckedCreateWithoutCreditNoteInput> | CreditNoteUsageCreateWithoutCreditNoteInput[] | CreditNoteUsageUncheckedCreateWithoutCreditNoteInput[]
    connectOrCreate?: CreditNoteUsageCreateOrConnectWithoutCreditNoteInput | CreditNoteUsageCreateOrConnectWithoutCreditNoteInput[]
    createMany?: CreditNoteUsageCreateManyCreditNoteInputEnvelope
    connect?: CreditNoteUsageWhereUniqueInput | CreditNoteUsageWhereUniqueInput[]
  }

  export type CreditNoteUsageUncheckedCreateNestedManyWithoutCreditNoteInput = {
    create?: XOR<CreditNoteUsageCreateWithoutCreditNoteInput, CreditNoteUsageUncheckedCreateWithoutCreditNoteInput> | CreditNoteUsageCreateWithoutCreditNoteInput[] | CreditNoteUsageUncheckedCreateWithoutCreditNoteInput[]
    connectOrCreate?: CreditNoteUsageCreateOrConnectWithoutCreditNoteInput | CreditNoteUsageCreateOrConnectWithoutCreditNoteInput[]
    createMany?: CreditNoteUsageCreateManyCreditNoteInputEnvelope
    connect?: CreditNoteUsageWhereUniqueInput | CreditNoteUsageWhereUniqueInput[]
  }

  export type EnumCreditNoteStatusFieldUpdateOperationsInput = {
    set?: $Enums.CreditNoteStatus
  }

  export type CancellationUpdateOneRequiredWithoutGeneratedCreditNoteNestedInput = {
    create?: XOR<CancellationCreateWithoutGeneratedCreditNoteInput, CancellationUncheckedCreateWithoutGeneratedCreditNoteInput>
    connectOrCreate?: CancellationCreateOrConnectWithoutGeneratedCreditNoteInput
    upsert?: CancellationUpsertWithoutGeneratedCreditNoteInput
    connect?: CancellationWhereUniqueInput
    update?: XOR<XOR<CancellationUpdateToOneWithWhereWithoutGeneratedCreditNoteInput, CancellationUpdateWithoutGeneratedCreditNoteInput>, CancellationUncheckedUpdateWithoutGeneratedCreditNoteInput>
  }

  export type CreditNoteUsageUpdateManyWithoutCreditNoteNestedInput = {
    create?: XOR<CreditNoteUsageCreateWithoutCreditNoteInput, CreditNoteUsageUncheckedCreateWithoutCreditNoteInput> | CreditNoteUsageCreateWithoutCreditNoteInput[] | CreditNoteUsageUncheckedCreateWithoutCreditNoteInput[]
    connectOrCreate?: CreditNoteUsageCreateOrConnectWithoutCreditNoteInput | CreditNoteUsageCreateOrConnectWithoutCreditNoteInput[]
    upsert?: CreditNoteUsageUpsertWithWhereUniqueWithoutCreditNoteInput | CreditNoteUsageUpsertWithWhereUniqueWithoutCreditNoteInput[]
    createMany?: CreditNoteUsageCreateManyCreditNoteInputEnvelope
    set?: CreditNoteUsageWhereUniqueInput | CreditNoteUsageWhereUniqueInput[]
    disconnect?: CreditNoteUsageWhereUniqueInput | CreditNoteUsageWhereUniqueInput[]
    delete?: CreditNoteUsageWhereUniqueInput | CreditNoteUsageWhereUniqueInput[]
    connect?: CreditNoteUsageWhereUniqueInput | CreditNoteUsageWhereUniqueInput[]
    update?: CreditNoteUsageUpdateWithWhereUniqueWithoutCreditNoteInput | CreditNoteUsageUpdateWithWhereUniqueWithoutCreditNoteInput[]
    updateMany?: CreditNoteUsageUpdateManyWithWhereWithoutCreditNoteInput | CreditNoteUsageUpdateManyWithWhereWithoutCreditNoteInput[]
    deleteMany?: CreditNoteUsageScalarWhereInput | CreditNoteUsageScalarWhereInput[]
  }

  export type CreditNoteUsageUncheckedUpdateManyWithoutCreditNoteNestedInput = {
    create?: XOR<CreditNoteUsageCreateWithoutCreditNoteInput, CreditNoteUsageUncheckedCreateWithoutCreditNoteInput> | CreditNoteUsageCreateWithoutCreditNoteInput[] | CreditNoteUsageUncheckedCreateWithoutCreditNoteInput[]
    connectOrCreate?: CreditNoteUsageCreateOrConnectWithoutCreditNoteInput | CreditNoteUsageCreateOrConnectWithoutCreditNoteInput[]
    upsert?: CreditNoteUsageUpsertWithWhereUniqueWithoutCreditNoteInput | CreditNoteUsageUpsertWithWhereUniqueWithoutCreditNoteInput[]
    createMany?: CreditNoteUsageCreateManyCreditNoteInputEnvelope
    set?: CreditNoteUsageWhereUniqueInput | CreditNoteUsageWhereUniqueInput[]
    disconnect?: CreditNoteUsageWhereUniqueInput | CreditNoteUsageWhereUniqueInput[]
    delete?: CreditNoteUsageWhereUniqueInput | CreditNoteUsageWhereUniqueInput[]
    connect?: CreditNoteUsageWhereUniqueInput | CreditNoteUsageWhereUniqueInput[]
    update?: CreditNoteUsageUpdateWithWhereUniqueWithoutCreditNoteInput | CreditNoteUsageUpdateWithWhereUniqueWithoutCreditNoteInput[]
    updateMany?: CreditNoteUsageUpdateManyWithWhereWithoutCreditNoteInput | CreditNoteUsageUpdateManyWithWhereWithoutCreditNoteInput[]
    deleteMany?: CreditNoteUsageScalarWhereInput | CreditNoteUsageScalarWhereInput[]
  }

  export type SupplierCreditNoteCreateNestedOneWithoutUsageHistoryInput = {
    create?: XOR<SupplierCreditNoteCreateWithoutUsageHistoryInput, SupplierCreditNoteUncheckedCreateWithoutUsageHistoryInput>
    connectOrCreate?: SupplierCreditNoteCreateOrConnectWithoutUsageHistoryInput
    connect?: SupplierCreditNoteWhereUniqueInput
  }

  export type CostItemSupplierCreateNestedOneWithoutPaidByCreditNoteUsageInput = {
    create?: XOR<CostItemSupplierCreateWithoutPaidByCreditNoteUsageInput, CostItemSupplierUncheckedCreateWithoutPaidByCreditNoteUsageInput>
    connectOrCreate?: CostItemSupplierCreateOrConnectWithoutPaidByCreditNoteUsageInput
    connect?: CostItemSupplierWhereUniqueInput
  }

  export type SupplierCreditNoteUpdateOneRequiredWithoutUsageHistoryNestedInput = {
    create?: XOR<SupplierCreditNoteCreateWithoutUsageHistoryInput, SupplierCreditNoteUncheckedCreateWithoutUsageHistoryInput>
    connectOrCreate?: SupplierCreditNoteCreateOrConnectWithoutUsageHistoryInput
    upsert?: SupplierCreditNoteUpsertWithoutUsageHistoryInput
    connect?: SupplierCreditNoteWhereUniqueInput
    update?: XOR<XOR<SupplierCreditNoteUpdateToOneWithWhereWithoutUsageHistoryInput, SupplierCreditNoteUpdateWithoutUsageHistoryInput>, SupplierCreditNoteUncheckedUpdateWithoutUsageHistoryInput>
  }

  export type CostItemSupplierUpdateOneRequiredWithoutPaidByCreditNoteUsageNestedInput = {
    create?: XOR<CostItemSupplierCreateWithoutPaidByCreditNoteUsageInput, CostItemSupplierUncheckedCreateWithoutPaidByCreditNoteUsageInput>
    connectOrCreate?: CostItemSupplierCreateOrConnectWithoutPaidByCreditNoteUsageInput
    upsert?: CostItemSupplierUpsertWithoutPaidByCreditNoteUsageInput
    connect?: CostItemSupplierWhereUniqueInput
    update?: XOR<XOR<CostItemSupplierUpdateToOneWithWhereWithoutPaidByCreditNoteUsageInput, CostItemSupplierUpdateWithoutPaidByCreditNoteUsageInput>, CostItemSupplierUncheckedUpdateWithoutPaidByCreditNoteUsageInput>
  }

  export type CancellationCreateNestedOneWithoutCreatedPayableInput = {
    create?: XOR<CancellationCreateWithoutCreatedPayableInput, CancellationUncheckedCreateWithoutCreatedPayableInput>
    connectOrCreate?: CancellationCreateOrConnectWithoutCreatedPayableInput
    connect?: CancellationWhereUniqueInput
  }

  export type SupplierPayableSettlementCreateNestedManyWithoutPayableInput = {
    create?: XOR<SupplierPayableSettlementCreateWithoutPayableInput, SupplierPayableSettlementUncheckedCreateWithoutPayableInput> | SupplierPayableSettlementCreateWithoutPayableInput[] | SupplierPayableSettlementUncheckedCreateWithoutPayableInput[]
    connectOrCreate?: SupplierPayableSettlementCreateOrConnectWithoutPayableInput | SupplierPayableSettlementCreateOrConnectWithoutPayableInput[]
    createMany?: SupplierPayableSettlementCreateManyPayableInputEnvelope
    connect?: SupplierPayableSettlementWhereUniqueInput | SupplierPayableSettlementWhereUniqueInput[]
  }

  export type SupplierPayableSettlementUncheckedCreateNestedManyWithoutPayableInput = {
    create?: XOR<SupplierPayableSettlementCreateWithoutPayableInput, SupplierPayableSettlementUncheckedCreateWithoutPayableInput> | SupplierPayableSettlementCreateWithoutPayableInput[] | SupplierPayableSettlementUncheckedCreateWithoutPayableInput[]
    connectOrCreate?: SupplierPayableSettlementCreateOrConnectWithoutPayableInput | SupplierPayableSettlementCreateOrConnectWithoutPayableInput[]
    createMany?: SupplierPayableSettlementCreateManyPayableInputEnvelope
    connect?: SupplierPayableSettlementWhereUniqueInput | SupplierPayableSettlementWhereUniqueInput[]
  }

  export type CancellationUpdateOneRequiredWithoutCreatedPayableNestedInput = {
    create?: XOR<CancellationCreateWithoutCreatedPayableInput, CancellationUncheckedCreateWithoutCreatedPayableInput>
    connectOrCreate?: CancellationCreateOrConnectWithoutCreatedPayableInput
    upsert?: CancellationUpsertWithoutCreatedPayableInput
    connect?: CancellationWhereUniqueInput
    update?: XOR<XOR<CancellationUpdateToOneWithWhereWithoutCreatedPayableInput, CancellationUpdateWithoutCreatedPayableInput>, CancellationUncheckedUpdateWithoutCreatedPayableInput>
  }

  export type SupplierPayableSettlementUpdateManyWithoutPayableNestedInput = {
    create?: XOR<SupplierPayableSettlementCreateWithoutPayableInput, SupplierPayableSettlementUncheckedCreateWithoutPayableInput> | SupplierPayableSettlementCreateWithoutPayableInput[] | SupplierPayableSettlementUncheckedCreateWithoutPayableInput[]
    connectOrCreate?: SupplierPayableSettlementCreateOrConnectWithoutPayableInput | SupplierPayableSettlementCreateOrConnectWithoutPayableInput[]
    upsert?: SupplierPayableSettlementUpsertWithWhereUniqueWithoutPayableInput | SupplierPayableSettlementUpsertWithWhereUniqueWithoutPayableInput[]
    createMany?: SupplierPayableSettlementCreateManyPayableInputEnvelope
    set?: SupplierPayableSettlementWhereUniqueInput | SupplierPayableSettlementWhereUniqueInput[]
    disconnect?: SupplierPayableSettlementWhereUniqueInput | SupplierPayableSettlementWhereUniqueInput[]
    delete?: SupplierPayableSettlementWhereUniqueInput | SupplierPayableSettlementWhereUniqueInput[]
    connect?: SupplierPayableSettlementWhereUniqueInput | SupplierPayableSettlementWhereUniqueInput[]
    update?: SupplierPayableSettlementUpdateWithWhereUniqueWithoutPayableInput | SupplierPayableSettlementUpdateWithWhereUniqueWithoutPayableInput[]
    updateMany?: SupplierPayableSettlementUpdateManyWithWhereWithoutPayableInput | SupplierPayableSettlementUpdateManyWithWhereWithoutPayableInput[]
    deleteMany?: SupplierPayableSettlementScalarWhereInput | SupplierPayableSettlementScalarWhereInput[]
  }

  export type SupplierPayableSettlementUncheckedUpdateManyWithoutPayableNestedInput = {
    create?: XOR<SupplierPayableSettlementCreateWithoutPayableInput, SupplierPayableSettlementUncheckedCreateWithoutPayableInput> | SupplierPayableSettlementCreateWithoutPayableInput[] | SupplierPayableSettlementUncheckedCreateWithoutPayableInput[]
    connectOrCreate?: SupplierPayableSettlementCreateOrConnectWithoutPayableInput | SupplierPayableSettlementCreateOrConnectWithoutPayableInput[]
    upsert?: SupplierPayableSettlementUpsertWithWhereUniqueWithoutPayableInput | SupplierPayableSettlementUpsertWithWhereUniqueWithoutPayableInput[]
    createMany?: SupplierPayableSettlementCreateManyPayableInputEnvelope
    set?: SupplierPayableSettlementWhereUniqueInput | SupplierPayableSettlementWhereUniqueInput[]
    disconnect?: SupplierPayableSettlementWhereUniqueInput | SupplierPayableSettlementWhereUniqueInput[]
    delete?: SupplierPayableSettlementWhereUniqueInput | SupplierPayableSettlementWhereUniqueInput[]
    connect?: SupplierPayableSettlementWhereUniqueInput | SupplierPayableSettlementWhereUniqueInput[]
    update?: SupplierPayableSettlementUpdateWithWhereUniqueWithoutPayableInput | SupplierPayableSettlementUpdateWithWhereUniqueWithoutPayableInput[]
    updateMany?: SupplierPayableSettlementUpdateManyWithWhereWithoutPayableInput | SupplierPayableSettlementUpdateManyWithWhereWithoutPayableInput[]
    deleteMany?: SupplierPayableSettlementScalarWhereInput | SupplierPayableSettlementScalarWhereInput[]
  }

  export type SupplierPayableCreateNestedOneWithoutSettlementsInput = {
    create?: XOR<SupplierPayableCreateWithoutSettlementsInput, SupplierPayableUncheckedCreateWithoutSettlementsInput>
    connectOrCreate?: SupplierPayableCreateOrConnectWithoutSettlementsInput
    connect?: SupplierPayableWhereUniqueInput
  }

  export type SupplierPayableUpdateOneRequiredWithoutSettlementsNestedInput = {
    create?: XOR<SupplierPayableCreateWithoutSettlementsInput, SupplierPayableUncheckedCreateWithoutSettlementsInput>
    connectOrCreate?: SupplierPayableCreateOrConnectWithoutSettlementsInput
    upsert?: SupplierPayableUpsertWithoutSettlementsInput
    connect?: SupplierPayableWhereUniqueInput
    update?: XOR<XOR<SupplierPayableUpdateToOneWithWhereWithoutSettlementsInput, SupplierPayableUpdateWithoutSettlementsInput>, SupplierPayableUncheckedUpdateWithoutSettlementsInput>
  }

  export type CustomerPayableSettlementCreateNestedManyWithoutPayableInput = {
    create?: XOR<CustomerPayableSettlementCreateWithoutPayableInput, CustomerPayableSettlementUncheckedCreateWithoutPayableInput> | CustomerPayableSettlementCreateWithoutPayableInput[] | CustomerPayableSettlementUncheckedCreateWithoutPayableInput[]
    connectOrCreate?: CustomerPayableSettlementCreateOrConnectWithoutPayableInput | CustomerPayableSettlementCreateOrConnectWithoutPayableInput[]
    createMany?: CustomerPayableSettlementCreateManyPayableInputEnvelope
    connect?: CustomerPayableSettlementWhereUniqueInput | CustomerPayableSettlementWhereUniqueInput[]
  }

  export type CancellationCreateNestedOneWithoutCreatedCustomerPayableInput = {
    create?: XOR<CancellationCreateWithoutCreatedCustomerPayableInput, CancellationUncheckedCreateWithoutCreatedCustomerPayableInput>
    connectOrCreate?: CancellationCreateOrConnectWithoutCreatedCustomerPayableInput
    connect?: CancellationWhereUniqueInput
  }

  export type BookingCreateNestedOneWithoutCustomerPayablesInput = {
    create?: XOR<BookingCreateWithoutCustomerPayablesInput, BookingUncheckedCreateWithoutCustomerPayablesInput>
    connectOrCreate?: BookingCreateOrConnectWithoutCustomerPayablesInput
    connect?: BookingWhereUniqueInput
  }

  export type CustomerPayableSettlementUncheckedCreateNestedManyWithoutPayableInput = {
    create?: XOR<CustomerPayableSettlementCreateWithoutPayableInput, CustomerPayableSettlementUncheckedCreateWithoutPayableInput> | CustomerPayableSettlementCreateWithoutPayableInput[] | CustomerPayableSettlementUncheckedCreateWithoutPayableInput[]
    connectOrCreate?: CustomerPayableSettlementCreateOrConnectWithoutPayableInput | CustomerPayableSettlementCreateOrConnectWithoutPayableInput[]
    createMany?: CustomerPayableSettlementCreateManyPayableInputEnvelope
    connect?: CustomerPayableSettlementWhereUniqueInput | CustomerPayableSettlementWhereUniqueInput[]
  }

  export type CustomerPayableSettlementUpdateManyWithoutPayableNestedInput = {
    create?: XOR<CustomerPayableSettlementCreateWithoutPayableInput, CustomerPayableSettlementUncheckedCreateWithoutPayableInput> | CustomerPayableSettlementCreateWithoutPayableInput[] | CustomerPayableSettlementUncheckedCreateWithoutPayableInput[]
    connectOrCreate?: CustomerPayableSettlementCreateOrConnectWithoutPayableInput | CustomerPayableSettlementCreateOrConnectWithoutPayableInput[]
    upsert?: CustomerPayableSettlementUpsertWithWhereUniqueWithoutPayableInput | CustomerPayableSettlementUpsertWithWhereUniqueWithoutPayableInput[]
    createMany?: CustomerPayableSettlementCreateManyPayableInputEnvelope
    set?: CustomerPayableSettlementWhereUniqueInput | CustomerPayableSettlementWhereUniqueInput[]
    disconnect?: CustomerPayableSettlementWhereUniqueInput | CustomerPayableSettlementWhereUniqueInput[]
    delete?: CustomerPayableSettlementWhereUniqueInput | CustomerPayableSettlementWhereUniqueInput[]
    connect?: CustomerPayableSettlementWhereUniqueInput | CustomerPayableSettlementWhereUniqueInput[]
    update?: CustomerPayableSettlementUpdateWithWhereUniqueWithoutPayableInput | CustomerPayableSettlementUpdateWithWhereUniqueWithoutPayableInput[]
    updateMany?: CustomerPayableSettlementUpdateManyWithWhereWithoutPayableInput | CustomerPayableSettlementUpdateManyWithWhereWithoutPayableInput[]
    deleteMany?: CustomerPayableSettlementScalarWhereInput | CustomerPayableSettlementScalarWhereInput[]
  }

  export type CancellationUpdateOneRequiredWithoutCreatedCustomerPayableNestedInput = {
    create?: XOR<CancellationCreateWithoutCreatedCustomerPayableInput, CancellationUncheckedCreateWithoutCreatedCustomerPayableInput>
    connectOrCreate?: CancellationCreateOrConnectWithoutCreatedCustomerPayableInput
    upsert?: CancellationUpsertWithoutCreatedCustomerPayableInput
    connect?: CancellationWhereUniqueInput
    update?: XOR<XOR<CancellationUpdateToOneWithWhereWithoutCreatedCustomerPayableInput, CancellationUpdateWithoutCreatedCustomerPayableInput>, CancellationUncheckedUpdateWithoutCreatedCustomerPayableInput>
  }

  export type BookingUpdateOneRequiredWithoutCustomerPayablesNestedInput = {
    create?: XOR<BookingCreateWithoutCustomerPayablesInput, BookingUncheckedCreateWithoutCustomerPayablesInput>
    connectOrCreate?: BookingCreateOrConnectWithoutCustomerPayablesInput
    upsert?: BookingUpsertWithoutCustomerPayablesInput
    connect?: BookingWhereUniqueInput
    update?: XOR<XOR<BookingUpdateToOneWithWhereWithoutCustomerPayablesInput, BookingUpdateWithoutCustomerPayablesInput>, BookingUncheckedUpdateWithoutCustomerPayablesInput>
  }

  export type CustomerPayableSettlementUncheckedUpdateManyWithoutPayableNestedInput = {
    create?: XOR<CustomerPayableSettlementCreateWithoutPayableInput, CustomerPayableSettlementUncheckedCreateWithoutPayableInput> | CustomerPayableSettlementCreateWithoutPayableInput[] | CustomerPayableSettlementUncheckedCreateWithoutPayableInput[]
    connectOrCreate?: CustomerPayableSettlementCreateOrConnectWithoutPayableInput | CustomerPayableSettlementCreateOrConnectWithoutPayableInput[]
    upsert?: CustomerPayableSettlementUpsertWithWhereUniqueWithoutPayableInput | CustomerPayableSettlementUpsertWithWhereUniqueWithoutPayableInput[]
    createMany?: CustomerPayableSettlementCreateManyPayableInputEnvelope
    set?: CustomerPayableSettlementWhereUniqueInput | CustomerPayableSettlementWhereUniqueInput[]
    disconnect?: CustomerPayableSettlementWhereUniqueInput | CustomerPayableSettlementWhereUniqueInput[]
    delete?: CustomerPayableSettlementWhereUniqueInput | CustomerPayableSettlementWhereUniqueInput[]
    connect?: CustomerPayableSettlementWhereUniqueInput | CustomerPayableSettlementWhereUniqueInput[]
    update?: CustomerPayableSettlementUpdateWithWhereUniqueWithoutPayableInput | CustomerPayableSettlementUpdateWithWhereUniqueWithoutPayableInput[]
    updateMany?: CustomerPayableSettlementUpdateManyWithWhereWithoutPayableInput | CustomerPayableSettlementUpdateManyWithWhereWithoutPayableInput[]
    deleteMany?: CustomerPayableSettlementScalarWhereInput | CustomerPayableSettlementScalarWhereInput[]
  }

  export type CustomerPayableCreateNestedOneWithoutSettlementsInput = {
    create?: XOR<CustomerPayableCreateWithoutSettlementsInput, CustomerPayableUncheckedCreateWithoutSettlementsInput>
    connectOrCreate?: CustomerPayableCreateOrConnectWithoutSettlementsInput
    connect?: CustomerPayableWhereUniqueInput
  }

  export type CustomerPayableUpdateOneRequiredWithoutSettlementsNestedInput = {
    create?: XOR<CustomerPayableCreateWithoutSettlementsInput, CustomerPayableUncheckedCreateWithoutSettlementsInput>
    connectOrCreate?: CustomerPayableCreateOrConnectWithoutSettlementsInput
    upsert?: CustomerPayableUpsertWithoutSettlementsInput
    connect?: CustomerPayableWhereUniqueInput
    update?: XOR<XOR<CustomerPayableUpdateToOneWithWhereWithoutSettlementsInput, CustomerPayableUpdateWithoutSettlementsInput>, CustomerPayableUncheckedUpdateWithoutSettlementsInput>
  }

  export type CancellationCreateNestedOneWithoutRefundPaymentInput = {
    create?: XOR<CancellationCreateWithoutRefundPaymentInput, CancellationUncheckedCreateWithoutRefundPaymentInput>
    connectOrCreate?: CancellationCreateOrConnectWithoutRefundPaymentInput
    connect?: CancellationWhereUniqueInput
  }

  export type CancellationUpdateOneRequiredWithoutRefundPaymentNestedInput = {
    create?: XOR<CancellationCreateWithoutRefundPaymentInput, CancellationUncheckedCreateWithoutRefundPaymentInput>
    connectOrCreate?: CancellationCreateOrConnectWithoutRefundPaymentInput
    upsert?: CancellationUpsertWithoutRefundPaymentInput
    connect?: CancellationWhereUniqueInput
    update?: XOR<XOR<CancellationUpdateToOneWithWhereWithoutRefundPaymentInput, CancellationUpdateWithoutRefundPaymentInput>, CancellationUncheckedUpdateWithoutRefundPaymentInput>
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumActionTypeFieldUpdateOperationsInput = {
    set?: $Enums.ActionType
  }

  export type UserUpdateOneRequiredWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumTeamsNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Teams | EnumTeamsFieldRefInput<$PrismaModel> | null
    in?: $Enums.Teams[] | ListEnumTeamsFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Teams[] | ListEnumTeamsFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTeamsNullableFilter<$PrismaModel> | $Enums.Teams | null
  }

  export type NestedEnumBookingTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingType | EnumBookingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BookingType[] | ListEnumBookingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingType[] | ListEnumBookingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingTypeFilter<$PrismaModel> | $Enums.BookingType
  }

  export type NestedEnumBookingStatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumBookingStatusNullableFilter<$PrismaModel> | $Enums.BookingStatus | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedEnumTeamsNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Teams | EnumTeamsFieldRefInput<$PrismaModel> | null
    in?: $Enums.Teams[] | ListEnumTeamsFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Teams[] | ListEnumTeamsFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTeamsNullableWithAggregatesFilter<$PrismaModel> | $Enums.Teams | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumTeamsNullableFilter<$PrismaModel>
    _max?: NestedEnumTeamsNullableFilter<$PrismaModel>
  }

  export type NestedEnumBookingTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingType | EnumBookingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BookingType[] | ListEnumBookingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingType[] | ListEnumBookingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingTypeWithAggregatesFilter<$PrismaModel> | $Enums.BookingType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBookingTypeFilter<$PrismaModel>
    _max?: NestedEnumBookingTypeFilter<$PrismaModel>
  }

  export type NestedEnumBookingStatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumBookingStatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.BookingStatus | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumBookingStatusNullableFilter<$PrismaModel>
    _max?: NestedEnumBookingStatusNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedEnumPendingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PendingStatus | EnumPendingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PendingStatus[] | ListEnumPendingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PendingStatus[] | ListEnumPendingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPendingStatusFilter<$PrismaModel> | $Enums.PendingStatus
  }

  export type NestedEnumPendingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PendingStatus | EnumPendingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PendingStatus[] | ListEnumPendingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PendingStatus[] | ListEnumPendingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPendingStatusWithAggregatesFilter<$PrismaModel> | $Enums.PendingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPendingStatusFilter<$PrismaModel>
    _max?: NestedEnumPendingStatusFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumTitleNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Title | EnumTitleFieldRefInput<$PrismaModel> | null
    in?: $Enums.Title[] | ListEnumTitleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Title[] | ListEnumTitleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTitleNullableFilter<$PrismaModel> | $Enums.Title | null
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedEnumTitleNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Title | EnumTitleFieldRefInput<$PrismaModel> | null
    in?: $Enums.Title[] | ListEnumTitleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Title[] | ListEnumTitleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumTitleNullableWithAggregatesFilter<$PrismaModel> | $Enums.Title | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumTitleNullableFilter<$PrismaModel>
    _max?: NestedEnumTitleNullableFilter<$PrismaModel>
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedEnumTitleFilter<$PrismaModel = never> = {
    equals?: $Enums.Title | EnumTitleFieldRefInput<$PrismaModel>
    in?: $Enums.Title[] | ListEnumTitleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Title[] | ListEnumTitleFieldRefInput<$PrismaModel>
    not?: NestedEnumTitleFilter<$PrismaModel> | $Enums.Title
  }

  export type NestedEnumGenderFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderFilter<$PrismaModel> | $Enums.Gender
  }

  export type NestedEnumPassengerCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.PassengerCategory | EnumPassengerCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.PassengerCategory[] | ListEnumPassengerCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.PassengerCategory[] | ListEnumPassengerCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumPassengerCategoryFilter<$PrismaModel> | $Enums.PassengerCategory
  }

  export type NestedEnumTitleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Title | EnumTitleFieldRefInput<$PrismaModel>
    in?: $Enums.Title[] | ListEnumTitleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Title[] | ListEnumTitleFieldRefInput<$PrismaModel>
    not?: NestedEnumTitleWithAggregatesFilter<$PrismaModel> | $Enums.Title
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTitleFilter<$PrismaModel>
    _max?: NestedEnumTitleFilter<$PrismaModel>
  }

  export type NestedEnumGenderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderWithAggregatesFilter<$PrismaModel> | $Enums.Gender
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGenderFilter<$PrismaModel>
    _max?: NestedEnumGenderFilter<$PrismaModel>
  }

  export type NestedEnumPassengerCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PassengerCategory | EnumPassengerCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.PassengerCategory[] | ListEnumPassengerCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.PassengerCategory[] | ListEnumPassengerCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumPassengerCategoryWithAggregatesFilter<$PrismaModel> | $Enums.PassengerCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPassengerCategoryFilter<$PrismaModel>
    _max?: NestedEnumPassengerCategoryFilter<$PrismaModel>
  }

  export type NestedEnumSuppliersFilter<$PrismaModel = never> = {
    equals?: $Enums.Suppliers | EnumSuppliersFieldRefInput<$PrismaModel>
    in?: $Enums.Suppliers[] | ListEnumSuppliersFieldRefInput<$PrismaModel>
    notIn?: $Enums.Suppliers[] | ListEnumSuppliersFieldRefInput<$PrismaModel>
    not?: NestedEnumSuppliersFilter<$PrismaModel> | $Enums.Suppliers
  }

  export type NestedEnumSuppliersWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Suppliers | EnumSuppliersFieldRefInput<$PrismaModel>
    in?: $Enums.Suppliers[] | ListEnumSuppliersFieldRefInput<$PrismaModel>
    notIn?: $Enums.Suppliers[] | ListEnumSuppliersFieldRefInput<$PrismaModel>
    not?: NestedEnumSuppliersWithAggregatesFilter<$PrismaModel> | $Enums.Suppliers
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSuppliersFilter<$PrismaModel>
    _max?: NestedEnumSuppliersFilter<$PrismaModel>
  }

  export type NestedEnumCreditNoteStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CreditNoteStatus | EnumCreditNoteStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CreditNoteStatus[] | ListEnumCreditNoteStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CreditNoteStatus[] | ListEnumCreditNoteStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCreditNoteStatusFilter<$PrismaModel> | $Enums.CreditNoteStatus
  }

  export type NestedEnumCreditNoteStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CreditNoteStatus | EnumCreditNoteStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CreditNoteStatus[] | ListEnumCreditNoteStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CreditNoteStatus[] | ListEnumCreditNoteStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCreditNoteStatusWithAggregatesFilter<$PrismaModel> | $Enums.CreditNoteStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCreditNoteStatusFilter<$PrismaModel>
    _max?: NestedEnumCreditNoteStatusFilter<$PrismaModel>
  }

  export type NestedEnumActionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ActionType | EnumActionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActionType[] | ListEnumActionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActionType[] | ListEnumActionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActionTypeFilter<$PrismaModel> | $Enums.ActionType
  }

  export type NestedEnumActionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActionType | EnumActionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ActionType[] | ListEnumActionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActionType[] | ListEnumActionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumActionTypeWithAggregatesFilter<$PrismaModel> | $Enums.ActionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActionTypeFilter<$PrismaModel>
    _max?: NestedEnumActionTypeFilter<$PrismaModel>
  }

  export type CostItemCreateWithoutBookingInput = {
    category: string
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    suppliers?: CostItemSupplierCreateNestedManyWithoutCostItemInput
  }

  export type CostItemUncheckedCreateWithoutBookingInput = {
    id?: number
    category: string
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    suppliers?: CostItemSupplierUncheckedCreateNestedManyWithoutCostItemInput
  }

  export type CostItemCreateOrConnectWithoutBookingInput = {
    where: CostItemWhereUniqueInput
    create: XOR<CostItemCreateWithoutBookingInput, CostItemUncheckedCreateWithoutBookingInput>
  }

  export type CostItemCreateManyBookingInputEnvelope = {
    data: CostItemCreateManyBookingInput | CostItemCreateManyBookingInput[]
    skipDuplicates?: boolean
  }

  export type InstalmentCreateWithoutBookingInput = {
    dueDate: Date | string
    amount: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: InstalmentPaymentCreateNestedManyWithoutInstalmentInput
  }

  export type InstalmentUncheckedCreateWithoutBookingInput = {
    id?: number
    dueDate: Date | string
    amount: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: InstalmentPaymentUncheckedCreateNestedManyWithoutInstalmentInput
  }

  export type InstalmentCreateOrConnectWithoutBookingInput = {
    where: InstalmentWhereUniqueInput
    create: XOR<InstalmentCreateWithoutBookingInput, InstalmentUncheckedCreateWithoutBookingInput>
  }

  export type InstalmentCreateManyBookingInputEnvelope = {
    data: InstalmentCreateManyBookingInput | InstalmentCreateManyBookingInput[]
    skipDuplicates?: boolean
  }

  export type PassengerCreateWithoutBookingInput = {
    title: $Enums.Title
    firstName: string
    middleName?: string | null
    lastName: string
    gender: $Enums.Gender
    email?: string | null
    contactNo?: string | null
    nationality?: string | null
    birthday?: Date | string | null
    category: $Enums.PassengerCategory
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PassengerUncheckedCreateWithoutBookingInput = {
    id?: number
    title: $Enums.Title
    firstName: string
    middleName?: string | null
    lastName: string
    gender: $Enums.Gender
    email?: string | null
    contactNo?: string | null
    nationality?: string | null
    birthday?: Date | string | null
    category: $Enums.PassengerCategory
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PassengerCreateOrConnectWithoutBookingInput = {
    where: PassengerWhereUniqueInput
    create: XOR<PassengerCreateWithoutBookingInput, PassengerUncheckedCreateWithoutBookingInput>
  }

  export type PassengerCreateManyBookingInputEnvelope = {
    data: PassengerCreateManyBookingInput | PassengerCreateManyBookingInput[]
    skipDuplicates?: boolean
  }

  export type BookingCreateWithoutFollowUpBookingsInput = {
    folderNo: string
    refNo: string
    paxName: string
    agentName: string
    teamName?: $Enums.Teams | null
    pnr: string
    airline: string
    fromTo: string
    bookingType: $Enums.BookingType
    bookingStatus?: $Enums.BookingStatus | null
    pcDate: Date | string
    issuedDate?: Date | string | null
    paymentMethod: $Enums.PaymentMethod
    lastPaymentDate?: Date | string | null
    travelDate?: Date | string | null
    revenue?: number | null
    prodCost?: number | null
    transFee?: number | null
    surcharge?: number | null
    received?: number | null
    transactionMethod?: string | null
    receivedDate?: Date | string | null
    balance?: number | null
    profit?: number | null
    invoiced?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    numPax: number
    initialDeposit?: number | null
    statusBeforeVoid?: $Enums.BookingStatus | null
    voidReason?: string | null
    voidedAt?: Date | string | null
    costItems?: CostItemCreateNestedManyWithoutBookingInput
    instalments?: InstalmentCreateNestedManyWithoutBookingInput
    passengers?: PassengerCreateNestedManyWithoutBookingInput
    originalBooking?: BookingCreateNestedOneWithoutFollowUpBookingsInput
    voidedBy?: UserCreateNestedOneWithoutVoidedBookingsInput
    customerPayables?: CustomerPayableCreateNestedManyWithoutBookingInput
    cancellation?: CancellationCreateNestedOneWithoutOriginalBookingInput
  }

  export type BookingUncheckedCreateWithoutFollowUpBookingsInput = {
    id?: number
    folderNo: string
    refNo: string
    paxName: string
    agentName: string
    teamName?: $Enums.Teams | null
    pnr: string
    airline: string
    fromTo: string
    bookingType: $Enums.BookingType
    bookingStatus?: $Enums.BookingStatus | null
    pcDate: Date | string
    issuedDate?: Date | string | null
    paymentMethod: $Enums.PaymentMethod
    lastPaymentDate?: Date | string | null
    travelDate?: Date | string | null
    revenue?: number | null
    prodCost?: number | null
    transFee?: number | null
    surcharge?: number | null
    received?: number | null
    transactionMethod?: string | null
    receivedDate?: Date | string | null
    balance?: number | null
    profit?: number | null
    invoiced?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    numPax: number
    initialDeposit?: number | null
    originalBookingId?: number | null
    statusBeforeVoid?: $Enums.BookingStatus | null
    voidReason?: string | null
    voidedAt?: Date | string | null
    voidedById?: number | null
    costItems?: CostItemUncheckedCreateNestedManyWithoutBookingInput
    instalments?: InstalmentUncheckedCreateNestedManyWithoutBookingInput
    passengers?: PassengerUncheckedCreateNestedManyWithoutBookingInput
    customerPayables?: CustomerPayableUncheckedCreateNestedManyWithoutBookingInput
    cancellation?: CancellationUncheckedCreateNestedOneWithoutOriginalBookingInput
  }

  export type BookingCreateOrConnectWithoutFollowUpBookingsInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutFollowUpBookingsInput, BookingUncheckedCreateWithoutFollowUpBookingsInput>
  }

  export type BookingCreateWithoutOriginalBookingInput = {
    folderNo: string
    refNo: string
    paxName: string
    agentName: string
    teamName?: $Enums.Teams | null
    pnr: string
    airline: string
    fromTo: string
    bookingType: $Enums.BookingType
    bookingStatus?: $Enums.BookingStatus | null
    pcDate: Date | string
    issuedDate?: Date | string | null
    paymentMethod: $Enums.PaymentMethod
    lastPaymentDate?: Date | string | null
    travelDate?: Date | string | null
    revenue?: number | null
    prodCost?: number | null
    transFee?: number | null
    surcharge?: number | null
    received?: number | null
    transactionMethod?: string | null
    receivedDate?: Date | string | null
    balance?: number | null
    profit?: number | null
    invoiced?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    numPax: number
    initialDeposit?: number | null
    statusBeforeVoid?: $Enums.BookingStatus | null
    voidReason?: string | null
    voidedAt?: Date | string | null
    costItems?: CostItemCreateNestedManyWithoutBookingInput
    instalments?: InstalmentCreateNestedManyWithoutBookingInput
    passengers?: PassengerCreateNestedManyWithoutBookingInput
    followUpBookings?: BookingCreateNestedManyWithoutOriginalBookingInput
    voidedBy?: UserCreateNestedOneWithoutVoidedBookingsInput
    customerPayables?: CustomerPayableCreateNestedManyWithoutBookingInput
    cancellation?: CancellationCreateNestedOneWithoutOriginalBookingInput
  }

  export type BookingUncheckedCreateWithoutOriginalBookingInput = {
    id?: number
    folderNo: string
    refNo: string
    paxName: string
    agentName: string
    teamName?: $Enums.Teams | null
    pnr: string
    airline: string
    fromTo: string
    bookingType: $Enums.BookingType
    bookingStatus?: $Enums.BookingStatus | null
    pcDate: Date | string
    issuedDate?: Date | string | null
    paymentMethod: $Enums.PaymentMethod
    lastPaymentDate?: Date | string | null
    travelDate?: Date | string | null
    revenue?: number | null
    prodCost?: number | null
    transFee?: number | null
    surcharge?: number | null
    received?: number | null
    transactionMethod?: string | null
    receivedDate?: Date | string | null
    balance?: number | null
    profit?: number | null
    invoiced?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    numPax: number
    initialDeposit?: number | null
    statusBeforeVoid?: $Enums.BookingStatus | null
    voidReason?: string | null
    voidedAt?: Date | string | null
    voidedById?: number | null
    costItems?: CostItemUncheckedCreateNestedManyWithoutBookingInput
    instalments?: InstalmentUncheckedCreateNestedManyWithoutBookingInput
    passengers?: PassengerUncheckedCreateNestedManyWithoutBookingInput
    followUpBookings?: BookingUncheckedCreateNestedManyWithoutOriginalBookingInput
    customerPayables?: CustomerPayableUncheckedCreateNestedManyWithoutBookingInput
    cancellation?: CancellationUncheckedCreateNestedOneWithoutOriginalBookingInput
  }

  export type BookingCreateOrConnectWithoutOriginalBookingInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutOriginalBookingInput, BookingUncheckedCreateWithoutOriginalBookingInput>
  }

  export type BookingCreateManyOriginalBookingInputEnvelope = {
    data: BookingCreateManyOriginalBookingInput | BookingCreateManyOriginalBookingInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutVoidedBookingsInput = {
    email: string
    password: string
    title?: $Enums.Title | null
    firstName: string
    lastName: string
    contactNo?: string | null
    role: $Enums.Role
    team?: $Enums.Teams | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdPendingBookings?: PendingBookingCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutVoidedBookingsInput = {
    id?: number
    email: string
    password: string
    title?: $Enums.Title | null
    firstName: string
    lastName: string
    contactNo?: string | null
    role: $Enums.Role
    team?: $Enums.Teams | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdPendingBookings?: PendingBookingUncheckedCreateNestedManyWithoutCreatedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutVoidedBookingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutVoidedBookingsInput, UserUncheckedCreateWithoutVoidedBookingsInput>
  }

  export type CustomerPayableCreateWithoutBookingInput = {
    totalAmount: number
    paidAmount?: number
    pendingAmount: number
    reason: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    settlements?: CustomerPayableSettlementCreateNestedManyWithoutPayableInput
    createdFromCancellation: CancellationCreateNestedOneWithoutCreatedCustomerPayableInput
  }

  export type CustomerPayableUncheckedCreateWithoutBookingInput = {
    id?: number
    totalAmount: number
    paidAmount?: number
    pendingAmount: number
    reason: string
    status?: string
    createdFromCancellationId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    settlements?: CustomerPayableSettlementUncheckedCreateNestedManyWithoutPayableInput
  }

  export type CustomerPayableCreateOrConnectWithoutBookingInput = {
    where: CustomerPayableWhereUniqueInput
    create: XOR<CustomerPayableCreateWithoutBookingInput, CustomerPayableUncheckedCreateWithoutBookingInput>
  }

  export type CustomerPayableCreateManyBookingInputEnvelope = {
    data: CustomerPayableCreateManyBookingInput | CustomerPayableCreateManyBookingInput[]
    skipDuplicates?: boolean
  }

  export type CancellationCreateWithoutOriginalBookingInput = {
    folderNo: string
    refundTransactionMethod: string
    originalRevenue: number
    originalProdCost: number
    supplierCancellationFee: number
    refundToPassenger: number
    adminFee?: number
    refundStatus?: string
    creditNoteAmount?: number | null
    profitOrLoss: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    refundPayment?: PassengerRefundPaymentCreateNestedOneWithoutCancellationInput
    createdCustomerPayable?: CustomerPayableCreateNestedOneWithoutCreatedFromCancellationInput
    createdPayable?: SupplierPayableCreateNestedOneWithoutCreatedFromCancellationInput
    generatedCreditNote?: SupplierCreditNoteCreateNestedOneWithoutGeneratedFromCancellationInput
  }

  export type CancellationUncheckedCreateWithoutOriginalBookingInput = {
    id?: number
    folderNo: string
    refundTransactionMethod: string
    originalRevenue: number
    originalProdCost: number
    supplierCancellationFee: number
    refundToPassenger: number
    adminFee?: number
    refundStatus?: string
    creditNoteAmount?: number | null
    profitOrLoss: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    refundPayment?: PassengerRefundPaymentUncheckedCreateNestedOneWithoutCancellationInput
    createdCustomerPayable?: CustomerPayableUncheckedCreateNestedOneWithoutCreatedFromCancellationInput
    createdPayable?: SupplierPayableUncheckedCreateNestedOneWithoutCreatedFromCancellationInput
    generatedCreditNote?: SupplierCreditNoteUncheckedCreateNestedOneWithoutGeneratedFromCancellationInput
  }

  export type CancellationCreateOrConnectWithoutOriginalBookingInput = {
    where: CancellationWhereUniqueInput
    create: XOR<CancellationCreateWithoutOriginalBookingInput, CancellationUncheckedCreateWithoutOriginalBookingInput>
  }

  export type CostItemUpsertWithWhereUniqueWithoutBookingInput = {
    where: CostItemWhereUniqueInput
    update: XOR<CostItemUpdateWithoutBookingInput, CostItemUncheckedUpdateWithoutBookingInput>
    create: XOR<CostItemCreateWithoutBookingInput, CostItemUncheckedCreateWithoutBookingInput>
  }

  export type CostItemUpdateWithWhereUniqueWithoutBookingInput = {
    where: CostItemWhereUniqueInput
    data: XOR<CostItemUpdateWithoutBookingInput, CostItemUncheckedUpdateWithoutBookingInput>
  }

  export type CostItemUpdateManyWithWhereWithoutBookingInput = {
    where: CostItemScalarWhereInput
    data: XOR<CostItemUpdateManyMutationInput, CostItemUncheckedUpdateManyWithoutBookingInput>
  }

  export type CostItemScalarWhereInput = {
    AND?: CostItemScalarWhereInput | CostItemScalarWhereInput[]
    OR?: CostItemScalarWhereInput[]
    NOT?: CostItemScalarWhereInput | CostItemScalarWhereInput[]
    id?: IntFilter<"CostItem"> | number
    bookingId?: IntFilter<"CostItem"> | number
    category?: StringFilter<"CostItem"> | string
    amount?: FloatFilter<"CostItem"> | number
    createdAt?: DateTimeFilter<"CostItem"> | Date | string
    updatedAt?: DateTimeFilter<"CostItem"> | Date | string
  }

  export type InstalmentUpsertWithWhereUniqueWithoutBookingInput = {
    where: InstalmentWhereUniqueInput
    update: XOR<InstalmentUpdateWithoutBookingInput, InstalmentUncheckedUpdateWithoutBookingInput>
    create: XOR<InstalmentCreateWithoutBookingInput, InstalmentUncheckedCreateWithoutBookingInput>
  }

  export type InstalmentUpdateWithWhereUniqueWithoutBookingInput = {
    where: InstalmentWhereUniqueInput
    data: XOR<InstalmentUpdateWithoutBookingInput, InstalmentUncheckedUpdateWithoutBookingInput>
  }

  export type InstalmentUpdateManyWithWhereWithoutBookingInput = {
    where: InstalmentScalarWhereInput
    data: XOR<InstalmentUpdateManyMutationInput, InstalmentUncheckedUpdateManyWithoutBookingInput>
  }

  export type InstalmentScalarWhereInput = {
    AND?: InstalmentScalarWhereInput | InstalmentScalarWhereInput[]
    OR?: InstalmentScalarWhereInput[]
    NOT?: InstalmentScalarWhereInput | InstalmentScalarWhereInput[]
    id?: IntFilter<"Instalment"> | number
    bookingId?: IntFilter<"Instalment"> | number
    dueDate?: DateTimeFilter<"Instalment"> | Date | string
    amount?: FloatFilter<"Instalment"> | number
    status?: StringFilter<"Instalment"> | string
    createdAt?: DateTimeFilter<"Instalment"> | Date | string
    updatedAt?: DateTimeFilter<"Instalment"> | Date | string
  }

  export type PassengerUpsertWithWhereUniqueWithoutBookingInput = {
    where: PassengerWhereUniqueInput
    update: XOR<PassengerUpdateWithoutBookingInput, PassengerUncheckedUpdateWithoutBookingInput>
    create: XOR<PassengerCreateWithoutBookingInput, PassengerUncheckedCreateWithoutBookingInput>
  }

  export type PassengerUpdateWithWhereUniqueWithoutBookingInput = {
    where: PassengerWhereUniqueInput
    data: XOR<PassengerUpdateWithoutBookingInput, PassengerUncheckedUpdateWithoutBookingInput>
  }

  export type PassengerUpdateManyWithWhereWithoutBookingInput = {
    where: PassengerScalarWhereInput
    data: XOR<PassengerUpdateManyMutationInput, PassengerUncheckedUpdateManyWithoutBookingInput>
  }

  export type PassengerScalarWhereInput = {
    AND?: PassengerScalarWhereInput | PassengerScalarWhereInput[]
    OR?: PassengerScalarWhereInput[]
    NOT?: PassengerScalarWhereInput | PassengerScalarWhereInput[]
    id?: IntFilter<"Passenger"> | number
    bookingId?: IntFilter<"Passenger"> | number
    title?: EnumTitleFilter<"Passenger"> | $Enums.Title
    firstName?: StringFilter<"Passenger"> | string
    middleName?: StringNullableFilter<"Passenger"> | string | null
    lastName?: StringFilter<"Passenger"> | string
    gender?: EnumGenderFilter<"Passenger"> | $Enums.Gender
    email?: StringNullableFilter<"Passenger"> | string | null
    contactNo?: StringNullableFilter<"Passenger"> | string | null
    nationality?: StringNullableFilter<"Passenger"> | string | null
    birthday?: DateTimeNullableFilter<"Passenger"> | Date | string | null
    category?: EnumPassengerCategoryFilter<"Passenger"> | $Enums.PassengerCategory
    createdAt?: DateTimeFilter<"Passenger"> | Date | string
    updatedAt?: DateTimeFilter<"Passenger"> | Date | string
  }

  export type BookingUpsertWithoutFollowUpBookingsInput = {
    update: XOR<BookingUpdateWithoutFollowUpBookingsInput, BookingUncheckedUpdateWithoutFollowUpBookingsInput>
    create: XOR<BookingCreateWithoutFollowUpBookingsInput, BookingUncheckedCreateWithoutFollowUpBookingsInput>
    where?: BookingWhereInput
  }

  export type BookingUpdateToOneWithWhereWithoutFollowUpBookingsInput = {
    where?: BookingWhereInput
    data: XOR<BookingUpdateWithoutFollowUpBookingsInput, BookingUncheckedUpdateWithoutFollowUpBookingsInput>
  }

  export type BookingUpdateWithoutFollowUpBookingsInput = {
    folderNo?: StringFieldUpdateOperationsInput | string
    refNo?: StringFieldUpdateOperationsInput | string
    paxName?: StringFieldUpdateOperationsInput | string
    agentName?: StringFieldUpdateOperationsInput | string
    teamName?: NullableEnumTeamsFieldUpdateOperationsInput | $Enums.Teams | null
    pnr?: StringFieldUpdateOperationsInput | string
    airline?: StringFieldUpdateOperationsInput | string
    fromTo?: StringFieldUpdateOperationsInput | string
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    bookingStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    pcDate?: DateTimeFieldUpdateOperationsInput | Date | string
    issuedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    travelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    prodCost?: NullableFloatFieldUpdateOperationsInput | number | null
    transFee?: NullableFloatFieldUpdateOperationsInput | number | null
    surcharge?: NullableFloatFieldUpdateOperationsInput | number | null
    received?: NullableFloatFieldUpdateOperationsInput | number | null
    transactionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    profit?: NullableFloatFieldUpdateOperationsInput | number | null
    invoiced?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    numPax?: IntFieldUpdateOperationsInput | number
    initialDeposit?: NullableFloatFieldUpdateOperationsInput | number | null
    statusBeforeVoid?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    voidReason?: NullableStringFieldUpdateOperationsInput | string | null
    voidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    costItems?: CostItemUpdateManyWithoutBookingNestedInput
    instalments?: InstalmentUpdateManyWithoutBookingNestedInput
    passengers?: PassengerUpdateManyWithoutBookingNestedInput
    originalBooking?: BookingUpdateOneWithoutFollowUpBookingsNestedInput
    voidedBy?: UserUpdateOneWithoutVoidedBookingsNestedInput
    customerPayables?: CustomerPayableUpdateManyWithoutBookingNestedInput
    cancellation?: CancellationUpdateOneWithoutOriginalBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutFollowUpBookingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    folderNo?: StringFieldUpdateOperationsInput | string
    refNo?: StringFieldUpdateOperationsInput | string
    paxName?: StringFieldUpdateOperationsInput | string
    agentName?: StringFieldUpdateOperationsInput | string
    teamName?: NullableEnumTeamsFieldUpdateOperationsInput | $Enums.Teams | null
    pnr?: StringFieldUpdateOperationsInput | string
    airline?: StringFieldUpdateOperationsInput | string
    fromTo?: StringFieldUpdateOperationsInput | string
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    bookingStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    pcDate?: DateTimeFieldUpdateOperationsInput | Date | string
    issuedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    travelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    prodCost?: NullableFloatFieldUpdateOperationsInput | number | null
    transFee?: NullableFloatFieldUpdateOperationsInput | number | null
    surcharge?: NullableFloatFieldUpdateOperationsInput | number | null
    received?: NullableFloatFieldUpdateOperationsInput | number | null
    transactionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    profit?: NullableFloatFieldUpdateOperationsInput | number | null
    invoiced?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    numPax?: IntFieldUpdateOperationsInput | number
    initialDeposit?: NullableFloatFieldUpdateOperationsInput | number | null
    originalBookingId?: NullableIntFieldUpdateOperationsInput | number | null
    statusBeforeVoid?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    voidReason?: NullableStringFieldUpdateOperationsInput | string | null
    voidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    voidedById?: NullableIntFieldUpdateOperationsInput | number | null
    costItems?: CostItemUncheckedUpdateManyWithoutBookingNestedInput
    instalments?: InstalmentUncheckedUpdateManyWithoutBookingNestedInput
    passengers?: PassengerUncheckedUpdateManyWithoutBookingNestedInput
    customerPayables?: CustomerPayableUncheckedUpdateManyWithoutBookingNestedInput
    cancellation?: CancellationUncheckedUpdateOneWithoutOriginalBookingNestedInput
  }

  export type BookingUpsertWithWhereUniqueWithoutOriginalBookingInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutOriginalBookingInput, BookingUncheckedUpdateWithoutOriginalBookingInput>
    create: XOR<BookingCreateWithoutOriginalBookingInput, BookingUncheckedCreateWithoutOriginalBookingInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutOriginalBookingInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutOriginalBookingInput, BookingUncheckedUpdateWithoutOriginalBookingInput>
  }

  export type BookingUpdateManyWithWhereWithoutOriginalBookingInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutOriginalBookingInput>
  }

  export type BookingScalarWhereInput = {
    AND?: BookingScalarWhereInput | BookingScalarWhereInput[]
    OR?: BookingScalarWhereInput[]
    NOT?: BookingScalarWhereInput | BookingScalarWhereInput[]
    id?: IntFilter<"Booking"> | number
    folderNo?: StringFilter<"Booking"> | string
    refNo?: StringFilter<"Booking"> | string
    paxName?: StringFilter<"Booking"> | string
    agentName?: StringFilter<"Booking"> | string
    teamName?: EnumTeamsNullableFilter<"Booking"> | $Enums.Teams | null
    pnr?: StringFilter<"Booking"> | string
    airline?: StringFilter<"Booking"> | string
    fromTo?: StringFilter<"Booking"> | string
    bookingType?: EnumBookingTypeFilter<"Booking"> | $Enums.BookingType
    bookingStatus?: EnumBookingStatusNullableFilter<"Booking"> | $Enums.BookingStatus | null
    pcDate?: DateTimeFilter<"Booking"> | Date | string
    issuedDate?: DateTimeNullableFilter<"Booking"> | Date | string | null
    paymentMethod?: EnumPaymentMethodFilter<"Booking"> | $Enums.PaymentMethod
    lastPaymentDate?: DateTimeNullableFilter<"Booking"> | Date | string | null
    travelDate?: DateTimeNullableFilter<"Booking"> | Date | string | null
    revenue?: FloatNullableFilter<"Booking"> | number | null
    prodCost?: FloatNullableFilter<"Booking"> | number | null
    transFee?: FloatNullableFilter<"Booking"> | number | null
    surcharge?: FloatNullableFilter<"Booking"> | number | null
    received?: FloatNullableFilter<"Booking"> | number | null
    transactionMethod?: StringNullableFilter<"Booking"> | string | null
    receivedDate?: DateTimeNullableFilter<"Booking"> | Date | string | null
    balance?: FloatNullableFilter<"Booking"> | number | null
    profit?: FloatNullableFilter<"Booking"> | number | null
    invoiced?: StringNullableFilter<"Booking"> | string | null
    description?: StringNullableFilter<"Booking"> | string | null
    createdAt?: DateTimeFilter<"Booking"> | Date | string
    updatedAt?: DateTimeFilter<"Booking"> | Date | string
    numPax?: IntFilter<"Booking"> | number
    initialDeposit?: FloatNullableFilter<"Booking"> | number | null
    originalBookingId?: IntNullableFilter<"Booking"> | number | null
    statusBeforeVoid?: EnumBookingStatusNullableFilter<"Booking"> | $Enums.BookingStatus | null
    voidReason?: StringNullableFilter<"Booking"> | string | null
    voidedAt?: DateTimeNullableFilter<"Booking"> | Date | string | null
    voidedById?: IntNullableFilter<"Booking"> | number | null
  }

  export type UserUpsertWithoutVoidedBookingsInput = {
    update: XOR<UserUpdateWithoutVoidedBookingsInput, UserUncheckedUpdateWithoutVoidedBookingsInput>
    create: XOR<UserCreateWithoutVoidedBookingsInput, UserUncheckedCreateWithoutVoidedBookingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutVoidedBookingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutVoidedBookingsInput, UserUncheckedUpdateWithoutVoidedBookingsInput>
  }

  export type UserUpdateWithoutVoidedBookingsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    title?: NullableEnumTitleFieldUpdateOperationsInput | $Enums.Title | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    team?: NullableEnumTeamsFieldUpdateOperationsInput | $Enums.Teams | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdPendingBookings?: PendingBookingUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutVoidedBookingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    title?: NullableEnumTitleFieldUpdateOperationsInput | $Enums.Title | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    team?: NullableEnumTeamsFieldUpdateOperationsInput | $Enums.Teams | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdPendingBookings?: PendingBookingUncheckedUpdateManyWithoutCreatedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CustomerPayableUpsertWithWhereUniqueWithoutBookingInput = {
    where: CustomerPayableWhereUniqueInput
    update: XOR<CustomerPayableUpdateWithoutBookingInput, CustomerPayableUncheckedUpdateWithoutBookingInput>
    create: XOR<CustomerPayableCreateWithoutBookingInput, CustomerPayableUncheckedCreateWithoutBookingInput>
  }

  export type CustomerPayableUpdateWithWhereUniqueWithoutBookingInput = {
    where: CustomerPayableWhereUniqueInput
    data: XOR<CustomerPayableUpdateWithoutBookingInput, CustomerPayableUncheckedUpdateWithoutBookingInput>
  }

  export type CustomerPayableUpdateManyWithWhereWithoutBookingInput = {
    where: CustomerPayableScalarWhereInput
    data: XOR<CustomerPayableUpdateManyMutationInput, CustomerPayableUncheckedUpdateManyWithoutBookingInput>
  }

  export type CustomerPayableScalarWhereInput = {
    AND?: CustomerPayableScalarWhereInput | CustomerPayableScalarWhereInput[]
    OR?: CustomerPayableScalarWhereInput[]
    NOT?: CustomerPayableScalarWhereInput | CustomerPayableScalarWhereInput[]
    id?: IntFilter<"CustomerPayable"> | number
    totalAmount?: FloatFilter<"CustomerPayable"> | number
    paidAmount?: FloatFilter<"CustomerPayable"> | number
    pendingAmount?: FloatFilter<"CustomerPayable"> | number
    reason?: StringFilter<"CustomerPayable"> | string
    status?: StringFilter<"CustomerPayable"> | string
    createdFromCancellationId?: IntFilter<"CustomerPayable"> | number
    bookingId?: IntFilter<"CustomerPayable"> | number
    createdAt?: DateTimeFilter<"CustomerPayable"> | Date | string
    updatedAt?: DateTimeFilter<"CustomerPayable"> | Date | string
  }

  export type CancellationUpsertWithoutOriginalBookingInput = {
    update: XOR<CancellationUpdateWithoutOriginalBookingInput, CancellationUncheckedUpdateWithoutOriginalBookingInput>
    create: XOR<CancellationCreateWithoutOriginalBookingInput, CancellationUncheckedCreateWithoutOriginalBookingInput>
    where?: CancellationWhereInput
  }

  export type CancellationUpdateToOneWithWhereWithoutOriginalBookingInput = {
    where?: CancellationWhereInput
    data: XOR<CancellationUpdateWithoutOriginalBookingInput, CancellationUncheckedUpdateWithoutOriginalBookingInput>
  }

  export type CancellationUpdateWithoutOriginalBookingInput = {
    folderNo?: StringFieldUpdateOperationsInput | string
    refundTransactionMethod?: StringFieldUpdateOperationsInput | string
    originalRevenue?: FloatFieldUpdateOperationsInput | number
    originalProdCost?: FloatFieldUpdateOperationsInput | number
    supplierCancellationFee?: FloatFieldUpdateOperationsInput | number
    refundToPassenger?: FloatFieldUpdateOperationsInput | number
    adminFee?: FloatFieldUpdateOperationsInput | number
    refundStatus?: StringFieldUpdateOperationsInput | string
    creditNoteAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    profitOrLoss?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refundPayment?: PassengerRefundPaymentUpdateOneWithoutCancellationNestedInput
    createdCustomerPayable?: CustomerPayableUpdateOneWithoutCreatedFromCancellationNestedInput
    createdPayable?: SupplierPayableUpdateOneWithoutCreatedFromCancellationNestedInput
    generatedCreditNote?: SupplierCreditNoteUpdateOneWithoutGeneratedFromCancellationNestedInput
  }

  export type CancellationUncheckedUpdateWithoutOriginalBookingInput = {
    id?: IntFieldUpdateOperationsInput | number
    folderNo?: StringFieldUpdateOperationsInput | string
    refundTransactionMethod?: StringFieldUpdateOperationsInput | string
    originalRevenue?: FloatFieldUpdateOperationsInput | number
    originalProdCost?: FloatFieldUpdateOperationsInput | number
    supplierCancellationFee?: FloatFieldUpdateOperationsInput | number
    refundToPassenger?: FloatFieldUpdateOperationsInput | number
    adminFee?: FloatFieldUpdateOperationsInput | number
    refundStatus?: StringFieldUpdateOperationsInput | string
    creditNoteAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    profitOrLoss?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refundPayment?: PassengerRefundPaymentUncheckedUpdateOneWithoutCancellationNestedInput
    createdCustomerPayable?: CustomerPayableUncheckedUpdateOneWithoutCreatedFromCancellationNestedInput
    createdPayable?: SupplierPayableUncheckedUpdateOneWithoutCreatedFromCancellationNestedInput
    generatedCreditNote?: SupplierCreditNoteUncheckedUpdateOneWithoutGeneratedFromCancellationNestedInput
  }

  export type PendingCostItemCreateWithoutPendingBookingInput = {
    category: string
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    suppliers?: CostItemSupplierCreateNestedManyWithoutPendingCostItemInput
  }

  export type PendingCostItemUncheckedCreateWithoutPendingBookingInput = {
    id?: number
    category: string
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    suppliers?: CostItemSupplierUncheckedCreateNestedManyWithoutPendingCostItemInput
  }

  export type PendingCostItemCreateOrConnectWithoutPendingBookingInput = {
    where: PendingCostItemWhereUniqueInput
    create: XOR<PendingCostItemCreateWithoutPendingBookingInput, PendingCostItemUncheckedCreateWithoutPendingBookingInput>
  }

  export type PendingCostItemCreateManyPendingBookingInputEnvelope = {
    data: PendingCostItemCreateManyPendingBookingInput | PendingCostItemCreateManyPendingBookingInput[]
    skipDuplicates?: boolean
  }

  export type PendingInstalmentCreateWithoutPendingBookingInput = {
    dueDate: Date | string
    amount: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PendingInstalmentUncheckedCreateWithoutPendingBookingInput = {
    id?: number
    dueDate: Date | string
    amount: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PendingInstalmentCreateOrConnectWithoutPendingBookingInput = {
    where: PendingInstalmentWhereUniqueInput
    create: XOR<PendingInstalmentCreateWithoutPendingBookingInput, PendingInstalmentUncheckedCreateWithoutPendingBookingInput>
  }

  export type PendingInstalmentCreateManyPendingBookingInputEnvelope = {
    data: PendingInstalmentCreateManyPendingBookingInput | PendingInstalmentCreateManyPendingBookingInput[]
    skipDuplicates?: boolean
  }

  export type PendingPassengerCreateWithoutPendingBookingInput = {
    title: $Enums.Title
    firstName: string
    middleName?: string | null
    lastName: string
    gender: $Enums.Gender
    email?: string | null
    contactNo?: string | null
    nationality?: string | null
    birthday?: Date | string | null
    category: $Enums.PassengerCategory
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PendingPassengerUncheckedCreateWithoutPendingBookingInput = {
    id?: number
    title: $Enums.Title
    firstName: string
    middleName?: string | null
    lastName: string
    gender: $Enums.Gender
    email?: string | null
    contactNo?: string | null
    nationality?: string | null
    birthday?: Date | string | null
    category: $Enums.PassengerCategory
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PendingPassengerCreateOrConnectWithoutPendingBookingInput = {
    where: PendingPassengerWhereUniqueInput
    create: XOR<PendingPassengerCreateWithoutPendingBookingInput, PendingPassengerUncheckedCreateWithoutPendingBookingInput>
  }

  export type PendingPassengerCreateManyPendingBookingInputEnvelope = {
    data: PendingPassengerCreateManyPendingBookingInput | PendingPassengerCreateManyPendingBookingInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutCreatedPendingBookingsInput = {
    email: string
    password: string
    title?: $Enums.Title | null
    firstName: string
    lastName: string
    contactNo?: string | null
    role: $Enums.Role
    team?: $Enums.Teams | null
    createdAt?: Date | string
    updatedAt?: Date | string
    voidedBookings?: BookingCreateNestedManyWithoutVoidedByInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCreatedPendingBookingsInput = {
    id?: number
    email: string
    password: string
    title?: $Enums.Title | null
    firstName: string
    lastName: string
    contactNo?: string | null
    role: $Enums.Role
    team?: $Enums.Teams | null
    createdAt?: Date | string
    updatedAt?: Date | string
    voidedBookings?: BookingUncheckedCreateNestedManyWithoutVoidedByInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCreatedPendingBookingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCreatedPendingBookingsInput, UserUncheckedCreateWithoutCreatedPendingBookingsInput>
  }

  export type PendingCostItemUpsertWithWhereUniqueWithoutPendingBookingInput = {
    where: PendingCostItemWhereUniqueInput
    update: XOR<PendingCostItemUpdateWithoutPendingBookingInput, PendingCostItemUncheckedUpdateWithoutPendingBookingInput>
    create: XOR<PendingCostItemCreateWithoutPendingBookingInput, PendingCostItemUncheckedCreateWithoutPendingBookingInput>
  }

  export type PendingCostItemUpdateWithWhereUniqueWithoutPendingBookingInput = {
    where: PendingCostItemWhereUniqueInput
    data: XOR<PendingCostItemUpdateWithoutPendingBookingInput, PendingCostItemUncheckedUpdateWithoutPendingBookingInput>
  }

  export type PendingCostItemUpdateManyWithWhereWithoutPendingBookingInput = {
    where: PendingCostItemScalarWhereInput
    data: XOR<PendingCostItemUpdateManyMutationInput, PendingCostItemUncheckedUpdateManyWithoutPendingBookingInput>
  }

  export type PendingCostItemScalarWhereInput = {
    AND?: PendingCostItemScalarWhereInput | PendingCostItemScalarWhereInput[]
    OR?: PendingCostItemScalarWhereInput[]
    NOT?: PendingCostItemScalarWhereInput | PendingCostItemScalarWhereInput[]
    id?: IntFilter<"PendingCostItem"> | number
    pendingBookingId?: IntFilter<"PendingCostItem"> | number
    category?: StringFilter<"PendingCostItem"> | string
    amount?: FloatFilter<"PendingCostItem"> | number
    createdAt?: DateTimeFilter<"PendingCostItem"> | Date | string
    updatedAt?: DateTimeFilter<"PendingCostItem"> | Date | string
  }

  export type PendingInstalmentUpsertWithWhereUniqueWithoutPendingBookingInput = {
    where: PendingInstalmentWhereUniqueInput
    update: XOR<PendingInstalmentUpdateWithoutPendingBookingInput, PendingInstalmentUncheckedUpdateWithoutPendingBookingInput>
    create: XOR<PendingInstalmentCreateWithoutPendingBookingInput, PendingInstalmentUncheckedCreateWithoutPendingBookingInput>
  }

  export type PendingInstalmentUpdateWithWhereUniqueWithoutPendingBookingInput = {
    where: PendingInstalmentWhereUniqueInput
    data: XOR<PendingInstalmentUpdateWithoutPendingBookingInput, PendingInstalmentUncheckedUpdateWithoutPendingBookingInput>
  }

  export type PendingInstalmentUpdateManyWithWhereWithoutPendingBookingInput = {
    where: PendingInstalmentScalarWhereInput
    data: XOR<PendingInstalmentUpdateManyMutationInput, PendingInstalmentUncheckedUpdateManyWithoutPendingBookingInput>
  }

  export type PendingInstalmentScalarWhereInput = {
    AND?: PendingInstalmentScalarWhereInput | PendingInstalmentScalarWhereInput[]
    OR?: PendingInstalmentScalarWhereInput[]
    NOT?: PendingInstalmentScalarWhereInput | PendingInstalmentScalarWhereInput[]
    id?: IntFilter<"PendingInstalment"> | number
    pendingBookingId?: IntFilter<"PendingInstalment"> | number
    dueDate?: DateTimeFilter<"PendingInstalment"> | Date | string
    amount?: FloatFilter<"PendingInstalment"> | number
    status?: StringFilter<"PendingInstalment"> | string
    createdAt?: DateTimeFilter<"PendingInstalment"> | Date | string
    updatedAt?: DateTimeFilter<"PendingInstalment"> | Date | string
  }

  export type PendingPassengerUpsertWithWhereUniqueWithoutPendingBookingInput = {
    where: PendingPassengerWhereUniqueInput
    update: XOR<PendingPassengerUpdateWithoutPendingBookingInput, PendingPassengerUncheckedUpdateWithoutPendingBookingInput>
    create: XOR<PendingPassengerCreateWithoutPendingBookingInput, PendingPassengerUncheckedCreateWithoutPendingBookingInput>
  }

  export type PendingPassengerUpdateWithWhereUniqueWithoutPendingBookingInput = {
    where: PendingPassengerWhereUniqueInput
    data: XOR<PendingPassengerUpdateWithoutPendingBookingInput, PendingPassengerUncheckedUpdateWithoutPendingBookingInput>
  }

  export type PendingPassengerUpdateManyWithWhereWithoutPendingBookingInput = {
    where: PendingPassengerScalarWhereInput
    data: XOR<PendingPassengerUpdateManyMutationInput, PendingPassengerUncheckedUpdateManyWithoutPendingBookingInput>
  }

  export type PendingPassengerScalarWhereInput = {
    AND?: PendingPassengerScalarWhereInput | PendingPassengerScalarWhereInput[]
    OR?: PendingPassengerScalarWhereInput[]
    NOT?: PendingPassengerScalarWhereInput | PendingPassengerScalarWhereInput[]
    id?: IntFilter<"PendingPassenger"> | number
    pendingBookingId?: IntFilter<"PendingPassenger"> | number
    title?: EnumTitleFilter<"PendingPassenger"> | $Enums.Title
    firstName?: StringFilter<"PendingPassenger"> | string
    middleName?: StringNullableFilter<"PendingPassenger"> | string | null
    lastName?: StringFilter<"PendingPassenger"> | string
    gender?: EnumGenderFilter<"PendingPassenger"> | $Enums.Gender
    email?: StringNullableFilter<"PendingPassenger"> | string | null
    contactNo?: StringNullableFilter<"PendingPassenger"> | string | null
    nationality?: StringNullableFilter<"PendingPassenger"> | string | null
    birthday?: DateTimeNullableFilter<"PendingPassenger"> | Date | string | null
    category?: EnumPassengerCategoryFilter<"PendingPassenger"> | $Enums.PassengerCategory
    createdAt?: DateTimeFilter<"PendingPassenger"> | Date | string
    updatedAt?: DateTimeFilter<"PendingPassenger"> | Date | string
  }

  export type UserUpsertWithoutCreatedPendingBookingsInput = {
    update: XOR<UserUpdateWithoutCreatedPendingBookingsInput, UserUncheckedUpdateWithoutCreatedPendingBookingsInput>
    create: XOR<UserCreateWithoutCreatedPendingBookingsInput, UserUncheckedCreateWithoutCreatedPendingBookingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCreatedPendingBookingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCreatedPendingBookingsInput, UserUncheckedUpdateWithoutCreatedPendingBookingsInput>
  }

  export type UserUpdateWithoutCreatedPendingBookingsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    title?: NullableEnumTitleFieldUpdateOperationsInput | $Enums.Title | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    team?: NullableEnumTeamsFieldUpdateOperationsInput | $Enums.Teams | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    voidedBookings?: BookingUpdateManyWithoutVoidedByNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCreatedPendingBookingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    title?: NullableEnumTitleFieldUpdateOperationsInput | $Enums.Title | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    team?: NullableEnumTeamsFieldUpdateOperationsInput | $Enums.Teams | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    voidedBookings?: BookingUncheckedUpdateManyWithoutVoidedByNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BookingCreateWithoutInstalmentsInput = {
    folderNo: string
    refNo: string
    paxName: string
    agentName: string
    teamName?: $Enums.Teams | null
    pnr: string
    airline: string
    fromTo: string
    bookingType: $Enums.BookingType
    bookingStatus?: $Enums.BookingStatus | null
    pcDate: Date | string
    issuedDate?: Date | string | null
    paymentMethod: $Enums.PaymentMethod
    lastPaymentDate?: Date | string | null
    travelDate?: Date | string | null
    revenue?: number | null
    prodCost?: number | null
    transFee?: number | null
    surcharge?: number | null
    received?: number | null
    transactionMethod?: string | null
    receivedDate?: Date | string | null
    balance?: number | null
    profit?: number | null
    invoiced?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    numPax: number
    initialDeposit?: number | null
    statusBeforeVoid?: $Enums.BookingStatus | null
    voidReason?: string | null
    voidedAt?: Date | string | null
    costItems?: CostItemCreateNestedManyWithoutBookingInput
    passengers?: PassengerCreateNestedManyWithoutBookingInput
    originalBooking?: BookingCreateNestedOneWithoutFollowUpBookingsInput
    followUpBookings?: BookingCreateNestedManyWithoutOriginalBookingInput
    voidedBy?: UserCreateNestedOneWithoutVoidedBookingsInput
    customerPayables?: CustomerPayableCreateNestedManyWithoutBookingInput
    cancellation?: CancellationCreateNestedOneWithoutOriginalBookingInput
  }

  export type BookingUncheckedCreateWithoutInstalmentsInput = {
    id?: number
    folderNo: string
    refNo: string
    paxName: string
    agentName: string
    teamName?: $Enums.Teams | null
    pnr: string
    airline: string
    fromTo: string
    bookingType: $Enums.BookingType
    bookingStatus?: $Enums.BookingStatus | null
    pcDate: Date | string
    issuedDate?: Date | string | null
    paymentMethod: $Enums.PaymentMethod
    lastPaymentDate?: Date | string | null
    travelDate?: Date | string | null
    revenue?: number | null
    prodCost?: number | null
    transFee?: number | null
    surcharge?: number | null
    received?: number | null
    transactionMethod?: string | null
    receivedDate?: Date | string | null
    balance?: number | null
    profit?: number | null
    invoiced?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    numPax: number
    initialDeposit?: number | null
    originalBookingId?: number | null
    statusBeforeVoid?: $Enums.BookingStatus | null
    voidReason?: string | null
    voidedAt?: Date | string | null
    voidedById?: number | null
    costItems?: CostItemUncheckedCreateNestedManyWithoutBookingInput
    passengers?: PassengerUncheckedCreateNestedManyWithoutBookingInput
    followUpBookings?: BookingUncheckedCreateNestedManyWithoutOriginalBookingInput
    customerPayables?: CustomerPayableUncheckedCreateNestedManyWithoutBookingInput
    cancellation?: CancellationUncheckedCreateNestedOneWithoutOriginalBookingInput
  }

  export type BookingCreateOrConnectWithoutInstalmentsInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutInstalmentsInput, BookingUncheckedCreateWithoutInstalmentsInput>
  }

  export type InstalmentPaymentCreateWithoutInstalmentInput = {
    amount: number
    transactionMethod: string
    paymentDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InstalmentPaymentUncheckedCreateWithoutInstalmentInput = {
    id?: number
    amount: number
    transactionMethod: string
    paymentDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InstalmentPaymentCreateOrConnectWithoutInstalmentInput = {
    where: InstalmentPaymentWhereUniqueInput
    create: XOR<InstalmentPaymentCreateWithoutInstalmentInput, InstalmentPaymentUncheckedCreateWithoutInstalmentInput>
  }

  export type InstalmentPaymentCreateManyInstalmentInputEnvelope = {
    data: InstalmentPaymentCreateManyInstalmentInput | InstalmentPaymentCreateManyInstalmentInput[]
    skipDuplicates?: boolean
  }

  export type BookingUpsertWithoutInstalmentsInput = {
    update: XOR<BookingUpdateWithoutInstalmentsInput, BookingUncheckedUpdateWithoutInstalmentsInput>
    create: XOR<BookingCreateWithoutInstalmentsInput, BookingUncheckedCreateWithoutInstalmentsInput>
    where?: BookingWhereInput
  }

  export type BookingUpdateToOneWithWhereWithoutInstalmentsInput = {
    where?: BookingWhereInput
    data: XOR<BookingUpdateWithoutInstalmentsInput, BookingUncheckedUpdateWithoutInstalmentsInput>
  }

  export type BookingUpdateWithoutInstalmentsInput = {
    folderNo?: StringFieldUpdateOperationsInput | string
    refNo?: StringFieldUpdateOperationsInput | string
    paxName?: StringFieldUpdateOperationsInput | string
    agentName?: StringFieldUpdateOperationsInput | string
    teamName?: NullableEnumTeamsFieldUpdateOperationsInput | $Enums.Teams | null
    pnr?: StringFieldUpdateOperationsInput | string
    airline?: StringFieldUpdateOperationsInput | string
    fromTo?: StringFieldUpdateOperationsInput | string
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    bookingStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    pcDate?: DateTimeFieldUpdateOperationsInput | Date | string
    issuedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    travelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    prodCost?: NullableFloatFieldUpdateOperationsInput | number | null
    transFee?: NullableFloatFieldUpdateOperationsInput | number | null
    surcharge?: NullableFloatFieldUpdateOperationsInput | number | null
    received?: NullableFloatFieldUpdateOperationsInput | number | null
    transactionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    profit?: NullableFloatFieldUpdateOperationsInput | number | null
    invoiced?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    numPax?: IntFieldUpdateOperationsInput | number
    initialDeposit?: NullableFloatFieldUpdateOperationsInput | number | null
    statusBeforeVoid?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    voidReason?: NullableStringFieldUpdateOperationsInput | string | null
    voidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    costItems?: CostItemUpdateManyWithoutBookingNestedInput
    passengers?: PassengerUpdateManyWithoutBookingNestedInput
    originalBooking?: BookingUpdateOneWithoutFollowUpBookingsNestedInput
    followUpBookings?: BookingUpdateManyWithoutOriginalBookingNestedInput
    voidedBy?: UserUpdateOneWithoutVoidedBookingsNestedInput
    customerPayables?: CustomerPayableUpdateManyWithoutBookingNestedInput
    cancellation?: CancellationUpdateOneWithoutOriginalBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutInstalmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    folderNo?: StringFieldUpdateOperationsInput | string
    refNo?: StringFieldUpdateOperationsInput | string
    paxName?: StringFieldUpdateOperationsInput | string
    agentName?: StringFieldUpdateOperationsInput | string
    teamName?: NullableEnumTeamsFieldUpdateOperationsInput | $Enums.Teams | null
    pnr?: StringFieldUpdateOperationsInput | string
    airline?: StringFieldUpdateOperationsInput | string
    fromTo?: StringFieldUpdateOperationsInput | string
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    bookingStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    pcDate?: DateTimeFieldUpdateOperationsInput | Date | string
    issuedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    travelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    prodCost?: NullableFloatFieldUpdateOperationsInput | number | null
    transFee?: NullableFloatFieldUpdateOperationsInput | number | null
    surcharge?: NullableFloatFieldUpdateOperationsInput | number | null
    received?: NullableFloatFieldUpdateOperationsInput | number | null
    transactionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    profit?: NullableFloatFieldUpdateOperationsInput | number | null
    invoiced?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    numPax?: IntFieldUpdateOperationsInput | number
    initialDeposit?: NullableFloatFieldUpdateOperationsInput | number | null
    originalBookingId?: NullableIntFieldUpdateOperationsInput | number | null
    statusBeforeVoid?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    voidReason?: NullableStringFieldUpdateOperationsInput | string | null
    voidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    voidedById?: NullableIntFieldUpdateOperationsInput | number | null
    costItems?: CostItemUncheckedUpdateManyWithoutBookingNestedInput
    passengers?: PassengerUncheckedUpdateManyWithoutBookingNestedInput
    followUpBookings?: BookingUncheckedUpdateManyWithoutOriginalBookingNestedInput
    customerPayables?: CustomerPayableUncheckedUpdateManyWithoutBookingNestedInput
    cancellation?: CancellationUncheckedUpdateOneWithoutOriginalBookingNestedInput
  }

  export type InstalmentPaymentUpsertWithWhereUniqueWithoutInstalmentInput = {
    where: InstalmentPaymentWhereUniqueInput
    update: XOR<InstalmentPaymentUpdateWithoutInstalmentInput, InstalmentPaymentUncheckedUpdateWithoutInstalmentInput>
    create: XOR<InstalmentPaymentCreateWithoutInstalmentInput, InstalmentPaymentUncheckedCreateWithoutInstalmentInput>
  }

  export type InstalmentPaymentUpdateWithWhereUniqueWithoutInstalmentInput = {
    where: InstalmentPaymentWhereUniqueInput
    data: XOR<InstalmentPaymentUpdateWithoutInstalmentInput, InstalmentPaymentUncheckedUpdateWithoutInstalmentInput>
  }

  export type InstalmentPaymentUpdateManyWithWhereWithoutInstalmentInput = {
    where: InstalmentPaymentScalarWhereInput
    data: XOR<InstalmentPaymentUpdateManyMutationInput, InstalmentPaymentUncheckedUpdateManyWithoutInstalmentInput>
  }

  export type InstalmentPaymentScalarWhereInput = {
    AND?: InstalmentPaymentScalarWhereInput | InstalmentPaymentScalarWhereInput[]
    OR?: InstalmentPaymentScalarWhereInput[]
    NOT?: InstalmentPaymentScalarWhereInput | InstalmentPaymentScalarWhereInput[]
    id?: IntFilter<"InstalmentPayment"> | number
    instalmentId?: IntFilter<"InstalmentPayment"> | number
    amount?: FloatFilter<"InstalmentPayment"> | number
    transactionMethod?: StringFilter<"InstalmentPayment"> | string
    paymentDate?: DateTimeFilter<"InstalmentPayment"> | Date | string
    createdAt?: DateTimeFilter<"InstalmentPayment"> | Date | string
    updatedAt?: DateTimeFilter<"InstalmentPayment"> | Date | string
  }

  export type PendingBookingCreateWithoutInstalmentsInput = {
    refNo: string
    paxName: string
    agentName: string
    teamName?: $Enums.Teams | null
    pnr: string
    airline: string
    fromTo: string
    bookingType: $Enums.BookingType
    bookingStatus?: $Enums.BookingStatus | null
    pcDate: Date | string
    issuedDate?: Date | string | null
    paymentMethod: $Enums.PaymentMethod
    lastPaymentDate?: Date | string | null
    travelDate?: Date | string | null
    revenue?: number | null
    prodCost?: number | null
    transFee?: number | null
    surcharge?: number | null
    received?: number | null
    transactionMethod?: string | null
    receivedDate?: Date | string | null
    balance?: number | null
    profit?: number | null
    invoiced?: string | null
    description?: string | null
    status?: $Enums.PendingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    numPax: number
    costItems?: PendingCostItemCreateNestedManyWithoutPendingBookingInput
    passengers?: PendingPassengerCreateNestedManyWithoutPendingBookingInput
    createdBy: UserCreateNestedOneWithoutCreatedPendingBookingsInput
  }

  export type PendingBookingUncheckedCreateWithoutInstalmentsInput = {
    id?: number
    refNo: string
    paxName: string
    agentName: string
    teamName?: $Enums.Teams | null
    pnr: string
    airline: string
    fromTo: string
    bookingType: $Enums.BookingType
    bookingStatus?: $Enums.BookingStatus | null
    pcDate: Date | string
    issuedDate?: Date | string | null
    paymentMethod: $Enums.PaymentMethod
    lastPaymentDate?: Date | string | null
    travelDate?: Date | string | null
    revenue?: number | null
    prodCost?: number | null
    transFee?: number | null
    surcharge?: number | null
    received?: number | null
    transactionMethod?: string | null
    receivedDate?: Date | string | null
    balance?: number | null
    profit?: number | null
    invoiced?: string | null
    description?: string | null
    status?: $Enums.PendingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    numPax: number
    createdById: number
    costItems?: PendingCostItemUncheckedCreateNestedManyWithoutPendingBookingInput
    passengers?: PendingPassengerUncheckedCreateNestedManyWithoutPendingBookingInput
  }

  export type PendingBookingCreateOrConnectWithoutInstalmentsInput = {
    where: PendingBookingWhereUniqueInput
    create: XOR<PendingBookingCreateWithoutInstalmentsInput, PendingBookingUncheckedCreateWithoutInstalmentsInput>
  }

  export type PendingBookingUpsertWithoutInstalmentsInput = {
    update: XOR<PendingBookingUpdateWithoutInstalmentsInput, PendingBookingUncheckedUpdateWithoutInstalmentsInput>
    create: XOR<PendingBookingCreateWithoutInstalmentsInput, PendingBookingUncheckedCreateWithoutInstalmentsInput>
    where?: PendingBookingWhereInput
  }

  export type PendingBookingUpdateToOneWithWhereWithoutInstalmentsInput = {
    where?: PendingBookingWhereInput
    data: XOR<PendingBookingUpdateWithoutInstalmentsInput, PendingBookingUncheckedUpdateWithoutInstalmentsInput>
  }

  export type PendingBookingUpdateWithoutInstalmentsInput = {
    refNo?: StringFieldUpdateOperationsInput | string
    paxName?: StringFieldUpdateOperationsInput | string
    agentName?: StringFieldUpdateOperationsInput | string
    teamName?: NullableEnumTeamsFieldUpdateOperationsInput | $Enums.Teams | null
    pnr?: StringFieldUpdateOperationsInput | string
    airline?: StringFieldUpdateOperationsInput | string
    fromTo?: StringFieldUpdateOperationsInput | string
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    bookingStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    pcDate?: DateTimeFieldUpdateOperationsInput | Date | string
    issuedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    travelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    prodCost?: NullableFloatFieldUpdateOperationsInput | number | null
    transFee?: NullableFloatFieldUpdateOperationsInput | number | null
    surcharge?: NullableFloatFieldUpdateOperationsInput | number | null
    received?: NullableFloatFieldUpdateOperationsInput | number | null
    transactionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    profit?: NullableFloatFieldUpdateOperationsInput | number | null
    invoiced?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPendingStatusFieldUpdateOperationsInput | $Enums.PendingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    numPax?: IntFieldUpdateOperationsInput | number
    costItems?: PendingCostItemUpdateManyWithoutPendingBookingNestedInput
    passengers?: PendingPassengerUpdateManyWithoutPendingBookingNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedPendingBookingsNestedInput
  }

  export type PendingBookingUncheckedUpdateWithoutInstalmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    refNo?: StringFieldUpdateOperationsInput | string
    paxName?: StringFieldUpdateOperationsInput | string
    agentName?: StringFieldUpdateOperationsInput | string
    teamName?: NullableEnumTeamsFieldUpdateOperationsInput | $Enums.Teams | null
    pnr?: StringFieldUpdateOperationsInput | string
    airline?: StringFieldUpdateOperationsInput | string
    fromTo?: StringFieldUpdateOperationsInput | string
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    bookingStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    pcDate?: DateTimeFieldUpdateOperationsInput | Date | string
    issuedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    travelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    prodCost?: NullableFloatFieldUpdateOperationsInput | number | null
    transFee?: NullableFloatFieldUpdateOperationsInput | number | null
    surcharge?: NullableFloatFieldUpdateOperationsInput | number | null
    received?: NullableFloatFieldUpdateOperationsInput | number | null
    transactionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    profit?: NullableFloatFieldUpdateOperationsInput | number | null
    invoiced?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPendingStatusFieldUpdateOperationsInput | $Enums.PendingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    numPax?: IntFieldUpdateOperationsInput | number
    createdById?: IntFieldUpdateOperationsInput | number
    costItems?: PendingCostItemUncheckedUpdateManyWithoutPendingBookingNestedInput
    passengers?: PendingPassengerUncheckedUpdateManyWithoutPendingBookingNestedInput
  }

  export type InstalmentCreateWithoutPaymentsInput = {
    dueDate: Date | string
    amount: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    booking: BookingCreateNestedOneWithoutInstalmentsInput
  }

  export type InstalmentUncheckedCreateWithoutPaymentsInput = {
    id?: number
    bookingId: number
    dueDate: Date | string
    amount: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InstalmentCreateOrConnectWithoutPaymentsInput = {
    where: InstalmentWhereUniqueInput
    create: XOR<InstalmentCreateWithoutPaymentsInput, InstalmentUncheckedCreateWithoutPaymentsInput>
  }

  export type InstalmentUpsertWithoutPaymentsInput = {
    update: XOR<InstalmentUpdateWithoutPaymentsInput, InstalmentUncheckedUpdateWithoutPaymentsInput>
    create: XOR<InstalmentCreateWithoutPaymentsInput, InstalmentUncheckedCreateWithoutPaymentsInput>
    where?: InstalmentWhereInput
  }

  export type InstalmentUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: InstalmentWhereInput
    data: XOR<InstalmentUpdateWithoutPaymentsInput, InstalmentUncheckedUpdateWithoutPaymentsInput>
  }

  export type InstalmentUpdateWithoutPaymentsInput = {
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUpdateOneRequiredWithoutInstalmentsNestedInput
  }

  export type InstalmentUncheckedUpdateWithoutPaymentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookingId?: IntFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PendingBookingCreateWithoutCreatedByInput = {
    refNo: string
    paxName: string
    agentName: string
    teamName?: $Enums.Teams | null
    pnr: string
    airline: string
    fromTo: string
    bookingType: $Enums.BookingType
    bookingStatus?: $Enums.BookingStatus | null
    pcDate: Date | string
    issuedDate?: Date | string | null
    paymentMethod: $Enums.PaymentMethod
    lastPaymentDate?: Date | string | null
    travelDate?: Date | string | null
    revenue?: number | null
    prodCost?: number | null
    transFee?: number | null
    surcharge?: number | null
    received?: number | null
    transactionMethod?: string | null
    receivedDate?: Date | string | null
    balance?: number | null
    profit?: number | null
    invoiced?: string | null
    description?: string | null
    status?: $Enums.PendingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    numPax: number
    costItems?: PendingCostItemCreateNestedManyWithoutPendingBookingInput
    instalments?: PendingInstalmentCreateNestedManyWithoutPendingBookingInput
    passengers?: PendingPassengerCreateNestedManyWithoutPendingBookingInput
  }

  export type PendingBookingUncheckedCreateWithoutCreatedByInput = {
    id?: number
    refNo: string
    paxName: string
    agentName: string
    teamName?: $Enums.Teams | null
    pnr: string
    airline: string
    fromTo: string
    bookingType: $Enums.BookingType
    bookingStatus?: $Enums.BookingStatus | null
    pcDate: Date | string
    issuedDate?: Date | string | null
    paymentMethod: $Enums.PaymentMethod
    lastPaymentDate?: Date | string | null
    travelDate?: Date | string | null
    revenue?: number | null
    prodCost?: number | null
    transFee?: number | null
    surcharge?: number | null
    received?: number | null
    transactionMethod?: string | null
    receivedDate?: Date | string | null
    balance?: number | null
    profit?: number | null
    invoiced?: string | null
    description?: string | null
    status?: $Enums.PendingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    numPax: number
    costItems?: PendingCostItemUncheckedCreateNestedManyWithoutPendingBookingInput
    instalments?: PendingInstalmentUncheckedCreateNestedManyWithoutPendingBookingInput
    passengers?: PendingPassengerUncheckedCreateNestedManyWithoutPendingBookingInput
  }

  export type PendingBookingCreateOrConnectWithoutCreatedByInput = {
    where: PendingBookingWhereUniqueInput
    create: XOR<PendingBookingCreateWithoutCreatedByInput, PendingBookingUncheckedCreateWithoutCreatedByInput>
  }

  export type PendingBookingCreateManyCreatedByInputEnvelope = {
    data: PendingBookingCreateManyCreatedByInput | PendingBookingCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type BookingCreateWithoutVoidedByInput = {
    folderNo: string
    refNo: string
    paxName: string
    agentName: string
    teamName?: $Enums.Teams | null
    pnr: string
    airline: string
    fromTo: string
    bookingType: $Enums.BookingType
    bookingStatus?: $Enums.BookingStatus | null
    pcDate: Date | string
    issuedDate?: Date | string | null
    paymentMethod: $Enums.PaymentMethod
    lastPaymentDate?: Date | string | null
    travelDate?: Date | string | null
    revenue?: number | null
    prodCost?: number | null
    transFee?: number | null
    surcharge?: number | null
    received?: number | null
    transactionMethod?: string | null
    receivedDate?: Date | string | null
    balance?: number | null
    profit?: number | null
    invoiced?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    numPax: number
    initialDeposit?: number | null
    statusBeforeVoid?: $Enums.BookingStatus | null
    voidReason?: string | null
    voidedAt?: Date | string | null
    costItems?: CostItemCreateNestedManyWithoutBookingInput
    instalments?: InstalmentCreateNestedManyWithoutBookingInput
    passengers?: PassengerCreateNestedManyWithoutBookingInput
    originalBooking?: BookingCreateNestedOneWithoutFollowUpBookingsInput
    followUpBookings?: BookingCreateNestedManyWithoutOriginalBookingInput
    customerPayables?: CustomerPayableCreateNestedManyWithoutBookingInput
    cancellation?: CancellationCreateNestedOneWithoutOriginalBookingInput
  }

  export type BookingUncheckedCreateWithoutVoidedByInput = {
    id?: number
    folderNo: string
    refNo: string
    paxName: string
    agentName: string
    teamName?: $Enums.Teams | null
    pnr: string
    airline: string
    fromTo: string
    bookingType: $Enums.BookingType
    bookingStatus?: $Enums.BookingStatus | null
    pcDate: Date | string
    issuedDate?: Date | string | null
    paymentMethod: $Enums.PaymentMethod
    lastPaymentDate?: Date | string | null
    travelDate?: Date | string | null
    revenue?: number | null
    prodCost?: number | null
    transFee?: number | null
    surcharge?: number | null
    received?: number | null
    transactionMethod?: string | null
    receivedDate?: Date | string | null
    balance?: number | null
    profit?: number | null
    invoiced?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    numPax: number
    initialDeposit?: number | null
    originalBookingId?: number | null
    statusBeforeVoid?: $Enums.BookingStatus | null
    voidReason?: string | null
    voidedAt?: Date | string | null
    costItems?: CostItemUncheckedCreateNestedManyWithoutBookingInput
    instalments?: InstalmentUncheckedCreateNestedManyWithoutBookingInput
    passengers?: PassengerUncheckedCreateNestedManyWithoutBookingInput
    followUpBookings?: BookingUncheckedCreateNestedManyWithoutOriginalBookingInput
    customerPayables?: CustomerPayableUncheckedCreateNestedManyWithoutBookingInput
    cancellation?: CancellationUncheckedCreateNestedOneWithoutOriginalBookingInput
  }

  export type BookingCreateOrConnectWithoutVoidedByInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutVoidedByInput, BookingUncheckedCreateWithoutVoidedByInput>
  }

  export type BookingCreateManyVoidedByInputEnvelope = {
    data: BookingCreateManyVoidedByInput | BookingCreateManyVoidedByInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogCreateWithoutUserInput = {
    modelName: string
    recordId: number
    action: $Enums.ActionType
    fieldName?: string | null
    oldValue?: string | null
    newValue?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: number
    modelName: string
    recordId: number
    action: $Enums.ActionType
    fieldName?: string | null
    oldValue?: string | null
    newValue?: string | null
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PendingBookingUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: PendingBookingWhereUniqueInput
    update: XOR<PendingBookingUpdateWithoutCreatedByInput, PendingBookingUncheckedUpdateWithoutCreatedByInput>
    create: XOR<PendingBookingCreateWithoutCreatedByInput, PendingBookingUncheckedCreateWithoutCreatedByInput>
  }

  export type PendingBookingUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: PendingBookingWhereUniqueInput
    data: XOR<PendingBookingUpdateWithoutCreatedByInput, PendingBookingUncheckedUpdateWithoutCreatedByInput>
  }

  export type PendingBookingUpdateManyWithWhereWithoutCreatedByInput = {
    where: PendingBookingScalarWhereInput
    data: XOR<PendingBookingUpdateManyMutationInput, PendingBookingUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type PendingBookingScalarWhereInput = {
    AND?: PendingBookingScalarWhereInput | PendingBookingScalarWhereInput[]
    OR?: PendingBookingScalarWhereInput[]
    NOT?: PendingBookingScalarWhereInput | PendingBookingScalarWhereInput[]
    id?: IntFilter<"PendingBooking"> | number
    refNo?: StringFilter<"PendingBooking"> | string
    paxName?: StringFilter<"PendingBooking"> | string
    agentName?: StringFilter<"PendingBooking"> | string
    teamName?: EnumTeamsNullableFilter<"PendingBooking"> | $Enums.Teams | null
    pnr?: StringFilter<"PendingBooking"> | string
    airline?: StringFilter<"PendingBooking"> | string
    fromTo?: StringFilter<"PendingBooking"> | string
    bookingType?: EnumBookingTypeFilter<"PendingBooking"> | $Enums.BookingType
    bookingStatus?: EnumBookingStatusNullableFilter<"PendingBooking"> | $Enums.BookingStatus | null
    pcDate?: DateTimeFilter<"PendingBooking"> | Date | string
    issuedDate?: DateTimeNullableFilter<"PendingBooking"> | Date | string | null
    paymentMethod?: EnumPaymentMethodFilter<"PendingBooking"> | $Enums.PaymentMethod
    lastPaymentDate?: DateTimeNullableFilter<"PendingBooking"> | Date | string | null
    travelDate?: DateTimeNullableFilter<"PendingBooking"> | Date | string | null
    revenue?: FloatNullableFilter<"PendingBooking"> | number | null
    prodCost?: FloatNullableFilter<"PendingBooking"> | number | null
    transFee?: FloatNullableFilter<"PendingBooking"> | number | null
    surcharge?: FloatNullableFilter<"PendingBooking"> | number | null
    received?: FloatNullableFilter<"PendingBooking"> | number | null
    transactionMethod?: StringNullableFilter<"PendingBooking"> | string | null
    receivedDate?: DateTimeNullableFilter<"PendingBooking"> | Date | string | null
    balance?: FloatNullableFilter<"PendingBooking"> | number | null
    profit?: FloatNullableFilter<"PendingBooking"> | number | null
    invoiced?: StringNullableFilter<"PendingBooking"> | string | null
    description?: StringNullableFilter<"PendingBooking"> | string | null
    status?: EnumPendingStatusFilter<"PendingBooking"> | $Enums.PendingStatus
    createdAt?: DateTimeFilter<"PendingBooking"> | Date | string
    updatedAt?: DateTimeFilter<"PendingBooking"> | Date | string
    numPax?: IntFilter<"PendingBooking"> | number
    createdById?: IntFilter<"PendingBooking"> | number
  }

  export type BookingUpsertWithWhereUniqueWithoutVoidedByInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutVoidedByInput, BookingUncheckedUpdateWithoutVoidedByInput>
    create: XOR<BookingCreateWithoutVoidedByInput, BookingUncheckedCreateWithoutVoidedByInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutVoidedByInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutVoidedByInput, BookingUncheckedUpdateWithoutVoidedByInput>
  }

  export type BookingUpdateManyWithWhereWithoutVoidedByInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutVoidedByInput>
  }

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: IntFilter<"AuditLog"> | number
    modelName?: StringFilter<"AuditLog"> | string
    recordId?: IntFilter<"AuditLog"> | number
    userId?: IntFilter<"AuditLog"> | number
    action?: EnumActionTypeFilter<"AuditLog"> | $Enums.ActionType
    fieldName?: StringNullableFilter<"AuditLog"> | string | null
    oldValue?: StringNullableFilter<"AuditLog"> | string | null
    newValue?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type BookingCreateWithoutCostItemsInput = {
    folderNo: string
    refNo: string
    paxName: string
    agentName: string
    teamName?: $Enums.Teams | null
    pnr: string
    airline: string
    fromTo: string
    bookingType: $Enums.BookingType
    bookingStatus?: $Enums.BookingStatus | null
    pcDate: Date | string
    issuedDate?: Date | string | null
    paymentMethod: $Enums.PaymentMethod
    lastPaymentDate?: Date | string | null
    travelDate?: Date | string | null
    revenue?: number | null
    prodCost?: number | null
    transFee?: number | null
    surcharge?: number | null
    received?: number | null
    transactionMethod?: string | null
    receivedDate?: Date | string | null
    balance?: number | null
    profit?: number | null
    invoiced?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    numPax: number
    initialDeposit?: number | null
    statusBeforeVoid?: $Enums.BookingStatus | null
    voidReason?: string | null
    voidedAt?: Date | string | null
    instalments?: InstalmentCreateNestedManyWithoutBookingInput
    passengers?: PassengerCreateNestedManyWithoutBookingInput
    originalBooking?: BookingCreateNestedOneWithoutFollowUpBookingsInput
    followUpBookings?: BookingCreateNestedManyWithoutOriginalBookingInput
    voidedBy?: UserCreateNestedOneWithoutVoidedBookingsInput
    customerPayables?: CustomerPayableCreateNestedManyWithoutBookingInput
    cancellation?: CancellationCreateNestedOneWithoutOriginalBookingInput
  }

  export type BookingUncheckedCreateWithoutCostItemsInput = {
    id?: number
    folderNo: string
    refNo: string
    paxName: string
    agentName: string
    teamName?: $Enums.Teams | null
    pnr: string
    airline: string
    fromTo: string
    bookingType: $Enums.BookingType
    bookingStatus?: $Enums.BookingStatus | null
    pcDate: Date | string
    issuedDate?: Date | string | null
    paymentMethod: $Enums.PaymentMethod
    lastPaymentDate?: Date | string | null
    travelDate?: Date | string | null
    revenue?: number | null
    prodCost?: number | null
    transFee?: number | null
    surcharge?: number | null
    received?: number | null
    transactionMethod?: string | null
    receivedDate?: Date | string | null
    balance?: number | null
    profit?: number | null
    invoiced?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    numPax: number
    initialDeposit?: number | null
    originalBookingId?: number | null
    statusBeforeVoid?: $Enums.BookingStatus | null
    voidReason?: string | null
    voidedAt?: Date | string | null
    voidedById?: number | null
    instalments?: InstalmentUncheckedCreateNestedManyWithoutBookingInput
    passengers?: PassengerUncheckedCreateNestedManyWithoutBookingInput
    followUpBookings?: BookingUncheckedCreateNestedManyWithoutOriginalBookingInput
    customerPayables?: CustomerPayableUncheckedCreateNestedManyWithoutBookingInput
    cancellation?: CancellationUncheckedCreateNestedOneWithoutOriginalBookingInput
  }

  export type BookingCreateOrConnectWithoutCostItemsInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutCostItemsInput, BookingUncheckedCreateWithoutCostItemsInput>
  }

  export type CostItemSupplierCreateWithoutCostItemInput = {
    supplier: $Enums.Suppliers
    amount: number
    paymentMethod?: string
    paidAmount?: number
    pendingAmount?: number
    transactionMethod?: string | null
    firstMethodAmount?: number | null
    secondMethodAmount?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pendingCostItem?: PendingCostItemCreateNestedOneWithoutSuppliersInput
    settlements?: SupplierPaymentSettlementCreateNestedManyWithoutCostItemSupplierInput
    paidByCreditNoteUsage?: CreditNoteUsageCreateNestedManyWithoutUsedOnCostItemSupplierInput
  }

  export type CostItemSupplierUncheckedCreateWithoutCostItemInput = {
    id?: number
    pendingCostItemId?: number | null
    supplier: $Enums.Suppliers
    amount: number
    paymentMethod?: string
    paidAmount?: number
    pendingAmount?: number
    transactionMethod?: string | null
    firstMethodAmount?: number | null
    secondMethodAmount?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    settlements?: SupplierPaymentSettlementUncheckedCreateNestedManyWithoutCostItemSupplierInput
    paidByCreditNoteUsage?: CreditNoteUsageUncheckedCreateNestedManyWithoutUsedOnCostItemSupplierInput
  }

  export type CostItemSupplierCreateOrConnectWithoutCostItemInput = {
    where: CostItemSupplierWhereUniqueInput
    create: XOR<CostItemSupplierCreateWithoutCostItemInput, CostItemSupplierUncheckedCreateWithoutCostItemInput>
  }

  export type CostItemSupplierCreateManyCostItemInputEnvelope = {
    data: CostItemSupplierCreateManyCostItemInput | CostItemSupplierCreateManyCostItemInput[]
    skipDuplicates?: boolean
  }

  export type BookingUpsertWithoutCostItemsInput = {
    update: XOR<BookingUpdateWithoutCostItemsInput, BookingUncheckedUpdateWithoutCostItemsInput>
    create: XOR<BookingCreateWithoutCostItemsInput, BookingUncheckedCreateWithoutCostItemsInput>
    where?: BookingWhereInput
  }

  export type BookingUpdateToOneWithWhereWithoutCostItemsInput = {
    where?: BookingWhereInput
    data: XOR<BookingUpdateWithoutCostItemsInput, BookingUncheckedUpdateWithoutCostItemsInput>
  }

  export type BookingUpdateWithoutCostItemsInput = {
    folderNo?: StringFieldUpdateOperationsInput | string
    refNo?: StringFieldUpdateOperationsInput | string
    paxName?: StringFieldUpdateOperationsInput | string
    agentName?: StringFieldUpdateOperationsInput | string
    teamName?: NullableEnumTeamsFieldUpdateOperationsInput | $Enums.Teams | null
    pnr?: StringFieldUpdateOperationsInput | string
    airline?: StringFieldUpdateOperationsInput | string
    fromTo?: StringFieldUpdateOperationsInput | string
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    bookingStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    pcDate?: DateTimeFieldUpdateOperationsInput | Date | string
    issuedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    travelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    prodCost?: NullableFloatFieldUpdateOperationsInput | number | null
    transFee?: NullableFloatFieldUpdateOperationsInput | number | null
    surcharge?: NullableFloatFieldUpdateOperationsInput | number | null
    received?: NullableFloatFieldUpdateOperationsInput | number | null
    transactionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    profit?: NullableFloatFieldUpdateOperationsInput | number | null
    invoiced?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    numPax?: IntFieldUpdateOperationsInput | number
    initialDeposit?: NullableFloatFieldUpdateOperationsInput | number | null
    statusBeforeVoid?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    voidReason?: NullableStringFieldUpdateOperationsInput | string | null
    voidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    instalments?: InstalmentUpdateManyWithoutBookingNestedInput
    passengers?: PassengerUpdateManyWithoutBookingNestedInput
    originalBooking?: BookingUpdateOneWithoutFollowUpBookingsNestedInput
    followUpBookings?: BookingUpdateManyWithoutOriginalBookingNestedInput
    voidedBy?: UserUpdateOneWithoutVoidedBookingsNestedInput
    customerPayables?: CustomerPayableUpdateManyWithoutBookingNestedInput
    cancellation?: CancellationUpdateOneWithoutOriginalBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutCostItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    folderNo?: StringFieldUpdateOperationsInput | string
    refNo?: StringFieldUpdateOperationsInput | string
    paxName?: StringFieldUpdateOperationsInput | string
    agentName?: StringFieldUpdateOperationsInput | string
    teamName?: NullableEnumTeamsFieldUpdateOperationsInput | $Enums.Teams | null
    pnr?: StringFieldUpdateOperationsInput | string
    airline?: StringFieldUpdateOperationsInput | string
    fromTo?: StringFieldUpdateOperationsInput | string
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    bookingStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    pcDate?: DateTimeFieldUpdateOperationsInput | Date | string
    issuedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    travelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    prodCost?: NullableFloatFieldUpdateOperationsInput | number | null
    transFee?: NullableFloatFieldUpdateOperationsInput | number | null
    surcharge?: NullableFloatFieldUpdateOperationsInput | number | null
    received?: NullableFloatFieldUpdateOperationsInput | number | null
    transactionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    profit?: NullableFloatFieldUpdateOperationsInput | number | null
    invoiced?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    numPax?: IntFieldUpdateOperationsInput | number
    initialDeposit?: NullableFloatFieldUpdateOperationsInput | number | null
    originalBookingId?: NullableIntFieldUpdateOperationsInput | number | null
    statusBeforeVoid?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    voidReason?: NullableStringFieldUpdateOperationsInput | string | null
    voidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    voidedById?: NullableIntFieldUpdateOperationsInput | number | null
    instalments?: InstalmentUncheckedUpdateManyWithoutBookingNestedInput
    passengers?: PassengerUncheckedUpdateManyWithoutBookingNestedInput
    followUpBookings?: BookingUncheckedUpdateManyWithoutOriginalBookingNestedInput
    customerPayables?: CustomerPayableUncheckedUpdateManyWithoutBookingNestedInput
    cancellation?: CancellationUncheckedUpdateOneWithoutOriginalBookingNestedInput
  }

  export type CostItemSupplierUpsertWithWhereUniqueWithoutCostItemInput = {
    where: CostItemSupplierWhereUniqueInput
    update: XOR<CostItemSupplierUpdateWithoutCostItemInput, CostItemSupplierUncheckedUpdateWithoutCostItemInput>
    create: XOR<CostItemSupplierCreateWithoutCostItemInput, CostItemSupplierUncheckedCreateWithoutCostItemInput>
  }

  export type CostItemSupplierUpdateWithWhereUniqueWithoutCostItemInput = {
    where: CostItemSupplierWhereUniqueInput
    data: XOR<CostItemSupplierUpdateWithoutCostItemInput, CostItemSupplierUncheckedUpdateWithoutCostItemInput>
  }

  export type CostItemSupplierUpdateManyWithWhereWithoutCostItemInput = {
    where: CostItemSupplierScalarWhereInput
    data: XOR<CostItemSupplierUpdateManyMutationInput, CostItemSupplierUncheckedUpdateManyWithoutCostItemInput>
  }

  export type CostItemSupplierScalarWhereInput = {
    AND?: CostItemSupplierScalarWhereInput | CostItemSupplierScalarWhereInput[]
    OR?: CostItemSupplierScalarWhereInput[]
    NOT?: CostItemSupplierScalarWhereInput | CostItemSupplierScalarWhereInput[]
    id?: IntFilter<"CostItemSupplier"> | number
    costItemId?: IntNullableFilter<"CostItemSupplier"> | number | null
    pendingCostItemId?: IntNullableFilter<"CostItemSupplier"> | number | null
    supplier?: EnumSuppliersFilter<"CostItemSupplier"> | $Enums.Suppliers
    amount?: FloatFilter<"CostItemSupplier"> | number
    paymentMethod?: StringFilter<"CostItemSupplier"> | string
    paidAmount?: FloatFilter<"CostItemSupplier"> | number
    pendingAmount?: FloatFilter<"CostItemSupplier"> | number
    transactionMethod?: StringNullableFilter<"CostItemSupplier"> | string | null
    firstMethodAmount?: FloatNullableFilter<"CostItemSupplier"> | number | null
    secondMethodAmount?: FloatNullableFilter<"CostItemSupplier"> | number | null
    createdAt?: DateTimeFilter<"CostItemSupplier"> | Date | string
    updatedAt?: DateTimeFilter<"CostItemSupplier"> | Date | string
  }

  export type PendingBookingCreateWithoutCostItemsInput = {
    refNo: string
    paxName: string
    agentName: string
    teamName?: $Enums.Teams | null
    pnr: string
    airline: string
    fromTo: string
    bookingType: $Enums.BookingType
    bookingStatus?: $Enums.BookingStatus | null
    pcDate: Date | string
    issuedDate?: Date | string | null
    paymentMethod: $Enums.PaymentMethod
    lastPaymentDate?: Date | string | null
    travelDate?: Date | string | null
    revenue?: number | null
    prodCost?: number | null
    transFee?: number | null
    surcharge?: number | null
    received?: number | null
    transactionMethod?: string | null
    receivedDate?: Date | string | null
    balance?: number | null
    profit?: number | null
    invoiced?: string | null
    description?: string | null
    status?: $Enums.PendingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    numPax: number
    instalments?: PendingInstalmentCreateNestedManyWithoutPendingBookingInput
    passengers?: PendingPassengerCreateNestedManyWithoutPendingBookingInput
    createdBy: UserCreateNestedOneWithoutCreatedPendingBookingsInput
  }

  export type PendingBookingUncheckedCreateWithoutCostItemsInput = {
    id?: number
    refNo: string
    paxName: string
    agentName: string
    teamName?: $Enums.Teams | null
    pnr: string
    airline: string
    fromTo: string
    bookingType: $Enums.BookingType
    bookingStatus?: $Enums.BookingStatus | null
    pcDate: Date | string
    issuedDate?: Date | string | null
    paymentMethod: $Enums.PaymentMethod
    lastPaymentDate?: Date | string | null
    travelDate?: Date | string | null
    revenue?: number | null
    prodCost?: number | null
    transFee?: number | null
    surcharge?: number | null
    received?: number | null
    transactionMethod?: string | null
    receivedDate?: Date | string | null
    balance?: number | null
    profit?: number | null
    invoiced?: string | null
    description?: string | null
    status?: $Enums.PendingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    numPax: number
    createdById: number
    instalments?: PendingInstalmentUncheckedCreateNestedManyWithoutPendingBookingInput
    passengers?: PendingPassengerUncheckedCreateNestedManyWithoutPendingBookingInput
  }

  export type PendingBookingCreateOrConnectWithoutCostItemsInput = {
    where: PendingBookingWhereUniqueInput
    create: XOR<PendingBookingCreateWithoutCostItemsInput, PendingBookingUncheckedCreateWithoutCostItemsInput>
  }

  export type CostItemSupplierCreateWithoutPendingCostItemInput = {
    supplier: $Enums.Suppliers
    amount: number
    paymentMethod?: string
    paidAmount?: number
    pendingAmount?: number
    transactionMethod?: string | null
    firstMethodAmount?: number | null
    secondMethodAmount?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    costItem?: CostItemCreateNestedOneWithoutSuppliersInput
    settlements?: SupplierPaymentSettlementCreateNestedManyWithoutCostItemSupplierInput
    paidByCreditNoteUsage?: CreditNoteUsageCreateNestedManyWithoutUsedOnCostItemSupplierInput
  }

  export type CostItemSupplierUncheckedCreateWithoutPendingCostItemInput = {
    id?: number
    costItemId?: number | null
    supplier: $Enums.Suppliers
    amount: number
    paymentMethod?: string
    paidAmount?: number
    pendingAmount?: number
    transactionMethod?: string | null
    firstMethodAmount?: number | null
    secondMethodAmount?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    settlements?: SupplierPaymentSettlementUncheckedCreateNestedManyWithoutCostItemSupplierInput
    paidByCreditNoteUsage?: CreditNoteUsageUncheckedCreateNestedManyWithoutUsedOnCostItemSupplierInput
  }

  export type CostItemSupplierCreateOrConnectWithoutPendingCostItemInput = {
    where: CostItemSupplierWhereUniqueInput
    create: XOR<CostItemSupplierCreateWithoutPendingCostItemInput, CostItemSupplierUncheckedCreateWithoutPendingCostItemInput>
  }

  export type CostItemSupplierCreateManyPendingCostItemInputEnvelope = {
    data: CostItemSupplierCreateManyPendingCostItemInput | CostItemSupplierCreateManyPendingCostItemInput[]
    skipDuplicates?: boolean
  }

  export type PendingBookingUpsertWithoutCostItemsInput = {
    update: XOR<PendingBookingUpdateWithoutCostItemsInput, PendingBookingUncheckedUpdateWithoutCostItemsInput>
    create: XOR<PendingBookingCreateWithoutCostItemsInput, PendingBookingUncheckedCreateWithoutCostItemsInput>
    where?: PendingBookingWhereInput
  }

  export type PendingBookingUpdateToOneWithWhereWithoutCostItemsInput = {
    where?: PendingBookingWhereInput
    data: XOR<PendingBookingUpdateWithoutCostItemsInput, PendingBookingUncheckedUpdateWithoutCostItemsInput>
  }

  export type PendingBookingUpdateWithoutCostItemsInput = {
    refNo?: StringFieldUpdateOperationsInput | string
    paxName?: StringFieldUpdateOperationsInput | string
    agentName?: StringFieldUpdateOperationsInput | string
    teamName?: NullableEnumTeamsFieldUpdateOperationsInput | $Enums.Teams | null
    pnr?: StringFieldUpdateOperationsInput | string
    airline?: StringFieldUpdateOperationsInput | string
    fromTo?: StringFieldUpdateOperationsInput | string
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    bookingStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    pcDate?: DateTimeFieldUpdateOperationsInput | Date | string
    issuedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    travelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    prodCost?: NullableFloatFieldUpdateOperationsInput | number | null
    transFee?: NullableFloatFieldUpdateOperationsInput | number | null
    surcharge?: NullableFloatFieldUpdateOperationsInput | number | null
    received?: NullableFloatFieldUpdateOperationsInput | number | null
    transactionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    profit?: NullableFloatFieldUpdateOperationsInput | number | null
    invoiced?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPendingStatusFieldUpdateOperationsInput | $Enums.PendingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    numPax?: IntFieldUpdateOperationsInput | number
    instalments?: PendingInstalmentUpdateManyWithoutPendingBookingNestedInput
    passengers?: PendingPassengerUpdateManyWithoutPendingBookingNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedPendingBookingsNestedInput
  }

  export type PendingBookingUncheckedUpdateWithoutCostItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    refNo?: StringFieldUpdateOperationsInput | string
    paxName?: StringFieldUpdateOperationsInput | string
    agentName?: StringFieldUpdateOperationsInput | string
    teamName?: NullableEnumTeamsFieldUpdateOperationsInput | $Enums.Teams | null
    pnr?: StringFieldUpdateOperationsInput | string
    airline?: StringFieldUpdateOperationsInput | string
    fromTo?: StringFieldUpdateOperationsInput | string
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    bookingStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    pcDate?: DateTimeFieldUpdateOperationsInput | Date | string
    issuedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    travelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    prodCost?: NullableFloatFieldUpdateOperationsInput | number | null
    transFee?: NullableFloatFieldUpdateOperationsInput | number | null
    surcharge?: NullableFloatFieldUpdateOperationsInput | number | null
    received?: NullableFloatFieldUpdateOperationsInput | number | null
    transactionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    profit?: NullableFloatFieldUpdateOperationsInput | number | null
    invoiced?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPendingStatusFieldUpdateOperationsInput | $Enums.PendingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    numPax?: IntFieldUpdateOperationsInput | number
    createdById?: IntFieldUpdateOperationsInput | number
    instalments?: PendingInstalmentUncheckedUpdateManyWithoutPendingBookingNestedInput
    passengers?: PendingPassengerUncheckedUpdateManyWithoutPendingBookingNestedInput
  }

  export type CostItemSupplierUpsertWithWhereUniqueWithoutPendingCostItemInput = {
    where: CostItemSupplierWhereUniqueInput
    update: XOR<CostItemSupplierUpdateWithoutPendingCostItemInput, CostItemSupplierUncheckedUpdateWithoutPendingCostItemInput>
    create: XOR<CostItemSupplierCreateWithoutPendingCostItemInput, CostItemSupplierUncheckedCreateWithoutPendingCostItemInput>
  }

  export type CostItemSupplierUpdateWithWhereUniqueWithoutPendingCostItemInput = {
    where: CostItemSupplierWhereUniqueInput
    data: XOR<CostItemSupplierUpdateWithoutPendingCostItemInput, CostItemSupplierUncheckedUpdateWithoutPendingCostItemInput>
  }

  export type CostItemSupplierUpdateManyWithWhereWithoutPendingCostItemInput = {
    where: CostItemSupplierScalarWhereInput
    data: XOR<CostItemSupplierUpdateManyMutationInput, CostItemSupplierUncheckedUpdateManyWithoutPendingCostItemInput>
  }

  export type BookingCreateWithoutPassengersInput = {
    folderNo: string
    refNo: string
    paxName: string
    agentName: string
    teamName?: $Enums.Teams | null
    pnr: string
    airline: string
    fromTo: string
    bookingType: $Enums.BookingType
    bookingStatus?: $Enums.BookingStatus | null
    pcDate: Date | string
    issuedDate?: Date | string | null
    paymentMethod: $Enums.PaymentMethod
    lastPaymentDate?: Date | string | null
    travelDate?: Date | string | null
    revenue?: number | null
    prodCost?: number | null
    transFee?: number | null
    surcharge?: number | null
    received?: number | null
    transactionMethod?: string | null
    receivedDate?: Date | string | null
    balance?: number | null
    profit?: number | null
    invoiced?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    numPax: number
    initialDeposit?: number | null
    statusBeforeVoid?: $Enums.BookingStatus | null
    voidReason?: string | null
    voidedAt?: Date | string | null
    costItems?: CostItemCreateNestedManyWithoutBookingInput
    instalments?: InstalmentCreateNestedManyWithoutBookingInput
    originalBooking?: BookingCreateNestedOneWithoutFollowUpBookingsInput
    followUpBookings?: BookingCreateNestedManyWithoutOriginalBookingInput
    voidedBy?: UserCreateNestedOneWithoutVoidedBookingsInput
    customerPayables?: CustomerPayableCreateNestedManyWithoutBookingInput
    cancellation?: CancellationCreateNestedOneWithoutOriginalBookingInput
  }

  export type BookingUncheckedCreateWithoutPassengersInput = {
    id?: number
    folderNo: string
    refNo: string
    paxName: string
    agentName: string
    teamName?: $Enums.Teams | null
    pnr: string
    airline: string
    fromTo: string
    bookingType: $Enums.BookingType
    bookingStatus?: $Enums.BookingStatus | null
    pcDate: Date | string
    issuedDate?: Date | string | null
    paymentMethod: $Enums.PaymentMethod
    lastPaymentDate?: Date | string | null
    travelDate?: Date | string | null
    revenue?: number | null
    prodCost?: number | null
    transFee?: number | null
    surcharge?: number | null
    received?: number | null
    transactionMethod?: string | null
    receivedDate?: Date | string | null
    balance?: number | null
    profit?: number | null
    invoiced?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    numPax: number
    initialDeposit?: number | null
    originalBookingId?: number | null
    statusBeforeVoid?: $Enums.BookingStatus | null
    voidReason?: string | null
    voidedAt?: Date | string | null
    voidedById?: number | null
    costItems?: CostItemUncheckedCreateNestedManyWithoutBookingInput
    instalments?: InstalmentUncheckedCreateNestedManyWithoutBookingInput
    followUpBookings?: BookingUncheckedCreateNestedManyWithoutOriginalBookingInput
    customerPayables?: CustomerPayableUncheckedCreateNestedManyWithoutBookingInput
    cancellation?: CancellationUncheckedCreateNestedOneWithoutOriginalBookingInput
  }

  export type BookingCreateOrConnectWithoutPassengersInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutPassengersInput, BookingUncheckedCreateWithoutPassengersInput>
  }

  export type BookingUpsertWithoutPassengersInput = {
    update: XOR<BookingUpdateWithoutPassengersInput, BookingUncheckedUpdateWithoutPassengersInput>
    create: XOR<BookingCreateWithoutPassengersInput, BookingUncheckedCreateWithoutPassengersInput>
    where?: BookingWhereInput
  }

  export type BookingUpdateToOneWithWhereWithoutPassengersInput = {
    where?: BookingWhereInput
    data: XOR<BookingUpdateWithoutPassengersInput, BookingUncheckedUpdateWithoutPassengersInput>
  }

  export type BookingUpdateWithoutPassengersInput = {
    folderNo?: StringFieldUpdateOperationsInput | string
    refNo?: StringFieldUpdateOperationsInput | string
    paxName?: StringFieldUpdateOperationsInput | string
    agentName?: StringFieldUpdateOperationsInput | string
    teamName?: NullableEnumTeamsFieldUpdateOperationsInput | $Enums.Teams | null
    pnr?: StringFieldUpdateOperationsInput | string
    airline?: StringFieldUpdateOperationsInput | string
    fromTo?: StringFieldUpdateOperationsInput | string
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    bookingStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    pcDate?: DateTimeFieldUpdateOperationsInput | Date | string
    issuedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    travelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    prodCost?: NullableFloatFieldUpdateOperationsInput | number | null
    transFee?: NullableFloatFieldUpdateOperationsInput | number | null
    surcharge?: NullableFloatFieldUpdateOperationsInput | number | null
    received?: NullableFloatFieldUpdateOperationsInput | number | null
    transactionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    profit?: NullableFloatFieldUpdateOperationsInput | number | null
    invoiced?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    numPax?: IntFieldUpdateOperationsInput | number
    initialDeposit?: NullableFloatFieldUpdateOperationsInput | number | null
    statusBeforeVoid?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    voidReason?: NullableStringFieldUpdateOperationsInput | string | null
    voidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    costItems?: CostItemUpdateManyWithoutBookingNestedInput
    instalments?: InstalmentUpdateManyWithoutBookingNestedInput
    originalBooking?: BookingUpdateOneWithoutFollowUpBookingsNestedInput
    followUpBookings?: BookingUpdateManyWithoutOriginalBookingNestedInput
    voidedBy?: UserUpdateOneWithoutVoidedBookingsNestedInput
    customerPayables?: CustomerPayableUpdateManyWithoutBookingNestedInput
    cancellation?: CancellationUpdateOneWithoutOriginalBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutPassengersInput = {
    id?: IntFieldUpdateOperationsInput | number
    folderNo?: StringFieldUpdateOperationsInput | string
    refNo?: StringFieldUpdateOperationsInput | string
    paxName?: StringFieldUpdateOperationsInput | string
    agentName?: StringFieldUpdateOperationsInput | string
    teamName?: NullableEnumTeamsFieldUpdateOperationsInput | $Enums.Teams | null
    pnr?: StringFieldUpdateOperationsInput | string
    airline?: StringFieldUpdateOperationsInput | string
    fromTo?: StringFieldUpdateOperationsInput | string
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    bookingStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    pcDate?: DateTimeFieldUpdateOperationsInput | Date | string
    issuedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    travelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    prodCost?: NullableFloatFieldUpdateOperationsInput | number | null
    transFee?: NullableFloatFieldUpdateOperationsInput | number | null
    surcharge?: NullableFloatFieldUpdateOperationsInput | number | null
    received?: NullableFloatFieldUpdateOperationsInput | number | null
    transactionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    profit?: NullableFloatFieldUpdateOperationsInput | number | null
    invoiced?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    numPax?: IntFieldUpdateOperationsInput | number
    initialDeposit?: NullableFloatFieldUpdateOperationsInput | number | null
    originalBookingId?: NullableIntFieldUpdateOperationsInput | number | null
    statusBeforeVoid?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    voidReason?: NullableStringFieldUpdateOperationsInput | string | null
    voidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    voidedById?: NullableIntFieldUpdateOperationsInput | number | null
    costItems?: CostItemUncheckedUpdateManyWithoutBookingNestedInput
    instalments?: InstalmentUncheckedUpdateManyWithoutBookingNestedInput
    followUpBookings?: BookingUncheckedUpdateManyWithoutOriginalBookingNestedInput
    customerPayables?: CustomerPayableUncheckedUpdateManyWithoutBookingNestedInput
    cancellation?: CancellationUncheckedUpdateOneWithoutOriginalBookingNestedInput
  }

  export type PendingBookingCreateWithoutPassengersInput = {
    refNo: string
    paxName: string
    agentName: string
    teamName?: $Enums.Teams | null
    pnr: string
    airline: string
    fromTo: string
    bookingType: $Enums.BookingType
    bookingStatus?: $Enums.BookingStatus | null
    pcDate: Date | string
    issuedDate?: Date | string | null
    paymentMethod: $Enums.PaymentMethod
    lastPaymentDate?: Date | string | null
    travelDate?: Date | string | null
    revenue?: number | null
    prodCost?: number | null
    transFee?: number | null
    surcharge?: number | null
    received?: number | null
    transactionMethod?: string | null
    receivedDate?: Date | string | null
    balance?: number | null
    profit?: number | null
    invoiced?: string | null
    description?: string | null
    status?: $Enums.PendingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    numPax: number
    costItems?: PendingCostItemCreateNestedManyWithoutPendingBookingInput
    instalments?: PendingInstalmentCreateNestedManyWithoutPendingBookingInput
    createdBy: UserCreateNestedOneWithoutCreatedPendingBookingsInput
  }

  export type PendingBookingUncheckedCreateWithoutPassengersInput = {
    id?: number
    refNo: string
    paxName: string
    agentName: string
    teamName?: $Enums.Teams | null
    pnr: string
    airline: string
    fromTo: string
    bookingType: $Enums.BookingType
    bookingStatus?: $Enums.BookingStatus | null
    pcDate: Date | string
    issuedDate?: Date | string | null
    paymentMethod: $Enums.PaymentMethod
    lastPaymentDate?: Date | string | null
    travelDate?: Date | string | null
    revenue?: number | null
    prodCost?: number | null
    transFee?: number | null
    surcharge?: number | null
    received?: number | null
    transactionMethod?: string | null
    receivedDate?: Date | string | null
    balance?: number | null
    profit?: number | null
    invoiced?: string | null
    description?: string | null
    status?: $Enums.PendingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    numPax: number
    createdById: number
    costItems?: PendingCostItemUncheckedCreateNestedManyWithoutPendingBookingInput
    instalments?: PendingInstalmentUncheckedCreateNestedManyWithoutPendingBookingInput
  }

  export type PendingBookingCreateOrConnectWithoutPassengersInput = {
    where: PendingBookingWhereUniqueInput
    create: XOR<PendingBookingCreateWithoutPassengersInput, PendingBookingUncheckedCreateWithoutPassengersInput>
  }

  export type PendingBookingUpsertWithoutPassengersInput = {
    update: XOR<PendingBookingUpdateWithoutPassengersInput, PendingBookingUncheckedUpdateWithoutPassengersInput>
    create: XOR<PendingBookingCreateWithoutPassengersInput, PendingBookingUncheckedCreateWithoutPassengersInput>
    where?: PendingBookingWhereInput
  }

  export type PendingBookingUpdateToOneWithWhereWithoutPassengersInput = {
    where?: PendingBookingWhereInput
    data: XOR<PendingBookingUpdateWithoutPassengersInput, PendingBookingUncheckedUpdateWithoutPassengersInput>
  }

  export type PendingBookingUpdateWithoutPassengersInput = {
    refNo?: StringFieldUpdateOperationsInput | string
    paxName?: StringFieldUpdateOperationsInput | string
    agentName?: StringFieldUpdateOperationsInput | string
    teamName?: NullableEnumTeamsFieldUpdateOperationsInput | $Enums.Teams | null
    pnr?: StringFieldUpdateOperationsInput | string
    airline?: StringFieldUpdateOperationsInput | string
    fromTo?: StringFieldUpdateOperationsInput | string
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    bookingStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    pcDate?: DateTimeFieldUpdateOperationsInput | Date | string
    issuedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    travelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    prodCost?: NullableFloatFieldUpdateOperationsInput | number | null
    transFee?: NullableFloatFieldUpdateOperationsInput | number | null
    surcharge?: NullableFloatFieldUpdateOperationsInput | number | null
    received?: NullableFloatFieldUpdateOperationsInput | number | null
    transactionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    profit?: NullableFloatFieldUpdateOperationsInput | number | null
    invoiced?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPendingStatusFieldUpdateOperationsInput | $Enums.PendingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    numPax?: IntFieldUpdateOperationsInput | number
    costItems?: PendingCostItemUpdateManyWithoutPendingBookingNestedInput
    instalments?: PendingInstalmentUpdateManyWithoutPendingBookingNestedInput
    createdBy?: UserUpdateOneRequiredWithoutCreatedPendingBookingsNestedInput
  }

  export type PendingBookingUncheckedUpdateWithoutPassengersInput = {
    id?: IntFieldUpdateOperationsInput | number
    refNo?: StringFieldUpdateOperationsInput | string
    paxName?: StringFieldUpdateOperationsInput | string
    agentName?: StringFieldUpdateOperationsInput | string
    teamName?: NullableEnumTeamsFieldUpdateOperationsInput | $Enums.Teams | null
    pnr?: StringFieldUpdateOperationsInput | string
    airline?: StringFieldUpdateOperationsInput | string
    fromTo?: StringFieldUpdateOperationsInput | string
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    bookingStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    pcDate?: DateTimeFieldUpdateOperationsInput | Date | string
    issuedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    travelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    prodCost?: NullableFloatFieldUpdateOperationsInput | number | null
    transFee?: NullableFloatFieldUpdateOperationsInput | number | null
    surcharge?: NullableFloatFieldUpdateOperationsInput | number | null
    received?: NullableFloatFieldUpdateOperationsInput | number | null
    transactionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    profit?: NullableFloatFieldUpdateOperationsInput | number | null
    invoiced?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPendingStatusFieldUpdateOperationsInput | $Enums.PendingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    numPax?: IntFieldUpdateOperationsInput | number
    createdById?: IntFieldUpdateOperationsInput | number
    costItems?: PendingCostItemUncheckedUpdateManyWithoutPendingBookingNestedInput
    instalments?: PendingInstalmentUncheckedUpdateManyWithoutPendingBookingNestedInput
  }

  export type CostItemCreateWithoutSuppliersInput = {
    category: string
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    booking: BookingCreateNestedOneWithoutCostItemsInput
  }

  export type CostItemUncheckedCreateWithoutSuppliersInput = {
    id?: number
    bookingId: number
    category: string
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CostItemCreateOrConnectWithoutSuppliersInput = {
    where: CostItemWhereUniqueInput
    create: XOR<CostItemCreateWithoutSuppliersInput, CostItemUncheckedCreateWithoutSuppliersInput>
  }

  export type PendingCostItemCreateWithoutSuppliersInput = {
    category: string
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    pendingBooking: PendingBookingCreateNestedOneWithoutCostItemsInput
  }

  export type PendingCostItemUncheckedCreateWithoutSuppliersInput = {
    id?: number
    pendingBookingId: number
    category: string
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PendingCostItemCreateOrConnectWithoutSuppliersInput = {
    where: PendingCostItemWhereUniqueInput
    create: XOR<PendingCostItemCreateWithoutSuppliersInput, PendingCostItemUncheckedCreateWithoutSuppliersInput>
  }

  export type SupplierPaymentSettlementCreateWithoutCostItemSupplierInput = {
    amount: number
    transactionMethod: string
    settlementDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupplierPaymentSettlementUncheckedCreateWithoutCostItemSupplierInput = {
    id?: number
    amount: number
    transactionMethod: string
    settlementDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupplierPaymentSettlementCreateOrConnectWithoutCostItemSupplierInput = {
    where: SupplierPaymentSettlementWhereUniqueInput
    create: XOR<SupplierPaymentSettlementCreateWithoutCostItemSupplierInput, SupplierPaymentSettlementUncheckedCreateWithoutCostItemSupplierInput>
  }

  export type SupplierPaymentSettlementCreateManyCostItemSupplierInputEnvelope = {
    data: SupplierPaymentSettlementCreateManyCostItemSupplierInput | SupplierPaymentSettlementCreateManyCostItemSupplierInput[]
    skipDuplicates?: boolean
  }

  export type CreditNoteUsageCreateWithoutUsedOnCostItemSupplierInput = {
    amountUsed: number
    usedAt?: Date | string
    creditNote: SupplierCreditNoteCreateNestedOneWithoutUsageHistoryInput
  }

  export type CreditNoteUsageUncheckedCreateWithoutUsedOnCostItemSupplierInput = {
    id?: number
    amountUsed: number
    usedAt?: Date | string
    creditNoteId: number
  }

  export type CreditNoteUsageCreateOrConnectWithoutUsedOnCostItemSupplierInput = {
    where: CreditNoteUsageWhereUniqueInput
    create: XOR<CreditNoteUsageCreateWithoutUsedOnCostItemSupplierInput, CreditNoteUsageUncheckedCreateWithoutUsedOnCostItemSupplierInput>
  }

  export type CreditNoteUsageCreateManyUsedOnCostItemSupplierInputEnvelope = {
    data: CreditNoteUsageCreateManyUsedOnCostItemSupplierInput | CreditNoteUsageCreateManyUsedOnCostItemSupplierInput[]
    skipDuplicates?: boolean
  }

  export type CostItemUpsertWithoutSuppliersInput = {
    update: XOR<CostItemUpdateWithoutSuppliersInput, CostItemUncheckedUpdateWithoutSuppliersInput>
    create: XOR<CostItemCreateWithoutSuppliersInput, CostItemUncheckedCreateWithoutSuppliersInput>
    where?: CostItemWhereInput
  }

  export type CostItemUpdateToOneWithWhereWithoutSuppliersInput = {
    where?: CostItemWhereInput
    data: XOR<CostItemUpdateWithoutSuppliersInput, CostItemUncheckedUpdateWithoutSuppliersInput>
  }

  export type CostItemUpdateWithoutSuppliersInput = {
    category?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUpdateOneRequiredWithoutCostItemsNestedInput
  }

  export type CostItemUncheckedUpdateWithoutSuppliersInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookingId?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PendingCostItemUpsertWithoutSuppliersInput = {
    update: XOR<PendingCostItemUpdateWithoutSuppliersInput, PendingCostItemUncheckedUpdateWithoutSuppliersInput>
    create: XOR<PendingCostItemCreateWithoutSuppliersInput, PendingCostItemUncheckedCreateWithoutSuppliersInput>
    where?: PendingCostItemWhereInput
  }

  export type PendingCostItemUpdateToOneWithWhereWithoutSuppliersInput = {
    where?: PendingCostItemWhereInput
    data: XOR<PendingCostItemUpdateWithoutSuppliersInput, PendingCostItemUncheckedUpdateWithoutSuppliersInput>
  }

  export type PendingCostItemUpdateWithoutSuppliersInput = {
    category?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pendingBooking?: PendingBookingUpdateOneRequiredWithoutCostItemsNestedInput
  }

  export type PendingCostItemUncheckedUpdateWithoutSuppliersInput = {
    id?: IntFieldUpdateOperationsInput | number
    pendingBookingId?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierPaymentSettlementUpsertWithWhereUniqueWithoutCostItemSupplierInput = {
    where: SupplierPaymentSettlementWhereUniqueInput
    update: XOR<SupplierPaymentSettlementUpdateWithoutCostItemSupplierInput, SupplierPaymentSettlementUncheckedUpdateWithoutCostItemSupplierInput>
    create: XOR<SupplierPaymentSettlementCreateWithoutCostItemSupplierInput, SupplierPaymentSettlementUncheckedCreateWithoutCostItemSupplierInput>
  }

  export type SupplierPaymentSettlementUpdateWithWhereUniqueWithoutCostItemSupplierInput = {
    where: SupplierPaymentSettlementWhereUniqueInput
    data: XOR<SupplierPaymentSettlementUpdateWithoutCostItemSupplierInput, SupplierPaymentSettlementUncheckedUpdateWithoutCostItemSupplierInput>
  }

  export type SupplierPaymentSettlementUpdateManyWithWhereWithoutCostItemSupplierInput = {
    where: SupplierPaymentSettlementScalarWhereInput
    data: XOR<SupplierPaymentSettlementUpdateManyMutationInput, SupplierPaymentSettlementUncheckedUpdateManyWithoutCostItemSupplierInput>
  }

  export type SupplierPaymentSettlementScalarWhereInput = {
    AND?: SupplierPaymentSettlementScalarWhereInput | SupplierPaymentSettlementScalarWhereInput[]
    OR?: SupplierPaymentSettlementScalarWhereInput[]
    NOT?: SupplierPaymentSettlementScalarWhereInput | SupplierPaymentSettlementScalarWhereInput[]
    id?: IntFilter<"SupplierPaymentSettlement"> | number
    costItemSupplierId?: IntFilter<"SupplierPaymentSettlement"> | number
    amount?: FloatFilter<"SupplierPaymentSettlement"> | number
    transactionMethod?: StringFilter<"SupplierPaymentSettlement"> | string
    settlementDate?: DateTimeFilter<"SupplierPaymentSettlement"> | Date | string
    createdAt?: DateTimeFilter<"SupplierPaymentSettlement"> | Date | string
    updatedAt?: DateTimeFilter<"SupplierPaymentSettlement"> | Date | string
  }

  export type CreditNoteUsageUpsertWithWhereUniqueWithoutUsedOnCostItemSupplierInput = {
    where: CreditNoteUsageWhereUniqueInput
    update: XOR<CreditNoteUsageUpdateWithoutUsedOnCostItemSupplierInput, CreditNoteUsageUncheckedUpdateWithoutUsedOnCostItemSupplierInput>
    create: XOR<CreditNoteUsageCreateWithoutUsedOnCostItemSupplierInput, CreditNoteUsageUncheckedCreateWithoutUsedOnCostItemSupplierInput>
  }

  export type CreditNoteUsageUpdateWithWhereUniqueWithoutUsedOnCostItemSupplierInput = {
    where: CreditNoteUsageWhereUniqueInput
    data: XOR<CreditNoteUsageUpdateWithoutUsedOnCostItemSupplierInput, CreditNoteUsageUncheckedUpdateWithoutUsedOnCostItemSupplierInput>
  }

  export type CreditNoteUsageUpdateManyWithWhereWithoutUsedOnCostItemSupplierInput = {
    where: CreditNoteUsageScalarWhereInput
    data: XOR<CreditNoteUsageUpdateManyMutationInput, CreditNoteUsageUncheckedUpdateManyWithoutUsedOnCostItemSupplierInput>
  }

  export type CreditNoteUsageScalarWhereInput = {
    AND?: CreditNoteUsageScalarWhereInput | CreditNoteUsageScalarWhereInput[]
    OR?: CreditNoteUsageScalarWhereInput[]
    NOT?: CreditNoteUsageScalarWhereInput | CreditNoteUsageScalarWhereInput[]
    id?: IntFilter<"CreditNoteUsage"> | number
    amountUsed?: FloatFilter<"CreditNoteUsage"> | number
    usedAt?: DateTimeFilter<"CreditNoteUsage"> | Date | string
    creditNoteId?: IntFilter<"CreditNoteUsage"> | number
    usedOnCostItemSupplierId?: IntFilter<"CreditNoteUsage"> | number
  }

  export type CostItemSupplierCreateWithoutSettlementsInput = {
    supplier: $Enums.Suppliers
    amount: number
    paymentMethod?: string
    paidAmount?: number
    pendingAmount?: number
    transactionMethod?: string | null
    firstMethodAmount?: number | null
    secondMethodAmount?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    costItem?: CostItemCreateNestedOneWithoutSuppliersInput
    pendingCostItem?: PendingCostItemCreateNestedOneWithoutSuppliersInput
    paidByCreditNoteUsage?: CreditNoteUsageCreateNestedManyWithoutUsedOnCostItemSupplierInput
  }

  export type CostItemSupplierUncheckedCreateWithoutSettlementsInput = {
    id?: number
    costItemId?: number | null
    pendingCostItemId?: number | null
    supplier: $Enums.Suppliers
    amount: number
    paymentMethod?: string
    paidAmount?: number
    pendingAmount?: number
    transactionMethod?: string | null
    firstMethodAmount?: number | null
    secondMethodAmount?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    paidByCreditNoteUsage?: CreditNoteUsageUncheckedCreateNestedManyWithoutUsedOnCostItemSupplierInput
  }

  export type CostItemSupplierCreateOrConnectWithoutSettlementsInput = {
    where: CostItemSupplierWhereUniqueInput
    create: XOR<CostItemSupplierCreateWithoutSettlementsInput, CostItemSupplierUncheckedCreateWithoutSettlementsInput>
  }

  export type CostItemSupplierUpsertWithoutSettlementsInput = {
    update: XOR<CostItemSupplierUpdateWithoutSettlementsInput, CostItemSupplierUncheckedUpdateWithoutSettlementsInput>
    create: XOR<CostItemSupplierCreateWithoutSettlementsInput, CostItemSupplierUncheckedCreateWithoutSettlementsInput>
    where?: CostItemSupplierWhereInput
  }

  export type CostItemSupplierUpdateToOneWithWhereWithoutSettlementsInput = {
    where?: CostItemSupplierWhereInput
    data: XOR<CostItemSupplierUpdateWithoutSettlementsInput, CostItemSupplierUncheckedUpdateWithoutSettlementsInput>
  }

  export type CostItemSupplierUpdateWithoutSettlementsInput = {
    supplier?: EnumSuppliersFieldUpdateOperationsInput | $Enums.Suppliers
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: StringFieldUpdateOperationsInput | string
    paidAmount?: FloatFieldUpdateOperationsInput | number
    pendingAmount?: FloatFieldUpdateOperationsInput | number
    transactionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    firstMethodAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    secondMethodAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    costItem?: CostItemUpdateOneWithoutSuppliersNestedInput
    pendingCostItem?: PendingCostItemUpdateOneWithoutSuppliersNestedInput
    paidByCreditNoteUsage?: CreditNoteUsageUpdateManyWithoutUsedOnCostItemSupplierNestedInput
  }

  export type CostItemSupplierUncheckedUpdateWithoutSettlementsInput = {
    id?: IntFieldUpdateOperationsInput | number
    costItemId?: NullableIntFieldUpdateOperationsInput | number | null
    pendingCostItemId?: NullableIntFieldUpdateOperationsInput | number | null
    supplier?: EnumSuppliersFieldUpdateOperationsInput | $Enums.Suppliers
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: StringFieldUpdateOperationsInput | string
    paidAmount?: FloatFieldUpdateOperationsInput | number
    pendingAmount?: FloatFieldUpdateOperationsInput | number
    transactionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    firstMethodAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    secondMethodAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paidByCreditNoteUsage?: CreditNoteUsageUncheckedUpdateManyWithoutUsedOnCostItemSupplierNestedInput
  }

  export type BookingCreateWithoutCancellationInput = {
    folderNo: string
    refNo: string
    paxName: string
    agentName: string
    teamName?: $Enums.Teams | null
    pnr: string
    airline: string
    fromTo: string
    bookingType: $Enums.BookingType
    bookingStatus?: $Enums.BookingStatus | null
    pcDate: Date | string
    issuedDate?: Date | string | null
    paymentMethod: $Enums.PaymentMethod
    lastPaymentDate?: Date | string | null
    travelDate?: Date | string | null
    revenue?: number | null
    prodCost?: number | null
    transFee?: number | null
    surcharge?: number | null
    received?: number | null
    transactionMethod?: string | null
    receivedDate?: Date | string | null
    balance?: number | null
    profit?: number | null
    invoiced?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    numPax: number
    initialDeposit?: number | null
    statusBeforeVoid?: $Enums.BookingStatus | null
    voidReason?: string | null
    voidedAt?: Date | string | null
    costItems?: CostItemCreateNestedManyWithoutBookingInput
    instalments?: InstalmentCreateNestedManyWithoutBookingInput
    passengers?: PassengerCreateNestedManyWithoutBookingInput
    originalBooking?: BookingCreateNestedOneWithoutFollowUpBookingsInput
    followUpBookings?: BookingCreateNestedManyWithoutOriginalBookingInput
    voidedBy?: UserCreateNestedOneWithoutVoidedBookingsInput
    customerPayables?: CustomerPayableCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutCancellationInput = {
    id?: number
    folderNo: string
    refNo: string
    paxName: string
    agentName: string
    teamName?: $Enums.Teams | null
    pnr: string
    airline: string
    fromTo: string
    bookingType: $Enums.BookingType
    bookingStatus?: $Enums.BookingStatus | null
    pcDate: Date | string
    issuedDate?: Date | string | null
    paymentMethod: $Enums.PaymentMethod
    lastPaymentDate?: Date | string | null
    travelDate?: Date | string | null
    revenue?: number | null
    prodCost?: number | null
    transFee?: number | null
    surcharge?: number | null
    received?: number | null
    transactionMethod?: string | null
    receivedDate?: Date | string | null
    balance?: number | null
    profit?: number | null
    invoiced?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    numPax: number
    initialDeposit?: number | null
    originalBookingId?: number | null
    statusBeforeVoid?: $Enums.BookingStatus | null
    voidReason?: string | null
    voidedAt?: Date | string | null
    voidedById?: number | null
    costItems?: CostItemUncheckedCreateNestedManyWithoutBookingInput
    instalments?: InstalmentUncheckedCreateNestedManyWithoutBookingInput
    passengers?: PassengerUncheckedCreateNestedManyWithoutBookingInput
    followUpBookings?: BookingUncheckedCreateNestedManyWithoutOriginalBookingInput
    customerPayables?: CustomerPayableUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutCancellationInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutCancellationInput, BookingUncheckedCreateWithoutCancellationInput>
  }

  export type PassengerRefundPaymentCreateWithoutCancellationInput = {
    amount: number
    transactionMethod: string
    refundDate: Date | string
    createdAt?: Date | string
  }

  export type PassengerRefundPaymentUncheckedCreateWithoutCancellationInput = {
    id?: number
    amount: number
    transactionMethod: string
    refundDate: Date | string
    createdAt?: Date | string
  }

  export type PassengerRefundPaymentCreateOrConnectWithoutCancellationInput = {
    where: PassengerRefundPaymentWhereUniqueInput
    create: XOR<PassengerRefundPaymentCreateWithoutCancellationInput, PassengerRefundPaymentUncheckedCreateWithoutCancellationInput>
  }

  export type CustomerPayableCreateWithoutCreatedFromCancellationInput = {
    totalAmount: number
    paidAmount?: number
    pendingAmount: number
    reason: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    settlements?: CustomerPayableSettlementCreateNestedManyWithoutPayableInput
    booking: BookingCreateNestedOneWithoutCustomerPayablesInput
  }

  export type CustomerPayableUncheckedCreateWithoutCreatedFromCancellationInput = {
    id?: number
    totalAmount: number
    paidAmount?: number
    pendingAmount: number
    reason: string
    status?: string
    bookingId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    settlements?: CustomerPayableSettlementUncheckedCreateNestedManyWithoutPayableInput
  }

  export type CustomerPayableCreateOrConnectWithoutCreatedFromCancellationInput = {
    where: CustomerPayableWhereUniqueInput
    create: XOR<CustomerPayableCreateWithoutCreatedFromCancellationInput, CustomerPayableUncheckedCreateWithoutCreatedFromCancellationInput>
  }

  export type SupplierPayableCreateWithoutCreatedFromCancellationInput = {
    supplier: $Enums.Suppliers
    totalAmount: number
    paidAmount?: number
    pendingAmount: number
    reason: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    settlements?: SupplierPayableSettlementCreateNestedManyWithoutPayableInput
  }

  export type SupplierPayableUncheckedCreateWithoutCreatedFromCancellationInput = {
    id?: number
    supplier: $Enums.Suppliers
    totalAmount: number
    paidAmount?: number
    pendingAmount: number
    reason: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    settlements?: SupplierPayableSettlementUncheckedCreateNestedManyWithoutPayableInput
  }

  export type SupplierPayableCreateOrConnectWithoutCreatedFromCancellationInput = {
    where: SupplierPayableWhereUniqueInput
    create: XOR<SupplierPayableCreateWithoutCreatedFromCancellationInput, SupplierPayableUncheckedCreateWithoutCreatedFromCancellationInput>
  }

  export type SupplierCreditNoteCreateWithoutGeneratedFromCancellationInput = {
    supplier: $Enums.Suppliers
    initialAmount: number
    remainingAmount: number
    status?: $Enums.CreditNoteStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    usageHistory?: CreditNoteUsageCreateNestedManyWithoutCreditNoteInput
  }

  export type SupplierCreditNoteUncheckedCreateWithoutGeneratedFromCancellationInput = {
    id?: number
    supplier: $Enums.Suppliers
    initialAmount: number
    remainingAmount: number
    status?: $Enums.CreditNoteStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    usageHistory?: CreditNoteUsageUncheckedCreateNestedManyWithoutCreditNoteInput
  }

  export type SupplierCreditNoteCreateOrConnectWithoutGeneratedFromCancellationInput = {
    where: SupplierCreditNoteWhereUniqueInput
    create: XOR<SupplierCreditNoteCreateWithoutGeneratedFromCancellationInput, SupplierCreditNoteUncheckedCreateWithoutGeneratedFromCancellationInput>
  }

  export type BookingUpsertWithoutCancellationInput = {
    update: XOR<BookingUpdateWithoutCancellationInput, BookingUncheckedUpdateWithoutCancellationInput>
    create: XOR<BookingCreateWithoutCancellationInput, BookingUncheckedCreateWithoutCancellationInput>
    where?: BookingWhereInput
  }

  export type BookingUpdateToOneWithWhereWithoutCancellationInput = {
    where?: BookingWhereInput
    data: XOR<BookingUpdateWithoutCancellationInput, BookingUncheckedUpdateWithoutCancellationInput>
  }

  export type BookingUpdateWithoutCancellationInput = {
    folderNo?: StringFieldUpdateOperationsInput | string
    refNo?: StringFieldUpdateOperationsInput | string
    paxName?: StringFieldUpdateOperationsInput | string
    agentName?: StringFieldUpdateOperationsInput | string
    teamName?: NullableEnumTeamsFieldUpdateOperationsInput | $Enums.Teams | null
    pnr?: StringFieldUpdateOperationsInput | string
    airline?: StringFieldUpdateOperationsInput | string
    fromTo?: StringFieldUpdateOperationsInput | string
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    bookingStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    pcDate?: DateTimeFieldUpdateOperationsInput | Date | string
    issuedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    travelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    prodCost?: NullableFloatFieldUpdateOperationsInput | number | null
    transFee?: NullableFloatFieldUpdateOperationsInput | number | null
    surcharge?: NullableFloatFieldUpdateOperationsInput | number | null
    received?: NullableFloatFieldUpdateOperationsInput | number | null
    transactionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    profit?: NullableFloatFieldUpdateOperationsInput | number | null
    invoiced?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    numPax?: IntFieldUpdateOperationsInput | number
    initialDeposit?: NullableFloatFieldUpdateOperationsInput | number | null
    statusBeforeVoid?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    voidReason?: NullableStringFieldUpdateOperationsInput | string | null
    voidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    costItems?: CostItemUpdateManyWithoutBookingNestedInput
    instalments?: InstalmentUpdateManyWithoutBookingNestedInput
    passengers?: PassengerUpdateManyWithoutBookingNestedInput
    originalBooking?: BookingUpdateOneWithoutFollowUpBookingsNestedInput
    followUpBookings?: BookingUpdateManyWithoutOriginalBookingNestedInput
    voidedBy?: UserUpdateOneWithoutVoidedBookingsNestedInput
    customerPayables?: CustomerPayableUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutCancellationInput = {
    id?: IntFieldUpdateOperationsInput | number
    folderNo?: StringFieldUpdateOperationsInput | string
    refNo?: StringFieldUpdateOperationsInput | string
    paxName?: StringFieldUpdateOperationsInput | string
    agentName?: StringFieldUpdateOperationsInput | string
    teamName?: NullableEnumTeamsFieldUpdateOperationsInput | $Enums.Teams | null
    pnr?: StringFieldUpdateOperationsInput | string
    airline?: StringFieldUpdateOperationsInput | string
    fromTo?: StringFieldUpdateOperationsInput | string
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    bookingStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    pcDate?: DateTimeFieldUpdateOperationsInput | Date | string
    issuedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    travelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    prodCost?: NullableFloatFieldUpdateOperationsInput | number | null
    transFee?: NullableFloatFieldUpdateOperationsInput | number | null
    surcharge?: NullableFloatFieldUpdateOperationsInput | number | null
    received?: NullableFloatFieldUpdateOperationsInput | number | null
    transactionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    profit?: NullableFloatFieldUpdateOperationsInput | number | null
    invoiced?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    numPax?: IntFieldUpdateOperationsInput | number
    initialDeposit?: NullableFloatFieldUpdateOperationsInput | number | null
    originalBookingId?: NullableIntFieldUpdateOperationsInput | number | null
    statusBeforeVoid?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    voidReason?: NullableStringFieldUpdateOperationsInput | string | null
    voidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    voidedById?: NullableIntFieldUpdateOperationsInput | number | null
    costItems?: CostItemUncheckedUpdateManyWithoutBookingNestedInput
    instalments?: InstalmentUncheckedUpdateManyWithoutBookingNestedInput
    passengers?: PassengerUncheckedUpdateManyWithoutBookingNestedInput
    followUpBookings?: BookingUncheckedUpdateManyWithoutOriginalBookingNestedInput
    customerPayables?: CustomerPayableUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type PassengerRefundPaymentUpsertWithoutCancellationInput = {
    update: XOR<PassengerRefundPaymentUpdateWithoutCancellationInput, PassengerRefundPaymentUncheckedUpdateWithoutCancellationInput>
    create: XOR<PassengerRefundPaymentCreateWithoutCancellationInput, PassengerRefundPaymentUncheckedCreateWithoutCancellationInput>
    where?: PassengerRefundPaymentWhereInput
  }

  export type PassengerRefundPaymentUpdateToOneWithWhereWithoutCancellationInput = {
    where?: PassengerRefundPaymentWhereInput
    data: XOR<PassengerRefundPaymentUpdateWithoutCancellationInput, PassengerRefundPaymentUncheckedUpdateWithoutCancellationInput>
  }

  export type PassengerRefundPaymentUpdateWithoutCancellationInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    transactionMethod?: StringFieldUpdateOperationsInput | string
    refundDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PassengerRefundPaymentUncheckedUpdateWithoutCancellationInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    transactionMethod?: StringFieldUpdateOperationsInput | string
    refundDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerPayableUpsertWithoutCreatedFromCancellationInput = {
    update: XOR<CustomerPayableUpdateWithoutCreatedFromCancellationInput, CustomerPayableUncheckedUpdateWithoutCreatedFromCancellationInput>
    create: XOR<CustomerPayableCreateWithoutCreatedFromCancellationInput, CustomerPayableUncheckedCreateWithoutCreatedFromCancellationInput>
    where?: CustomerPayableWhereInput
  }

  export type CustomerPayableUpdateToOneWithWhereWithoutCreatedFromCancellationInput = {
    where?: CustomerPayableWhereInput
    data: XOR<CustomerPayableUpdateWithoutCreatedFromCancellationInput, CustomerPayableUncheckedUpdateWithoutCreatedFromCancellationInput>
  }

  export type CustomerPayableUpdateWithoutCreatedFromCancellationInput = {
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    pendingAmount?: FloatFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settlements?: CustomerPayableSettlementUpdateManyWithoutPayableNestedInput
    booking?: BookingUpdateOneRequiredWithoutCustomerPayablesNestedInput
  }

  export type CustomerPayableUncheckedUpdateWithoutCreatedFromCancellationInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    pendingAmount?: FloatFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    bookingId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settlements?: CustomerPayableSettlementUncheckedUpdateManyWithoutPayableNestedInput
  }

  export type SupplierPayableUpsertWithoutCreatedFromCancellationInput = {
    update: XOR<SupplierPayableUpdateWithoutCreatedFromCancellationInput, SupplierPayableUncheckedUpdateWithoutCreatedFromCancellationInput>
    create: XOR<SupplierPayableCreateWithoutCreatedFromCancellationInput, SupplierPayableUncheckedCreateWithoutCreatedFromCancellationInput>
    where?: SupplierPayableWhereInput
  }

  export type SupplierPayableUpdateToOneWithWhereWithoutCreatedFromCancellationInput = {
    where?: SupplierPayableWhereInput
    data: XOR<SupplierPayableUpdateWithoutCreatedFromCancellationInput, SupplierPayableUncheckedUpdateWithoutCreatedFromCancellationInput>
  }

  export type SupplierPayableUpdateWithoutCreatedFromCancellationInput = {
    supplier?: EnumSuppliersFieldUpdateOperationsInput | $Enums.Suppliers
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    pendingAmount?: FloatFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settlements?: SupplierPayableSettlementUpdateManyWithoutPayableNestedInput
  }

  export type SupplierPayableUncheckedUpdateWithoutCreatedFromCancellationInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplier?: EnumSuppliersFieldUpdateOperationsInput | $Enums.Suppliers
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    pendingAmount?: FloatFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settlements?: SupplierPayableSettlementUncheckedUpdateManyWithoutPayableNestedInput
  }

  export type SupplierCreditNoteUpsertWithoutGeneratedFromCancellationInput = {
    update: XOR<SupplierCreditNoteUpdateWithoutGeneratedFromCancellationInput, SupplierCreditNoteUncheckedUpdateWithoutGeneratedFromCancellationInput>
    create: XOR<SupplierCreditNoteCreateWithoutGeneratedFromCancellationInput, SupplierCreditNoteUncheckedCreateWithoutGeneratedFromCancellationInput>
    where?: SupplierCreditNoteWhereInput
  }

  export type SupplierCreditNoteUpdateToOneWithWhereWithoutGeneratedFromCancellationInput = {
    where?: SupplierCreditNoteWhereInput
    data: XOR<SupplierCreditNoteUpdateWithoutGeneratedFromCancellationInput, SupplierCreditNoteUncheckedUpdateWithoutGeneratedFromCancellationInput>
  }

  export type SupplierCreditNoteUpdateWithoutGeneratedFromCancellationInput = {
    supplier?: EnumSuppliersFieldUpdateOperationsInput | $Enums.Suppliers
    initialAmount?: FloatFieldUpdateOperationsInput | number
    remainingAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumCreditNoteStatusFieldUpdateOperationsInput | $Enums.CreditNoteStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usageHistory?: CreditNoteUsageUpdateManyWithoutCreditNoteNestedInput
  }

  export type SupplierCreditNoteUncheckedUpdateWithoutGeneratedFromCancellationInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplier?: EnumSuppliersFieldUpdateOperationsInput | $Enums.Suppliers
    initialAmount?: FloatFieldUpdateOperationsInput | number
    remainingAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumCreditNoteStatusFieldUpdateOperationsInput | $Enums.CreditNoteStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usageHistory?: CreditNoteUsageUncheckedUpdateManyWithoutCreditNoteNestedInput
  }

  export type CancellationCreateWithoutGeneratedCreditNoteInput = {
    folderNo: string
    refundTransactionMethod: string
    originalRevenue: number
    originalProdCost: number
    supplierCancellationFee: number
    refundToPassenger: number
    adminFee?: number
    refundStatus?: string
    creditNoteAmount?: number | null
    profitOrLoss: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    originalBooking: BookingCreateNestedOneWithoutCancellationInput
    refundPayment?: PassengerRefundPaymentCreateNestedOneWithoutCancellationInput
    createdCustomerPayable?: CustomerPayableCreateNestedOneWithoutCreatedFromCancellationInput
    createdPayable?: SupplierPayableCreateNestedOneWithoutCreatedFromCancellationInput
  }

  export type CancellationUncheckedCreateWithoutGeneratedCreditNoteInput = {
    id?: number
    originalBookingId: number
    folderNo: string
    refundTransactionMethod: string
    originalRevenue: number
    originalProdCost: number
    supplierCancellationFee: number
    refundToPassenger: number
    adminFee?: number
    refundStatus?: string
    creditNoteAmount?: number | null
    profitOrLoss: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    refundPayment?: PassengerRefundPaymentUncheckedCreateNestedOneWithoutCancellationInput
    createdCustomerPayable?: CustomerPayableUncheckedCreateNestedOneWithoutCreatedFromCancellationInput
    createdPayable?: SupplierPayableUncheckedCreateNestedOneWithoutCreatedFromCancellationInput
  }

  export type CancellationCreateOrConnectWithoutGeneratedCreditNoteInput = {
    where: CancellationWhereUniqueInput
    create: XOR<CancellationCreateWithoutGeneratedCreditNoteInput, CancellationUncheckedCreateWithoutGeneratedCreditNoteInput>
  }

  export type CreditNoteUsageCreateWithoutCreditNoteInput = {
    amountUsed: number
    usedAt?: Date | string
    usedOnCostItemSupplier: CostItemSupplierCreateNestedOneWithoutPaidByCreditNoteUsageInput
  }

  export type CreditNoteUsageUncheckedCreateWithoutCreditNoteInput = {
    id?: number
    amountUsed: number
    usedAt?: Date | string
    usedOnCostItemSupplierId: number
  }

  export type CreditNoteUsageCreateOrConnectWithoutCreditNoteInput = {
    where: CreditNoteUsageWhereUniqueInput
    create: XOR<CreditNoteUsageCreateWithoutCreditNoteInput, CreditNoteUsageUncheckedCreateWithoutCreditNoteInput>
  }

  export type CreditNoteUsageCreateManyCreditNoteInputEnvelope = {
    data: CreditNoteUsageCreateManyCreditNoteInput | CreditNoteUsageCreateManyCreditNoteInput[]
    skipDuplicates?: boolean
  }

  export type CancellationUpsertWithoutGeneratedCreditNoteInput = {
    update: XOR<CancellationUpdateWithoutGeneratedCreditNoteInput, CancellationUncheckedUpdateWithoutGeneratedCreditNoteInput>
    create: XOR<CancellationCreateWithoutGeneratedCreditNoteInput, CancellationUncheckedCreateWithoutGeneratedCreditNoteInput>
    where?: CancellationWhereInput
  }

  export type CancellationUpdateToOneWithWhereWithoutGeneratedCreditNoteInput = {
    where?: CancellationWhereInput
    data: XOR<CancellationUpdateWithoutGeneratedCreditNoteInput, CancellationUncheckedUpdateWithoutGeneratedCreditNoteInput>
  }

  export type CancellationUpdateWithoutGeneratedCreditNoteInput = {
    folderNo?: StringFieldUpdateOperationsInput | string
    refundTransactionMethod?: StringFieldUpdateOperationsInput | string
    originalRevenue?: FloatFieldUpdateOperationsInput | number
    originalProdCost?: FloatFieldUpdateOperationsInput | number
    supplierCancellationFee?: FloatFieldUpdateOperationsInput | number
    refundToPassenger?: FloatFieldUpdateOperationsInput | number
    adminFee?: FloatFieldUpdateOperationsInput | number
    refundStatus?: StringFieldUpdateOperationsInput | string
    creditNoteAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    profitOrLoss?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    originalBooking?: BookingUpdateOneRequiredWithoutCancellationNestedInput
    refundPayment?: PassengerRefundPaymentUpdateOneWithoutCancellationNestedInput
    createdCustomerPayable?: CustomerPayableUpdateOneWithoutCreatedFromCancellationNestedInput
    createdPayable?: SupplierPayableUpdateOneWithoutCreatedFromCancellationNestedInput
  }

  export type CancellationUncheckedUpdateWithoutGeneratedCreditNoteInput = {
    id?: IntFieldUpdateOperationsInput | number
    originalBookingId?: IntFieldUpdateOperationsInput | number
    folderNo?: StringFieldUpdateOperationsInput | string
    refundTransactionMethod?: StringFieldUpdateOperationsInput | string
    originalRevenue?: FloatFieldUpdateOperationsInput | number
    originalProdCost?: FloatFieldUpdateOperationsInput | number
    supplierCancellationFee?: FloatFieldUpdateOperationsInput | number
    refundToPassenger?: FloatFieldUpdateOperationsInput | number
    adminFee?: FloatFieldUpdateOperationsInput | number
    refundStatus?: StringFieldUpdateOperationsInput | string
    creditNoteAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    profitOrLoss?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refundPayment?: PassengerRefundPaymentUncheckedUpdateOneWithoutCancellationNestedInput
    createdCustomerPayable?: CustomerPayableUncheckedUpdateOneWithoutCreatedFromCancellationNestedInput
    createdPayable?: SupplierPayableUncheckedUpdateOneWithoutCreatedFromCancellationNestedInput
  }

  export type CreditNoteUsageUpsertWithWhereUniqueWithoutCreditNoteInput = {
    where: CreditNoteUsageWhereUniqueInput
    update: XOR<CreditNoteUsageUpdateWithoutCreditNoteInput, CreditNoteUsageUncheckedUpdateWithoutCreditNoteInput>
    create: XOR<CreditNoteUsageCreateWithoutCreditNoteInput, CreditNoteUsageUncheckedCreateWithoutCreditNoteInput>
  }

  export type CreditNoteUsageUpdateWithWhereUniqueWithoutCreditNoteInput = {
    where: CreditNoteUsageWhereUniqueInput
    data: XOR<CreditNoteUsageUpdateWithoutCreditNoteInput, CreditNoteUsageUncheckedUpdateWithoutCreditNoteInput>
  }

  export type CreditNoteUsageUpdateManyWithWhereWithoutCreditNoteInput = {
    where: CreditNoteUsageScalarWhereInput
    data: XOR<CreditNoteUsageUpdateManyMutationInput, CreditNoteUsageUncheckedUpdateManyWithoutCreditNoteInput>
  }

  export type SupplierCreditNoteCreateWithoutUsageHistoryInput = {
    supplier: $Enums.Suppliers
    initialAmount: number
    remainingAmount: number
    status?: $Enums.CreditNoteStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    generatedFromCancellation: CancellationCreateNestedOneWithoutGeneratedCreditNoteInput
  }

  export type SupplierCreditNoteUncheckedCreateWithoutUsageHistoryInput = {
    id?: number
    supplier: $Enums.Suppliers
    initialAmount: number
    remainingAmount: number
    status?: $Enums.CreditNoteStatus
    generatedFromCancellationId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupplierCreditNoteCreateOrConnectWithoutUsageHistoryInput = {
    where: SupplierCreditNoteWhereUniqueInput
    create: XOR<SupplierCreditNoteCreateWithoutUsageHistoryInput, SupplierCreditNoteUncheckedCreateWithoutUsageHistoryInput>
  }

  export type CostItemSupplierCreateWithoutPaidByCreditNoteUsageInput = {
    supplier: $Enums.Suppliers
    amount: number
    paymentMethod?: string
    paidAmount?: number
    pendingAmount?: number
    transactionMethod?: string | null
    firstMethodAmount?: number | null
    secondMethodAmount?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    costItem?: CostItemCreateNestedOneWithoutSuppliersInput
    pendingCostItem?: PendingCostItemCreateNestedOneWithoutSuppliersInput
    settlements?: SupplierPaymentSettlementCreateNestedManyWithoutCostItemSupplierInput
  }

  export type CostItemSupplierUncheckedCreateWithoutPaidByCreditNoteUsageInput = {
    id?: number
    costItemId?: number | null
    pendingCostItemId?: number | null
    supplier: $Enums.Suppliers
    amount: number
    paymentMethod?: string
    paidAmount?: number
    pendingAmount?: number
    transactionMethod?: string | null
    firstMethodAmount?: number | null
    secondMethodAmount?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    settlements?: SupplierPaymentSettlementUncheckedCreateNestedManyWithoutCostItemSupplierInput
  }

  export type CostItemSupplierCreateOrConnectWithoutPaidByCreditNoteUsageInput = {
    where: CostItemSupplierWhereUniqueInput
    create: XOR<CostItemSupplierCreateWithoutPaidByCreditNoteUsageInput, CostItemSupplierUncheckedCreateWithoutPaidByCreditNoteUsageInput>
  }

  export type SupplierCreditNoteUpsertWithoutUsageHistoryInput = {
    update: XOR<SupplierCreditNoteUpdateWithoutUsageHistoryInput, SupplierCreditNoteUncheckedUpdateWithoutUsageHistoryInput>
    create: XOR<SupplierCreditNoteCreateWithoutUsageHistoryInput, SupplierCreditNoteUncheckedCreateWithoutUsageHistoryInput>
    where?: SupplierCreditNoteWhereInput
  }

  export type SupplierCreditNoteUpdateToOneWithWhereWithoutUsageHistoryInput = {
    where?: SupplierCreditNoteWhereInput
    data: XOR<SupplierCreditNoteUpdateWithoutUsageHistoryInput, SupplierCreditNoteUncheckedUpdateWithoutUsageHistoryInput>
  }

  export type SupplierCreditNoteUpdateWithoutUsageHistoryInput = {
    supplier?: EnumSuppliersFieldUpdateOperationsInput | $Enums.Suppliers
    initialAmount?: FloatFieldUpdateOperationsInput | number
    remainingAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumCreditNoteStatusFieldUpdateOperationsInput | $Enums.CreditNoteStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    generatedFromCancellation?: CancellationUpdateOneRequiredWithoutGeneratedCreditNoteNestedInput
  }

  export type SupplierCreditNoteUncheckedUpdateWithoutUsageHistoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplier?: EnumSuppliersFieldUpdateOperationsInput | $Enums.Suppliers
    initialAmount?: FloatFieldUpdateOperationsInput | number
    remainingAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumCreditNoteStatusFieldUpdateOperationsInput | $Enums.CreditNoteStatus
    generatedFromCancellationId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CostItemSupplierUpsertWithoutPaidByCreditNoteUsageInput = {
    update: XOR<CostItemSupplierUpdateWithoutPaidByCreditNoteUsageInput, CostItemSupplierUncheckedUpdateWithoutPaidByCreditNoteUsageInput>
    create: XOR<CostItemSupplierCreateWithoutPaidByCreditNoteUsageInput, CostItemSupplierUncheckedCreateWithoutPaidByCreditNoteUsageInput>
    where?: CostItemSupplierWhereInput
  }

  export type CostItemSupplierUpdateToOneWithWhereWithoutPaidByCreditNoteUsageInput = {
    where?: CostItemSupplierWhereInput
    data: XOR<CostItemSupplierUpdateWithoutPaidByCreditNoteUsageInput, CostItemSupplierUncheckedUpdateWithoutPaidByCreditNoteUsageInput>
  }

  export type CostItemSupplierUpdateWithoutPaidByCreditNoteUsageInput = {
    supplier?: EnumSuppliersFieldUpdateOperationsInput | $Enums.Suppliers
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: StringFieldUpdateOperationsInput | string
    paidAmount?: FloatFieldUpdateOperationsInput | number
    pendingAmount?: FloatFieldUpdateOperationsInput | number
    transactionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    firstMethodAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    secondMethodAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    costItem?: CostItemUpdateOneWithoutSuppliersNestedInput
    pendingCostItem?: PendingCostItemUpdateOneWithoutSuppliersNestedInput
    settlements?: SupplierPaymentSettlementUpdateManyWithoutCostItemSupplierNestedInput
  }

  export type CostItemSupplierUncheckedUpdateWithoutPaidByCreditNoteUsageInput = {
    id?: IntFieldUpdateOperationsInput | number
    costItemId?: NullableIntFieldUpdateOperationsInput | number | null
    pendingCostItemId?: NullableIntFieldUpdateOperationsInput | number | null
    supplier?: EnumSuppliersFieldUpdateOperationsInput | $Enums.Suppliers
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: StringFieldUpdateOperationsInput | string
    paidAmount?: FloatFieldUpdateOperationsInput | number
    pendingAmount?: FloatFieldUpdateOperationsInput | number
    transactionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    firstMethodAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    secondMethodAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settlements?: SupplierPaymentSettlementUncheckedUpdateManyWithoutCostItemSupplierNestedInput
  }

  export type CancellationCreateWithoutCreatedPayableInput = {
    folderNo: string
    refundTransactionMethod: string
    originalRevenue: number
    originalProdCost: number
    supplierCancellationFee: number
    refundToPassenger: number
    adminFee?: number
    refundStatus?: string
    creditNoteAmount?: number | null
    profitOrLoss: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    originalBooking: BookingCreateNestedOneWithoutCancellationInput
    refundPayment?: PassengerRefundPaymentCreateNestedOneWithoutCancellationInput
    createdCustomerPayable?: CustomerPayableCreateNestedOneWithoutCreatedFromCancellationInput
    generatedCreditNote?: SupplierCreditNoteCreateNestedOneWithoutGeneratedFromCancellationInput
  }

  export type CancellationUncheckedCreateWithoutCreatedPayableInput = {
    id?: number
    originalBookingId: number
    folderNo: string
    refundTransactionMethod: string
    originalRevenue: number
    originalProdCost: number
    supplierCancellationFee: number
    refundToPassenger: number
    adminFee?: number
    refundStatus?: string
    creditNoteAmount?: number | null
    profitOrLoss: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    refundPayment?: PassengerRefundPaymentUncheckedCreateNestedOneWithoutCancellationInput
    createdCustomerPayable?: CustomerPayableUncheckedCreateNestedOneWithoutCreatedFromCancellationInput
    generatedCreditNote?: SupplierCreditNoteUncheckedCreateNestedOneWithoutGeneratedFromCancellationInput
  }

  export type CancellationCreateOrConnectWithoutCreatedPayableInput = {
    where: CancellationWhereUniqueInput
    create: XOR<CancellationCreateWithoutCreatedPayableInput, CancellationUncheckedCreateWithoutCreatedPayableInput>
  }

  export type SupplierPayableSettlementCreateWithoutPayableInput = {
    amount: number
    transactionMethod: string
    settlementDate: Date | string
    createdAt?: Date | string
  }

  export type SupplierPayableSettlementUncheckedCreateWithoutPayableInput = {
    id?: number
    amount: number
    transactionMethod: string
    settlementDate: Date | string
    createdAt?: Date | string
  }

  export type SupplierPayableSettlementCreateOrConnectWithoutPayableInput = {
    where: SupplierPayableSettlementWhereUniqueInput
    create: XOR<SupplierPayableSettlementCreateWithoutPayableInput, SupplierPayableSettlementUncheckedCreateWithoutPayableInput>
  }

  export type SupplierPayableSettlementCreateManyPayableInputEnvelope = {
    data: SupplierPayableSettlementCreateManyPayableInput | SupplierPayableSettlementCreateManyPayableInput[]
    skipDuplicates?: boolean
  }

  export type CancellationUpsertWithoutCreatedPayableInput = {
    update: XOR<CancellationUpdateWithoutCreatedPayableInput, CancellationUncheckedUpdateWithoutCreatedPayableInput>
    create: XOR<CancellationCreateWithoutCreatedPayableInput, CancellationUncheckedCreateWithoutCreatedPayableInput>
    where?: CancellationWhereInput
  }

  export type CancellationUpdateToOneWithWhereWithoutCreatedPayableInput = {
    where?: CancellationWhereInput
    data: XOR<CancellationUpdateWithoutCreatedPayableInput, CancellationUncheckedUpdateWithoutCreatedPayableInput>
  }

  export type CancellationUpdateWithoutCreatedPayableInput = {
    folderNo?: StringFieldUpdateOperationsInput | string
    refundTransactionMethod?: StringFieldUpdateOperationsInput | string
    originalRevenue?: FloatFieldUpdateOperationsInput | number
    originalProdCost?: FloatFieldUpdateOperationsInput | number
    supplierCancellationFee?: FloatFieldUpdateOperationsInput | number
    refundToPassenger?: FloatFieldUpdateOperationsInput | number
    adminFee?: FloatFieldUpdateOperationsInput | number
    refundStatus?: StringFieldUpdateOperationsInput | string
    creditNoteAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    profitOrLoss?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    originalBooking?: BookingUpdateOneRequiredWithoutCancellationNestedInput
    refundPayment?: PassengerRefundPaymentUpdateOneWithoutCancellationNestedInput
    createdCustomerPayable?: CustomerPayableUpdateOneWithoutCreatedFromCancellationNestedInput
    generatedCreditNote?: SupplierCreditNoteUpdateOneWithoutGeneratedFromCancellationNestedInput
  }

  export type CancellationUncheckedUpdateWithoutCreatedPayableInput = {
    id?: IntFieldUpdateOperationsInput | number
    originalBookingId?: IntFieldUpdateOperationsInput | number
    folderNo?: StringFieldUpdateOperationsInput | string
    refundTransactionMethod?: StringFieldUpdateOperationsInput | string
    originalRevenue?: FloatFieldUpdateOperationsInput | number
    originalProdCost?: FloatFieldUpdateOperationsInput | number
    supplierCancellationFee?: FloatFieldUpdateOperationsInput | number
    refundToPassenger?: FloatFieldUpdateOperationsInput | number
    adminFee?: FloatFieldUpdateOperationsInput | number
    refundStatus?: StringFieldUpdateOperationsInput | string
    creditNoteAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    profitOrLoss?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refundPayment?: PassengerRefundPaymentUncheckedUpdateOneWithoutCancellationNestedInput
    createdCustomerPayable?: CustomerPayableUncheckedUpdateOneWithoutCreatedFromCancellationNestedInput
    generatedCreditNote?: SupplierCreditNoteUncheckedUpdateOneWithoutGeneratedFromCancellationNestedInput
  }

  export type SupplierPayableSettlementUpsertWithWhereUniqueWithoutPayableInput = {
    where: SupplierPayableSettlementWhereUniqueInput
    update: XOR<SupplierPayableSettlementUpdateWithoutPayableInput, SupplierPayableSettlementUncheckedUpdateWithoutPayableInput>
    create: XOR<SupplierPayableSettlementCreateWithoutPayableInput, SupplierPayableSettlementUncheckedCreateWithoutPayableInput>
  }

  export type SupplierPayableSettlementUpdateWithWhereUniqueWithoutPayableInput = {
    where: SupplierPayableSettlementWhereUniqueInput
    data: XOR<SupplierPayableSettlementUpdateWithoutPayableInput, SupplierPayableSettlementUncheckedUpdateWithoutPayableInput>
  }

  export type SupplierPayableSettlementUpdateManyWithWhereWithoutPayableInput = {
    where: SupplierPayableSettlementScalarWhereInput
    data: XOR<SupplierPayableSettlementUpdateManyMutationInput, SupplierPayableSettlementUncheckedUpdateManyWithoutPayableInput>
  }

  export type SupplierPayableSettlementScalarWhereInput = {
    AND?: SupplierPayableSettlementScalarWhereInput | SupplierPayableSettlementScalarWhereInput[]
    OR?: SupplierPayableSettlementScalarWhereInput[]
    NOT?: SupplierPayableSettlementScalarWhereInput | SupplierPayableSettlementScalarWhereInput[]
    id?: IntFilter<"SupplierPayableSettlement"> | number
    supplierPayableId?: IntFilter<"SupplierPayableSettlement"> | number
    amount?: FloatFilter<"SupplierPayableSettlement"> | number
    transactionMethod?: StringFilter<"SupplierPayableSettlement"> | string
    settlementDate?: DateTimeFilter<"SupplierPayableSettlement"> | Date | string
    createdAt?: DateTimeFilter<"SupplierPayableSettlement"> | Date | string
  }

  export type SupplierPayableCreateWithoutSettlementsInput = {
    supplier: $Enums.Suppliers
    totalAmount: number
    paidAmount?: number
    pendingAmount: number
    reason: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdFromCancellation: CancellationCreateNestedOneWithoutCreatedPayableInput
  }

  export type SupplierPayableUncheckedCreateWithoutSettlementsInput = {
    id?: number
    supplier: $Enums.Suppliers
    totalAmount: number
    paidAmount?: number
    pendingAmount: number
    reason: string
    status?: string
    createdFromCancellationId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SupplierPayableCreateOrConnectWithoutSettlementsInput = {
    where: SupplierPayableWhereUniqueInput
    create: XOR<SupplierPayableCreateWithoutSettlementsInput, SupplierPayableUncheckedCreateWithoutSettlementsInput>
  }

  export type SupplierPayableUpsertWithoutSettlementsInput = {
    update: XOR<SupplierPayableUpdateWithoutSettlementsInput, SupplierPayableUncheckedUpdateWithoutSettlementsInput>
    create: XOR<SupplierPayableCreateWithoutSettlementsInput, SupplierPayableUncheckedCreateWithoutSettlementsInput>
    where?: SupplierPayableWhereInput
  }

  export type SupplierPayableUpdateToOneWithWhereWithoutSettlementsInput = {
    where?: SupplierPayableWhereInput
    data: XOR<SupplierPayableUpdateWithoutSettlementsInput, SupplierPayableUncheckedUpdateWithoutSettlementsInput>
  }

  export type SupplierPayableUpdateWithoutSettlementsInput = {
    supplier?: EnumSuppliersFieldUpdateOperationsInput | $Enums.Suppliers
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    pendingAmount?: FloatFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdFromCancellation?: CancellationUpdateOneRequiredWithoutCreatedPayableNestedInput
  }

  export type SupplierPayableUncheckedUpdateWithoutSettlementsInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplier?: EnumSuppliersFieldUpdateOperationsInput | $Enums.Suppliers
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    pendingAmount?: FloatFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdFromCancellationId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerPayableSettlementCreateWithoutPayableInput = {
    amount: number
    transactionMethod: string
    paymentDate: Date | string
    createdAt?: Date | string
  }

  export type CustomerPayableSettlementUncheckedCreateWithoutPayableInput = {
    id?: number
    amount: number
    transactionMethod: string
    paymentDate: Date | string
    createdAt?: Date | string
  }

  export type CustomerPayableSettlementCreateOrConnectWithoutPayableInput = {
    where: CustomerPayableSettlementWhereUniqueInput
    create: XOR<CustomerPayableSettlementCreateWithoutPayableInput, CustomerPayableSettlementUncheckedCreateWithoutPayableInput>
  }

  export type CustomerPayableSettlementCreateManyPayableInputEnvelope = {
    data: CustomerPayableSettlementCreateManyPayableInput | CustomerPayableSettlementCreateManyPayableInput[]
    skipDuplicates?: boolean
  }

  export type CancellationCreateWithoutCreatedCustomerPayableInput = {
    folderNo: string
    refundTransactionMethod: string
    originalRevenue: number
    originalProdCost: number
    supplierCancellationFee: number
    refundToPassenger: number
    adminFee?: number
    refundStatus?: string
    creditNoteAmount?: number | null
    profitOrLoss: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    originalBooking: BookingCreateNestedOneWithoutCancellationInput
    refundPayment?: PassengerRefundPaymentCreateNestedOneWithoutCancellationInput
    createdPayable?: SupplierPayableCreateNestedOneWithoutCreatedFromCancellationInput
    generatedCreditNote?: SupplierCreditNoteCreateNestedOneWithoutGeneratedFromCancellationInput
  }

  export type CancellationUncheckedCreateWithoutCreatedCustomerPayableInput = {
    id?: number
    originalBookingId: number
    folderNo: string
    refundTransactionMethod: string
    originalRevenue: number
    originalProdCost: number
    supplierCancellationFee: number
    refundToPassenger: number
    adminFee?: number
    refundStatus?: string
    creditNoteAmount?: number | null
    profitOrLoss: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    refundPayment?: PassengerRefundPaymentUncheckedCreateNestedOneWithoutCancellationInput
    createdPayable?: SupplierPayableUncheckedCreateNestedOneWithoutCreatedFromCancellationInput
    generatedCreditNote?: SupplierCreditNoteUncheckedCreateNestedOneWithoutGeneratedFromCancellationInput
  }

  export type CancellationCreateOrConnectWithoutCreatedCustomerPayableInput = {
    where: CancellationWhereUniqueInput
    create: XOR<CancellationCreateWithoutCreatedCustomerPayableInput, CancellationUncheckedCreateWithoutCreatedCustomerPayableInput>
  }

  export type BookingCreateWithoutCustomerPayablesInput = {
    folderNo: string
    refNo: string
    paxName: string
    agentName: string
    teamName?: $Enums.Teams | null
    pnr: string
    airline: string
    fromTo: string
    bookingType: $Enums.BookingType
    bookingStatus?: $Enums.BookingStatus | null
    pcDate: Date | string
    issuedDate?: Date | string | null
    paymentMethod: $Enums.PaymentMethod
    lastPaymentDate?: Date | string | null
    travelDate?: Date | string | null
    revenue?: number | null
    prodCost?: number | null
    transFee?: number | null
    surcharge?: number | null
    received?: number | null
    transactionMethod?: string | null
    receivedDate?: Date | string | null
    balance?: number | null
    profit?: number | null
    invoiced?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    numPax: number
    initialDeposit?: number | null
    statusBeforeVoid?: $Enums.BookingStatus | null
    voidReason?: string | null
    voidedAt?: Date | string | null
    costItems?: CostItemCreateNestedManyWithoutBookingInput
    instalments?: InstalmentCreateNestedManyWithoutBookingInput
    passengers?: PassengerCreateNestedManyWithoutBookingInput
    originalBooking?: BookingCreateNestedOneWithoutFollowUpBookingsInput
    followUpBookings?: BookingCreateNestedManyWithoutOriginalBookingInput
    voidedBy?: UserCreateNestedOneWithoutVoidedBookingsInput
    cancellation?: CancellationCreateNestedOneWithoutOriginalBookingInput
  }

  export type BookingUncheckedCreateWithoutCustomerPayablesInput = {
    id?: number
    folderNo: string
    refNo: string
    paxName: string
    agentName: string
    teamName?: $Enums.Teams | null
    pnr: string
    airline: string
    fromTo: string
    bookingType: $Enums.BookingType
    bookingStatus?: $Enums.BookingStatus | null
    pcDate: Date | string
    issuedDate?: Date | string | null
    paymentMethod: $Enums.PaymentMethod
    lastPaymentDate?: Date | string | null
    travelDate?: Date | string | null
    revenue?: number | null
    prodCost?: number | null
    transFee?: number | null
    surcharge?: number | null
    received?: number | null
    transactionMethod?: string | null
    receivedDate?: Date | string | null
    balance?: number | null
    profit?: number | null
    invoiced?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    numPax: number
    initialDeposit?: number | null
    originalBookingId?: number | null
    statusBeforeVoid?: $Enums.BookingStatus | null
    voidReason?: string | null
    voidedAt?: Date | string | null
    voidedById?: number | null
    costItems?: CostItemUncheckedCreateNestedManyWithoutBookingInput
    instalments?: InstalmentUncheckedCreateNestedManyWithoutBookingInput
    passengers?: PassengerUncheckedCreateNestedManyWithoutBookingInput
    followUpBookings?: BookingUncheckedCreateNestedManyWithoutOriginalBookingInput
    cancellation?: CancellationUncheckedCreateNestedOneWithoutOriginalBookingInput
  }

  export type BookingCreateOrConnectWithoutCustomerPayablesInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutCustomerPayablesInput, BookingUncheckedCreateWithoutCustomerPayablesInput>
  }

  export type CustomerPayableSettlementUpsertWithWhereUniqueWithoutPayableInput = {
    where: CustomerPayableSettlementWhereUniqueInput
    update: XOR<CustomerPayableSettlementUpdateWithoutPayableInput, CustomerPayableSettlementUncheckedUpdateWithoutPayableInput>
    create: XOR<CustomerPayableSettlementCreateWithoutPayableInput, CustomerPayableSettlementUncheckedCreateWithoutPayableInput>
  }

  export type CustomerPayableSettlementUpdateWithWhereUniqueWithoutPayableInput = {
    where: CustomerPayableSettlementWhereUniqueInput
    data: XOR<CustomerPayableSettlementUpdateWithoutPayableInput, CustomerPayableSettlementUncheckedUpdateWithoutPayableInput>
  }

  export type CustomerPayableSettlementUpdateManyWithWhereWithoutPayableInput = {
    where: CustomerPayableSettlementScalarWhereInput
    data: XOR<CustomerPayableSettlementUpdateManyMutationInput, CustomerPayableSettlementUncheckedUpdateManyWithoutPayableInput>
  }

  export type CustomerPayableSettlementScalarWhereInput = {
    AND?: CustomerPayableSettlementScalarWhereInput | CustomerPayableSettlementScalarWhereInput[]
    OR?: CustomerPayableSettlementScalarWhereInput[]
    NOT?: CustomerPayableSettlementScalarWhereInput | CustomerPayableSettlementScalarWhereInput[]
    id?: IntFilter<"CustomerPayableSettlement"> | number
    customerPayableId?: IntFilter<"CustomerPayableSettlement"> | number
    amount?: FloatFilter<"CustomerPayableSettlement"> | number
    transactionMethod?: StringFilter<"CustomerPayableSettlement"> | string
    paymentDate?: DateTimeFilter<"CustomerPayableSettlement"> | Date | string
    createdAt?: DateTimeFilter<"CustomerPayableSettlement"> | Date | string
  }

  export type CancellationUpsertWithoutCreatedCustomerPayableInput = {
    update: XOR<CancellationUpdateWithoutCreatedCustomerPayableInput, CancellationUncheckedUpdateWithoutCreatedCustomerPayableInput>
    create: XOR<CancellationCreateWithoutCreatedCustomerPayableInput, CancellationUncheckedCreateWithoutCreatedCustomerPayableInput>
    where?: CancellationWhereInput
  }

  export type CancellationUpdateToOneWithWhereWithoutCreatedCustomerPayableInput = {
    where?: CancellationWhereInput
    data: XOR<CancellationUpdateWithoutCreatedCustomerPayableInput, CancellationUncheckedUpdateWithoutCreatedCustomerPayableInput>
  }

  export type CancellationUpdateWithoutCreatedCustomerPayableInput = {
    folderNo?: StringFieldUpdateOperationsInput | string
    refundTransactionMethod?: StringFieldUpdateOperationsInput | string
    originalRevenue?: FloatFieldUpdateOperationsInput | number
    originalProdCost?: FloatFieldUpdateOperationsInput | number
    supplierCancellationFee?: FloatFieldUpdateOperationsInput | number
    refundToPassenger?: FloatFieldUpdateOperationsInput | number
    adminFee?: FloatFieldUpdateOperationsInput | number
    refundStatus?: StringFieldUpdateOperationsInput | string
    creditNoteAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    profitOrLoss?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    originalBooking?: BookingUpdateOneRequiredWithoutCancellationNestedInput
    refundPayment?: PassengerRefundPaymentUpdateOneWithoutCancellationNestedInput
    createdPayable?: SupplierPayableUpdateOneWithoutCreatedFromCancellationNestedInput
    generatedCreditNote?: SupplierCreditNoteUpdateOneWithoutGeneratedFromCancellationNestedInput
  }

  export type CancellationUncheckedUpdateWithoutCreatedCustomerPayableInput = {
    id?: IntFieldUpdateOperationsInput | number
    originalBookingId?: IntFieldUpdateOperationsInput | number
    folderNo?: StringFieldUpdateOperationsInput | string
    refundTransactionMethod?: StringFieldUpdateOperationsInput | string
    originalRevenue?: FloatFieldUpdateOperationsInput | number
    originalProdCost?: FloatFieldUpdateOperationsInput | number
    supplierCancellationFee?: FloatFieldUpdateOperationsInput | number
    refundToPassenger?: FloatFieldUpdateOperationsInput | number
    adminFee?: FloatFieldUpdateOperationsInput | number
    refundStatus?: StringFieldUpdateOperationsInput | string
    creditNoteAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    profitOrLoss?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refundPayment?: PassengerRefundPaymentUncheckedUpdateOneWithoutCancellationNestedInput
    createdPayable?: SupplierPayableUncheckedUpdateOneWithoutCreatedFromCancellationNestedInput
    generatedCreditNote?: SupplierCreditNoteUncheckedUpdateOneWithoutGeneratedFromCancellationNestedInput
  }

  export type BookingUpsertWithoutCustomerPayablesInput = {
    update: XOR<BookingUpdateWithoutCustomerPayablesInput, BookingUncheckedUpdateWithoutCustomerPayablesInput>
    create: XOR<BookingCreateWithoutCustomerPayablesInput, BookingUncheckedCreateWithoutCustomerPayablesInput>
    where?: BookingWhereInput
  }

  export type BookingUpdateToOneWithWhereWithoutCustomerPayablesInput = {
    where?: BookingWhereInput
    data: XOR<BookingUpdateWithoutCustomerPayablesInput, BookingUncheckedUpdateWithoutCustomerPayablesInput>
  }

  export type BookingUpdateWithoutCustomerPayablesInput = {
    folderNo?: StringFieldUpdateOperationsInput | string
    refNo?: StringFieldUpdateOperationsInput | string
    paxName?: StringFieldUpdateOperationsInput | string
    agentName?: StringFieldUpdateOperationsInput | string
    teamName?: NullableEnumTeamsFieldUpdateOperationsInput | $Enums.Teams | null
    pnr?: StringFieldUpdateOperationsInput | string
    airline?: StringFieldUpdateOperationsInput | string
    fromTo?: StringFieldUpdateOperationsInput | string
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    bookingStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    pcDate?: DateTimeFieldUpdateOperationsInput | Date | string
    issuedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    travelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    prodCost?: NullableFloatFieldUpdateOperationsInput | number | null
    transFee?: NullableFloatFieldUpdateOperationsInput | number | null
    surcharge?: NullableFloatFieldUpdateOperationsInput | number | null
    received?: NullableFloatFieldUpdateOperationsInput | number | null
    transactionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    profit?: NullableFloatFieldUpdateOperationsInput | number | null
    invoiced?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    numPax?: IntFieldUpdateOperationsInput | number
    initialDeposit?: NullableFloatFieldUpdateOperationsInput | number | null
    statusBeforeVoid?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    voidReason?: NullableStringFieldUpdateOperationsInput | string | null
    voidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    costItems?: CostItemUpdateManyWithoutBookingNestedInput
    instalments?: InstalmentUpdateManyWithoutBookingNestedInput
    passengers?: PassengerUpdateManyWithoutBookingNestedInput
    originalBooking?: BookingUpdateOneWithoutFollowUpBookingsNestedInput
    followUpBookings?: BookingUpdateManyWithoutOriginalBookingNestedInput
    voidedBy?: UserUpdateOneWithoutVoidedBookingsNestedInput
    cancellation?: CancellationUpdateOneWithoutOriginalBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutCustomerPayablesInput = {
    id?: IntFieldUpdateOperationsInput | number
    folderNo?: StringFieldUpdateOperationsInput | string
    refNo?: StringFieldUpdateOperationsInput | string
    paxName?: StringFieldUpdateOperationsInput | string
    agentName?: StringFieldUpdateOperationsInput | string
    teamName?: NullableEnumTeamsFieldUpdateOperationsInput | $Enums.Teams | null
    pnr?: StringFieldUpdateOperationsInput | string
    airline?: StringFieldUpdateOperationsInput | string
    fromTo?: StringFieldUpdateOperationsInput | string
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    bookingStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    pcDate?: DateTimeFieldUpdateOperationsInput | Date | string
    issuedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    travelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    prodCost?: NullableFloatFieldUpdateOperationsInput | number | null
    transFee?: NullableFloatFieldUpdateOperationsInput | number | null
    surcharge?: NullableFloatFieldUpdateOperationsInput | number | null
    received?: NullableFloatFieldUpdateOperationsInput | number | null
    transactionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    profit?: NullableFloatFieldUpdateOperationsInput | number | null
    invoiced?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    numPax?: IntFieldUpdateOperationsInput | number
    initialDeposit?: NullableFloatFieldUpdateOperationsInput | number | null
    originalBookingId?: NullableIntFieldUpdateOperationsInput | number | null
    statusBeforeVoid?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    voidReason?: NullableStringFieldUpdateOperationsInput | string | null
    voidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    voidedById?: NullableIntFieldUpdateOperationsInput | number | null
    costItems?: CostItemUncheckedUpdateManyWithoutBookingNestedInput
    instalments?: InstalmentUncheckedUpdateManyWithoutBookingNestedInput
    passengers?: PassengerUncheckedUpdateManyWithoutBookingNestedInput
    followUpBookings?: BookingUncheckedUpdateManyWithoutOriginalBookingNestedInput
    cancellation?: CancellationUncheckedUpdateOneWithoutOriginalBookingNestedInput
  }

  export type CustomerPayableCreateWithoutSettlementsInput = {
    totalAmount: number
    paidAmount?: number
    pendingAmount: number
    reason: string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    createdFromCancellation: CancellationCreateNestedOneWithoutCreatedCustomerPayableInput
    booking: BookingCreateNestedOneWithoutCustomerPayablesInput
  }

  export type CustomerPayableUncheckedCreateWithoutSettlementsInput = {
    id?: number
    totalAmount: number
    paidAmount?: number
    pendingAmount: number
    reason: string
    status?: string
    createdFromCancellationId: number
    bookingId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerPayableCreateOrConnectWithoutSettlementsInput = {
    where: CustomerPayableWhereUniqueInput
    create: XOR<CustomerPayableCreateWithoutSettlementsInput, CustomerPayableUncheckedCreateWithoutSettlementsInput>
  }

  export type CustomerPayableUpsertWithoutSettlementsInput = {
    update: XOR<CustomerPayableUpdateWithoutSettlementsInput, CustomerPayableUncheckedUpdateWithoutSettlementsInput>
    create: XOR<CustomerPayableCreateWithoutSettlementsInput, CustomerPayableUncheckedCreateWithoutSettlementsInput>
    where?: CustomerPayableWhereInput
  }

  export type CustomerPayableUpdateToOneWithWhereWithoutSettlementsInput = {
    where?: CustomerPayableWhereInput
    data: XOR<CustomerPayableUpdateWithoutSettlementsInput, CustomerPayableUncheckedUpdateWithoutSettlementsInput>
  }

  export type CustomerPayableUpdateWithoutSettlementsInput = {
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    pendingAmount?: FloatFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdFromCancellation?: CancellationUpdateOneRequiredWithoutCreatedCustomerPayableNestedInput
    booking?: BookingUpdateOneRequiredWithoutCustomerPayablesNestedInput
  }

  export type CustomerPayableUncheckedUpdateWithoutSettlementsInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    pendingAmount?: FloatFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdFromCancellationId?: IntFieldUpdateOperationsInput | number
    bookingId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CancellationCreateWithoutRefundPaymentInput = {
    folderNo: string
    refundTransactionMethod: string
    originalRevenue: number
    originalProdCost: number
    supplierCancellationFee: number
    refundToPassenger: number
    adminFee?: number
    refundStatus?: string
    creditNoteAmount?: number | null
    profitOrLoss: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    originalBooking: BookingCreateNestedOneWithoutCancellationInput
    createdCustomerPayable?: CustomerPayableCreateNestedOneWithoutCreatedFromCancellationInput
    createdPayable?: SupplierPayableCreateNestedOneWithoutCreatedFromCancellationInput
    generatedCreditNote?: SupplierCreditNoteCreateNestedOneWithoutGeneratedFromCancellationInput
  }

  export type CancellationUncheckedCreateWithoutRefundPaymentInput = {
    id?: number
    originalBookingId: number
    folderNo: string
    refundTransactionMethod: string
    originalRevenue: number
    originalProdCost: number
    supplierCancellationFee: number
    refundToPassenger: number
    adminFee?: number
    refundStatus?: string
    creditNoteAmount?: number | null
    profitOrLoss: number
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdCustomerPayable?: CustomerPayableUncheckedCreateNestedOneWithoutCreatedFromCancellationInput
    createdPayable?: SupplierPayableUncheckedCreateNestedOneWithoutCreatedFromCancellationInput
    generatedCreditNote?: SupplierCreditNoteUncheckedCreateNestedOneWithoutGeneratedFromCancellationInput
  }

  export type CancellationCreateOrConnectWithoutRefundPaymentInput = {
    where: CancellationWhereUniqueInput
    create: XOR<CancellationCreateWithoutRefundPaymentInput, CancellationUncheckedCreateWithoutRefundPaymentInput>
  }

  export type CancellationUpsertWithoutRefundPaymentInput = {
    update: XOR<CancellationUpdateWithoutRefundPaymentInput, CancellationUncheckedUpdateWithoutRefundPaymentInput>
    create: XOR<CancellationCreateWithoutRefundPaymentInput, CancellationUncheckedCreateWithoutRefundPaymentInput>
    where?: CancellationWhereInput
  }

  export type CancellationUpdateToOneWithWhereWithoutRefundPaymentInput = {
    where?: CancellationWhereInput
    data: XOR<CancellationUpdateWithoutRefundPaymentInput, CancellationUncheckedUpdateWithoutRefundPaymentInput>
  }

  export type CancellationUpdateWithoutRefundPaymentInput = {
    folderNo?: StringFieldUpdateOperationsInput | string
    refundTransactionMethod?: StringFieldUpdateOperationsInput | string
    originalRevenue?: FloatFieldUpdateOperationsInput | number
    originalProdCost?: FloatFieldUpdateOperationsInput | number
    supplierCancellationFee?: FloatFieldUpdateOperationsInput | number
    refundToPassenger?: FloatFieldUpdateOperationsInput | number
    adminFee?: FloatFieldUpdateOperationsInput | number
    refundStatus?: StringFieldUpdateOperationsInput | string
    creditNoteAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    profitOrLoss?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    originalBooking?: BookingUpdateOneRequiredWithoutCancellationNestedInput
    createdCustomerPayable?: CustomerPayableUpdateOneWithoutCreatedFromCancellationNestedInput
    createdPayable?: SupplierPayableUpdateOneWithoutCreatedFromCancellationNestedInput
    generatedCreditNote?: SupplierCreditNoteUpdateOneWithoutGeneratedFromCancellationNestedInput
  }

  export type CancellationUncheckedUpdateWithoutRefundPaymentInput = {
    id?: IntFieldUpdateOperationsInput | number
    originalBookingId?: IntFieldUpdateOperationsInput | number
    folderNo?: StringFieldUpdateOperationsInput | string
    refundTransactionMethod?: StringFieldUpdateOperationsInput | string
    originalRevenue?: FloatFieldUpdateOperationsInput | number
    originalProdCost?: FloatFieldUpdateOperationsInput | number
    supplierCancellationFee?: FloatFieldUpdateOperationsInput | number
    refundToPassenger?: FloatFieldUpdateOperationsInput | number
    adminFee?: FloatFieldUpdateOperationsInput | number
    refundStatus?: StringFieldUpdateOperationsInput | string
    creditNoteAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    profitOrLoss?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdCustomerPayable?: CustomerPayableUncheckedUpdateOneWithoutCreatedFromCancellationNestedInput
    createdPayable?: SupplierPayableUncheckedUpdateOneWithoutCreatedFromCancellationNestedInput
    generatedCreditNote?: SupplierCreditNoteUncheckedUpdateOneWithoutGeneratedFromCancellationNestedInput
  }

  export type UserCreateWithoutAuditLogsInput = {
    email: string
    password: string
    title?: $Enums.Title | null
    firstName: string
    lastName: string
    contactNo?: string | null
    role: $Enums.Role
    team?: $Enums.Teams | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdPendingBookings?: PendingBookingCreateNestedManyWithoutCreatedByInput
    voidedBookings?: BookingCreateNestedManyWithoutVoidedByInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: number
    email: string
    password: string
    title?: $Enums.Title | null
    firstName: string
    lastName: string
    contactNo?: string | null
    role: $Enums.Role
    team?: $Enums.Teams | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdPendingBookings?: PendingBookingUncheckedCreateNestedManyWithoutCreatedByInput
    voidedBookings?: BookingUncheckedCreateNestedManyWithoutVoidedByInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    title?: NullableEnumTitleFieldUpdateOperationsInput | $Enums.Title | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    team?: NullableEnumTeamsFieldUpdateOperationsInput | $Enums.Teams | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdPendingBookings?: PendingBookingUpdateManyWithoutCreatedByNestedInput
    voidedBookings?: BookingUpdateManyWithoutVoidedByNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    title?: NullableEnumTitleFieldUpdateOperationsInput | $Enums.Title | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    team?: NullableEnumTeamsFieldUpdateOperationsInput | $Enums.Teams | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdPendingBookings?: PendingBookingUncheckedUpdateManyWithoutCreatedByNestedInput
    voidedBookings?: BookingUncheckedUpdateManyWithoutVoidedByNestedInput
  }

  export type CostItemCreateManyBookingInput = {
    id?: number
    category: string
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InstalmentCreateManyBookingInput = {
    id?: number
    dueDate: Date | string
    amount: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PassengerCreateManyBookingInput = {
    id?: number
    title: $Enums.Title
    firstName: string
    middleName?: string | null
    lastName: string
    gender: $Enums.Gender
    email?: string | null
    contactNo?: string | null
    nationality?: string | null
    birthday?: Date | string | null
    category: $Enums.PassengerCategory
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingCreateManyOriginalBookingInput = {
    id?: number
    folderNo: string
    refNo: string
    paxName: string
    agentName: string
    teamName?: $Enums.Teams | null
    pnr: string
    airline: string
    fromTo: string
    bookingType: $Enums.BookingType
    bookingStatus?: $Enums.BookingStatus | null
    pcDate: Date | string
    issuedDate?: Date | string | null
    paymentMethod: $Enums.PaymentMethod
    lastPaymentDate?: Date | string | null
    travelDate?: Date | string | null
    revenue?: number | null
    prodCost?: number | null
    transFee?: number | null
    surcharge?: number | null
    received?: number | null
    transactionMethod?: string | null
    receivedDate?: Date | string | null
    balance?: number | null
    profit?: number | null
    invoiced?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    numPax: number
    initialDeposit?: number | null
    statusBeforeVoid?: $Enums.BookingStatus | null
    voidReason?: string | null
    voidedAt?: Date | string | null
    voidedById?: number | null
  }

  export type CustomerPayableCreateManyBookingInput = {
    id?: number
    totalAmount: number
    paidAmount?: number
    pendingAmount: number
    reason: string
    status?: string
    createdFromCancellationId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CostItemUpdateWithoutBookingInput = {
    category?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    suppliers?: CostItemSupplierUpdateManyWithoutCostItemNestedInput
  }

  export type CostItemUncheckedUpdateWithoutBookingInput = {
    id?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    suppliers?: CostItemSupplierUncheckedUpdateManyWithoutCostItemNestedInput
  }

  export type CostItemUncheckedUpdateManyWithoutBookingInput = {
    id?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstalmentUpdateWithoutBookingInput = {
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: InstalmentPaymentUpdateManyWithoutInstalmentNestedInput
  }

  export type InstalmentUncheckedUpdateWithoutBookingInput = {
    id?: IntFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: InstalmentPaymentUncheckedUpdateManyWithoutInstalmentNestedInput
  }

  export type InstalmentUncheckedUpdateManyWithoutBookingInput = {
    id?: IntFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PassengerUpdateWithoutBookingInput = {
    title?: EnumTitleFieldUpdateOperationsInput | $Enums.Title
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: EnumPassengerCategoryFieldUpdateOperationsInput | $Enums.PassengerCategory
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PassengerUncheckedUpdateWithoutBookingInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: EnumTitleFieldUpdateOperationsInput | $Enums.Title
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: EnumPassengerCategoryFieldUpdateOperationsInput | $Enums.PassengerCategory
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PassengerUncheckedUpdateManyWithoutBookingInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: EnumTitleFieldUpdateOperationsInput | $Enums.Title
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: EnumPassengerCategoryFieldUpdateOperationsInput | $Enums.PassengerCategory
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUpdateWithoutOriginalBookingInput = {
    folderNo?: StringFieldUpdateOperationsInput | string
    refNo?: StringFieldUpdateOperationsInput | string
    paxName?: StringFieldUpdateOperationsInput | string
    agentName?: StringFieldUpdateOperationsInput | string
    teamName?: NullableEnumTeamsFieldUpdateOperationsInput | $Enums.Teams | null
    pnr?: StringFieldUpdateOperationsInput | string
    airline?: StringFieldUpdateOperationsInput | string
    fromTo?: StringFieldUpdateOperationsInput | string
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    bookingStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    pcDate?: DateTimeFieldUpdateOperationsInput | Date | string
    issuedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    travelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    prodCost?: NullableFloatFieldUpdateOperationsInput | number | null
    transFee?: NullableFloatFieldUpdateOperationsInput | number | null
    surcharge?: NullableFloatFieldUpdateOperationsInput | number | null
    received?: NullableFloatFieldUpdateOperationsInput | number | null
    transactionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    profit?: NullableFloatFieldUpdateOperationsInput | number | null
    invoiced?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    numPax?: IntFieldUpdateOperationsInput | number
    initialDeposit?: NullableFloatFieldUpdateOperationsInput | number | null
    statusBeforeVoid?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    voidReason?: NullableStringFieldUpdateOperationsInput | string | null
    voidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    costItems?: CostItemUpdateManyWithoutBookingNestedInput
    instalments?: InstalmentUpdateManyWithoutBookingNestedInput
    passengers?: PassengerUpdateManyWithoutBookingNestedInput
    followUpBookings?: BookingUpdateManyWithoutOriginalBookingNestedInput
    voidedBy?: UserUpdateOneWithoutVoidedBookingsNestedInput
    customerPayables?: CustomerPayableUpdateManyWithoutBookingNestedInput
    cancellation?: CancellationUpdateOneWithoutOriginalBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutOriginalBookingInput = {
    id?: IntFieldUpdateOperationsInput | number
    folderNo?: StringFieldUpdateOperationsInput | string
    refNo?: StringFieldUpdateOperationsInput | string
    paxName?: StringFieldUpdateOperationsInput | string
    agentName?: StringFieldUpdateOperationsInput | string
    teamName?: NullableEnumTeamsFieldUpdateOperationsInput | $Enums.Teams | null
    pnr?: StringFieldUpdateOperationsInput | string
    airline?: StringFieldUpdateOperationsInput | string
    fromTo?: StringFieldUpdateOperationsInput | string
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    bookingStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    pcDate?: DateTimeFieldUpdateOperationsInput | Date | string
    issuedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    travelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    prodCost?: NullableFloatFieldUpdateOperationsInput | number | null
    transFee?: NullableFloatFieldUpdateOperationsInput | number | null
    surcharge?: NullableFloatFieldUpdateOperationsInput | number | null
    received?: NullableFloatFieldUpdateOperationsInput | number | null
    transactionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    profit?: NullableFloatFieldUpdateOperationsInput | number | null
    invoiced?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    numPax?: IntFieldUpdateOperationsInput | number
    initialDeposit?: NullableFloatFieldUpdateOperationsInput | number | null
    statusBeforeVoid?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    voidReason?: NullableStringFieldUpdateOperationsInput | string | null
    voidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    voidedById?: NullableIntFieldUpdateOperationsInput | number | null
    costItems?: CostItemUncheckedUpdateManyWithoutBookingNestedInput
    instalments?: InstalmentUncheckedUpdateManyWithoutBookingNestedInput
    passengers?: PassengerUncheckedUpdateManyWithoutBookingNestedInput
    followUpBookings?: BookingUncheckedUpdateManyWithoutOriginalBookingNestedInput
    customerPayables?: CustomerPayableUncheckedUpdateManyWithoutBookingNestedInput
    cancellation?: CancellationUncheckedUpdateOneWithoutOriginalBookingNestedInput
  }

  export type BookingUncheckedUpdateManyWithoutOriginalBookingInput = {
    id?: IntFieldUpdateOperationsInput | number
    folderNo?: StringFieldUpdateOperationsInput | string
    refNo?: StringFieldUpdateOperationsInput | string
    paxName?: StringFieldUpdateOperationsInput | string
    agentName?: StringFieldUpdateOperationsInput | string
    teamName?: NullableEnumTeamsFieldUpdateOperationsInput | $Enums.Teams | null
    pnr?: StringFieldUpdateOperationsInput | string
    airline?: StringFieldUpdateOperationsInput | string
    fromTo?: StringFieldUpdateOperationsInput | string
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    bookingStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    pcDate?: DateTimeFieldUpdateOperationsInput | Date | string
    issuedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    travelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    prodCost?: NullableFloatFieldUpdateOperationsInput | number | null
    transFee?: NullableFloatFieldUpdateOperationsInput | number | null
    surcharge?: NullableFloatFieldUpdateOperationsInput | number | null
    received?: NullableFloatFieldUpdateOperationsInput | number | null
    transactionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    profit?: NullableFloatFieldUpdateOperationsInput | number | null
    invoiced?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    numPax?: IntFieldUpdateOperationsInput | number
    initialDeposit?: NullableFloatFieldUpdateOperationsInput | number | null
    statusBeforeVoid?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    voidReason?: NullableStringFieldUpdateOperationsInput | string | null
    voidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    voidedById?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CustomerPayableUpdateWithoutBookingInput = {
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    pendingAmount?: FloatFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settlements?: CustomerPayableSettlementUpdateManyWithoutPayableNestedInput
    createdFromCancellation?: CancellationUpdateOneRequiredWithoutCreatedCustomerPayableNestedInput
  }

  export type CustomerPayableUncheckedUpdateWithoutBookingInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    pendingAmount?: FloatFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdFromCancellationId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settlements?: CustomerPayableSettlementUncheckedUpdateManyWithoutPayableNestedInput
  }

  export type CustomerPayableUncheckedUpdateManyWithoutBookingInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    pendingAmount?: FloatFieldUpdateOperationsInput | number
    reason?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    createdFromCancellationId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PendingCostItemCreateManyPendingBookingInput = {
    id?: number
    category: string
    amount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PendingInstalmentCreateManyPendingBookingInput = {
    id?: number
    dueDate: Date | string
    amount: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PendingPassengerCreateManyPendingBookingInput = {
    id?: number
    title: $Enums.Title
    firstName: string
    middleName?: string | null
    lastName: string
    gender: $Enums.Gender
    email?: string | null
    contactNo?: string | null
    nationality?: string | null
    birthday?: Date | string | null
    category: $Enums.PassengerCategory
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PendingCostItemUpdateWithoutPendingBookingInput = {
    category?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    suppliers?: CostItemSupplierUpdateManyWithoutPendingCostItemNestedInput
  }

  export type PendingCostItemUncheckedUpdateWithoutPendingBookingInput = {
    id?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    suppliers?: CostItemSupplierUncheckedUpdateManyWithoutPendingCostItemNestedInput
  }

  export type PendingCostItemUncheckedUpdateManyWithoutPendingBookingInput = {
    id?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PendingInstalmentUpdateWithoutPendingBookingInput = {
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PendingInstalmentUncheckedUpdateWithoutPendingBookingInput = {
    id?: IntFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PendingInstalmentUncheckedUpdateManyWithoutPendingBookingInput = {
    id?: IntFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PendingPassengerUpdateWithoutPendingBookingInput = {
    title?: EnumTitleFieldUpdateOperationsInput | $Enums.Title
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: EnumPassengerCategoryFieldUpdateOperationsInput | $Enums.PassengerCategory
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PendingPassengerUncheckedUpdateWithoutPendingBookingInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: EnumTitleFieldUpdateOperationsInput | $Enums.Title
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: EnumPassengerCategoryFieldUpdateOperationsInput | $Enums.PassengerCategory
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PendingPassengerUncheckedUpdateManyWithoutPendingBookingInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: EnumTitleFieldUpdateOperationsInput | $Enums.Title
    firstName?: StringFieldUpdateOperationsInput | string
    middleName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    email?: NullableStringFieldUpdateOperationsInput | string | null
    contactNo?: NullableStringFieldUpdateOperationsInput | string | null
    nationality?: NullableStringFieldUpdateOperationsInput | string | null
    birthday?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    category?: EnumPassengerCategoryFieldUpdateOperationsInput | $Enums.PassengerCategory
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstalmentPaymentCreateManyInstalmentInput = {
    id?: number
    amount: number
    transactionMethod: string
    paymentDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InstalmentPaymentUpdateWithoutInstalmentInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    transactionMethod?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstalmentPaymentUncheckedUpdateWithoutInstalmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    transactionMethod?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InstalmentPaymentUncheckedUpdateManyWithoutInstalmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    transactionMethod?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PendingBookingCreateManyCreatedByInput = {
    id?: number
    refNo: string
    paxName: string
    agentName: string
    teamName?: $Enums.Teams | null
    pnr: string
    airline: string
    fromTo: string
    bookingType: $Enums.BookingType
    bookingStatus?: $Enums.BookingStatus | null
    pcDate: Date | string
    issuedDate?: Date | string | null
    paymentMethod: $Enums.PaymentMethod
    lastPaymentDate?: Date | string | null
    travelDate?: Date | string | null
    revenue?: number | null
    prodCost?: number | null
    transFee?: number | null
    surcharge?: number | null
    received?: number | null
    transactionMethod?: string | null
    receivedDate?: Date | string | null
    balance?: number | null
    profit?: number | null
    invoiced?: string | null
    description?: string | null
    status?: $Enums.PendingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    numPax: number
  }

  export type BookingCreateManyVoidedByInput = {
    id?: number
    folderNo: string
    refNo: string
    paxName: string
    agentName: string
    teamName?: $Enums.Teams | null
    pnr: string
    airline: string
    fromTo: string
    bookingType: $Enums.BookingType
    bookingStatus?: $Enums.BookingStatus | null
    pcDate: Date | string
    issuedDate?: Date | string | null
    paymentMethod: $Enums.PaymentMethod
    lastPaymentDate?: Date | string | null
    travelDate?: Date | string | null
    revenue?: number | null
    prodCost?: number | null
    transFee?: number | null
    surcharge?: number | null
    received?: number | null
    transactionMethod?: string | null
    receivedDate?: Date | string | null
    balance?: number | null
    profit?: number | null
    invoiced?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    numPax: number
    initialDeposit?: number | null
    originalBookingId?: number | null
    statusBeforeVoid?: $Enums.BookingStatus | null
    voidReason?: string | null
    voidedAt?: Date | string | null
  }

  export type AuditLogCreateManyUserInput = {
    id?: number
    modelName: string
    recordId: number
    action: $Enums.ActionType
    fieldName?: string | null
    oldValue?: string | null
    newValue?: string | null
    createdAt?: Date | string
  }

  export type PendingBookingUpdateWithoutCreatedByInput = {
    refNo?: StringFieldUpdateOperationsInput | string
    paxName?: StringFieldUpdateOperationsInput | string
    agentName?: StringFieldUpdateOperationsInput | string
    teamName?: NullableEnumTeamsFieldUpdateOperationsInput | $Enums.Teams | null
    pnr?: StringFieldUpdateOperationsInput | string
    airline?: StringFieldUpdateOperationsInput | string
    fromTo?: StringFieldUpdateOperationsInput | string
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    bookingStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    pcDate?: DateTimeFieldUpdateOperationsInput | Date | string
    issuedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    travelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    prodCost?: NullableFloatFieldUpdateOperationsInput | number | null
    transFee?: NullableFloatFieldUpdateOperationsInput | number | null
    surcharge?: NullableFloatFieldUpdateOperationsInput | number | null
    received?: NullableFloatFieldUpdateOperationsInput | number | null
    transactionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    profit?: NullableFloatFieldUpdateOperationsInput | number | null
    invoiced?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPendingStatusFieldUpdateOperationsInput | $Enums.PendingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    numPax?: IntFieldUpdateOperationsInput | number
    costItems?: PendingCostItemUpdateManyWithoutPendingBookingNestedInput
    instalments?: PendingInstalmentUpdateManyWithoutPendingBookingNestedInput
    passengers?: PendingPassengerUpdateManyWithoutPendingBookingNestedInput
  }

  export type PendingBookingUncheckedUpdateWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    refNo?: StringFieldUpdateOperationsInput | string
    paxName?: StringFieldUpdateOperationsInput | string
    agentName?: StringFieldUpdateOperationsInput | string
    teamName?: NullableEnumTeamsFieldUpdateOperationsInput | $Enums.Teams | null
    pnr?: StringFieldUpdateOperationsInput | string
    airline?: StringFieldUpdateOperationsInput | string
    fromTo?: StringFieldUpdateOperationsInput | string
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    bookingStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    pcDate?: DateTimeFieldUpdateOperationsInput | Date | string
    issuedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    travelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    prodCost?: NullableFloatFieldUpdateOperationsInput | number | null
    transFee?: NullableFloatFieldUpdateOperationsInput | number | null
    surcharge?: NullableFloatFieldUpdateOperationsInput | number | null
    received?: NullableFloatFieldUpdateOperationsInput | number | null
    transactionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    profit?: NullableFloatFieldUpdateOperationsInput | number | null
    invoiced?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPendingStatusFieldUpdateOperationsInput | $Enums.PendingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    numPax?: IntFieldUpdateOperationsInput | number
    costItems?: PendingCostItemUncheckedUpdateManyWithoutPendingBookingNestedInput
    instalments?: PendingInstalmentUncheckedUpdateManyWithoutPendingBookingNestedInput
    passengers?: PendingPassengerUncheckedUpdateManyWithoutPendingBookingNestedInput
  }

  export type PendingBookingUncheckedUpdateManyWithoutCreatedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    refNo?: StringFieldUpdateOperationsInput | string
    paxName?: StringFieldUpdateOperationsInput | string
    agentName?: StringFieldUpdateOperationsInput | string
    teamName?: NullableEnumTeamsFieldUpdateOperationsInput | $Enums.Teams | null
    pnr?: StringFieldUpdateOperationsInput | string
    airline?: StringFieldUpdateOperationsInput | string
    fromTo?: StringFieldUpdateOperationsInput | string
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    bookingStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    pcDate?: DateTimeFieldUpdateOperationsInput | Date | string
    issuedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    travelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    prodCost?: NullableFloatFieldUpdateOperationsInput | number | null
    transFee?: NullableFloatFieldUpdateOperationsInput | number | null
    surcharge?: NullableFloatFieldUpdateOperationsInput | number | null
    received?: NullableFloatFieldUpdateOperationsInput | number | null
    transactionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    profit?: NullableFloatFieldUpdateOperationsInput | number | null
    invoiced?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPendingStatusFieldUpdateOperationsInput | $Enums.PendingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    numPax?: IntFieldUpdateOperationsInput | number
  }

  export type BookingUpdateWithoutVoidedByInput = {
    folderNo?: StringFieldUpdateOperationsInput | string
    refNo?: StringFieldUpdateOperationsInput | string
    paxName?: StringFieldUpdateOperationsInput | string
    agentName?: StringFieldUpdateOperationsInput | string
    teamName?: NullableEnumTeamsFieldUpdateOperationsInput | $Enums.Teams | null
    pnr?: StringFieldUpdateOperationsInput | string
    airline?: StringFieldUpdateOperationsInput | string
    fromTo?: StringFieldUpdateOperationsInput | string
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    bookingStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    pcDate?: DateTimeFieldUpdateOperationsInput | Date | string
    issuedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    travelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    prodCost?: NullableFloatFieldUpdateOperationsInput | number | null
    transFee?: NullableFloatFieldUpdateOperationsInput | number | null
    surcharge?: NullableFloatFieldUpdateOperationsInput | number | null
    received?: NullableFloatFieldUpdateOperationsInput | number | null
    transactionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    profit?: NullableFloatFieldUpdateOperationsInput | number | null
    invoiced?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    numPax?: IntFieldUpdateOperationsInput | number
    initialDeposit?: NullableFloatFieldUpdateOperationsInput | number | null
    statusBeforeVoid?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    voidReason?: NullableStringFieldUpdateOperationsInput | string | null
    voidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    costItems?: CostItemUpdateManyWithoutBookingNestedInput
    instalments?: InstalmentUpdateManyWithoutBookingNestedInput
    passengers?: PassengerUpdateManyWithoutBookingNestedInput
    originalBooking?: BookingUpdateOneWithoutFollowUpBookingsNestedInput
    followUpBookings?: BookingUpdateManyWithoutOriginalBookingNestedInput
    customerPayables?: CustomerPayableUpdateManyWithoutBookingNestedInput
    cancellation?: CancellationUpdateOneWithoutOriginalBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutVoidedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    folderNo?: StringFieldUpdateOperationsInput | string
    refNo?: StringFieldUpdateOperationsInput | string
    paxName?: StringFieldUpdateOperationsInput | string
    agentName?: StringFieldUpdateOperationsInput | string
    teamName?: NullableEnumTeamsFieldUpdateOperationsInput | $Enums.Teams | null
    pnr?: StringFieldUpdateOperationsInput | string
    airline?: StringFieldUpdateOperationsInput | string
    fromTo?: StringFieldUpdateOperationsInput | string
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    bookingStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    pcDate?: DateTimeFieldUpdateOperationsInput | Date | string
    issuedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    travelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    prodCost?: NullableFloatFieldUpdateOperationsInput | number | null
    transFee?: NullableFloatFieldUpdateOperationsInput | number | null
    surcharge?: NullableFloatFieldUpdateOperationsInput | number | null
    received?: NullableFloatFieldUpdateOperationsInput | number | null
    transactionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    profit?: NullableFloatFieldUpdateOperationsInput | number | null
    invoiced?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    numPax?: IntFieldUpdateOperationsInput | number
    initialDeposit?: NullableFloatFieldUpdateOperationsInput | number | null
    originalBookingId?: NullableIntFieldUpdateOperationsInput | number | null
    statusBeforeVoid?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    voidReason?: NullableStringFieldUpdateOperationsInput | string | null
    voidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    costItems?: CostItemUncheckedUpdateManyWithoutBookingNestedInput
    instalments?: InstalmentUncheckedUpdateManyWithoutBookingNestedInput
    passengers?: PassengerUncheckedUpdateManyWithoutBookingNestedInput
    followUpBookings?: BookingUncheckedUpdateManyWithoutOriginalBookingNestedInput
    customerPayables?: CustomerPayableUncheckedUpdateManyWithoutBookingNestedInput
    cancellation?: CancellationUncheckedUpdateOneWithoutOriginalBookingNestedInput
  }

  export type BookingUncheckedUpdateManyWithoutVoidedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    folderNo?: StringFieldUpdateOperationsInput | string
    refNo?: StringFieldUpdateOperationsInput | string
    paxName?: StringFieldUpdateOperationsInput | string
    agentName?: StringFieldUpdateOperationsInput | string
    teamName?: NullableEnumTeamsFieldUpdateOperationsInput | $Enums.Teams | null
    pnr?: StringFieldUpdateOperationsInput | string
    airline?: StringFieldUpdateOperationsInput | string
    fromTo?: StringFieldUpdateOperationsInput | string
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    bookingStatus?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    pcDate?: DateTimeFieldUpdateOperationsInput | Date | string
    issuedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    lastPaymentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    travelDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revenue?: NullableFloatFieldUpdateOperationsInput | number | null
    prodCost?: NullableFloatFieldUpdateOperationsInput | number | null
    transFee?: NullableFloatFieldUpdateOperationsInput | number | null
    surcharge?: NullableFloatFieldUpdateOperationsInput | number | null
    received?: NullableFloatFieldUpdateOperationsInput | number | null
    transactionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    receivedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    profit?: NullableFloatFieldUpdateOperationsInput | number | null
    invoiced?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    numPax?: IntFieldUpdateOperationsInput | number
    initialDeposit?: NullableFloatFieldUpdateOperationsInput | number | null
    originalBookingId?: NullableIntFieldUpdateOperationsInput | number | null
    statusBeforeVoid?: NullableEnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus | null
    voidReason?: NullableStringFieldUpdateOperationsInput | string | null
    voidedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AuditLogUpdateWithoutUserInput = {
    modelName?: StringFieldUpdateOperationsInput | string
    recordId?: IntFieldUpdateOperationsInput | number
    action?: EnumActionTypeFieldUpdateOperationsInput | $Enums.ActionType
    fieldName?: NullableStringFieldUpdateOperationsInput | string | null
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    modelName?: StringFieldUpdateOperationsInput | string
    recordId?: IntFieldUpdateOperationsInput | number
    action?: EnumActionTypeFieldUpdateOperationsInput | $Enums.ActionType
    fieldName?: NullableStringFieldUpdateOperationsInput | string | null
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    modelName?: StringFieldUpdateOperationsInput | string
    recordId?: IntFieldUpdateOperationsInput | number
    action?: EnumActionTypeFieldUpdateOperationsInput | $Enums.ActionType
    fieldName?: NullableStringFieldUpdateOperationsInput | string | null
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CostItemSupplierCreateManyCostItemInput = {
    id?: number
    pendingCostItemId?: number | null
    supplier: $Enums.Suppliers
    amount: number
    paymentMethod?: string
    paidAmount?: number
    pendingAmount?: number
    transactionMethod?: string | null
    firstMethodAmount?: number | null
    secondMethodAmount?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CostItemSupplierUpdateWithoutCostItemInput = {
    supplier?: EnumSuppliersFieldUpdateOperationsInput | $Enums.Suppliers
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: StringFieldUpdateOperationsInput | string
    paidAmount?: FloatFieldUpdateOperationsInput | number
    pendingAmount?: FloatFieldUpdateOperationsInput | number
    transactionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    firstMethodAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    secondMethodAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pendingCostItem?: PendingCostItemUpdateOneWithoutSuppliersNestedInput
    settlements?: SupplierPaymentSettlementUpdateManyWithoutCostItemSupplierNestedInput
    paidByCreditNoteUsage?: CreditNoteUsageUpdateManyWithoutUsedOnCostItemSupplierNestedInput
  }

  export type CostItemSupplierUncheckedUpdateWithoutCostItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    pendingCostItemId?: NullableIntFieldUpdateOperationsInput | number | null
    supplier?: EnumSuppliersFieldUpdateOperationsInput | $Enums.Suppliers
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: StringFieldUpdateOperationsInput | string
    paidAmount?: FloatFieldUpdateOperationsInput | number
    pendingAmount?: FloatFieldUpdateOperationsInput | number
    transactionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    firstMethodAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    secondMethodAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settlements?: SupplierPaymentSettlementUncheckedUpdateManyWithoutCostItemSupplierNestedInput
    paidByCreditNoteUsage?: CreditNoteUsageUncheckedUpdateManyWithoutUsedOnCostItemSupplierNestedInput
  }

  export type CostItemSupplierUncheckedUpdateManyWithoutCostItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    pendingCostItemId?: NullableIntFieldUpdateOperationsInput | number | null
    supplier?: EnumSuppliersFieldUpdateOperationsInput | $Enums.Suppliers
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: StringFieldUpdateOperationsInput | string
    paidAmount?: FloatFieldUpdateOperationsInput | number
    pendingAmount?: FloatFieldUpdateOperationsInput | number
    transactionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    firstMethodAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    secondMethodAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CostItemSupplierCreateManyPendingCostItemInput = {
    id?: number
    costItemId?: number | null
    supplier: $Enums.Suppliers
    amount: number
    paymentMethod?: string
    paidAmount?: number
    pendingAmount?: number
    transactionMethod?: string | null
    firstMethodAmount?: number | null
    secondMethodAmount?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CostItemSupplierUpdateWithoutPendingCostItemInput = {
    supplier?: EnumSuppliersFieldUpdateOperationsInput | $Enums.Suppliers
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: StringFieldUpdateOperationsInput | string
    paidAmount?: FloatFieldUpdateOperationsInput | number
    pendingAmount?: FloatFieldUpdateOperationsInput | number
    transactionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    firstMethodAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    secondMethodAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    costItem?: CostItemUpdateOneWithoutSuppliersNestedInput
    settlements?: SupplierPaymentSettlementUpdateManyWithoutCostItemSupplierNestedInput
    paidByCreditNoteUsage?: CreditNoteUsageUpdateManyWithoutUsedOnCostItemSupplierNestedInput
  }

  export type CostItemSupplierUncheckedUpdateWithoutPendingCostItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    costItemId?: NullableIntFieldUpdateOperationsInput | number | null
    supplier?: EnumSuppliersFieldUpdateOperationsInput | $Enums.Suppliers
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: StringFieldUpdateOperationsInput | string
    paidAmount?: FloatFieldUpdateOperationsInput | number
    pendingAmount?: FloatFieldUpdateOperationsInput | number
    transactionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    firstMethodAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    secondMethodAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settlements?: SupplierPaymentSettlementUncheckedUpdateManyWithoutCostItemSupplierNestedInput
    paidByCreditNoteUsage?: CreditNoteUsageUncheckedUpdateManyWithoutUsedOnCostItemSupplierNestedInput
  }

  export type CostItemSupplierUncheckedUpdateManyWithoutPendingCostItemInput = {
    id?: IntFieldUpdateOperationsInput | number
    costItemId?: NullableIntFieldUpdateOperationsInput | number | null
    supplier?: EnumSuppliersFieldUpdateOperationsInput | $Enums.Suppliers
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: StringFieldUpdateOperationsInput | string
    paidAmount?: FloatFieldUpdateOperationsInput | number
    pendingAmount?: FloatFieldUpdateOperationsInput | number
    transactionMethod?: NullableStringFieldUpdateOperationsInput | string | null
    firstMethodAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    secondMethodAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierPaymentSettlementCreateManyCostItemSupplierInput = {
    id?: number
    amount: number
    transactionMethod: string
    settlementDate: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CreditNoteUsageCreateManyUsedOnCostItemSupplierInput = {
    id?: number
    amountUsed: number
    usedAt?: Date | string
    creditNoteId: number
  }

  export type SupplierPaymentSettlementUpdateWithoutCostItemSupplierInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    transactionMethod?: StringFieldUpdateOperationsInput | string
    settlementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierPaymentSettlementUncheckedUpdateWithoutCostItemSupplierInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    transactionMethod?: StringFieldUpdateOperationsInput | string
    settlementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierPaymentSettlementUncheckedUpdateManyWithoutCostItemSupplierInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    transactionMethod?: StringFieldUpdateOperationsInput | string
    settlementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CreditNoteUsageUpdateWithoutUsedOnCostItemSupplierInput = {
    amountUsed?: FloatFieldUpdateOperationsInput | number
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creditNote?: SupplierCreditNoteUpdateOneRequiredWithoutUsageHistoryNestedInput
  }

  export type CreditNoteUsageUncheckedUpdateWithoutUsedOnCostItemSupplierInput = {
    id?: IntFieldUpdateOperationsInput | number
    amountUsed?: FloatFieldUpdateOperationsInput | number
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creditNoteId?: IntFieldUpdateOperationsInput | number
  }

  export type CreditNoteUsageUncheckedUpdateManyWithoutUsedOnCostItemSupplierInput = {
    id?: IntFieldUpdateOperationsInput | number
    amountUsed?: FloatFieldUpdateOperationsInput | number
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creditNoteId?: IntFieldUpdateOperationsInput | number
  }

  export type CreditNoteUsageCreateManyCreditNoteInput = {
    id?: number
    amountUsed: number
    usedAt?: Date | string
    usedOnCostItemSupplierId: number
  }

  export type CreditNoteUsageUpdateWithoutCreditNoteInput = {
    amountUsed?: FloatFieldUpdateOperationsInput | number
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedOnCostItemSupplier?: CostItemSupplierUpdateOneRequiredWithoutPaidByCreditNoteUsageNestedInput
  }

  export type CreditNoteUsageUncheckedUpdateWithoutCreditNoteInput = {
    id?: IntFieldUpdateOperationsInput | number
    amountUsed?: FloatFieldUpdateOperationsInput | number
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedOnCostItemSupplierId?: IntFieldUpdateOperationsInput | number
  }

  export type CreditNoteUsageUncheckedUpdateManyWithoutCreditNoteInput = {
    id?: IntFieldUpdateOperationsInput | number
    amountUsed?: FloatFieldUpdateOperationsInput | number
    usedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedOnCostItemSupplierId?: IntFieldUpdateOperationsInput | number
  }

  export type SupplierPayableSettlementCreateManyPayableInput = {
    id?: number
    amount: number
    transactionMethod: string
    settlementDate: Date | string
    createdAt?: Date | string
  }

  export type SupplierPayableSettlementUpdateWithoutPayableInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    transactionMethod?: StringFieldUpdateOperationsInput | string
    settlementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierPayableSettlementUncheckedUpdateWithoutPayableInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    transactionMethod?: StringFieldUpdateOperationsInput | string
    settlementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierPayableSettlementUncheckedUpdateManyWithoutPayableInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    transactionMethod?: StringFieldUpdateOperationsInput | string
    settlementDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerPayableSettlementCreateManyPayableInput = {
    id?: number
    amount: number
    transactionMethod: string
    paymentDate: Date | string
    createdAt?: Date | string
  }

  export type CustomerPayableSettlementUpdateWithoutPayableInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    transactionMethod?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerPayableSettlementUncheckedUpdateWithoutPayableInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    transactionMethod?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerPayableSettlementUncheckedUpdateManyWithoutPayableInput = {
    id?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    transactionMethod?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}