generator client {
  provider = "prisma-client-js"
  binaryTargets = ["native", "debian-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url = env("DB_url")
}

model Booking {
  id                Int             @id @default(autoincrement())
  folderNo          String          @unique @map("folder_no")
  refNo             String          @map("ref_no") 
  paxName           String          @map("pax_name")
  agentName         String          @map("agent_name")  
  teamName          Teams?          @map("team_name")  
  pnr               String          @map("pnr") 
  airline           String          @map("airline")
  fromTo            String          @map("from_to")
  bookingType       BookingType     @map("booking_type")
  bookingStatus     BookingStatus?  @map("booking_status")
  pcDate            DateTime        @map("pc_date")
  issuedDate        DateTime?       @map("issued_date")
  paymentMethod     PaymentMethod   @map("payment_method")
  lastPaymentDate   DateTime?       @map("last_payment_date")
  travelDate        DateTime?       @map("travel_date")
  revenue           Float?          @map("revenue")
  prodCost          Float?          @map("prod_cost")
  transFee          Float?          @map("trans_fee")
  surcharge         Float?          @map("surcharge")
  initialPayments   InitialPayment[]
  balance           Float?          @map("balance")
  profit            Float?          @map("profit")
  invoiced          String?         @map("invoice")
  description       String?         @map("description")
  createdAt         DateTime        @default(now()) @map("created_at")
  updatedAt         DateTime        @updatedAt @map("updated_at")
  costItems         CostItem[] 
  instalments       Instalment[]    
  passengers        Passenger[]
  numPax            Int             @map("num_pax")
  initialDeposit    Float?          @map("initial_deposit")

  originalBookingId Int?            @map("original_booking_id")
  originalBooking   Booking?        @relation("BookingChain", fields: [originalBookingId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  followUpBookings  Booking[]       @relation("BookingChain")

  statusBeforeVoid  BookingStatus? @map("status_before_void")
  voidReason        String?        @map("void_reason")
  voidedAt          DateTime?      @map("voided_at")
  voidedById        String?        @map("voided_by_id")
  voidedBy          User?          @relation("VoidedBookings", fields: [voidedById], references: [id])

  customerPayables        CustomerPayable[]

  cancellation      Cancellation?   

  @@map("bookings")
}

model PendingBooking {
  id                Int             @id @default(autoincrement())
  refNo             String          @map("ref_no")
  paxName           String          @map("pax_name")
  agentName         String          @map("agent_name")
  teamName          Teams?          @map("team_name")
  pnr               String          @map("pnr")
  airline           String          @map("airline")
  fromTo            String          @map("from_to")
  bookingType       BookingType     @map("booking_type")
  bookingStatus     BookingStatus?  @map("booking_status")
  pcDate            DateTime        @map("pc_date")
  issuedDate        DateTime?       @map("issued_date")
  paymentMethod     PaymentMethod   @map("payment_method")
  lastPaymentDate   DateTime?       @map("last_payment_date")
  travelDate        DateTime?       @map("travel_date")
  revenue           Float?          @map("revenue")
  prodCost          Float?          @map("prod_cost")
  transFee          Float?          @map("trans_fee")
  surcharge         Float?          @map("surcharge")
  initialPayments   InitialPayment[]
  balance           Float?          @map("balance")
  profit            Float?          @map("profit")
  invoiced          String?         @map("invoice")
  description       String?         @map("description")
  status            PendingStatus   @default(PENDING) @map("status")
  createdAt         DateTime        @default(now()) @map("created_at")
  updatedAt         DateTime        @updatedAt @map("updated_at")
  costItems         PendingCostItem[]
  instalments       PendingInstalment[]
  passengers        PendingPassenger[]
  numPax            Int             @map("num_pax")

  createdById       String          @map("created_by_id")
  createdBy         User            @relation(fields: [createdById], references: [id])

  @@map("pending_bookings")
}

model Instalment {
  id            Int              @id @default(autoincrement())
  bookingId     Int
  dueDate       DateTime         @map("due_date")
  amount        Float
  status        String           @default("PENDING")
  booking       Booking          @relation(fields: [bookingId], references: [id], onDelete: Cascade)
  payments      InstalmentPayment[]
  createdAt     DateTime         @default(now()) @map("created_at")
  updatedAt     DateTime         @updatedAt @map("updated_at")
  @@map("instalments")
}

model PendingInstalment {
  id                Int            @id @default(autoincrement())
  pendingBookingId  Int
  dueDate           DateTime       @map("due_date")
  amount            Float
  status            String         @default("PENDING")
  pendingBooking    PendingBooking @relation(fields: [pendingBookingId], references: [id], onDelete: Cascade)
  createdAt         DateTime       @default(now()) @map("created_at")
  updatedAt         DateTime       @updatedAt @map("updated_at")
  @@map("pending_instalments")
}

model InstalmentPayment {
  id            Int        @id @default(autoincrement())
  instalmentId  Int
  amount        Float
  transactionMethod String
  paymentDate   DateTime
  instalment    Instalment @relation(fields: [instalmentId], references: [id], onDelete: Cascade)
  createdAt     DateTime   @default(now()) @map("created_at")
  updatedAt     DateTime   @updatedAt @map("updated_at")
  @@map("instalment_payments")
}

enum InstalmentStatus {
  PENDING
  PAID
  OVERDUE
}

model User {
  id        String   @id
  email     String   @unique // CHANGED: Made non-nullable as it's the primary login identifier.
  
  title     Title?   // CHANGED: Re-using the existing 'Title' enum for consistency.
  firstName String   @map("first_name")
  lastName  String   @map("last_name")
  contactNo String?  @map("contact_no")
  role      Role     // This will use the new Role enum below.
  team      Teams?   // NEW: Added the team property as requested. It's optional.
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at") // NEW: Added for tracking updates.

  createdPendingBookings PendingBooking[]
  voidedBookings Booking[] @relation("VoidedBookings")
  auditLogs AuditLog[]

  @@map("users")
}

model CostItem {
  id            Int            @id @default(autoincrement())
  bookingId     Int
  category      String
  amount        Float
  booking       Booking        @relation(fields: [bookingId], references: [id], onDelete: Cascade)
  suppliers     CostItemSupplier[]
  createdAt     DateTime       @default(now()) @map("created_at")
  updatedAt     DateTime       @updatedAt @map("updated_at")
  @@map("cost_items")
}

model PendingCostItem {
  id                Int            @id @default(autoincrement())
  pendingBookingId  Int
  category          String
  amount            Float
  pendingBooking    PendingBooking @relation(fields: [pendingBookingId], references: [id], onDelete: Cascade)
  suppliers         CostItemSupplier[]
  createdAt         DateTime       @default(now()) @map("created_at")
  updatedAt         DateTime       @updatedAt @map("updated_at")
  @@map("pending_cost_items")
}

enum Teams {
  PH
  TOURS
  MARKETING // NEW
  QC        // NEW
  IT        // NEW
}

enum Role {
  ADMIN
  CONSULTANT
  MANAGEMENT
  SUPER_MANAGER // NOTE: Enum values with spaces are written with underscores.
  SUPER_ADMIN
}

enum Suppliers {
  BTRES
  LYCA
  CEBU
  BTRES_LYCA
  BA
  TRAINLINE
  EASYJET
  FLYDUBAI
}


enum BookingType {
  FRESH
  DATE_CHANGE
  CANCELLATION
}

enum PaxType {
  FRESH
  REFERRAL
  REPEAT
}

enum PaymentMethod {
  FULL
  INTERNAL
  REFUND
  HUMM
  FULL_HUMM
  INTERNAL_HUMM
}

enum BookingStatus {
  PENDING
  CONFIRMED
  COMPLETED
  CANCELLED
  VOID
}

enum PendingStatus {
  PENDING
  APPROVED
  REJECTED
}

enum Title {
  MR
  MRS
  MS
  MASTER
}

enum Gender {
  MALE
  FEMALE
  OTHER
}

enum PassengerCategory {
  ADULT
  CHILD
  INFANT
}

model Passenger {
  id            Int               @id @default(autoincrement())
  bookingId     Int
  title         Title
  firstName     String            @map("first_name")
  middleName    String?           @map("middle_name")
  lastName      String            @map("last_name")
  gender        Gender
  email         String?
  contactNo     String?           @map("contact_no")
  nationality   String?           @map("nationality")
  birthday      DateTime?         @map("birthday")
  category      PassengerCategory
  booking       Booking           @relation(fields: [bookingId], references: [id], onDelete: Cascade)
  createdAt     DateTime          @default(now()) @map("created_at")
  updatedAt     DateTime          @updatedAt @map("updated_at")
  @@map("passengers")
}

model PendingPassenger {
  id                Int               @id @default(autoincrement())
  pendingBookingId  Int
  title             Title
  firstName         String            @map("first_name")
  middleName        String?           @map("middle_name")
  lastName          String            @map("last_name")
  gender            Gender
  email             String?
  contactNo         String?           @map("contact_no")
  nationality       String?           @map("nationality")
  birthday          DateTime?         @map("birthday")
  category          PassengerCategory
  pendingBooking    PendingBooking     @relation(fields: [pendingBookingId], references: [id], onDelete: Cascade)
  createdAt         DateTime          @default(now()) @map("created_at")
  updatedAt         DateTime          @updatedAt @map("updated_at")
  @@map("pending_passengers")
}

model CostItemSupplier {
  id                     Int                     @id @default(autoincrement())
  costItemId             Int?
  pendingCostItemId      Int?
  supplier               Suppliers
  amount                 Float
  paymentMethod          String                  @default("BANK_TRANSFER")
  paidAmount             Float                   @default(0.0)
  pendingAmount          Float                   @default(0.0)
  transactionMethod      String?
  firstMethodAmount      Float?           
  secondMethodAmount     Float?          
  costItem               CostItem?               @relation(fields: [costItemId], references: [id], onDelete: Cascade)
  pendingCostItem        PendingCostItem?        @relation(fields: [pendingCostItemId], references: [id], onDelete: Cascade)
  settlements            SupplierPaymentSettlement[]
  createdAt              DateTime                @default(now()) @map("created_at")
  updatedAt              DateTime                @updatedAt @map("updated_at")
  paidByCreditNoteUsage  CreditNoteUsage[]


  @@map("cost_item_suppliers")
}

model SupplierPaymentSettlement {
  id                Int              @id @default(autoincrement())
  costItemSupplierId Int
  amount            Float
  transactionMethod String
  settlementDate    DateTime
  costItemSupplier  CostItemSupplier @relation(fields: [costItemSupplierId], references: [id], onDelete: Cascade)
  createdAt         DateTime         @default(now()) @map("created_at")
  updatedAt         DateTime         @updatedAt @map("updated_at")
  @@map("supplier_payment_settlements")
}

enum CreditNoteStatus {
  AVAILABLE
  PARTIALLY_USED
  USED
}


// In prisma/schema.prisma, find the Cancellation model

model Cancellation {
  id                      Int      @id @default(autoincrement())
  originalBookingId       Int      @unique @map("original_booking_id")
  originalBooking         Booking  @relation(fields: [originalBookingId], references: [id])
  
  // --- NEW FIELDS TO ADD ---
  folderNo                String         @unique @map("folder_no") // Its own unique folder number
  refundTransactionMethod String   @map("refund_transaction_method") // How we paid the pax

  // Snapshot of the original booking's key financials
  originalRevenue         Float    @map("original_revenue")
  originalProdCost        Float    @map("original_prod_cost")

  // The new transaction details you input
  supplierCancellationFee Float    @map("supplier_cancellation_fee")
  refundToPassenger       Float    @map("refund_to_passenger")

  adminFee                Float    @default(0.0) @map("admin_fee")
  refundStatus            String   @default("N/A") @map("refund_status")
  refundPayment           PassengerRefundPayment?
  
  // The results of this transaction
  creditNoteAmount        Float?   @map("credit_note_amount")
  profitOrLoss            Float    @map("profit_or_loss")

  description             String?
  createdAt               DateTime @default(now()) @map("created_at")
  updatedAt               DateTime @updatedAt @map("updated_at")

  createdCustomerPayable  CustomerPayable?

  createdPayable          SupplierPayable?
  generatedCreditNote     SupplierCreditNote?



  @@map("cancellations")
}

// Add this model for the credit notes
model SupplierCreditNote {
  id                 Int      @id @default(autoincrement())
  supplier           Suppliers
  initialAmount      Float    @map("initial_amount")
  remainingAmount    Float    @map("remaining_amount")
  status             CreditNoteStatus @default(AVAILABLE)
  generatedFromCancellationId Int @unique @map("generated_from_cancellation_id")
  generatedFromCancellation Cancellation @relation(fields: [generatedFromCancellationId], references: [id])
  
  // This links to all the times this credit note was used
  usageHistory       CreditNoteUsage[]

  createdAt          DateTime @default(now()) @map("created_at")
  updatedAt          DateTime @updatedAt @map("updated_at")
  @@map("supplier_credit_notes")
}

// Add this model to track the usage history
// In prisma/schema.prisma

model CreditNoteUsage {
  id                  Int      @id @default(autoincrement())
  amountUsed          Float    @map("amount_used")
  usedAt              DateTime @default(now()) @map("used_at")

  creditNoteId        Int
  creditNote          SupplierCreditNote @relation(fields: [creditNoteId], references: [id])
  
  usedOnCostItemSupplierId Int 
  usedOnCostItemSupplier   CostItemSupplier @relation(fields: [usedOnCostItemSupplierId], references: [id])

  @@map("credit_note_usage")
} 

model SupplierPayable {
  id                      Int                 @id @default(autoincrement())
  supplier                Suppliers
  totalAmount             Float               @map("total_amount")
  paidAmount              Float               @default(0.0) @map("paid_amount")
  pendingAmount           Float               @map("pending_amount")
  reason                  String
  status                  String              @default("PENDING") // PENDING or PAID
  
  createdFromCancellationId Int                 @unique @map("created_from_cancellation_id")
  createdFromCancellation Cancellation          @relation(fields: [createdFromCancellationId], references: [id])

  settlements             SupplierPayableSettlement[]

  createdAt               DateTime            @default(now()) @map("created_at")
  updatedAt               DateTime            @updatedAt @map("updated_at")

  @@map("supplier_payables")
}

model SupplierPayableSettlement {
  id                Int              @id @default(autoincrement())
  supplierPayableId Int              @map("supplier_payable_id")
  amount            Float
  transactionMethod String
  settlementDate    DateTime

  payable           SupplierPayable  @relation(fields: [supplierPayableId], references: [id], onDelete: Cascade)
  createdAt         DateTime         @default(now()) @map("created_at")

  @@map("supplier_payable_settlements")
}



model CustomerPayable {
  id                      Int                 @id @default(autoincrement())
  totalAmount             Float               @map("total_amount")
  paidAmount              Float               @default(0.0) @map("paid_amount")
  pendingAmount           Float               @map("pending_amount")
  reason                  String
  status                  String              @default("PENDING") // PENDING or PAID
  settlements             CustomerPayableSettlement[]
  
  // Link back to the cancellation event that created this payable
  createdFromCancellationId Int                 @unique @map("created_from_cancellation_id")
  createdFromCancellation Cancellation          @relation(fields: [createdFromCancellationId], references: [id])

  bookingId               Int                 @map("booking_id")
  booking                 Booking             @relation(fields: [bookingId], references: [id])

  // You can add settlements for this later if needed

  createdAt               DateTime            @default(now()) @map("created_at")
  updatedAt               DateTime            @updatedAt @map("updated_at")

  @@map("customer_payables")
}

model CustomerPayableSettlement {
  id                Int              @id @default(autoincrement())
  customerPayableId Int              @map("customer_payable_id")
  amount            Float
  transactionMethod String
  paymentDate       DateTime

  payable           CustomerPayable  @relation(fields: [customerPayableId], references: [id], onDelete: Cascade)
  createdAt         DateTime         @default(now()) @map("created_at")

  @@map("customer_payable_settlements")
}

model PassengerRefundPayment {
  id                      Int          @id @default(autoincrement())
  amount                  Float
  transactionMethod       String       @map("transaction_method")
  refundDate              DateTime     @map("refund_date")

  cancellationId          Int          @unique // A cancellation can only have one refund payment
  cancellation            Cancellation @relation(fields: [cancellationId], references: [id])

  createdAt               DateTime     @default(now()) @map("created_at")

  @@map("passenger_refund_payments")
}


model AuditLog {
  id         Int        @id @default(autoincrement())
  modelName  String     @map("model_name")      // e.g., "Booking", "Cancellation"
  recordId   Int        @map("record_id")       // The ID of the record that was changed (e.g., booking.id)
  userId     String     @map("user_id")         // Who did it?
  user       User       @relation(fields: [userId], references: [id])
  action     ActionType @map("action")         // What happened? (e.g., CREATE, UPDATE, APPROVE)
  fieldName  String?    @map("field_name")     // Which field was changed? (e.g., "revenue", "bookingStatus")
  oldValue   String?    @map("old_value")      // What was it before?
  newValue   String?    @map("new_value")      // What is it now?
  createdAt  DateTime   @default(now()) @map("created_at")

  @@map("audit_logs")
}

enum ActionType {
  CREATE
  CREATE_PENDING
  UPDATE
  DELETE
  APPROVE_PENDING
  REJECT_PENDING
  DATE_CHANGE
  VOID_BOOKING 
  UNVOID_BOOKING
  CREATE_CANCELLATION
  SETTLEMENT_PAYMENT
  REFUND_PAYMENT
}

model InitialPayment {
  id                Int      @id @default(autoincrement())
  amount            Float
  transactionMethod String
  paymentDate       DateTime

  // Relation to PendingBooking
  pendingBookingId  Int?
  pendingBooking    PendingBooking? @relation(fields: [pendingBookingId], references: [id], onDelete: Cascade)

  // Relation to Booking
  bookingId         Int?
  booking           Booking?        @relation(fields: [bookingId], references: [id], onDelete: Cascade)

  createdAt         DateTime @default(now()) @map("created_at")
  updatedAt         DateTime @updatedAt @map("updated_at")

  @@map("initial_payments")
}
